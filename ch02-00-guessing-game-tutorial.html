<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programando un juego de adivinanzas - El Lenguaje de Programación Rust</title>


        <!-- Custom HTML head -->
        
            <link rel="canonical" href="https://book.rustlang-es.org/ch02-00-guessing-game-tutorial" />


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta property="og:url" content="https://book.rustlang-es.org">
        <meta property="og:type" content="book">
        <meta property="og:title" content="Programando un juego de adivinanzas - El Lenguaje de Programación Rust">
        <meta property="og:description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta property="og:image" content="https://rustlang-es.org/rust-book-es/img/open-graph.png">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El Lenguaje de Programación Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Empezando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ¡Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ¡Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html" class="active"><strong aria-hidden="true">2.</strong> Programando un juego de adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Flujo de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Entendiendo el Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ¿Qué es el Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Prestamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> El Tipo Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa de Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintaxis de Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El operador de control de flujo match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Flujo de Control Conciso con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Administrando Proyectos en Crecimiento con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo módulos para controlar el scope y la privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths para referirse a un item en el árbol de módulos</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Incluyendo rutas al Scope con la palabra clave use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separando Módulos en Diferentes Archivos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenando listas de valores con vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenando texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Almacenar Claves con Valores Asociados en HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! o no panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos Genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definiendo Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Escribiendo Tests Automatizados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Cómo Escribir Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlando Cómo Los Tests Son Ejecutados</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización De Los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un proyecto de I/O: Construyendo un programa de línea de comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando argumentos de línea de comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la modularidad y el manejo de errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la funcionalidad de la biblioteca con T.D.D.</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo mensajes de error estándar en lugar del output estándar</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características De Lenguajes Funcionales: Iteradores y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones anónimas que capturan su entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una serie de elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando nuestro proyecto I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparando Performance: Bucles vs. Iteradores</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más sobre Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate a Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extendiendo Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Usando Box&lt;T&gt; para Apuntar a Datos en el Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratando los Smart Pointers como Referencias Regulares con el Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ejecutando Código al Limpiar con el Trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, el Smart Pointer de Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referencias Circulares Pueden Fugar Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia Sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Usando Threads para Ejecutar Código Simultáneamente</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Usando el Pasaje de Mensajes para Transferir Datos entre Hilos</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Concurrencia con Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible con los Traits Sync y Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust como un Lenguaje de Programación Orientado a Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Usando Trait Objects que Permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementando un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los lugares donde se pueden usar Patterns</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: Si un Pattern Puede Fallar al Hacer Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Sintaxis de los Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Rust Nightly”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Lenguaje de Programación Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustLangES/rust-book-es" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="programando-un-juego-de-adivinanzas"><a class="header" href="#programando-un-juego-de-adivinanzas">Programando un juego de adivinanzas</a></h1>
<p>¡Vamos a empezar con Rust trabajando en un proyecto práctico! Este capítulo te
introduce a algunos conceptos comunes de Rust mostrándote cómo usarlos en un
programa real. ¡Aprenderás sobre <code>let</code>, <code>match</code>, métodos, funciones asociadas,
paquetes externos y más! En los capítulos siguientes, exploraremos estos
conceptos en más detalle. En este capítulo, solo practicarás los fundamentos.</p>
<p>Implementaremos un clásico problema de programación para principiantes: un
juego de adivinanzas. Así es como funciona: el programa generará un número
entero aleatorio entre 1 y 100. Luego le pedirá al jugador que ingrese una
adivinanza. Después de ingresar una adivinanza, el programa indicará si la
adivinanza es demasiado baja o demasiado alta. Si la adivinanza es correcta, el
juego imprimirá un mensaje de felicitación y saldrá.</p>
<h2 id="configurando-un-nuevo-proyecto"><a class="header" href="#configurando-un-nuevo-proyecto">Configurando un nuevo proyecto</a></h2>
<p>Para configurar un nuevo proyecto, vaya al directorio <em>proyectos</em> que creó en
el Capítulo 1 y cree un nuevo proyecto usando Cargo, así:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>El primer comando, <code>cargo new</code>, toma el nombre del proyecto (<code>guessing_game</code>)
como el primer argumento. El segundo comando cambia al directorio del nuevo
proyecto.</p>
<p>Mira el archivo <em>Cargo.toml</em> generado:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Como viste en el Capítulo 1, <code>cargo new</code> genera un programa “Hola, mundo!” para
ti. Mira el archivo <em>src/main.rs</em>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Ahora compilemos este programa “Hola, mundo!” y ejecutémoslo en el mismo paso
usando el comando <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>El comando <code>run</code> es útil cuando necesitas iterar rápidamente en un proyecto,
como haremos en este juego, probando rápidamente cada iteración antes de
pasar a la siguiente.</p>
<p>Vuelve a abrir el archivo <em>src/main.rs</em>. Escribirás todo el código en este</p>
<h2 id="procesando-una-adivinanza"><a class="header" href="#procesando-una-adivinanza">Procesando una adivinanza</a></h2>
<p>La primera parte del programa del juego de adivinanzas pedirá al usuario que
ingrese un valor, procesará ese valor y verificará que el valor esté en el
formato esperado. Para comenzar, permitiremos al jugador ingresar una adivinanza.
Ingresa el código de la Lista 2-1 en <em>src/main.rs</em>.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}</code></pre>
<p><span class="caption">Lista 2-1: Código que obtiene una adivinanza del usuario
y la imprime</span></p>
<p>Este código contiene mucha información, así que repasémoslo línea por línea.
Para obtener la entrada del usuario y luego imprimir el resultado como salida,
necesitamos traer la biblioteca de entrada/salida <code>io</code> al alcance. La biblioteca
<code>io</code> viene de la biblioteca estándar, conocida como <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="prelude-meaning"></a></p>
<p>Por defecto, Rust tiene un conjunto de elementos definidos en la biblioteca
estándar que trae al alcance de cada programa. Este conjunto se llama
<em>prelude</em>, y puedes ver todo lo que contiene <a href="https://doc.rust-lang.org/std/prelude/index.html">en la documentación de la
biblioteca estándar</a>.</p>
<p>Si un tipo que quieres usar no está en el prelude, tienes que traer ese tipo
al alcance explícitamente con una declaración <code>use</code>. Usar la biblioteca <code>std::io</code>
te proporciona una serie de características útiles, incluyendo la capacidad de
aceptar la entrada del usuario.</p>
<p>Como viste en el Capítulo 1, la función <code>main</code> es el punto de entrada al
programa:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>La sintaxis <code>fn</code> declara una nueva función; los paréntesis, <code>()</code>, indican que
no hay parámetros; y la llave, <code>{</code>, inicia el cuerpo de la función.</p>
<p>Como también aprendiste en el Capítulo 1, <code>println!</code> es una macro que imprime
una cadena en la pantalla:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Este código está imprimiendo una solicitud que indica qué es el juego y está
solicitando la entrada del usuario.</p>
<h3 id="almacenando-valores-con-variables"><a class="header" href="#almacenando-valores-con-variables">Almacenando valores con variables</a></h3>
<p>A continuación, crearemos una <em>variable</em> para almacenar la entrada del usuario,
como esto:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>¡Ahora el programa está interesante! Hay mucho que está pasando en esta pequeña
línea. Usamos la declaración <code>let</code> para crear la variable. Aquí hay otro
ejemplo:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Esta línea crea una nueva variable llamada <code>apples</code> y la enlaza con el valor 5.
En Rust, las variables son inmutables por defecto, lo que significa que una vez
que le damos a la variable un valor, el valor no cambiará. Vamos a discutir
este concepto en detalle en la sección <a href="ch03-01-variables-and-mutability.html#variables-y-mutabilidad">“Variables y Mutabilidad”</a><!-- ignore -->
del Capítulo 3. Para hacer una variable mutable, agregamos <code>mut</code> antes del
nombre de la variable:</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable</code></pre>
<blockquote>
<p>Nota: La sintaxis <code>//</code> inicia un comentario que continúa hasta el final de la
línea. Rust ignora todo lo que está en los comentarios. Vamos a discutir los
comentarios en más detalle en el <a href="ch03-04-comments.html">Capítulo 3</a><!-- ignore -->.</p>
</blockquote>
<p>Regresando al programa del juego de adivinanzas, ahora sabes que <code>let mut guess</code>
introducirá una variable mutable llamada <code>guess</code>. El signo igual (<code>=</code>) le dice
a Rust que queremos enlazar algo a la variable ahora. A la derecha del signo
igual está el valor al que <code>guess</code> está enlazado, que es el resultado de llamar
a <code>String::new</code>, una función que devuelve una nueva instancia de un <code>String</code>.
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> es un tipo de cadena proporcionado por la
biblioteca estándar que es una parte de texto codificada en UTF-8 que puede
crecer.</p>
<p>La sintaxis <code>::</code> en la línea <code>::new</code> indica que <code>new</code> es una función asociada
del tipo <code>String</code>. Una <em>función asociada</em> es una función que está implementada
en un tipo, en este caso <code>String</code>. Esta función <code>new</code> crea una nueva cadena
vacía. Encontrarás una función <code>new</code> en muchos tipos porque es un nombre
común para una función que crea un nuevo valor de algún tipo.</p>
<p>En total, la línea <code>let mut guess = String::new();</code> ha creado una variable
mutable que está actualmente enlazada a una nueva instancia vacía de un
<code>String</code>. ¡Uf!</p>
<h3 id="recibiendo-la-entrada-del-usuario"><a class="header" href="#recibiendo-la-entrada-del-usuario">Recibiendo la entrada del usuario</a></h3>
<p>Recuerda que incluimos la funcionalidad de entrada/salida de la biblioteca
estándar con <code>use std::io;</code> en la primera línea del programa. Ahora llamaremos
a la función <code>stdin</code> del módulo <code>io</code>, que nos permitirá manejar la entrada del
usuario:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Si no hubiéramos importado la biblioteca <code>io</code> con <code>use std::io;</code> al comienzo del
programa, aún podríamos usar la función escribiendo esta llamada de función
como <code>std::io::stdin</code>. La función <code>stdin</code> devuelve una instancia de
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, que es un tipo que representa un
manejador de la entrada estándar para tu terminal.</p>
<p>A continuación, la línea <code>.read_line(&amp;mut guess)</code> llama al método
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> en el manejador de entrada estándar para
obtener la entrada del usuario. También estamos pasando <code>&amp;mut guess</code> como
argumento a <code>read_line</code> para decirle qué cadena almacenar la entrada del
usuario. El trabajo completo de <code>read_line</code> es tomar lo que el usuario escribe
en la entrada estándar y agregar eso a una cadena (sin sobrescribir su
contenido), por lo que, por lo tanto, pasamos esa cadena como argumento. La
cadena de argumentos debe ser mutable para que el método pueda cambiar el
contenido de la cadena.</p>
<p>El <code>&amp;</code> indica que este argumento es una <em>referencia</em>, que te da una forma de
permitir que varias partes de tu código accedan a una pieza de datos sin
necesidad de copiar esos datos en la memoria varias veces. Las referencias son
una característica compleja, y una de las principales ventajas de Rust es lo
seguro y fácil que es usar referencias. No necesitas saber mucho de esos
detalles para terminar este programa. Por ahora, todo lo que necesitas saber es
que, como las variables, las referencias son inmutables por defecto. Por lo
tanto, necesitas escribir <code>&amp;mut guess</code> en lugar de <code>&amp;guess</code> para hacerlo
mutable. (El capítulo 4 explicará las referencias con más detalle.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="manejando-el-posible-fallo-con-result"><a class="header" href="#manejando-el-posible-fallo-con-result">Manejando el posible fallo con <code>Result</code></a></h3>
<p>Todavía estamos trabajando en esta línea de código. Ahora estamos discutiendo
una tercera línea de texto, pero ten en cuenta que aún es parte de una sola
línea lógica de código. La siguiente parte es este método:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Podríamos haber escrito este código como:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);</code></pre>
<p>Sin embargo, una línea larga es difícil de leer, por lo que es mejor dividirla.
A menudo es sabio introducir un salto de línea y otros espacios en blanco para
ayudar a dividir líneas largas cuando llamas a un método con la sintaxis
<code>.method_name()</code>. Ahora discutamos lo que hace esta línea.</p>
<p>Como se mencionó anteriormente, <code>read_line</code> coloca lo que el usuario ingresa en
la cadena que le pasamos, pero también devuelve un valor <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> es una <a href="ch06-00-enums.html"><em>enumeración</em></a><!-- ignore -->, a menudo
llamada <em>enum</em>, que es un tipo que puede estar en uno de varios estados
posibles. Llamamos a cada estado posible a una <em>variante</em>.</p>
<p>El <a href="ch06-00-enums.html">Capítulo 6</a><!-- ignore --> cubrirá las enumeraciones con más
detalles. El propósito de estos tipos <code>Result</code> es codificar información de
manejo de errores.</p>
<p>Las variantes de <code>Result</code> son <code>Ok</code> y <code>Err</code>. La variante <code>Ok</code> indica que la
operación fue exitosa, y dentro de <code>Ok</code> está el valor generado con éxito. La
variante <code>Err</code> significa que la operación falló, y <code>Err</code> contiene información
sobre cómo o por qué la operación falló.</p>
<p>Los valores del tipo <code>Result</code>, como los valores de cualquier tipo, tienen
métodos definidos en ellos. Una instancia de <code>Result</code> tiene un método
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a><!-- ignore --> que puedes llamar. Si esta instancia de
<code>Result</code> es un valor <code>Err</code>, <code>expect</code> hará que el programa se bloquee y muestre
el mensaje que pasaste como argumento a <code>expect</code>. Si el método <code>read_line</code>
devuelve un <code>Err</code>, probablemente sea el resultado de un error proveniente del
sistema operativo subyacente. Si esta instancia de <code>Result</code> es un valor <code>Ok</code>,
<code>expect</code> tomará el valor de retorno que <code>Ok</code> está sosteniendo y devolverá solo
ese valor para que lo puedas usar. En este caso, ese valor es el número de
bytes en la entrada del usuario.</p>
<p>Si no llamas a <code>expect</code>, el programa se compilará, pero obtendrás una advertencia:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust advierte que no has usado el valor <code>Result</code> devuelto por <code>read_line</code>,
indicando que el programa no ha manejado un posible error.</p>
<p>La forma correcta de suprimir la advertencia es escribir realmente código de
manejo de errores, pero en nuestro caso solo queremos bloquear este programa
cuando ocurra un problema, por lo que podemos usar <code>expect</code>. Aprenderás a
recuperarte de los errores en el <a href="ch09-02-recoverable-errors-with-result.html">Capítulo 9</a><!-- ignore -->.</p>
<h3 id="imprimiendo-valores-con-marcadores-de-posición-println"><a class="header" href="#imprimiendo-valores-con-marcadores-de-posición-println">Imprimiendo valores con marcadores de posición <code>println!</code></a></h3>
<p>Además del corchete de cierre, solo hay una línea más que discutir en el código
hasta ahora:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>    println!(&quot;You guessed: {}&quot;, guess);
<span class="boring">}</span></code></pre>
<p>Esta línea imprime la cadena que ahora contiene la entrada del usuario. El
conjunto de llaves <code>{}</code> es un marcador de posición: piensa en <code>{}</code> como pequeñas
pinzas de cangrejo que mantienen un valor en su lugar. Al imprimir el valor de
una variable, el nombre de la variable puede ir dentro de las llaves
curvas. Al imprimir el resultado de evaluar una expresión, coloca llaves
curvas vacías en la cadena de formato, luego sigue la cadena de formato con una
lista separada por comas de expresiones para imprimir en cada marcador de
posición vacío de llaves curvas en el mismo orden. Imprimir una variable y el
resultado de una expresión en una llamada a <code>println!</code> se vería así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {x} and y + 2 = {}&quot;, y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Este código imprimiría <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="probando-la-primera-parte"><a class="header" href="#probando-la-primera-parte">Probando la primera parte</a></h3>
<p>Probemos la primera parte del juego de adivinanzas. Ejecútalo usando <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>En este punto, la primera parte del juego está terminada: estamos obteniendo
entrada del teclado y luego la imprimimos.</p>
<h2 id="generando-un-número-secreto"><a class="header" href="#generando-un-número-secreto">Generando un número secreto</a></h2>
<p>A continuación, necesitamos generar un número secreto que el usuario intentará
adivinar. El número secreto debe ser diferente cada vez para que el juego sea
divertido de jugar más de una vez. Usaremos un número aleatorio entre 1 y 100
para que el juego no sea demasiado difícil. Rust aún no incluye la
funcionalidad de números aleatorios en su biblioteca estándar. Sin embargo, el
equipo de Rust proporciona un <a href="https://crates.io/crates/rand"><code>rand</code> crate</a> con dicha
funcionalidad.</p>
<h3 id="usando-un-crate-para-obtener-más-funcionalidad"><a class="header" href="#usando-un-crate-para-obtener-más-funcionalidad">Usando un Crate para obtener más funcionalidad</a></h3>
<p>Recuerda que un crate es una colección de archivos de código fuente de Rust. El
proyecto que hemos estado construyendo es un <em>binary crate</em>, que es un
ejecutable. El crate <code>rand</code> es un <em>library crate</em>, que contiene código que se
pretende usar en otros programas y no se puede ejecutar por sí solo.</p>
<p>La coordinación de los crates externos de Cargo es donde realmente brilla
Cargo. Antes de poder escribir código que use <code>rand</code>, necesitamos modificar el
archivo <em>Cargo.toml</em> para incluir el crate <code>rand</code> como una dependencia. Abre ese
archivo ahora y agrega la siguiente línea al final, debajo del encabezado de la
sección <code>[dependencies]</code> que Cargo creó para ti. Asegúrate de especificar <code>rand</code>
exactamente como lo tenemos aquí, con este número de versión, o los ejemplos de
código en este tutorial pueden no funcionar:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>En el archivo <em>Cargo.toml</em>, todo lo que sigue a un encabezado es parte de esa
sección que continúa hasta que comienza otra sección. En <code>[dependencies]</code> le
dices a Cargo qué crates externos depende tu proyecto y qué versiones de esos
crates requieres. En este caso, especificamos el crate <code>rand</code> con el
especificador de versión semántica <code>0.8.5</code>. Cargo entiende <a href="http://semver.org">Semantic
Versioning</a><!-- ignore --> (a veces llamado <em>SemVer</em>), que es un
estándar para escribir números de versión. El especificador <code>0.8.5</code> es
realmente un atajo para <code>^0.8.5</code>, lo que significa cualquier versión que sea
al menos 0.8.5 pero inferior a 0.9.0.</p>
<p>Cargo considera que estas versiones tienen APIs públicas compatibles con la
versión 0.8.5, y esta especificación asegura que obtendrá la última versión de
corrección que aún se compilará con el código de este capítulo. Cualquier
versión 0.9.0 o superior no está garantizada de tener la misma API que lo que
usarán los siguientes ejemplos.</p>
<p>Ahora, sin cambiar ningún código, construyamos el proyecto, como se muestra en
el Listado 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Listado 2-2: La salida de ejecutar <code>cargo build</code> después
de agregar el crate rand como una dependencia</span></p>
<p>Es posible que veas números de versión diferentes (¡pero todos serán
compatibles con el código, gracias a SemVer!) y líneas diferentes (dependiendo
del sistema operativo), y las líneas pueden estar en un orden diferente.</p>
<p>Cuando incluimos una dependencia externa, Cargo obtiene las últimas versiones de
todo lo que la dependencia necesita del <em>registro</em>, que es una copia de datos
de <a href="https://crates.io/">Crates.io</a>. Crates.io es donde las personas en el ecosistema de
Rust publican sus proyectos de Rust de código abierto para que otros los
utilicen.</p>
<p>Después de actualizar el registro, Cargo verifica la sección <code>[dependencies]</code>
y descarga cualquier crate que se haya enumerado que aún no se haya
descargado. En este caso, aunque solo enumeramos <code>rand</code> como una dependencia,
Cargo también tomó otros crates que <code>rand</code> depende para funcionar. Después de
descargar los crates, Rust los compila y luego compila el proyecto con las
dependencias disponibles.</p>
<p>Si ejecuta <code>cargo build</code> nuevamente sin hacer ningún cambio, no obtendrá
ninguna salida aparte de la línea <code>Finished</code>. Cargo sabe que ya ha descargado y
compilado las dependencias, y no ha cambiado nada sobre ellas en su archivo
<em>Cargo.toml</em>. Cargo también sabe que no ha cambiado nada sobre su código, por
lo que tampoco lo vuelve a compilar. Sin nada que hacer, simplemente sale.</p>
<p>Si abre el archivo <em>src/main.rs</em>, realiza un cambio trivial y luego lo guarda y
vuelve a construir, solo verá dos líneas de salida:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Estas líneas muestran que Cargo solo actualiza la compilación con su pequeño
cambio en el archivo <em>src/main.rs</em>. Sus dependencias no han cambiado, por lo
que Cargo sabe que puede reutilizar lo que ya ha descargado y compilado para
esas.</p>
<h4 id="garantizar-compilaciones-reproducibles-con-el-archivo-cargolock"><a class="header" href="#garantizar-compilaciones-reproducibles-con-el-archivo-cargolock">Garantizar compilaciones reproducibles con el archivo <em>Cargo.lock</em></a></h4>
<p>Cargo tiene un mecanismo que le garantiza que puede reconstruir el mismo
artefacto cada vez que usted o cualquier otra persona construye su código:
Cargo solo usará las versiones de las dependencias que haya especificado hasta
que indique lo contrario. Por ejemplo, digamos que la semana que viene sale la
versión 0.8.6 del crate <code>rand</code>, y que esa versión contiene una corrección de
error importante, pero también contiene una regresión que romperá su código.
Para manejar esto, Rust crea el archivo <em>Cargo.lock</em> la primera vez que ejecuta
<code>cargo build</code>, por lo que ahora tenemos esto en el directorio <em>guessing_game</em></p>
<p>Cuando construye un proyecto por primera vez, Cargo determina todas las
versiones de las dependencias que cumplen con los criterios y luego las escribe
en el archivo <em>Cargo.lock</em>. Cuando construye su proyecto en el futuro, Cargo
verá que el archivo <em>Cargo.lock</em> existe y usará las versiones especificadas
allí en lugar de hacer todo el trabajo de averiguar las versiones nuevamente.
Esto le permite tener una compilación reproducible de forma automática. En
otras palabras, su proyecto permanecerá en 0.8.5 hasta que actualice
explícitamente, gracias al archivo <em>Cargo.lock</em>. Debido a que el archivo
<em>Cargo.lock</em> es importante para las compilaciones reproducibles, a menudo se
verifica en el control de versiones con el resto del código en su proyecto.</p>
<h4 id="actualizar-un-crate-para-obtener-una-nueva-versión"><a class="header" href="#actualizar-un-crate-para-obtener-una-nueva-versión">Actualizar un crate para obtener una nueva versión</a></h4>
<p>Cuando <em>quiera</em> actualizar un crate, Cargo proporciona el comando <code>update</code>,
que ignorará el archivo <em>Cargo.lock</em> y determinará todas las últimas versiones
que cumplan con sus especificaciones en <em>Cargo.toml</em>. Cargo luego escribirá
esas versiones en el archivo <em>Cargo.lock</em>. En este caso, Cargo solo buscará 
versiones mayores que 0.8.5 y menores que 0.9.0. Si el crate <code>rand</code> ha lanzado 
las dos nuevas versiones 0.8.6 y 0.9.0, vería lo siguiente si ejecutara 
<code>cargo update</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo ignora el lanzamiento 0.9.0. En este punto, también notaría un cambio en
su archivo <em>Cargo.lock</em> que indica que la versión del crate <code>rand</code> que ahora
está usando es 0.8.6. Para usar la versión 0.9.0 o cualquier versión en la
serie 0.9.<em>x</em>, tendría que actualizar el archivo <em>Cargo.toml</em> para que se
vea así:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>La próxima vez que ejecute <code>cargo build</code>, Cargo actualizará el registro de
crates disponibles y volverá a evaluar sus requisitos de <code>rand</code> de acuerdo con
la nueva versión que ha especificado.</p>
<p>Hay mucho más que decir sobre <a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore --> y <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">su
ecosistema</a><!-- ignore -->, que discutiremos en el Capítulo 14, pero
por ahora, eso es todo lo que necesita saber. Cargo hace muy fácil reutilizar
bibliotecas, por lo que los Rustaceans pueden escribir proyectos más pequeños
que se ensamblan a partir de un número de paquetes.</p>
<h3 id="generar-un-numero-aleatorio"><a class="header" href="#generar-un-numero-aleatorio">Generar un numero aleatorio</a></h3>
<p>Comencemos a usar <code>rand</code> para generar un número para adivinar. El siguiente
paso es actualizar <em>src/main.rs</em>, como se muestra en el Listado 2-3.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;The secret number is: {secret_number}&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}</code></pre>
<p><span class="caption">Listado 2-3: Agregando código para generar un número
aleatorio</span></p>
<p>Primero agregamos la línea <code>use rand::Rng;</code>. El trait <code>Rng</code> define métodos que
los generadores de números aleatorios implementan, y este trait debe estar en
el alcance para que podamos usar esos métodos. El Capítulo 10 cubrirá los
traits en detalle.</p>
<p>A continuación, estamos agregando dos líneas en el medio. En la primera línea,
llamamos a la función <code>rand::thread_rng</code> que nos da el generador de números
aleatorios particular que vamos a usar: uno que es local al hilo de ejecución
actual y está sembrado por el sistema operativo. Luego llamamos al método
<code>gen_range</code> en el generador de números aleatorios. Este método está definido
por el trait <code>Rng</code> que traemos al alcance con la declaración <code>use rand::Rng;</code>.
El método <code>gen_range</code> toma una expresión de rango como argumento y genera un
número aleatorio en el rango. El tipo de expresión de rango que estamos
utilizando aquí toma la forma <code>start..=end</code> y es inclusivo en los límites
inferior y superior, por lo que necesitamos especificar <code>1..=100</code> para solicitar
un número entre 1 y 100.</p>
<blockquote>
<p>Nota: No sabrá solo qué traits usar y qué métodos y funciones llamar desde un
crate, por lo que cada crate tiene documentación con instrucciones para
usarlo. Otra característica interesante de Cargo es que ejecutar el comando
<code>cargo doc --open</code> construirá la documentación proporcionada por todas sus
dependencias localmente y la abrirá en su navegador. Si está interesado en
otra funcionalidad en el crate <code>rand</code>, por ejemplo, ejecute <code>cargo doc --open</code> y haga clic en <code>rand</code> en la barra lateral a la izquierda.</p>
</blockquote>
<p>La segunda línea nueva imprime el número secreto. Esto es útil mientras
desarrollamos el programa para poder probarlo, pero lo eliminaremos de la
versión final. ¡No es mucho un juego si el programa imprime la respuesta tan
pronto como comienza!</p>
<p>Intente ejecutar el programa varias veces:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Debería obtener números aleatorios diferentes, y todos deberían ser números
entre 1 y 100. ¡Gran trabajo!</p>
<p><a id="comparando-la-adivinanza-con-el-numero-secreto"></a></p>
<h2 id="comparando-la-adivinanza-con-el-número-secreto"><a class="header" href="#comparando-la-adivinanza-con-el-número-secreto">Comparando la Adivinanza con el Número Secreto</a></h2>
<p>Ahora que tenemos la entrada del usuario y un número aleatorio, podemos
compararlos. Ese paso se muestra en el Listado 2-4. Tenga en cuenta que este
código aún no se compilará, como explicaremos.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}</code></pre>
<p><span class="caption">Listado 2-4: Manejo de los posibles valores de retorno
de la comparación de dos números</span></p>
<p>Primero agregamos otra declaración <code>use</code>, que trae un tipo llamado
<code>std::cmp::Ordering</code> al alcance de la biblioteca estándar. El tipo <code>Ordering</code>
es otro enum y tiene las variantes <code>Less</code>, <code>Greater</code> y <code>Equal</code>. Estos son los
tres resultados posibles cuando compara dos valores.</p>
<p>Luego agregamos cinco nuevas líneas al final que usan el tipo <code>Ordering</code>. El
método <code>cmp</code> compara dos valores y se puede llamar en cualquier cosa que se
pueda comparar. Toma una referencia a lo que quiera comparar: aquí está
comparando <code>guess</code> con <code>secret_number</code>. Luego devuelve una variante del enum
<code>Ordering</code> que importamos al alcance con la declaración <code>use</code>. Usamos una
expresión <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> para decidir qué hacer a continuación
basándonos en qué variante de <code>Ordering</code> se devolvió de la llamada a <code>cmp</code> con
los valores en <code>guess</code> y <code>secret_number</code>.</p>
<p>Una expresión <code>match</code> está compuesta por <em>brazos</em>. Un brazo consta de un
<em>patrón</em> para coincidir y el código que se debe ejecutar si el valor dado a
<code>match</code> se ajusta al patrón del brazo. Rust toma el valor dado a <code>match</code> y
busca cada patrón de brazo en orden. Los patrones y la construcción <code>match</code> son
potentes características de Rust: le permiten expresar una variedad de
situaciones que su código puede encontrar y se aseguran de que los maneje
todos. Estas características se cubrirán en detalle en el Capítulo 6 y el
Capítulo 18, respectivamente.</p>
<p>Vamos a repasar un ejemplo con la expresión <code>match</code> que usamos aquí. Digamos
que el usuario ha adivinado 50 y el número secreto generado aleatoriamente
esta vez es 38.</p>
<p>Cuando el código compara 50 con 38, el método <code>cmp</code> devolverá
<code>Ordering::Greater</code> porque 50 es mayor que 38. La expresión <code>match</code> obtiene el
valor <code>Ordering::Greater</code> y comienza a verificar el patrón de cada brazo. Mira
el patrón del primer brazo, <code>Ordering::Less</code>, y ve que el valor
<code>Ordering::Greater</code> no coincide con <code>Ordering::Less</code>, ¡así que ignora el código
en ese brazo y se mueve al siguiente brazo! El patrón del siguiente brazo es
<code>Ordering::Greater</code>, ¡que <em>sí</em> coincide con <code>Ordering::Greater</code>! El código
asociado en ese brazo se ejecutará y mostrará <code>Too big!</code> en la pantalla. La
expresión <code>match</code> termina después de la primera coincidencia exitosa, ¡así que
no mirará el último brazo en este escenario.</p>
<p>Sin embargo, el código del Listado 2-4 aún no se compilará. Vamos a intentarlo:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/cmp.rs:836:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin &quot;guessing_game&quot;) due to 1 previous error
</code></pre>
<p>El núcleo del error indica que hay <em>tipos no coincidentes</em>. Rust tiene un
sistema de tipos fuerte y estático. Sin embargo, también tiene inferencia de
tipo. Cuando escribimos <code>let mut guess = String::new()</code>, Rust pudo inferir que
<code>guess</code> debería ser un <code>String</code> y no nos obligó a escribir el tipo. El
<code>secret_number</code>, por otro lado, es un tipo de número. Algunos de los tipos de
números de Rust pueden tener un valor entre 1 y 100: <code>i32</code>, un número de 32 bits;
<code>u32</code>, un número sin signo de 32 bits; <code>i64</code>, un número de 64 bits; así como
otros. A menos que se especifique lo contrario, Rust predetermina un <code>i32</code>, que
es el tipo de <code>secret_number</code> a menos que agregue información de tipo en otro
lugar que haga que Rust infiera un tipo numérico diferente. La razón del error
es que Rust no puede comparar una cadena y un tipo numérico.</p>
<p>Finalmente, queremos convertir la <code>String</code> que el programa lee como entrada en
un tipo de número real para que podamos compararlo numéricamente con el número
secreto. Lo hacemos agregando esta línea al cuerpo de la función <code>main</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
<span class="boring">}</span></code></pre>
<p>La línea es:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);</code></pre>
<p>Creamos una variable llamada <code>guess</code>. Pero espera, ¿no tiene el programa ya una
variable llamada <code>guess</code>? Lo hace, pero Rust nos permite redefinir el valor
anterior de <code>guess</code> con uno nuevo. Este concepto en Rust se le conoce como
<em>Shadowing</em>, nos permite volver a usar el nombre de la variable <code>guess</code>
en lugar de obligarnos a crear dos variables únicas, como <code>guess_str</code>
y <code>guess</code>, por ejemplo. Lo cubriremos con más detalle en el
<a href="ch03-01-variables-and-mutability.html#shadowing">Capítulo 3</a><!-- ignore -->, pero por ahora, sé que esta
característica se usa a menudo cuando desea convertir un valor de un tipo a
otro tipo.</p>
<p>Enlazamos esta nueva variable a la expresión <code>guess.trim().parse()</code>. La <code>guess</code>
en la expresión se refiere a la variable <code>guess</code> original que contenía la
entrada como una cadena. El método <code>trim</code> en una instancia <code>String</code> eliminará
cualquier espacio en blanco al principio y al final, lo que debemos hacer para
poder comparar la cadena con el <code>u32</code>, que solo puede contener datos numéricos.
El usuario debe presionar <span class="keystroke">enter</span> para satisfacer
<code>read_line</code> e ingresar su conjetura, lo que agrega un carácter de nueva línea
a la cadena. Por ejemplo, si el usuario escribe <span class="keystroke">5</span>
y presiona <span class="keystroke">enter</span>, <code>guess</code> se ve así: <code>5\n</code>. El
<code>\n</code> representa &quot;nueva línea&quot;. (En Windows, presionar <span
class="keystroke">enter</span> resulta en un retorno de carro y una nueva
línea, <code>\r\n</code>). El método <code>trim</code> elimina <code>\n</code> o <code>\r\n</code>, lo que resulta en solo
<code>5</code>.</p>
<p>El <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">método <code>parse</code> en las cadenas</a><!-- ignore --> convierte una cadena
en otro tipo. Aquí, lo usamos para convertir de una cadena a un número. Debemos
decirle a Rust el tipo de número exacto que queremos usando <code>let guess: u32</code>.
Los dos puntos (<code>:</code>) después de <code>guess</code> le dicen a Rust que anotaremos el tipo
de variable. Rust tiene algunos tipos de número integrados; el <code>u32</code> visto
aquí es un entero sin signo de 32 bits. Es una buena opción predeterminada para
un número positivo pequeño. Aprenderá sobre otros tipos de números en el
<a href="ch03-02-data-types.html#tipos-de-enteros">Capítulo 3</a><!-- ignore -->.</p>
<p>Además, la anotación <code>u32</code> en este programa de ejemplo y la comparación con
<code>secret_number</code> significa que Rust inferirá que <code>secret_number</code> también
debería ser <code>u32</code>. ¡Entonces la comparación será entre dos valores del mismo
tipo!</p>
<p>El método <code>parse</code> solo funcionará en caracteres que se puedan convertir
lógicamente en números y, por lo tanto, pueden causar fácilmente errores. Si,
por ejemplo, la cadena contiene <code>A👍%</code>, no habría manera de convertir eso en un
número. Debido a que podría fallar, el método <code>parse</code> devuelve un tipo <code>Result</code>,
tal como lo hace el método <code>read_line</code> (discutido anteriormente en
<a href="#handling-potential-failure-with-the-result-type">“Manejo de posibles fallas con <code>Result</code>”</a><!-- ignore-->).
Trataremos este <code>Result</code> de la misma manera usando el método <code>expect</code> de nuevo.
Si <code>parse</code> devuelve una variante <code>Err</code> del tipo <code>Result</code> porque no pudo crear
un número a partir de la cadena, la llamada <code>expect</code> hará que el juego se
bloquee y muestre el mensaje que le damos. Si <code>parse</code> puede convertir
exitosamente la cadena en un número, devolverá la variante <code>Ok</code> del tipo
<code>Result</code>, y <code>expect</code> devolverá el número que queremos del valor <code>Ok</code>.</p>
<p>¡Corramos el programa ahora!</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>¡Bien! Aunque se agregaron espacios antes de la adivinanza, el programa aún
sabía que el usuario adivinó 76. Ejecute el programa varias veces para
verificar el comportamiento diferente con diferentes tipos de entrada: adivine
el número correctamente, adivine un número que sea demasiado alto y adivine un
número que sea demasiado bajo.</p>
<p>Tenemos la mayoría del juego funcionando ahora, pero el usuario solo puede
adivinar una vez. ¡Cambiamos eso agregando un bucle!</p>
<h2 id="permitir-múltiples-adivinanzas-con-bucles"><a class="header" href="#permitir-múltiples-adivinanzas-con-bucles">Permitir múltiples adivinanzas con bucles</a></h2>
<p>La palabra clave <code>loop</code> crea un bucle infinito. Agregaremos un bucle para darle
a los usuarios más oportunidades para adivinar el número:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;The secret number is: {secret_number}&quot;);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}</code></pre>
<p>Como puede ver, hemos movido todo desde la solicitud de entrada de adivinanzas
hacia adelante en un bucle. Asegúrese de indentar las líneas dentro del bucle
otras cuatro veces y ejecute el programa nuevamente. ¡El programa ahora pedirá
otra adivinanza para siempre, lo que introduce un nuevo problema! ¡Parece que el
usuario no puede salir!</p>
<p>El usuario siempre podría interrumpir el programa usando el atajo de teclado
<span class="keystroke">ctrl-c</span>. Pero hay otra forma de escapar de este
monstruo insaciable, como se mencionó en la discusión de <code>parse</code> en
<a href="#comparando-la-adivinanza-con-el-numero-secreto">“Comparando la adivinanza con el número secreto”</a><!--
ignore -->: si el usuario ingresa una respuesta que no es un número, el
programa se bloqueará. Podemos aprovechar eso para permitir que el usuario
salga, como se muestra aquí:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Al escribir <code>quit</code> se cerrará el juego, pero como notará, también lo hará al
ingresar cualquier otra entrada que no sea un número. Esto es lo menos
óptimo, para decir lo menos; queremos que el juego también se detenga cuando se
adivine el número correcto.</p>
<p><a id="salir-despues-de-una-adivinanza-correcta"></a></p>
<h3 id="salir-después-de-una-adivinanza-correcta"><a class="header" href="#salir-después-de-una-adivinanza-correcta">Salir después de una adivinanza correcta</a></h3>
<p>Programemos el juego para que se cierre cuando el usuario gane agregando una
declaración <code>break</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p>Agregando la línea <code>break</code> después de <code>You win!</code> hace que el programa salga del
bucle cuando el usuario adivina el número secreto correctamente. Salir del
bucle también significa salir del programa, porque el bucle es la última parte
de <code>main</code>.</p>
<h3 id="manejo-de-entrada-no-válida"><a class="header" href="#manejo-de-entrada-no-válida">Manejo de entrada no válida</a></h3>
<p>Para mejorar aún más el comportamiento del juego, en lugar de bloquear el
programa cuando el usuario ingresa un número no válido, hagamos que el juego
ignore un número no válido para que el usuario pueda seguir adivinando. Podemos
hacer eso alterando la línea donde <code>guess</code> se convierte de un <code>String</code> a un
<code>u32</code>, como se muestra en el Listado 2-5.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 2-5: Ignorar una adivinanza que no es un número
y pedir otra adivinanza en lugar de bloquear el programa</span></p>
<p>Cambiamos de una llamada <code>expect</code> a una expresión <code>match</code> para pasar de
bloquear el programa en un error a manejar el error. Recuerde que <code>parse</code>
devuelve un tipo <code>Result</code> y <code>Result</code> es un enum que tiene las variantes <code>Ok</code> y
<code>Err</code>. Aquí estamos usando una expresión <code>match</code>, como hicimos con el resultado
<code>Ordering</code> del método <code>cmp</code>.</p>
<p>Si <code>parse</code> es capaz de convertir exitosamente la cadena en un número, devolverá
un valor <code>Ok</code> que contiene el número resultante. Ese valor <code>Ok</code> coincidirá con
el patrón de la primera rama y la expresión <code>match</code> devolverá el valor <code>num</code>
que <code>parse</code> produjo y puso dentro del valor <code>Ok</code>. Ese número terminará en el
lugar correcto en la nueva variable <code>guess</code> que estamos creando.</p>
<p>Si <code>parse</code> <em>no</em> es capaz de convertir la cadena en un número, devolverá un
valor <code>Err</code> que contiene más información sobre el error. El valor <code>Err</code> no
coincide con el patrón <code>Ok(num)</code> en la primera rama de <code>match</code>, pero sí
coincide con el patrón <code>Err(_)</code> en la segunda rama. El guión bajo, <code>_</code>, es un
valor de captura; en este ejemplo, estamos diciendo que queremos coincidir con
todos los valores <code>Err</code>, sin importar qué información tengan dentro. ¡Así que
el programa ejecutará el código de la segunda rama, <code>continue</code>, que le dice al
programa que vaya a la siguiente iteración del <code>loop</code> y pida otra adivinanza.
¡Así que, efectivamente, el programa ignora todos los errores que <code>parse</code> puede
encontrar!</p>
<p>Ahora todo en el programa debería funcionar como se espera. Vamos a probarlo:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>¡Genial! Con un pequeño ajuste final, terminaremos el juego de adivinanzas.
Recuerde que el programa todavía está imprimiendo el número secreto. Eso
funcionó bien para las pruebas, pero arruina el juego. Vamos a eliminar el
<code>println!</code> que muestra el número secreto. El listado 2-6 muestra el código
final.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p><span class="caption">Listado 2-6: Código completo del juego de adivinanzas</span></p>
<p>En este punto, ha construido exitosamente el juego de adivinanzas. ¡Felicidades!</p>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>Este proyecto fue una manera práctica de introducirle a muchos nuevos conceptos
de Rust: <code>let</code>, <code>match</code>, funciones, el uso de paquetes externos, y más. En los
próximos capítulos, aprenderá sobre estos conceptos en más detalle. El capítulo
3 cubre conceptos que la mayoría de los lenguajes de programación tienen, como
variables, tipos de datos y funciones, y muestra cómo usarlos en Rust. El
capítulo 4 explora la propiedad, una característica que hace que Rust sea
diferente de otros lenguajes. El capítulo 5 discute las estructuras y la
sintaxis de los métodos, y el capítulo 6 explica cómo funcionan los enums.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
