<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tipos de Datos - El Lenguaje de Programación Rust</title>


        <!-- Custom HTML head -->
        
            <link rel="canonical" href="https://book.rustlang-es.org/ch03-02-data-types" />


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta property="og:url" content="https://book.rustlang-es.org">
        <meta property="og:type" content="book">
        <meta property="og:title" content="Tipos de Datos - El Lenguaje de Programación Rust">
        <meta property="og:description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta property="og:image" content="https://rustlang-es.org/rust-book-es/img/open-graph.png">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El Lenguaje de Programación Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Empezando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ¡Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ¡Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un juego de adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html" class="active"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Flujo de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Entendiendo el Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ¿Qué es el Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Prestamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> El Tipo Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa de Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintaxis de Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El operador de control de flujo match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Flujo de Control Conciso con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Administrando Proyectos en Crecimiento con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo módulos para controlar el scope y la privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths para referirse a un item en el árbol de módulos</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Incluyendo rutas al Scope con la palabra clave use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separando Módulos en Diferentes Archivos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenando listas de valores con vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenando texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Almacenar Claves con Valores Asociados en HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! o no panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos Genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definiendo Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Escribiendo Tests Automatizados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Cómo Escribir Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlando Cómo Los Tests Son Ejecutados</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización De Los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un proyecto de I/O: Construyendo un programa de línea de comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando argumentos de línea de comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la modularidad y el manejo de errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la funcionalidad de la biblioteca con T.D.D.</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo mensajes de error estándar en lugar del output estándar</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características De Lenguajes Funcionales: Iteradores y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones anónimas que capturan su entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una serie de elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando nuestro proyecto I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparando Performance: Bucles vs. Iteradores</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más sobre Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate a Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extendiendo Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Usando Box&lt;T&gt; para Apuntar a Datos en el Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratando los Smart Pointers como Referencias Regulares con el Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ejecutando Código al Limpiar con el Trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, el Smart Pointer de Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referencias Circulares Pueden Fugar Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia Sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Usando Threads para Ejecutar Código Simultáneamente</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Usando el Pasaje de Mensajes para Transferir Datos entre Hilos</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Concurrencia con Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible con los Traits Sync y Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust como un Lenguaje de Programación Orientado a Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Usando Trait Objects que Permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementando un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los lugares donde se pueden usar Patterns</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: Si un Pattern Puede Fallar al Hacer Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Sintaxis de los Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Rust Nightly”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Lenguaje de Programación Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustLangES/rust-book-es" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="tipos-de-datos"><a class="header" href="#tipos-de-datos">Tipos de datos</a></h2>
<p>Cada valor en Rust es de un cierto <em>tipo de dato</em>, que le dice a Rust qué tipo
de dato se está especificando para que sepa cómo trabajar con ese dato. Veremos 
dos subconjuntos de tipos de datos: escalares y compuestos.</p>
<p>Tenga en cuenta que Rust es un lenguaje <em>estáticamente tipado</em>, lo que significa
que debe conocer los tipos de todas las variables en tiempo de compilación. El
compilador generalmente puede inferir qué tipo queremos usar en función del
valor y cómo lo usamos. En los casos en que muchos tipos son posibles, como
cuando convertimos un <code>String</code> en un tipo numérico usando <code>parse</code> en la sección
<a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">“Comparando la Adivinanza con el Número Secreto”</a>
del capítulo 2, debemos agregar una anotación de tipo, como
esta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Si no agregamos la anotación de tipo <code>: u32</code> mostrada en el código anterior,
Rust mostrará el siguiente error, lo que significa que el compilador necesita
más información de nosotros para saber qué tipo queremos usar:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin &quot;no_type_annotations&quot;) due to 1 previous error
</code></pre>
<p>Verá diferentes anotaciones de tipo para otros tipos de datos.</p>
<h3 id="tipos-escalares"><a class="header" href="#tipos-escalares">Tipos Escalares</a></h3>
<p>Un tipo <em>escalar</em> representa un solo valor. Rust tiene cuatro tipos escalares
principales: enteros, números de punto flotante, booleanos y caracteres. Puede
reconocerlos de otros lenguajes de programación. Vamos a ver cómo funcionan en
Rust.</p>
<h4 id="tipos-de-enteros"><a class="header" href="#tipos-de-enteros">Tipos de Enteros</a></h4>
<p>Un <em>entero</em> es un número sin componente fraccionario. Usamos un tipo de entero
en el capítulo 2, el tipo <code>u32</code>. Esta declaración de tipo indica que el valor
con el que está asociado debe ser un entero sin signo (los tipos de enteros con
signo comienzan con <code>i</code> en lugar de <code>u</code>) que ocupa 32 bits de espacio. La tabla
3-1 muestra los tipos de enteros integrados en Rust. Podemos usar cualquiera de
estas variantes para declarar el tipo de un valor entero.</p>
<p><span class="caption">Tabla 3-1: Tipos Enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Tamaño</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Cada variante puede ser <em>signed</em> (con signo) o <em>unsigned</em> (sin signo) y tiene
un tamaño explícito. <em>Signed</em> y <em>unsigned</em> se refieren a si es posible que el
número sea negativo, es decir, si el número necesita tener un signo con él
(signed) o si solo será positivo y por lo tanto puede representarse sin signo
(unsigned). Es como escribir números en papel: cuando el signo importa,
un número se muestra con un signo más o un signo menos; sin embargo, cuando es
seguro suponer que el número es positivo, se muestra sin signo.
Los números con signo se almacenan usando la
representación de <a href="https://es.wikipedia.org/wiki/Complemento_a_dos">complemento a dos</a>.</p>
<p>Cada variante con signo puede almacenar números de -(2<sup>n - 1</sup>)
a 2<sup>n - 1</sup> - 1, donde <em>n</em> es el número de bits que usa la variante.
Así, un <code>i8</code> puede almacenar números de -(2<sup>7</sup>) a 2<sup>7</sup> - 1,
lo que equivale a -128 a 127. Las variantes sin signo pueden almacenar números
de 0 a 2<sup>n</sup> - 1, por lo que un <code>u8</code> puede almacenar números de 0 a 2<sup>8</sup> - 1,
lo que equivale a 0 a 255.</p>
<p>Además, los tipos <code>isize</code> y <code>usize</code> dependen de la arquitectura de la
computadora en la que se ejecuta su programa, que se denota en la tabla como
“arch”: 64 bits si está en una arquitectura de 64 bits y 32 bits si está en una
arquitectura de 32 bits.</p>
<p>Puede escribir literales enteros en cualquiera de las formas que se muestran en
la Tabla 3-2. Tenga en cuenta que los literales numéricos que pueden ser
múltiples tipos numéricos permiten un sufijo de tipo, como <code>57u8</code>, para
designar el tipo. Los literales numéricos también pueden usar <code>_</code> como un
separador visual para facilitar la lectura del número, como <code>1_000</code>, que tendrá
el mismo valor que si hubiera especificado <code>1000</code>.</p>
<p><span class="caption">Tabla 3-2: Literales enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Literales numéricos</th><th>Ejemplo</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binario</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> solamente)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Entonces, ¿cómo sabe qué tipo de entero usar? Si no está seguro, los valores
predeterminados de Rust son generalmente buenos lugares para comenzar: los
tipos enteros se configuran predeterminadamente en <code>i32</code>. La situación
principal en la que usaría <code>isize</code> o <code>usize</code> es cuando indexa algún tipo de
colección.</p>
<blockquote>
<h5 id="desbordamiento-de-enteros"><a class="header" href="#desbordamiento-de-enteros">Desbordamiento de enteros</a></h5>
<p>Digamos que tiene una variable de tipo <code>u8</code> que puede contener valores entre 0
y 255. Si intenta cambiar la variable a un valor fuera de ese rango, como 256,
<em>se producirá un desbordamiento de enteros</em>, que puede resultar en uno de dos
comportamientos. Cuando está compilando en modo de depuración, Rust incluye
comprobaciones para el desbordamiento de enteros que hacen que su programa
<em>se desborde</em> en tiempo de ejecución si ocurre este comportamiento.
Rust usa el término <em>desbordamiento</em> cuando un programa sale con un error;
discutiremos los desbordamientos con más profundidad en la sección <a href="ch09-01-unrecoverable-errors-with-panic.html">“Errores
irrecuperables con <code>panic!</code>”</a><!-- ignore -->
del Capítulo 9.</p>
<p>Cuando está compilando en modo de lanzamiento con la bandera <code>--release</code>,
Rust <em>no</em> incluye comprobaciones para el desbordamiento de enteros que
provocan desbordamientos. En su lugar, si ocurre un desbordamiento, Rust
realiza una <em>envoltura de complemento a dos</em>. En resumen, los valores mayores que
el valor máximo que el tipo puede contener “se envuelven” al mínimo de los
valores que el tipo puede contener. En el caso de un <code>u8</code>, el valor 256 se
convierte en 0, el valor 257 se convierte en 1, y así sucesivamente. El
programa no se desbordará, pero la variable tendrá un valor que probablemente
no sea el que esperaba que tuviera. Depender del comportamiento de la envoltura
del desbordamiento de enteros se considera un error.</p>
<p>Para manejar explícitamente la posibilidad de desbordamiento, puede usar estas
familias de métodos proporcionados por la biblioteca estándar para tipos
numéricos primitivos:</p>
<ul>
<li>Envolver en todos los modos con los métodos <code>wrapping_*</code>, como
<code>wrapping_add</code>.</li>
<li>Devolver el valor <code>None</code> si hay desbordamiento con los métodos <code>checked_*</code>.</li>
<li>Devolver el valor y un booleano que indica si hubo desbordamiento con los
métodos <code>overflowing_*</code>.</li>
<li>Saturar en los valores mínimos o máximos del valor con los métodos
<code>saturating_*</code>.</li>
</ul>
</blockquote>
<h4 id="tipos-de-punto-flotante"><a class="header" href="#tipos-de-punto-flotante">Tipos de punto flotante</a></h4>
<p>Rust también tiene dos tipos primitivos para <em>números de punto flotante</em>, que
son números con puntos decimales. Los tipos de punto flotante de Rust son <code>f32</code>
y <code>f64</code>, que tienen 32 bits y 64 bits de tamaño, respectivamente. El tipo
predeterminado es <code>f64</code> porque en CPUs modernas, es aproximadamente la misma
velocidad que <code>f32</code> pero es capaz de más precisión. Todos los tipos de punto
flotante son con signo.</p>
<p>Aquí hay un ejemplo que muestra números de punto flotante en acción:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Los números de punto flotante se representan de acuerdo con el estándar
IEEE-754. El tipo <code>f32</code> es un punto flotante de precisión simple, y <code>f64</code> tiene
doble precisión.</p>
<h4 id="operaciones-numéricas"><a class="header" href="#operaciones-numéricas">Operaciones numéricas</a></h4>
<p>Rust admite las operaciones matemáticas básicas que esperaría para todos los
tipos de números: adición, sustracción, multiplicación, división y resto.
La división entera se trunca hacia cero al entero más cercano. El siguiente
código muestra cómo usaría cada operación numérica en una declaración <code>let</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<p>Cada expresión en estas instrucciones usa un operador matemático y se evalúa a
un solo valor, que luego se vincula a una variable. El <a href="appendix-02-operators.html">Apéndice
B</a> contiene una lista de todos los operadores que
Rust proporciona.</p>
<h4 id="el-tipo-booleano"><a class="header" href="#el-tipo-booleano">El tipo booleano</a></h4>
<p>Como en la mayoría de los otros lenguajes de programación, un tipo booleano en
Rust tiene dos posibles valores: <code>true</code> y <code>false</code>. Los booleanos tienen un
byte de tamaño. El tipo booleano en Rust se especifica usando <code>bool</code>. Por
ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre></pre>
<p>La forma principal de usar valores booleanos es a través de condicionales, como
una expresión <code>if</code>. Cubriremos cómo funcionan las expresiones <code>if</code> en Rust en
la sección <a href="ch03-05-control-flow.html#flujo-de-control">“Control de flujo”</a><!-- ignore -->.</p>
<h4 id="el-tipo-de-carácter"><a class="header" href="#el-tipo-de-carácter">El tipo de carácter</a></h4>
<p>El tipo <code>char</code> de Rust es el tipo alfabético más primitivo del lenguaje. Estos son algunos ejemplos de declaración de valores <code>char</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>Tenga en cuenta que especificamos literales <code>char</code> con comillas simples, en
oposición a literales de cadena, que usan comillas dobles. El tipo <code>char</code> de 
Rust tiene un tamaño de cuatro bytes y representa un valor escalar Unicode, lo 
que significa que puede representar mucho más que ASCII. Letras
acentuadas; Caracteres chinos, japoneses y coreanos; Emojis; y espacios de ancho
cero son todos valores <code>char</code> válidos en Rust. Los valores escalar de Unicode
van desde <code>U+0000</code> a <code>U+D7FF</code> y <code>U+E000</code> a <code>U+10FFFF</code> inclusive. Sin embargo,
un &quot;carácter&quot; no es realmente un concepto en Unicode, por lo que su intuición
humana sobre lo que es un &quot;carácter&quot; puede no coincidir con lo que es un <code>char</code>
en Rust. Discutiremos este tema en detalle en <a href="ch08-02-strings.html#almacenando-texto-codificado-en-utf-8-con-strings">“Almacenar texto codificado en
UTF-8 con cadenas”</a><!-- ignore --> en el capítulo 8.</p>
<h3 id="tipos-compuestos"><a class="header" href="#tipos-compuestos">Tipos compuestos</a></h3>
<p><em>Tipos compuestos</em> pueden agrupar múltiples valores en un solo tipo. Rust
tiene dos tipos compuestos primitivos: tuplas y arreglos.</p>
<h4 id="el-tipo-tupla"><a class="header" href="#el-tipo-tupla">El Tipo Tupla</a></h4>
<p>Una <em>tupla</em> es una forma general de agrupar varios valores de distintos tipos en 
un tipo compuesto. Las tuplas tienen una longitud fija: una vez declaradas, su 
tamaño no puede aumentar ni disminuir.</p>
<p>Creamos una tupla escribiendo una lista de valores separados por comas dentro de
paréntesis. Cada posición de la tupla tiene un tipo, y los tipos de los 
distintos valores de la tupla no tienen por qué ser iguales. En este ejemplo 
hemos añadido anotaciones de tipo opcionales:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>La variable <code>tup</code> se vincula a toda la tupla porque una tupla se considera un 
único elemento compuesto. Para obtener los valores individuales de una tupla, 
podemos utilizar la concordancia de patrones para desestructurar un valor de 
tupla, así:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {y}&quot;);
}</code></pre></pre>
<p>Este programa primero crea una tupla y la vincula a la variable <code>tup</code>. Luego
usa un patrón con <code>let</code> para tomar <code>tup</code> y convertirla en tres variables
separadas, <code>x</code>, <code>y</code> y <code>z</code>. Esto se llama <em>desestructuración</em> porque rompe la
única tupla en tres partes. Finalmente, el programa imprime el valor de <code>y</code>,
que es <code>6.4</code>.</p>
<p>También podemos acceder directamente a un elemento de la tupla usando un punto
(<code>.</code>) seguido del índice del valor que queremos acceder. Por ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>Este programa crea la tupla <code>x</code> y luego accede a cada elemento de la tupla
usando sus respectivos índices. Al igual que la mayoría de los lenguajes de
programación, el primer índice en una tupla es 0.</p>
<p>La tupla sin ningún valor tiene un nombre especial, <em>unit</em>. Este valor y su
tipo correspondiente están escritos ambos como <code>()</code> y representan un valor
vacío o un tipo de retorno vacío. Las expresiones devuelven implícitamente el
valor unit si no devuelven ningún otro valor.</p>
<h4 id="el-tipo-arreglo"><a class="header" href="#el-tipo-arreglo">El Tipo Arreglo</a></h4>
<p>Otra forma de tener una colección de múltiples valores es con un <em>arreglo</em>.
A diferencia de una tupla, cada elemento de un arreglo debe tener el mismo
tipo. A diferencia de los arreglos en algunos otros lenguajes, los arreglos en
Rust tienen una longitud fija.</p>
<p>Escribimos los valores en un arreglo como una lista separada por comas dentro
de corchetes:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Los arreglos son útiles cuando desea que sus datos se asignen en el stack (pila)
en lugar del heap (montículo) (hablaremos más sobre el stack y el heap en el
<a href="ch04-01-what-is-ownership.html#el-stack-y-el-heap">Capítulo 4</a><!-- ignore -->) o cuando desea asegurarse de que
siempre tenga un número fijo de elementos. Sin embargo, un arreglo no es tan
flexible como el tipo vector. Un <em>vector</em> es un tipo de colección similar
proporcionado por la biblioteca estándar que <em>puede</em> crecer o reducir su tamaño.
Si no está seguro de si debe usar un arreglo o un vector, es probable que deba
usar un vector. El <a href="ch08-01-vectors.html">Capítulo 8</a><!-- ignore --> discute los vectores en
más detalle.</p>
<p>Sin embargo, los arreglos son más útiles cuando sabe que el número de elementos
no cambiará. Por ejemplo, si está utilizando los nombres del mes en un
programa, probablemente usaría un arreglo en lugar de un vector porque sabe que
siempre contendrá 12 elementos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}</span></code></pre></pre>
<p>Escribe el tipo de un arreglo usando corchetes con el tipo de cada elemento,
un punto y coma y luego el número de elementos en el arreglo, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Aquí, <code>i32</code> es el tipo de cada elemento. Después del punto y coma, el número
<code>5</code> indica que el arreglo contiene cinco elementos.</p>
<p>También puede inicializar un arreglo para contener el mismo valor para cada
elemento especificando el valor inicial, seguido de un punto y coma y luego la
longitud del arreglo en corchetes, como se muestra aquí:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>El arreglo llamado <code>a</code> contendrá <code>5</code> elementos que inicialmente se establecerán
en el valor <code>3</code>. Esto es lo mismo que escribir <code>let a = [3, 3, 3, 3, 3];</code> pero
de una manera más concisa.</p>
<h5 id="accediendo-a-los-elementos-del-arreglo"><a class="header" href="#accediendo-a-los-elementos-del-arreglo">Accediendo a los Elementos del Arreglo</a></h5>
<p>Un arreglo es un trozo de memoria de tamaño fijo y conocido que puede asignarse 
a la pila. Se puede acceder a los elementos de una arreglo utilizando la 
indexación, de la siguiente manera:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>En este ejemplo, la variable llamada <code>first</code> obtendrá el valor <code>1</code> porque ese
es el valor en el índice <code>[0]</code> en el arreglo. La variable llamada <code>second</code>
obtendrá el valor <code>2</code> del índice <code>[1]</code> en el arreglo.</p>
<h5 id="acceso-inválido-a-los-elementos-del-arreglo"><a class="header" href="#acceso-inválido-a-los-elementos-del-arreglo">Acceso Inválido a los Elementos del Arreglo</a></h5>
<p>Veamos qué sucede si intenta acceder a un elemento de un arreglo que está más
allá del final del arreglo. Digamos que ejecuta este código, similar al juego
de adivinanzas del Capítulo 2, para obtener un índice de arreglo del usuario:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(&quot;The value of the element at index {index} is: {element}&quot;);
}</code></pre>
<p>Este código se compila con éxito. Si ejecuta este código usando <code>cargo run</code> y
ingresa <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> o <code>4</code>, el programa imprimirá el valor
correspondiente en ese índice en el arreglo. Si en cambio ingresa un número
más allá del final del arreglo, como <code>10</code>, verá una salida como esta:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>El programa dio lugar a un <em>error en tiempo de ejecución</em> al momento de utilizar 
un valor no válido en la operación de indexación. El programa salió con un 
mensaje de error y no ejecutó la sentencia final <code>println!</code>. Cuando intentas 
acceder a un elemento utilizando la indexación, Rust comprobará que el índice 
que has especificado es menor que la longitud del array. Si el índice es mayor o 
igual que la longitud, Rust entrará en pánico. Esta comprobación tiene que 
ocurrir en tiempo de ejecución, especialmente en este caso, porque el compilador 
no puede saber qué valor introducirá el usuario cuando ejecute el código más 
tarde.</p>
<p>Este es un ejemplo de los principios de seguridad de memoria de Rust en acción. 
En muchos lenguajes de bajo nivel, este tipo de comprobación no se hace, y 
cuando proporcionas un índice incorrecto, se puede acceder a memoria inválida. 
Rust te protege contra este tipo de error saliendo inmediatamente en lugar de 
permitir el acceso a la memoria y continuar. El Capítulo 9 discute más sobre el 
manejo de errores de Rust y cómo puedes escribir código legible y seguro que no 
entre en pánico ni permita el acceso a memoria inválida.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
