<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Closures: Funciones anónimas que capturan su entorno - El Lenguaje de Programación Rust</title>


        <!-- Custom HTML head -->
        
            <link rel="canonical" href="https://book.rustlang-es.org/ch13-01-closures" />


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta property="og:url" content="https://book.rustlang-es.org">
        <meta property="og:type" content="book">
        <meta property="og:title" content="Closures: Funciones anónimas que capturan su entorno - El Lenguaje de Programación Rust">
        <meta property="og:description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta property="og:image" content="https://rustlang-es.org/rust-book-es/img/open-graph.png">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El Lenguaje de Programación Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Empezando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ¡Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ¡Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un juego de adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Flujo de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Entendiendo el Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ¿Qué es el Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Prestamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> El Tipo Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa de Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintaxis de Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El operador de control de flujo match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Flujo de Control Conciso con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Administrando Proyectos en Crecimiento con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo módulos para controlar el scope y la privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths para referirse a un item en el árbol de módulos</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Incluyendo rutas al Scope con la palabra clave use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separando Módulos en Diferentes Archivos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenando listas de valores con vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenando texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Almacenar Claves con Valores Asociados en HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! o no panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos Genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definiendo Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Escribiendo Tests Automatizados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Cómo Escribir Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlando Cómo Los Tests Son Ejecutados</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización De Los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un proyecto de I/O: Construyendo un programa de línea de comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando argumentos de línea de comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la modularidad y el manejo de errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la funcionalidad de la biblioteca con T.D.D.</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo mensajes de error estándar en lugar del output estándar</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características De Lenguajes Funcionales: Iteradores y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html" class="active"><strong aria-hidden="true">13.1.</strong> Closures: Funciones anónimas que capturan su entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una serie de elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando nuestro proyecto I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparando Performance: Bucles vs. Iteradores</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más sobre Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate a Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extendiendo Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Usando Box&lt;T&gt; para Apuntar a Datos en el Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratando los Smart Pointers como Referencias Regulares con el Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ejecutando Código al Limpiar con el Trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, el Smart Pointer de Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referencias Circulares Pueden Fugar Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia Sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Usando Threads para Ejecutar Código Simultáneamente</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Usando el Pasaje de Mensajes para Transferir Datos entre Hilos</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Concurrencia con Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible con los Traits Sync y Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust como un Lenguaje de Programación Orientado a Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Usando Trait Objects que Permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementando un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los lugares donde se pueden usar Patterns</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: Si un Pattern Puede Fallar al Hacer Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Sintaxis de los Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Rust Nightly”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Lenguaje de Programación Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustLangES/rust-book-es" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="closures-funciones-anónimas-que-capturan-su-entorno"><a class="header" href="#closures-funciones-anónimas-que-capturan-su-entorno">Closures: Funciones anónimas que capturan su entorno</a></h2>
<p>Los closures de Rust son funciones anónimas que puede guardar en una variable o
pasar como argumentos a otras funciones. Puede crear el closure en un lugar y
luego llamar al closure en otro lugar para evaluarlo en un contexto diferente.
A diferencia de las funciones, los closures pueden capturar valores del scope en
el que se definen. Demostraremos cómo estas características de los closures
permiten la reutilización de código y la personalización del comportamiento.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="capturando-el-entorno-con-closures"><a class="header" href="#capturando-el-entorno-con-closures">Capturando el entorno con Closures</a></h3>
<p>Primero examinaremos cómo podemos usar closures para capturar valores del
entorno en el que están definidos para su uso posterior. Aquí está el escenario:
Cada cierto tiempo, nuestra compañía de camisetas regala una camiseta exclusiva
y de edición limitada a alguien en nuestra lista de correo como promoción. Las
personas en la lista de correo pueden agregar opcionalmente su color favorito a
su perfil. Si la persona elegida para una camiseta gratis tiene su color
favorito establecido, obtienen esa camiseta de color. Si la persona no ha
especificado un color favorito, obtienen el color que la compañía tiene
actualmente en mayor cantidad.</p>
<p>Hay muchas formas de implementar esto. Para este ejemplo, vamos a usar un enum
llamado <code>ShirtColor</code> que tiene las variantes <code>Red</code> y <code>Blue</code> (limitando el
número de colores disponibles para simplificar). Representamos el inventario de
la compañía con un struct <code>Inventory</code> que tiene un campo llamado <code>shirts</code> que
contiene un <code>Vec&lt;ShirtColor&gt;</code> que representa los colores de camisetas
actualmente en stock. El método <code>giveaway</code> definido en <code>Inventory</code> obtiene la
preferencia opcional de color de camiseta del ganador de la camiseta gratis, y
devuelve el color de camiseta que la persona obtendrá. Esta configuración se
muestra en el Listado 13-1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref2, giveaway2
    );
}</code></pre>
<p><span class="caption">Listing 13-1: Situación de giveaway</span></p>
<p>El <code>almacén</code> definido en <code>main</code> tiene dos camisetas azules y una camiseta roja
restante para distribuir para esta promoción de edición limitada. Llamamos al
método <code>giveaway</code> para un usuario con preferencia por una camiseta roja y un
usuario sin ninguna preferencia.</p>
<p>Otra vez, este código podría implementarse de muchas maneras, y aquí, para
centrarnos en los closures, nos hemos adherido a los conceptos que ya has
aprendido, excepto por el cuerpo del método <code>giveaway</code> que usa un closure. En el
método <code>giveaway</code>, obtenemos la preferencia del usuario como un parámetro de
tipo <code>Option&lt;ShirtColor&gt;</code> y llamamos al método <code>unwrap_or_else</code> en
<code>user_preference</code>. El método <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> en <code>Option&lt;T&gt;</code></a></p>
<!-- ignore --> está definido por la biblioteca estándar. Toma un argumento: un
<p>Closure sin ningún argumento que devuelve un valor <code>T</code> (el mismo tipo almacenado
en la variante <code>Some</code> de la <code>Option&lt;T&gt;</code>, en este caso <code>ShirtColor</code>). Si la
<code>Option&lt;T&gt;</code> es la variante <code>Some</code>, <code>unwrap_or_else</code> devuelve el valor de dentro
de <code>Some</code>. Si la <code>Option&lt;T&gt;</code> es la variante <code>None</code>, <code>unwrap_or_else</code> llama al
closure y devuelve el valor devuelto por el closure.</p>
<p>Especificamos el closure <code>|| self.most_stocked()</code> como argumento a
<code>unwrap_or_else</code>. Este es un closure que no toma parámetros en sí mismo (si el
closure tuviera parámetros, aparecerían entre las dos barras verticales). El
cuerpo del closure llama a <code>self.most_stocked()</code>. Estamos definiendo el closure
aquí, y la implementación de <code>unwrap_or_else</code> evaluará el closure más tarde si
se necesita el resultado.</p>
<p>Ejecutar este código imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>Un aspecto interesante aquí es que hemos pasado un closure que llama a
<code>self.most_stocked()</code> en la instancia <code>Inventory</code> actual. La biblioteca estándar
no necesitaba saber nada sobre los tipos <code>Inventory</code> o <code>ShirtColor</code> que
definimos, o la lógica que queremos usar en este escenario. El closure captura
una referencia inmutable a la instancia <code>self</code> <code>Inventory</code> y la pasa con el
código que especificamos al método <code>unwrap_or_else</code>. Las funciones, por otro
lado, no pueden capturar su entorno de esta manera.</p>
<h3 id="inferencia-de-tipo-de-closure-y-anotación"><a class="header" href="#inferencia-de-tipo-de-closure-y-anotación">Inferencia de tipo de Closure y anotación</a></h3>
<p>Existen más diferencias entre funciones y closures. Los closures no suelen
requerir que anotes los tipos de los parámetros o el valor de retorno como lo
hacen las funciones <code>fn</code>. Las anotaciones de tipo son necesarias en las
funciones porque los tipos son parte de una interfaz explícita expuesta a tus
usuarios. Definir esta interfaz rígidamente es importante para garantizar que
todos estén de acuerdo en qué tipos de valores usa y devuelve una función. Los
closures, por otro lado, no se usan en una interfaz expuesta como esta: se
almacenan en variables y se usan sin nombrarlos y exponerlos a los usuarios de
nuestra biblioteca.</p>
<p>Los closures típicamente son cortos y relevantes solo dentro de un contexto
estrecho en lugar de en cualquier escenario arbitrario. Dentro de estos
contextos limitados, el compilador puede inferir los tipos de los parámetros y
el tipo de retorno, similar a cómo puede inferir los tipos de la mayoría de las
variables (hay casos raros en los que el compilador también necesita
anotaciones de tipo de closure).</p>
<p>Como con las variables, podemos agregar anotaciones de tipo opcionales si
queremos aumentar la explicitud y la claridad a costa de ser más verbosos de lo
estrictamente necesario. La anotación de tipos para un closure se vería como la
definición que se muestra en el Listado 13-2. En este ejemplo, estamos
definiendo un closure y almacenándolo en una variable en lugar de definir el
closure en el lugar donde lo pasamos como argumento como lo hicimos en el
Listado 13-1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-2: Agregando anotaciones de tipo opcionales
para los tipos de parámetros y valor de retorno en el closure</span></p>
<p>Con la anotación de tipo agregada, la sintaxis de los closures se parece más a
la sintaxis de las funciones. Aquí definimos una función que agrega 1 a su
parámetro y un closure que tiene el mismo comportamiento, para comparación.
Hemos agregado algunos espacios para alinear las partes relevantes. Esto
ilustra cómo la sintaxis de los closures es similar a la sintaxis de las
funciones, excepto por el uso de tuberías y la cantidad de sintaxis que es
opcional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>La primera línea muestra una definición de función, y la segunda línea muestra
una definición de closure completamente anotada. En la tercera línea, quitamos
las anotaciones de tipo de la definición de closure. En la cuarta línea,
quitamos los corchetes, que son opcionales porque el cuerpo del closure tiene
solo una expresión. Estas son todas definiciones válidas que producirán el mismo
comportamiento cuando se llamen. Las líneas <code>add_one_v3</code> y <code>add_one_v4</code>
requieren que los closures se evalúen para poder compilar porque los tipos se
inferirán a partir de su uso. Esto es similar a <code>let v = Vec::new();</code> que
necesita anotaciones de tipo o valores de algún tipo para insertar en el <code>Vec</code>
para que Rust pueda inferir el tipo.</p>
<p>Para las definiciones de closure, el compilador infiere un tipo concreto para
cada uno de sus parámetros y para su valor de retorno. Por ejemplo, el Listado
13-3 muestra la definición de un closure corto que solo devuelve el valor que
recibe como parámetro. Este closure no es muy útil, excepto para los propósitos
de este ejemplo. Tenga en cuenta que no hemos agregado ninguna anotación de
tipo a la definición. Debido a que no hay anotaciones de tipo, podemos llamar al
closure con cualquier tipo, lo que hemos hecho aquí con <code>String</code> la primera
vez. Si luego intentamos llamar a <code>example_closure</code> con un entero, obtendremos
un error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-3: Intentando llamar a un closure cuyos tipos
se infieren con dos tipos diferentes</span></p>
<p>El compilador nos da este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from(&quot;hello&quot;));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin &quot;closure-example&quot;) due to 1 previous error
</code></pre>
<p>La primera vez que llamamos a <code>example_closure</code> con el valor <code>String</code>, el
compilador infiere el tipo de <code>x</code> y el tipo de retorno del closure como
<code>String</code>. Esos tipos se bloquean en el closure en <code>example_closure</code>, y
obtenemos un error de tipo cuando intentamos usar un tipo diferente con el
mismo closure.</p>
<h3 id="capturando-referencias-o-moviendo-el-ownership"><a class="header" href="#capturando-referencias-o-moviendo-el-ownership">Capturando referencias o moviendo el ownership</a></h3>
<p>Los closures pueden valores desde su entorno de tres maneras, que se mapean
directamente a las tres formas en que una función puede tomar un parámetro:
borrowing inmutable, borrowing mutable y tomando ownership. El closure decidirá
cuál de estos usar en función de lo que haga el cuerpo de la función con los
valores capturados.</p>
<p>En el Listado 13-4, definimos un closure que captura una referencia inmutable al
vector <code>list</code> ya que solo necesita una referencia inmutable para imprimir el
valor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    let only_borrows = || println!(&quot;From closure: {list:?}&quot;);

    println!(&quot;Before calling closure: {list:?}&quot;);
    only_borrows();
    println!(&quot;After calling closure: {list:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-4: Definiendo y llamando a un closure que
captura una referencia inmutable</span></p>
<p>Este ejemplo también ilustra que una variable puede vincularse a una definición
de closure, y luego podemos llamar al closure usando el nombre de la variable y
paréntesis como si el nombre de la variable fuera un nombre de función.</p>
<p>Debido a que podemos tener múltiples referencias inmutables a <code>list</code> al mismo
tiempo, <code>list</code> sigue siendo accesible desde el código antes de la definición del
closure, después de la definición del closure, pero antes de que se llame al
closure, y después de que se llame al closure. Este código se compila, se
ejecuta e imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Luego, en el Listado 13-5, cambiamos el cuerpo del closure para que agregue un
elemento al vector <code>list</code>. El closure ahora captura una referencia mutable:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;After calling closure: {list:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-5: Definiendo y llamando a un closure que
captura una referencia mutable</span></p>
<p>Este código compila, se ejecuta e imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Nota que ya no hay un <code>println!</code> entre la definición y la llamada del closure
<code>borrows_mutably</code>: cuando se define <code>borrows_mutably</code>, captura una referencia
mutable a <code>list</code>. No usamos el closure nuevamente después de llamar al closure,
por lo que el préstamo mutable termina. Entre la definición del closure y la
llamada del closure, no se permite un préstamo inmutable para imprimir porque
no se permiten otros préstamos cuando hay un préstamo mutable. ¡Intente agregar
un <code>println!</code> allí para ver qué mensaje de error obtiene!</p>
<p>Si deseas forzar al closure para que tome ownership de los valores que usa en el
entorno, incluso cuando el cuerpo del closure no los necesite, puedes usar la
palabra clave <code>move</code> antes de la lista de parámetros.</p>
<p>Esta técnica es principalmente útil cuando se pasa un closure a un nuevo hilo
para mover los datos para que sean propiedad del nuevo hilo. Discutiremos los
hilos y por qué querrías usarlos en detalle en el Capítulo 16 cuando hablemos
sobre la concurrencia, pero por ahora, exploremos brevemente cómo generar un
nuevo hilo usando un closure que necesita la palabra clave <code>move</code>. El Listado
13-6 muestra el Listado 13-4 modificado para imprimir el vector en un nuevo
hilo en lugar de en el hilo principal:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    thread::spawn(move || println!(&quot;From thread: {list:?}&quot;))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 13-6: Usando <code>move</code> para forzar que el closure del
thread tome el ownership de <code>list</code></span></p>
<p>Iniciamos un nuevo hilo, dando al hilo un closure para ejecutar como argumento.
El cuerpo del closure imprime la lista. En el Listado 13-4, el closure solo
capturó <code>list</code> usando una referencia inmutable porque esa es la menor cantidad
de acceso a <code>list</code> necesaria para imprimirla. En este ejemplo, aunque el cuerpo
del closure todavía solo necesita una referencia inmutable, debemos especificar
que <code>list</code> debe moverse al closure poniendo la palabra clave <code>move</code> al comienzo
de la definición del closure. El nuevo hilo podría terminar antes de que el
resto del hilo principal termine, o el hilo principal podría terminar primero.
Si el hilo principal mantuviera la propiedad de <code>list</code> pero terminara antes de
que lo hiciera el nuevo hilo y dejara caer <code>list</code>, la referencia inmutable en
el hilo sería inválida. Por lo tanto, el compilador requiere que <code>list</code> se
mueva al closure dado al nuevo hilo para que la referencia sea válida. ¡Intente
eliminar la palabra clave <code>move</code> o usar <code>list</code> en el hilo principal después de
que se defina el closure para ver qué errores del compilador obtiene!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="moviendo-valores-capturados-fuera-de-los-closures-y-los-traits-fn"><a class="header" href="#moviendo-valores-capturados-fuera-de-los-closures-y-los-traits-fn">Moviendo valores capturados fuera de los closures y los traits <code>Fn</code></a></h3>
<p>Una vez que un closure ha capturado una referencia o capturado el ownership de
un valor del entorno donde se define el closure (afectando así lo que, si
cualquier cosa, se mueve <em>dentro</em> del closure), el código en el cuerpo del
closure define lo que sucede con las referencias o valores cuando el closure se
evalúa más tarde (afectando así lo que, si cualquier cosa, se mueve <em>fuera</em> del
closure). El cuerpo de un closure puede hacer cualquiera de las siguientes
acciones: mover un valor capturado fuera del closure, mutar el valor capturado,
ni mover ni mutar el valor, o no capturar nada del entorno para comenzar.</p>
<p>La forma en que un closure captura y maneja los valores del entorno afecta qué
traits implementa el closure, y los traits son cómo las funciones y los
structs pueden especificar qué tipos de closures pueden usar. Los closures
implementarán automáticamente uno, dos o los tres de estos traits <code>Fn</code>, de
manera aditiva, dependiendo de cómo el cuerpo del closure maneje los valores:</p>
<ol>
<li><code>FnOnce</code> se aplica los closures que pueden ser llamados una vez. Todos los
closures implementan al menos este trait, porque todos los closures pueden
ser llamados. Un closure que mueve valores capturados fuera de su cuerpo
solo implementará <code>FnOnce</code> y ninguno de los otros traits <code>Fn</code>, porque solo
puede ser llamado una vez.</li>
<li><code>FnMut</code> se aplica a los closures que no mueven valores capturados fuera de
su cuerpo, pero que podrían mutar los valores capturados. Estos closures
pueden ser llamados más de una vez.</li>
<li><code>Fn</code> se aplica a los closures que no mueven valores capturados fuera de su
cuerpo y que no mutan los valores capturados, así como los closures que no
capturan nada de su entorno. Estos closures pueden ser llamados más de una
vez sin mutar su entorno, lo cual es importante en casos como llamar a un
closure múltiples veces concurrentemente.</li>
</ol>
<p>Veamos la definición del método <code>unwrap_or_else</code> en <code>Option&lt;T&gt;</code> que utilizamos
en el Listado 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Recuerda que <code>T</code> es el tipo generic que representa el tipo del valor en la
variante <code>Some</code> de un <code>Option</code>. Ese tipo <code>T</code> también es el tipo de retorno de
la función <code>unwrap_or_else</code>: el código que llama a <code>unwrap_or_else</code> en un
<code>Option&lt;String&gt;</code>, por ejemplo, obtendrá un <code>String</code>.</p>
<p>Luego, observe que el método <code>unwrap_or_else</code> tiene el parámetro de tipo
generic adicional <code>F</code>. El tipo <code>F</code> es el tipo del parámetro llamado <code>f</code>, que
es el closure que proporcionamos al llamar a <code>unwrap_or_else</code>.</p>
<p>El trait bound especificado en el tipo generic <code>F</code> es <code>FnOnce() -&gt; T</code>, lo que
significa que <code>F</code> debe poder ser llamado una vez para producir un valor del
tipo <code>T</code>. Usar <code>FnOnce</code> en el trait bound expresa la restricción de que
<code>unwrap_or_else</code> solo va a llamar a <code>f</code> como máximo una vez. En el cuerpo de
<code>unwrap_or_else</code>, podemos ver que si el <code>Option</code> es <code>Some</code>, <code>f</code> no se llamará.
Si el <code>Option</code> es <code>None</code>, <code>f</code> se llamará una vez. Debido a que todos los
closures implementan <code>FnOnce</code>, <code>unwrap_or_else</code> acepta todos esos tipos de 
closures y es tan flexible como puede ser.</p>
<blockquote>
<p>Nota: Las funciones también pueden implementar los tres traits <code>Fn</code>, <code>FnMut</code>
y <code>FnOnce</code>. Si lo que queremos hacer no requiere capturar un valor del
entorno, podemos usar el nombre de una función en lugar de un closure donde
necesitamos algo que implemente uno de los traits <code>Fn</code>. Por ejemplo, en un
valor <code>Option&lt;Vec&lt;T&gt;&gt;</code>, podríamos llamar a <code>unwrap_or_else(Vec::new)</code> para
obtener un nuevo vector vacío si el valor es <code>None</code>.</p>
</blockquote>
<p>Ahora veamos el método de la biblioteca estándar <code>sort_by_key</code> definido en
slices, para ver cómo difiere de <code>unwrap_or_else</code> y por qué <code>sort_by_key</code>
utiliza <code>FnMut</code> en lugar de <code>FnOnce</code> para el trait bound. El closure recibe un
argumento en forma de referencia al elemento actual en el slice que se está
considerando, y devuelve un valor de tipo <code>K</code> que se puede ordenar. Esta
función es útil cuando desea ordenar un slice por un atributo particular de
cada elemento. En el Listado 13-7, tenemos una lista de instancias de
<code>Rectangle</code> y usamos <code>sort_by_key</code> para ordenarlas por su atributo <code>width</code>
de menor a mayor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{list:#?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-7: Usando <code>sort_by_key</code> para ordenar
rectángulos por ancho</span></p>
<p>Este código imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>La razón por la que <code>sort_by_key</code> está definido para tomar un closure <code>FnMut</code>
es que llama al closure varias veces: una vez por cada elemento en el slice.
El closure <code>|r| r.width</code> no captura, muta ni mueve nada de su entorno, por lo
que cumple con los requisitos de los trait bound.</p>
<p>En contraste, El Listado 13-8 muestra un ejemplo de un closure que implementa
solo el trait <code>FnOnce</code>, porque mueve un valor fuera del entorno. El
compilador no nos permitirá usar este closure con <code>sort_by_key</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;closure called&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{list:#?}&quot;);
}</code></pre>
<p><span class="caption">Listing 13-8: Intentando usar un closure <code>FnOnce</code> con
<code>sort_by_key</code></span></p>
<p>Esto es un ejemplo artificial y complicado (que no funciona) para tratar de
contar la cantidad de veces que se llama a <code>sort_by_key</code> llama a la closure al 
ordenar <code>list</code>.
Este código intenta hacer este conteo empujando <code>value</code>—un <code>String</code> del
entorno del closure—en el vector <code>sort_operations</code>. El closure captura <code>value</code>
y luego mueve <code>value</code> fuera del closure transfiriendo la propiedad de <code>value</code>
al vector <code>sort_operations</code>. Este closure puede ser llamado una vez; tratar de
llamarlo una segunda vez no funcionaría porque <code>value</code> ya no estaría en el
entorno para ser empujado a <code>sort_operations</code> nuevamente. Por lo tanto, este
closure solo implementa <code>FnOnce</code>. Cuando intentamos compilar este código,
obtenemos este error de que <code>value</code> no se puede mover fuera del closure porque
el closure debe implementar <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from(&quot;closure called&quot;);
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin &quot;rectangles&quot;) due to 1 previous error
</code></pre>
<p>El error señala la línea en el cuerpo del closure que mueve <code>value</code> fuera del
entorno. Para solucionar esto, debemos cambiar el cuerpo del closure para que
no mueva valores fuera del entorno. Para contar la cantidad de veces que se
llama a la closure, mantener un contador en el entorno e incrementar su
valor en el cuerpo del closure es una forma más directa de calcular eso. El
closure en el Listado 13-9 funciona con <code>sort_by_key</code> porque solo está
capturando una referencia mutable al contador <code>num_sort_operations</code> y, por lo
tanto, puede ser llamado más de una vez:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{list:#?}, sorted in {num_sort_operations} operations&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-9: Usando un closure <code>FnMut</code> con <code>sort_by_key</code>
está permitido</span></p>
<p>Los <code>Fn</code> traits son importantes al definir o usar funciones o tipos que
hacen uso de closures. En la siguiente sección, discutiremos los iteradores.
Muchos métodos de iteradores toman argumentos de closure, ¡así que tenga en
cuenta estos detalles de closure a medida que continuamos!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
