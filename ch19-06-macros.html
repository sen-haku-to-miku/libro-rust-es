<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macros - El Lenguaje de Programación Rust</title>


        <!-- Custom HTML head -->
        
            <link rel="canonical" href="https://book.rustlang-es.org/ch19-06-macros" />


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta property="og:url" content="https://book.rustlang-es.org">
        <meta property="og:type" content="book">
        <meta property="og:title" content="Macros - El Lenguaje de Programación Rust">
        <meta property="og:description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta property="og:image" content="https://rustlang-es.org/rust-book-es/img/open-graph.png">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El Lenguaje de Programación Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Empezando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ¡Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ¡Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un juego de adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Flujo de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Entendiendo el Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ¿Qué es el Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Prestamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> El Tipo Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa de Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintaxis de Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El operador de control de flujo match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Flujo de Control Conciso con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Administrando Proyectos en Crecimiento con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo módulos para controlar el scope y la privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths para referirse a un item en el árbol de módulos</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Incluyendo rutas al Scope con la palabra clave use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separando Módulos en Diferentes Archivos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenando listas de valores con vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenando texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Almacenar Claves con Valores Asociados en HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! o no panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos Genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definiendo Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Escribiendo Tests Automatizados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Cómo Escribir Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlando Cómo Los Tests Son Ejecutados</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización De Los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un proyecto de I/O: Construyendo un programa de línea de comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando argumentos de línea de comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la modularidad y el manejo de errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la funcionalidad de la biblioteca con T.D.D.</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo mensajes de error estándar en lugar del output estándar</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características De Lenguajes Funcionales: Iteradores y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones anónimas que capturan su entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una serie de elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando nuestro proyecto I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparando Performance: Bucles vs. Iteradores</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más sobre Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate a Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extendiendo Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Usando Box&lt;T&gt; para Apuntar a Datos en el Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratando los Smart Pointers como Referencias Regulares con el Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ejecutando Código al Limpiar con el Trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, el Smart Pointer de Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referencias Circulares Pueden Fugar Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia Sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Usando Threads para Ejecutar Código Simultáneamente</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Usando el Pasaje de Mensajes para Transferir Datos entre Hilos</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Concurrencia con Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible con los Traits Sync y Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust como un Lenguaje de Programación Orientado a Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Usando Trait Objects que Permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementando un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los lugares donde se pueden usar Patterns</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: Si un Pattern Puede Fallar al Hacer Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Sintaxis de los Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html" class="active"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Rust Nightly”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Lenguaje de Programación Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustLangES/rust-book-es" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Hemos utilizado macros como <code>println!</code> a lo largo de este libro, pero no hemos
explorado completamente qué es una macro y cómo funciona. El término <em>macro</em> se
refiere a una familia de características en Rust: macros <em>declarativas</em> con
<code>macro_rules!</code> y tres tipos de macros <em>procedurales</em>:</p>
<ul>
<li>Macros Personalizadas <code>#[derive]</code> que especifican código agregado con el</li>
<li>atributo <code>derive</code> usado en structs y enums</li>
<li>Macros similares a atributos que definen atributos personalizados utilizables
en cualquier item</li>
<li>Macros similares a funciones que se ven como llamadas a funciones, pero
operan en los tokens especificados como argumento</li>
</ul>
<p>Hablaremos de cada uno de estos a su vez, pero primero, veamos por qué
necesitamos macros cuando ya tenemos funciones.</p>
<h3 id="la-diferencia-entre-macros-y-funciones"><a class="header" href="#la-diferencia-entre-macros-y-funciones">La Diferencia Entre Macros y Funciones</a></h3>
<p>Fundamentalmente, las macros son una forma de escribir código que escribe otro
código, lo que se conoce como <em>metaprogramación</em>. En el Apéndice C, discutimos
el atributo <code>derive</code>, que genera una implementación de varios traits para ti.
También hemos usado las macros <code>println!</code> y <code>vec!</code> a lo largo del libro. Todas
estas macros <em>se expanden</em> para producir más código que el código que has
escrito manualmente.</p>
<p>La metaprogramación es útil para reducir la cantidad de código que tienes que
escribir y mantener, que también es uno de los roles de las funciones. Sin
embargo, las macros tienen algunos poderes adicionales que las funciones no
tienen.</p>
<p>Una función debe declarar el número y el tipo de parámetros que tiene la
función. Las macros, por otro lado, pueden tomar un número variable de
parámetros: podemos llamar a <code>println!(&quot;hello&quot;)</code> con un argumento o
<code>println!(&quot;hello {}&quot;, name)</code> con dos argumentos. Además, las macros se
expanden antes de que el compilador interprete el significado del código, por
lo que una macro puede, por ejemplo, implementar un trait en un tipo dado. Una
función no puede, porque se llama en tiempo de ejecución y un trait debe
implementarse en tiempo de compilación.</p>
<p>La desventaja de implementar una macro en lugar de una función es que las
definiciones de macros son más complejas que las definiciones de funciones
porque estás escribiendo código Rust que escribe código Rust. Debido a esta
indirección, las definiciones de macros generalmente son más difíciles de leer,
entender y mantener que las definiciones de funciones.</p>
<p>Otra diferencia importante entre las macros y las funciones es que debes
definir macros o traerlas al scope <em>antes</em> de llamarlas en un archivo, a
diferencia de las funciones que puedes definir en cualquier lugar y llamar en
cualquier lugar.</p>
<h3 id="macros-declarativas-con-macro_rules-para-metaprogramacion-general"><a class="header" href="#macros-declarativas-con-macro_rules-para-metaprogramacion-general">Macros Declarativas con <code>macro_rules!</code> para Metaprogramacion General</a></h3>
<p>La forma más utilizada de macros en Rust es la <em>macro declarativa</em>. A veces
también se denominan “macros por ejemplo”, “<code>macro_rules!</code> macros” o simplemente
“macros”. En su núcleo, las macros declarativas te permiten escribir algo
similar a una expresión <code>match</code> de Rust. Como se discutió en el Capítulo 6, las
expresiones <code>match</code> son estructuras de control que toman una expresión,
comparan el valor resultante de la expresión con patrones y luego ejecutan el
código asociado con el patrón coincidente. Las macros también comparan un valor
con patrones que están asociados con un código particular: en esta situación,
el valor es el código fuente literal de Rust que se pasa a la macro; los
patrones se comparan con la estructura de ese código fuente; y el código
asociado con cada patrón, cuando coincide, reemplaza el código pasado a la
macro. Todo esto sucede durante la compilación.</p>
<p>Para definir una macro, usas el constructor <code>macro_rules!</code>. Exploremos cómo
usar <code>macro_rules!</code> mirando cómo se define la macro <code>vec!</code>. El Capítulo 8
cubrió cómo podemos usar la macro <code>vec!</code> para crear un nuevo vector con valores
particulares. Por ejemplo, la siguiente macro crea un nuevo vector que contiene
tres enteros:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>También podemos usar la macro <code>vec!</code> para crear un vector de dos enteros o un
vector de cinco string slices. No podríamos usar una función porque no
conoceríamos el número o el tipo de valores.</p>
<p>El Listado 19-28 muestra una definición ligeramente simplificada de la macro
<code>vec!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<p><span class="caption">Listing 19-28: Una versión simplificada de la definición
de la macro <code>vec!</code></span></p>
<blockquote>
<p>Nota: La definición real de la macro <code>vec!</code> en la biblioteca estándar incluye
código para preasignar la cantidad correcta de memoria por adelantado. Ese
código es una optimización que no incluimos aquí para hacer el ejemplo más
simple.</p>
</blockquote>
<p>La anotación <code>#[macro_export]</code> indica que esta macro debe estar disponible
siempre que la biblioteca en la que se define la macro se traiga al scope. Sin
esta anotación, la macro no se puede traer al scope.</p>
<p>Luego comenzamos la definición de la macro con <code>macro_rules!</code> y el nombre de la
macro que estamos definiendo <em>sin</em> el signo de exclamación. El nombre, en este
caso <code>vec</code>, va seguido de llaves que denotan el cuerpo de la definición de la
macro.</p>
<p>La estructura en el cuerpo de <code>vec!</code> es similar a la estructura de una
expresión <code>match</code>. Aquí tenemos un brazo con el patrón <code>( $( $x:expr ),* )</code>,
seguido de <code>=&gt;</code> y el bloque de código asociado con este patrón. Si el patrón
coincide, se emitirá el bloque de código asociado. Dado que este es el único
patrón en esta macro, solo hay una forma válida de coincidir; cualquier otro
patrón dará como resultado un error. Las macros más complejas tendrán más de una
opción.</p>
<p>La sintaxis válida del pattern en una macro es diferente de la sintaxis de los
patterns cubiertos en el Capítulo 18 porque los patterns de macro se comparan
con la estructura del código Rust en lugar de con valores. Recorramos lo que
significan las piezas del pattern en el Listado 19-28; para obtener la sintaxis
completa del pattern de macro, consulte la <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Referencia de Rust</a>.</p>
<p>Primero, usamos un conjunto de paréntesis para englobar todo el patrón. Usamos
el signo de dólar (<code>$</code>) para declarar una variable en el sistema de macros que
contendrá el código Rust que coincida con el patrón. El signo de dólar hace que
quede claro que esta es una variable de macro en lugar de una variable regular
de Rust. A continuación, viene un conjunto de paréntesis que captura los valores
que coinciden con el patrón dentro de los paréntesis para su uso en el código de
reemplazo. Dentro de <code>$()</code> está <code>$x:expr</code>, que coincide con cualquier expresión
de Rust y le da el nombre <code>$x</code>.</p>
<p>La coma que sigue a <code>$()</code> índica que opcionalmente podría aparecer un carácter
de coma separador literal después del código que coincide con el código en
<code>$()</code>. Él <code>*</code> especifica que el patrón coincide cero o más veces con lo que
precede al <code>*</code>.</p>
<p>Cuando llamamos a esta macro con <code>vec![1, 2, 3];</code>, el patrón <code>$x</code> coincide tres
veces con las tres expresiones <code>1</code>, <code>2</code> y <code>3</code>.</p>
<p>Ahora veamos el pattern en el cuerpo del código asociado con esta opción:
<code>temp_vec.push($x);</code>. Dentro de <code>$()*</code> se genera para cada parte que coincide
con <code>$()</code> en el patrón cero o más veces dependiendo de cuántas veces coincida
el patrón. Él <code>$x</code> se reemplaza con cada expresión que coincida. Cuando llamamos
a esta macro con <code>vec![1, 2, 3];</code>, el código generado que reemplaza esta
llamada a la macro será el siguiente:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>Hemos definido una macro que puede tomar cualquier número de argumentos de
cualquier tipo y puede generar código para crear un vector que contenga los
elementos especificados.</p>
<p>Para obtener más información sobre cómo escribir macros, consulta la
documentación en línea u otros recursos, como <a href="https://veykril.github.io/tlborm/">“The Little Book of Rust
Macros”</a> iniciado por Daniel Keep y continuado por Lukas Wirth.</p>
<h3 id="macros-procedurales-para-generar-código-a-partir-de-atributos"><a class="header" href="#macros-procedurales-para-generar-código-a-partir-de-atributos">Macros Procedurales para Generar Código a partir de Atributos</a></h3>
<p>Las macros procedurales, que es la segunda forma de macros, actúan más como
una función (y son un tipo de procedimiento). Las macros procedurales aceptan
código como entrada, operan en ese código y producen código como salida en
lugar de coincidir con patrones y reemplazar el código por otro código como lo
hacen las macros declarativas. Los tres tipos de macros procedurales son
derivaciones personalizadas, atributos y funciones, y todas funcionan de manera
similar.</p>
<p>Al crear macros procedurales, las definiciones deben residir en su propio
crate con un tipo de crate especial. Esto se debe a razones técnicas complejas
que esperamos eliminar en el futuro. En el Listado 19-29 se muestra cómo se
define una macro procedural, donde <code>some_attribute</code> es un marcador de posición
para usar un tipo específico de macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Listing 19-29: Un ejemplo de definición de una macro
procedural</span></p>
<p>La función que define una macro procedural tome un <code>TokenStream</code> como entrada y
devuelve un <code>TokenStream</code> como salida. El <code>TokenStream</code> tipo es definido por el
<code>proc_macro</code> crate que se incluye con Rust y representa una secuencia de tokens.
Esta es la base de la macro: el código fuente en el que la macro está operando
constituye la entrada <code>TokenStream</code>, y el código que la macro produce es el
<code>TokenStream</code> de salida. La función también tiene un atributo adjunto que
especifica qué tipo de macro procedural estamos creando. Podemos tener varios
tipos de macros procedurales en el mismo crate.</p>
<p>Veamos los diferentes tipos de macros procedurales. Comenzaremos con una
derivación personalizada y luego explicaremos las pequeñas diferencias que
hacen que las otras formas sean diferentes.</p>
<h3 id="cómo-escribir-una-macro-derive-personalizada"><a class="header" href="#cómo-escribir-una-macro-derive-personalizada">Cómo Escribir una Macro <code>derive</code> Personalizada</a></h3>
<p>Creemos un crate llamado <code>hello_macro</code> que defina un trait llamado
<code>HelloMacro</code> con una función asociada llamada <code>hello_macro</code>. En lugar de hacer
que nuestros usuarios implementen el trait <code>HelloMacro</code> para cada uno de sus
tipos, proporcionaremos una macro procedural para que los usuarios puedan
anotar sus tipos con <code>#[derive(HelloMacro)]</code> para obtener una implementación
predeterminada de la función <code>hello_macro</code>. La implementación predeterminada
imprimirá <code>Hello, Macro! My name is TypeName!</code>, donde <code>TypeName</code> es el nombre
del tipo en el que se ha definido este trait. En otras palabras, escribiremos
un crate que permita a otro programador escribir código como el Listado 19-30
usando nuestro crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Listing 19-30: El código que un usuario de nuestro crate
podrá escribir cunado se use nuestra macro procedural</span></p>
<p>Este código imprimirá <code>Hello, Macro! My name is Pancakes!</code> cuando hayamos
terminado. El primer paso es hacer un nuevo crate de biblioteca, así:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>A continuación, definiremos el trait <code>HelloMacro</code> y su función asociada:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<p>Tenemos un trait y su función. En este punto, nuestro usuario de crate podría
implementar el trait para lograr la funcionalidad deseada, así:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>Sin embargo, tendrían que escribir el bloque de implementación para cada tipo
que quisieran usar con <code>hello_macro</code>; queremos evitar que tengan que hacer este
trabajo.</p>
<p>Además, aún no podemos proporcionar una implementación predeterminada de
la función <code>hello_macro</code> que imprimirá el nombre del tipo en el que se
implementa el trait: rust no tiene capacidades de reflexión, por lo que no
puede buscar el nombre del tipo en tiempo de ejecución. Necesitamos una macro
para generar código en tiempo de compilación.</p>
<p>El siguiente paso es definir la macro procedural. En el momento de escribir
esto, las macros procedurales deben estar en su propio crate. Eventualmente,
esta restricción podría ser levantada. La convención para estructurar crates y
macro crates es la siguiente: para un crate llamado <code>foo</code>, un crate de macro
procedural de derivación personalizada se llama <code>foo_derive</code>. Creemos un nuevo
crate llamado <code>hello_macro_derive</code> dentro de nuestro proyecto <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Nuestros dos crates están estrechamente relacionados, por lo que creamos el
crate de macro procedural dentro del directorio de nuestro crate <code>hello_macro</code>.
Si cambiamos la definición del trait en <code>hello_macro</code>, también tendremos que
cambiar la implementación de la macro procedural en <code>hello_macro_derive</code>. Los
dos crates deberán publicarse por separado, y los programadores que usen estos
crates deberán agregar ambos como dependencias y traerlos a ambos al scope.
En su lugar, podríamos hacer que el crate <code>hello_macro</code> use <code>hello_macro_derive</code>
como una dependencia y vuelva a exportar el código de la macro procedural.
Sin embargo, la forma en que hemos estructurado el proyecto hace posible que
los programadores usen <code>hello_macro</code> incluso si no quieren la funcionalidad
<code>derive</code>.</p>
<p>Necesitamos declarar el crate <code>hello_macro_derive</code> como un crate de macro
procedural. También necesitaremos funcionalidad de los crates <code>syn</code> y <code>quote</code>,
como veremos en un momento, por lo que necesitamos agregarlos como dependencias.
Agrega lo siguiente al archivo <em>Cargo.toml</em> para <code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;2.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>Para comenzar a definir la macro procedural, coloca el código del Listado 19-31
en tu archivo <em>src/lib.rs</em> para el crate <code>hello_macro_derive</code>. Ten en cuenta que
este código no se compilará hasta que agreguemos una definición para la función
<code>impl_hello_macro</code>.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}</code></pre>
<p><span class="caption">Listing 19-31: Código que la mayoría de los crates de
macros procedurales requerirán para procesar código Rust</span></p>
<p>Observa que hemos dividido el código en la función <code>hello_macro_derive</code>, que
es responsable de analizar el <code>TokenStream</code>, y la función <code>impl_hello_macro</code>,
que es responsable de transformar el árbol de sintaxis: esto hace que escribir
una macro procedural sea más conveniente. El código en la función externa
(<code>hello_macro_derive</code> en este caso) será el mismo para casi todos los crates de
macros procedurales que veas o crees. El código que especifiques en el cuerpo
de la función interna (<code>impl_hello_macro</code> en este caso) será diferente
dependiendo del propósito de tu macro procedural.</p>
<p>Hemos introducido tres nuevos crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, y <a href="https://crates.io/crates/quote"><code>quote</code></a>. El
crate <code>proc_macro</code> viene con Rust, por lo que no necesitamos agregarlo a las
dependencias en <em>Cargo.toml</em>. El crate <code>proc_macro</code> es la API del compilador
que nos permite leer y manipular código Rust desde nuestro código.</p>
<p>El crate <code>syn</code> analiza el código Rust desde un string en una estructura de
datos en la que podemos realizar operaciones. El crate <code>quote</code> convierte las
estructuras de datos de <code>syn</code> nuevamente en código Rust. Estos crates hacen que
sea mucho más simple analizar cualquier tipo de código Rust que deseemos
manipular: escribir un analizador completo para el código Rust no es una tarea
sencilla.</p>
<p>La función <code>hello_macro_derive</code> se llamará cuando un usuario de nuestro crate
especifique <code>#[derive(HelloMacro)]</code> en un tipo. Esto es posible porque hemos
anotado la función <code>hello_macro_derive</code> aquí con <code>proc_macro_derive</code> y
especificado el nombre <code>HelloMacro</code>, que coincide con el nombre de nuestro
trait; esta es la convención que siguen la mayoría de las macros procedurales.</p>
<p>La función <code>hello_macro_derive</code> convierte primero el <code>input</code> de un
<code>TokenStream</code> a una estructura de datos que podemos interpretar y realizar
operaciones. Aquí es donde entra en juego <code>syn</code>. La función <code>parse</code> en <code>syn</code>
toma un <code>TokenStream</code> y devuelve un struct <code>DeriveInput</code> que representa el
código Rust analizado. El Listado 19-32 muestra las partes relevantes del
struct <code>DeriveInput</code> que obtenemos al analizar el string <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Listing 19-32: La instancia <code>DeriveInput</code> que obtenemos
al analizar el código que tiene el atributo de la macro en el
Listado 19-30</span></p>
<p>Los campos de este struct muestran que el código Rust que hemos analizado es un
struct unitario con el <code>ident</code> (identificador, es decir, el nombre) de
<code>Pancakes</code>. Hay más campos en este struct para describir todo tipo de código
Rust; consulta la <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html">documentación de <code>syn</code> para <code>DeriveInput</code></a> para
obtener más información.</p>
<p>Pronto definiremos la función <code>impl_hello_macro</code>, que es donde construiremos el
código Rust que queremos incluir. Pero antes de hacerlo, ten en cuenta que la
salida de nuestra macro derive también es un <code>TokenStream</code>. El <code>TokenStream</code>
devuelto se agrega al código que escriben los usuarios de nuestro crate, por lo
que cuando compilan su crate, obtendrán la funcionalidad adicional que
proporcionamos en el <code>TokenStream</code> modificado.</p>
<p>Es posible que hayas notado que estamos usando <code>unwrap</code> para hacer que la
función <code>hello_macro_derive</code> genere un panic si la llamada a la función
<code>syn::parse</code> falla. Es necesario que nuestra macro procedural genere un panic
en caso de error porque las funciones <code>proc_macro_derive</code> deben devolver
<code>TokenStream</code> en lugar de <code>Result</code> para cumplir con la API de las macros
procedurales. Hemos simplificado este ejemplo usando <code>unwrap</code>; en código de
producción, debes proporcionar mensajes de error más específicos sobre lo que
salió mal usando <code>panic!</code> o <code>expect</code>.</p>
<p>Ahora que tenemos el código para convertir el código de Rust anotado de un
<code>TokenStream</code> a una instancia <code>DeriveInput</code>, generemos el código que implementa
el trait <code>HelloMacro</code> en el tipo anotado, como se muestra en el Listado 19-33.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<p><span class="caption">Listing 19-33: Implementando el trait <code>HelloMacro</code> usando
el código Rust analizado</span></p>
<p>Obtenemos una instancia del struct <code>DeriveInput</code> que contiene el nombre
(identificador) del tipo anotado usando <code>ast.ident</code>. El struct en el Listado
19-32 muestra que cuando ejecutamos la función <code>impl_hello_macro</code> en el código
del Listado 19-30, el <code>ident</code> que obtenemos tendrá el campo <code>ident</code> con un
valor de <code>&quot;Pancakes&quot;</code>. Por lo tanto, la variable <code>name</code> en el Listado 19-33
contendrá una instancia del struct <code>Ident</code> que, cuando se imprima, será la
cadena <code>&quot;Pancakes&quot;</code>, el nombre del struct en el Listado 19-30.</p>
<p>La macro <code>quote!</code> nos permite construir el código que queremos devolver. El
compilador espera algo diferente al resultado directo de la ejecución de la
macro <code>quote!</code>, por lo que debemos convertirlo a un <code>TokenStream</code>. Hacemos esto
llamando al método <code>into</code>, que consume esta representación intermedia y
devuelve un valor del tipo <code>TokenStream</code> requerido.</p>
<p>La macro <code>quote!</code> también proporciona algunas mecánicas de plantillas muy
interesantes: podemos ingresar <code>#name</code>, y <code>quote!</code> lo reemplazará con el valor
de la variable <code>name</code>. Incluso puedes hacer alguna repetición similar a la forma
en que funcionan las macros regulares. Consulta <a href="https://docs.rs/quote">la documentación del crate
<code>quote</code></a> para obtener una introducción completa.</p>
<p>Queremos que nuestra macro procedural genere una implementación de nuestro
trait <code>HelloMacro</code> para el tipo que el usuario ha anotado, lo cual podemos
lograr utilizando <code>#name</code>. La implementación del trait tiene la función
<code>hello_macro</code>, cuyo cuerpo contiene la funcionalidad que queremos proporcionar:
imprimir <code>Hello, Macro! My name is</code> y luego el nombre del tipo anotado.</p>
<p>La macro <code>stringify!</code> utilizada aquí está incorporada en Rust. Toma una
expresión de Rust como <code>1 + 2</code> y en tiempo de compilación convierte la
expresión en un literal de string como <code>&quot;1 + 2&quot;</code>. Esto es diferente a <code>format!</code>
o <code>println!</code>, macros que evalúan la expresión y luego convierten el resultado en
un <code>String</code>. Existe la posibilidad de que la entrada <code>#name</code> sea una expresión
para imprimir literalmente, por lo que usamos <code>stringify!</code>. El uso de
<code>stringify!</code> también ahorra una asignación al convertir <code>#name</code> en un literal
de string en tiempo de compilación.</p>
<p>En este punto, <code>cargo build</code> debería completarse correctamente tanto en
<code>hello_macro</code> como en <code>hello_macro_derive</code>. ¡Conectemos estos crates al código
del Listado 19-30 para ver la macro procedural en acción! Crea un nuevo
proyecto binario en tu directorio <em>projects</em> usando <code>cargo new pancakes</code>.
Necesitamos agregar <code>hello_macro</code> y <code>hello_macro_derive</code> como dependencias en el
<em>Cargo.toml</em> de <code>pancakes</code>. Si estás publicando tus versiones de <code>hello_macro</code>
y <code>hello_macro_derive</code> en <a href="https://crates.io/">crates.io</a>, serían dependencias
regulares; si no, puedes especificarlas como dependencias <code>path</code> de la
siguiente manera:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Coloca el código del Listado 19-30 en <em>src/main.rs</em> y ejecuta <code>cargo run</code>:
debería imprimir <code>Hello, Macro! My name is Pancakes!</code> La implementación del
trait <code>HelloMacro</code> de la macro procedural se incluyó sin que el crate <code>pancakes</code>
tuviera que implementarlo; la macro <code>#[derive(HelloMacro)]</code> agregó la
implementación del trait.</p>
<p>A continuación, vamos a explorar cómo los otros tipos de macros procedurales
difieren de las macros derive personalizadas.</p>
<h3 id="macros-similares-a-atributos"><a class="header" href="#macros-similares-a-atributos">Macros similares a atributos</a></h3>
<p>Las macros similares a atributos son similares a las macros derivadas
personalizadas, pero en lugar de generar código para el atributo <code>derive</code>,
permiten crear nuevos atributos. También son más flexibles: <code>derive</code> solo
funciona para structs y enums; los atributos se pueden aplicar a otros items
también, como funciones. Aquí hay un ejemplo de uso de una macro similar a un
atributo: digamos que tienes un atributo llamado <code>route</code> que anota funciones
cuando se usa un framework de aplicación web:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {</code></pre>
<p>El atributo <code>#[route]</code> será definido por el framework como una macro procedural.
La firma de la función de definición de la macro se vería así:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Aquí, tenemos dos parámetros de tipo <code>TokenStream</code>. El primero es para el
contenido del atributo: la parte <code>GET, &quot;/&quot;</code>. El segundo es el cuerpo del item
al que se adjunta el atributo: en este caso, <code>fn index() {}</code> y el resto del
cuerpo de la función.</p>
<p>Aparte de eso, las macros similares a atributos funcionan de la misma manera
que las macros derivadas personalizadas: creas un crate con el tipo <code>proc-macro</code>
y defines una función que genera el código que deseas.</p>
<h3 id="macros-similares-a-funciones"><a class="header" href="#macros-similares-a-funciones">Macros similares a funciones</a></h3>
<p>Las macros tipo función definen macros que se ven como llamadas a funciones.
De manera similar a las macros <code>macro_rules!</code>, son más flexibles que las
funciones; por ejemplo, pueden tomar un número desconocido de argumentos. Sin
embargo, las macros <code>macro_rules!</code> solo se pueden definir usando la sintaxis
similar a la de los patterns que discutimos en la sección <a href="#macros-declarativas-con-macro_rules-para-metaprogramacion-general">“Macros declarativas
con <code>macro_rules!</code> para metaprogramación general”</a><!-- ignore -->
anteriormente. Las macros tipo función toman un parámetro <code>TokenStream</code> y su
definición manipula ese <code>TokenStream</code> usando código Rust como los otros dos
tipos de macros procedurales. Un ejemplo de una macro tipo función es una macro
<code>sql!</code> que podría ser llamada así:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>Esta macro analizaría la declaración SQL dentro de ella y verificaría que sea
sintácticamente correcta, lo cual es un procesamiento mucho más complejo de lo
que una macro <code>macro_rules!</code> puede hacer. La macro <code>sql!</code> se definiría así:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Esta definición es similar a la firma de la macro de derivación personalizada:
recibimos los tokens que están dentro de los paréntesis y devolvemos el código
que queremos generar.</p>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>¡Uf! Ahora que tienes algunas características de Rust en tu caja de herramientas
que probablemente no usarás a menudo, pero sabrás que están disponibles en
circunstancias muy particulares. Hemos introducido varios temas complejos para
que cuando los encuentres en sugerencias de mensajes de error o en el código de
otras personas, puedas reconocer estos conceptos y sintaxis. Usa este capítulo
como referencia para guiarte hacia soluciones.</p>
<p>¡A continuación, pondremos en práctica todo lo que hemos discutido a lo largo
del libro y haremos un proyecto más!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-00-final-project-a-web-server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-00-final-project-a-web-server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
