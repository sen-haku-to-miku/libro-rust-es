<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>El Lenguaje de Programación Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
            <link rel="canonical" href="https://book.rustlang-es.org/" />


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta property="og:url" content="https://book.rustlang-es.org">
        <meta property="og:type" content="book">
        <meta property="og:title" content="El Lenguaje de Programación Rust">
        <meta property="og:description" content="El libro oficial para aprender el lenguaje de programación Rust, con tutoriales y guías.">
        <meta property="og:image" content="https://rustlang-es.org/rust-book-es/img/open-graph.png">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El Lenguaje de Programación Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Empezando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ¡Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ¡Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un juego de adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Flujo de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Entendiendo el Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ¿Qué es el Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Prestamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> El Tipo Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa de Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintaxis de Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El operador de control de flujo match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Flujo de Control Conciso con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Administrando Proyectos en Crecimiento con Paquetes, Crates y Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo módulos para controlar el scope y la privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths para referirse a un item en el árbol de módulos</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Incluyendo rutas al Scope con la palabra clave use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separando Módulos en Diferentes Archivos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenando listas de valores con vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenando texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Almacenar Claves con Valores Asociados en HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! o no panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos Genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definiendo Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Escribiendo Tests Automatizados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Cómo Escribir Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlando Cómo Los Tests Son Ejecutados</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización De Los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un proyecto de I/O: Construyendo un programa de línea de comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando argumentos de línea de comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la modularidad y el manejo de errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la funcionalidad de la biblioteca con T.D.D.</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo mensajes de error estándar en lugar del output estándar</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características De Lenguajes Funcionales: Iteradores y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones anónimas que capturan su entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una serie de elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando nuestro proyecto I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparando Performance: Bucles vs. Iteradores</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más sobre Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate a Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extendiendo Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Usando Box&lt;T&gt; para Apuntar a Datos en el Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratando los Smart Pointers como Referencias Regulares con el Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ejecutando Código al Limpiar con el Trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, el Smart Pointer de Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referencias Circulares Pueden Fugar Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia Sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Usando Threads para Ejecutar Código Simultáneamente</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Usando el Pasaje de Mensajes para Transferir Datos entre Hilos</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Concurrencia con Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible con los Traits Sync y Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust como un Lenguaje de Programación Orientado a Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Usando Trait Objects que Permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementando un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los lugares donde se pueden usar Patterns</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: Si un Pattern Puede Fallar al Hacer Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Sintaxis de los Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Rust Nightly”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Lenguaje de Programación Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustLangES/rust-book-es" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="el-lenguaje-de-programación-rust"><a class="header" href="#el-lenguaje-de-programación-rust">El Lenguaje de Programación Rust</a></h1>
<p><em>por Steve Klabnik y Carol Nichols, con contribuciones de la Comunidad Rust</em></p>
<p>Esta versión del texto asume que estás usando Rust 1.78.0 (lanzado 2024-05-02)
o posterior. Vea la <a href="ch01-01-installation.html">sección “Instalación” del Capítulo 1</a><!-- ignore -->
para instalar o actualizar Rust.</p>
<p>El formato HTML está disponible en línea en
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
y offline con instalaciones de Rust realizadas con <code>rustup</code>; ejecute <code>rustup doc --book</code> para abrir.</p>
<p>También están disponibles varias <a href="appendix-06-translation.html">traducciones</a> de la comunidad.</p>
<p>Este texto está disponible en <a href="https://nostarch.com/rust-programming-language-2nd-edition">formato de libro impreso y ebook de No Starch
Press</a>.</p>
<blockquote>
<p><strong>🚨 ¿Quieres una experiencia de aprendizaje más interactiva? Prueba una
versión diferente del Libro de Rust, con: cuestionarios, resaltado,
visualizaciones y más</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a> (en inglés)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefacio"><a class="header" href="#prefacio">Prefacio</a></h1>
<p>No siempre fue tan claro, pero el lenguaje de programación Rust es 
fundamentalmente sobre <em>empoderamiento</em>: no importa qué tipo de código estás 
escribiendo ahora, Rust te empodera para llegar más lejos, para programar con 
confianza en una mayor variedad de dominios de lo que lo hiciste antes.</p>
<p>Tomemos, por ejemplo, el trabajo de “sistemas” que se ocupa de los detalles de 
bajo nivel de la administración de la memoria, la representación de datos y la 
concurrencia. Tradicionalmente, este reino de la programación se ve como arcano,
accesible sólo a unos pocos que han dedicado los años necesarios para aprender 
a evitar sus infames trampas. Y aunque aquellos que lo practican lo hacen con 
precaución, para que su código no esté abierto a vulnerabilidades que puedan ser
explotadas, caídas o corrupción.</p>
<p>Rust rompe estas barreras al eliminar las antiguas trampas y proporciona un
conjunto amigable y pulido de herramientas para ayudarte en el camino.
Los programadores que necesitan “sumergirse” en un control de bajo nivel pueden 
hacerlo con Rust, sin asumir el riesgo habitual de caídas o agujeros de 
seguridad, y sin tener que aprender los puntos finos de una cadena de 
herramientas caprichosa. Lo mejor de todo, el lenguaje está diseñado para 
guiarte naturalmente hacia un código confiable que es eficiente en términos 
de velocidad y uso de memoria.</p>
<p>Los programadores que ya están trabajando con código de bajo nivel pueden usar
Rust para elevar sus ambiciones. Por ejemplo, introducir la paralelización en
Rust es una operación relativamente de bajo riesgo: el compilador lo detectará
por ti. Así puedes abordar optimizaciones más agresivas en tu código con la
confianza de que no introducirás accidentalmente caídas o vulnerabilidades.</p>
<p>Pero Rust no se limita a la programación de sistemas de bajo nivel. Es lo
suficientemente expresivo y ergonómico para hacer que las aplicaciones CLI,
servidores web y muchos otros tipos de código sean bastante agradables de
escribir - encontrarás ejemplos simples de ambos más adelante en el libro.
Trabajar con Rust te permite desarrollar habilidades que se transfieren de un
dominio a otro; puedes aprender Rust escribiendo una aplicación web, y luego
aplicar esas mismas habilidades para dirigir tu Raspberry Pi.</p>
<p>Este libro abraza plenamente el potencial de Rust para empoderar a tus usuarios.
Es un texto amigable y accesible que tiene como objetivo ayudarte a mejorar no
sólo tu conocimiento de Rust, sino también tu alcance y confianza como
programador en general. Así que sumérgete, prepárate para aprender y ¡bienvenido
a la comunidad Rust!</p>
<p>— Nicholas Matsakis y Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<blockquote>
<p>Nota: Esta edición del libro es la misma que <a href="https://nostarch.com/rust-programming-language-2nd-edition">The Rust Programming
Language</a> disponible en formato impreso y ebook de <a href="https://nostarch.com/">No Starch
Press</a>.</p>
</blockquote>
<p>Bienvenido a <em>El Lenguaje de Programación Rust</em>, un libro introductorio sobre Rust.
El lenguaje de programación Rust te ayuda a escribir software más rápido y
confiable. La ergonomía de alto nivel y el control de bajo nivel a menudo están
en conflicto en el diseño de lenguajes de programación; Rust desafía ese
conflicto. A través del equilibrio entre una capacidad técnica poderosa y una gran
experiencia de desarrollo, Rust te da la opción de controlar los detalles de
bajo nivel (como el uso de memoria) sin todo el problema tradicionalmente
asociado con tal control.</p>
<h2 id="para-quién-es-rust"><a class="header" href="#para-quién-es-rust">Para Quién Es Rust</a></h2>
<p>Rust es ideal para muchas personas por una variedad de razones. Veamos algunos
de los grupos más importantes.</p>
<h3 id="equipos-de-desarrolladores"><a class="header" href="#equipos-de-desarrolladores">Equipos de Desarrolladores</a></h3>
<p>Rust está demostrando ser una herramienta productiva para colaborar entre
equipos grandes de desarrolladores con diferentes niveles de conocimiento de
programación de sistemas. El código de bajo nivel tiende a tener varios
sutiles errores, que en la mayoría de otros lenguajes solo pueden ser
detectados a través de pruebas extensivas y una revisión cuidadosa del código
por parte de desarrolladores experimentados. En Rust, el compilador juega un
rol de guardián al negarse a compilar código con estos errores elusivos,
incluidos los errores de concurrencia. Trabajando junto al compilador, el
equipo puede dedicar su tiempo a enfocarse en la lógica del programa en lugar
de perseguir errores.</p>
<p>Rust también trae herramientas de desarrollo contemporáneas al mundo de la
programación de sistemas:</p>
<ul>
<li>Cargo, el administrador de dependencias y herramienta de compilación
incluido, hace que agregar, compilar y administrar dependencias sea fácil y
consistente en todo el ecosistema de Rust.</li>
<li>La herramienta de formateo Rustfmt garantiza un estilo de codificación
consistente entre los desarrolladores.</li>
<li>El servidor de lenguaje Rust proporciona integración con entornos de
desarrollo integrado (IDE) para la finalización del código y los mensajes de
error en línea.</li>
</ul>
<p>Al usar estas y otras herramientas en el ecosistema de Rust, los desarrolladores
pueden ser productivos mientras escriben código de nivel de sistemas.</p>
<h3 id="estudiantes"><a class="header" href="#estudiantes">Estudiantes</a></h3>
<p>Rust es para estudiantes y quienes estén interesados en aprender sobre conceptos
de sistemas. Usando Rust, muchas personas han aprendido sobre temas como el
desarrollo de sistemas operativos. La comunidad es muy acogedora y feliz de
responder preguntas de estudiantes. A través de esfuerzos como este libro, los
equipos de Rust quieren hacer que los conceptos de sistemas sean más
accesibles para más personas, especialmente para quienes son nuevos en la
programación.</p>
<h3 id="empresas"><a class="header" href="#empresas">Empresas</a></h3>
<p>Cientos de empresas, grandes y pequeñas, usan Rust en producción para una
variedad de tareas, incluidas herramientas de línea de comandos, servicios web,
herramientas de DevOps, dispositivos incrustados, análisis y transcodificación
de audio y video, criptomonedas, bioinformática, motores de búsqueda, aplicaciones
de Internet de las cosas, aprendizaje automático e incluso partes importantes del
navegador web Firefox.</p>
<h3 id="desarrolladores-de-código-abierto"><a class="header" href="#desarrolladores-de-código-abierto">Desarrolladores de Código Abierto</a></h3>
<p>Rust es para personas que quieren construir el lenguaje de programación Rust,
la comunidad, las herramientas de desarrollo y las bibliotecas. Nos encantaría
que contribuyeras al lenguaje Rust.</p>
<h3 id="personas-que-valoran-la-velocidad-y-la-estabilidad"><a class="header" href="#personas-que-valoran-la-velocidad-y-la-estabilidad">Personas que Valoran la Velocidad y la Estabilidad</a></h3>
<p>Rust es para personas que anhelan velocidad y estabilidad en un lenguaje. Por
velocidad, nos referimos tanto a la rapidez con que el código Rust puede
ejecutarse como a la velocidad con que Rust te permite escribir programas. Las
verificaciones del compilador de Rust garantizan la estabilidad a través de
adiciones de funcionalidades y refactorizaciones. Esto contrasta con el código
heredado quebradizo en lenguajes sin estas verificaciones, que los desarrolladores
a menudo tienen miedo de modificar. Al esforzarse por lograr abstracciones de
costo cero, características de alto nivel que se compilan en código de bajo
nivel tan rápido como el código escrito manualmente, Rust se esfuerza por hacer
que el código seguro sea también código rápido.</p>
<p>El lenguaje Rust también espera apoyar a muchos otros usuarios; los mencionados
aquí son solo algunos de los principales interesados. En general, la mayor
ambición de Rust es eliminar los compromisos que los programadores han
aceptado durante décadas al proporcionar seguridad <em>y</em> productividad, velocidad
<em>y</em> ergonomía. Pruébalo y ve si sus elecciones funcionan para ti.</p>
<h2 id="para-quién-es-este-libro"><a class="header" href="#para-quién-es-este-libro">Para Quién Es Este Libro</a></h2>
<p>Este libro asume que has escrito código en otro lenguaje de programación, pero
no hace ninguna suposición sobre cuál es. Hemos intentado hacer que el material
sea ampliamente accesible para aquellos de una amplia variedad de antecedentes
en programación. No pasamos mucho tiempo hablando de lo que <em>es</em> la 
programación o cómo pensar sobre ella. Si eres completamente nuevo en la 
programación, sería mejor leer un libro que brinde una introducción específica a
la programación.</p>
<h2 id="cómo-usar-este-libro"><a class="header" href="#cómo-usar-este-libro">Cómo Usar Este Libro</a></h2>
<p>En general, este libro asume que lo estás leyendo en secuencia, de principio a
fin. Los capítulos posteriores se basan en conceptos de los capítulos
anteriores, y los capítulos anteriores pueden no profundizar en detalles sobre
un tema en particular, pero volverán al tema en un capítulo posterior.</p>
<p>Encontrarás dos tipos de capítulos en este libro: capítulos de conceptos y
capítulos de proyectos. En los capítulos de conceptos, aprenderás sobre un
aspecto de Rust. En los capítulos de proyectos, construiremos programas
pequeños juntos, aplicando lo que has aprendido hasta ahora. Los capítulos 2, 12
y 20 son capítulos de proyectos; el resto son capítulos de conceptos.</p>
<p>El capítulo 1 explica cómo instalar Rust, cómo escribir un programa “Hola,
mundo!” Y cómo usar Cargo, el administrador de paquetes y herramienta de
compilación de Rust. El capítulo 2 es una introducción práctica a la escritura
de un programa en Rust, teniendo que construir un juego de adivinanzas. Aquí
tratamos los conceptos a un nivel alto, y capítulos posteriores proporcionarán
detalles adicionales. Si quieres ponerte manos a la obra de inmediato, el
capítulo 2 es el lugar para eso. El capítulo 3 cubre las características de
Rust que son similares a las de otros lenguajes de programación, y en el
capítulo 4 aprenderás sobre el sistema de propiedad de Rust. Si eres un
aprendiz particularmente meticuloso que prefiere aprender todos los detalles
antes de pasar al siguiente, es posible que desees omitir el capítulo 2 y
dirigirte directamente al capítulo 3, regresando al capítulo 2 cuando gustes
trabajar en un proyecto aplicando los detalles que has aprendido.</p>
<p>El capítulo 5 discute las estructuras y los métodos, y el capítulo 6 cubre las
enumeraciones, las expresiones <code>match</code>, y la construcción de flujo de control
<code>if let</code>. Usarás estructuras y enumeraciones para crear tipos personalizados en
Rust.</p>
<p>En el capítulo 7, aprenderás sobre el sistema de módulos de Rust y sobre las
reglas de privacidad para organizar tu código y su interfaz de programación de
aplicaciones (API) pública. El capítulo 8 discute algunas estructuras de datos
de colección comunes que proporciona la biblioteca estándar, como vectores,
cadenas y mapas hash. El capítulo 9 explora la filosofía y técnicas de
manejo de errores de Rust.</p>
<p>El capítulo 10 se adentra en los genéricos, los traits y los lifetimes, que te
dan el poder de definir código que se aplique a varios tipos. El capítulo 11 trata
sobre las pruebas, que incluso con las garantías de seguridad de Rust, son
necesarias para asegurar que la lógica de tu programa sea correcta. En el capítulo
12, construiremos nuestra propia implementación de un subconjunto de la
funcionalidad del comando de línea de comandos <code>grep</code> que busca texto dentro de
archivos. Para esto, usaremos muchos de los conceptos que discutimos en los
capítulos anteriores.</p>
<p>El capítulo 13 explora las closures y los iteradores: características de Rust
que provienen de los lenguajes de programación funcional. En el capítulo 14,
examinaremos Cargo en más profundidad y hablaremos sobre las mejores prácticas
para compartir tus bibliotecas con otros. El capítulo 15 discute los punteros
inteligentes que proporciona la biblioteca estándar y las características que
habilitan su funcionalidad.</p>
<p>En el capítulo 16, recorreremos diferentes modelos de programación concurrente
y hablaremos sobre cómo Rust te ayuda a programar en múltiples hilos sin
temor. El capítulo 17 examina cómo los modismos de Rust se comparan con los
principios de programación orientada a objetos con los que podrías estar
familiarizado.</p>
<p>El capítulo 18 es una referencia a los patrones y el emparejamiento de patrones,
que son formas poderosas de expresar ideas en todo programa de Rust. El capítulo
19 contiene un banquete de temas avanzados de interés, incluyendo Rust inseguro,
macros y más sobre lifetimes, traits, tipos, funciones y closures.</p>
<p>En el capítulo 20, ¡completaremos un proyecto en el que implementaremos un
servidor web de múltiples hilos de bajo nivel!</p>
<p>Finalmente, algunos apéndices contienen información útil sobre el lenguaje en
un formato más de referencia. El apéndice A cubre las palabras clave de Rust,
el apéndice B cubre los operadores y símbolos de Rust, el apéndice C cubre los
traits derivables proporcionados por la biblioteca estándar, el apéndice D cubre
algunas herramientas de desarrollo útiles, y el apéndice E explica las ediciones
de Rust. En el apéndice F, puede encontrar traducciones del libro, y en el
apéndice G cubriremos cómo se hace Rust y qué es Rust nightly.</p>
<p>No hay una forma incorrecta de leer este libro: ¡si quieres adelantarte, hazlo!
Es posible que debas volver a los capítulos anteriores si experimentas
alguna confusión. Pero haz lo que funcione para ti.</p>
<p><span id="ferris"></span></p>
<p>Una parte importante del proceso de aprendizaje de Rust es aprender a leer los
mensajes de error que muestra el compilador: estos te guiarán hacia el código
funcional. Por lo tanto, proporcionaremos muchos ejemplos que no se compilan
junto con el mensaje de error que mostrará el compilador en cada situación.
Ten en cuenta que si ingresas y ejecutas un ejemplo aleatorio, ¡es posible que
no se compile! Asegúrate de leer el texto circundante para ver si el ejemplo
que estás intentando ejecutar está destinado a error. Ferris también te ayudará
a distinguir el código que no está destinado a funcionar:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Significado</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/></td><td>¡Este código no compila!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/></td><td>¡Este código provoca un pánico!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/></td><td>Este código no produce el comportamiento deseado.</td></tr>
</tbody></table>
</div>
<p>En la mayoría de las situaciones, te guiaremos a la versión correcta de cualquier
código que no se compile.</p>
<h2 id="código-fuente"><a class="header" href="#código-fuente">Código fuente</a></h2>
<p>Los archivos de origen de los que se genera este libro se pueden encontrar en
<a href="https://github.com/RustLangES/rust-book-es/tree/main/src">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empezando"><a class="header" href="#empezando">Empezando</a></h1>
<p>¡Empecemos tu viaje con Rust! Hay mucho que aprender, pero todo viaje comienza
en algún lugar. En este capítulo, discutiremos:</p>
<ul>
<li>Instalación de Rust en Linux, macOS y Windows</li>
<li>Escribir un programa que imprima <code>Hola, mundo!</code></li>
<li>Uso de <code>cargo</code>, el administrador de paquetes y sistema de compilación de Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><a id="instalacion"></a></p>
<h2 id="instalación"><a class="header" href="#instalación">Instalación</a></h2>
<p>El primer paso es instalar Rust. Descargaremos Rust a través de <code>rustup</code>, una
herramienta de línea de comandos para administrar las versiones de Rust y las
herramientas asociadas. Necesitarás una conexión a Internet para la descarga.</p>
<blockquote>
<p>Nota: Si prefieres no usar <code>rustup</code> por alguna razón, consulta la página
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Otros métodos de instalación de Rust</a> para obtener más opciones.</p>
</blockquote>
<p>Los siguientes pasos instalan la última versión estable del compilador de Rust.
Las garantías de estabilidad de Rust aseguran que todos los ejemplos del libro
que se compilan seguirán compilando con versiones más nuevas de Rust. La salida
puede diferir ligeramente entre versiones porque Rust a menudo mejora los
mensajes de error y las advertencias. En otras palabras, cualquier versión más
nueva, estable de Rust que instales usando estos pasos debería funcionar como se
espera con el contenido de este libro.</p>
<blockquote>
<h3 id="notación-de-línea-de-comandos"><a class="header" href="#notación-de-línea-de-comandos">Notación de línea de comandos</a></h3>
<p>En este capítulo y en todo el libro, mostraremos algunos comandos utilizados
en la terminal. Las líneas que debes ingresar en una terminal comienzan con <code>$</code>.
No necesitas escribir el carácter <code>$</code>; es el indicador de línea de comandos
mostrado para indicar el comienzo de cada comando. Las líneas que no comienzan
con <code>$</code> generalmente muestran la salida del comando anterior. Además, los
ejemplos específicos de PowerShell usarán <code>&gt;</code> en lugar de <code>$</code>.</p>
</blockquote>
<h3 id="instalación-de-rustup-en-linux-o-macos"><a class="header" href="#instalación-de-rustup-en-linux-o-macos">Instalación de <code>rustup</code> en Linux o macOS</a></h3>
<p>Si estás utilizando Linux o macOS, abre una terminal y escribe lo siguiente</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>El comando descarga un script y comienza la instalación de la herramienta
<code>rustup</code>, que instala la última versión estable de Rust. Es posible que se te
solicite tu contraseña. Si la instalación es exitosa, aparecerá la siguiente
línea:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>También necesitarás un <em>enlazador</em>, que es un programa que Rust utiliza para
unir sus salidas compiladas en un solo archivo. Es probable que ya lo tengas.
Si obtienes errores de enlace, debes instalar un compilador C, que generalmente
incluye un enlazador. Un compilador C también es útil porque algunos paquetes
comunes de Rust dependen de código C y necesitarán un compilador C.</p>
<p>En macOS, puedes obtener un compilador C ejecutando:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Los usuarios de Linux deben instalar generalmente GCC o Clang, según la
documentación de su distribución. Por ejemplo, si usas Ubuntu, puede instalar el
paquete <code>build-essential</code>.</p>
<h3 id="instalación-de-rustup-en-windows"><a class="header" href="#instalación-de-rustup-en-windows">Instalación de <code>rustup</code> en Windows</a></h3>
<p>En Windows, ve a <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> y sigue las
instrucciones para instalar Rust. En algún momento de la instalación, recibirás
un mensaje para instalar Visual Studio. Este provee un linker y las bibliotecas
nativas necesarias para compilar programas. </p>
<p>Para obtener las herramientas de compilación, deberás instalar 
<a href="https://visualstudio.microsoft.com/downloads/">Visual Studio</a>. Cuando se te pregunte qué paquetes de trabajo 
instalar, incluye:</p>
<ul>
<li>“Desarrollo de escritorio con C ++”</li>
<li>El SDK de Windows 10 o 11</li>
<li>El componente de paquete de idioma inglés, junto con cualquier otro paquete de
idioma de tu elección</li>
</ul>
<p>El resto de este libro usa comandos que funcionan tanto en <em>cmd.exe</em> como en
PowerShell. Si hay diferencias específicas, explicaremos cuál usar.</p>
<p>Si tu necesitas más ayuda con este 
paso, mira <a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html">MSVC prerequisites</a> o escríbenos en nuestro <a href="https://discord.rustlang-es.org">discord</a></p>
<p><a id="solucion-de-problemas"></a></p>
<h3 id="solución-de-problemas"><a class="header" href="#solución-de-problemas">Solución de problemas</a></h3>
<p>Para verificar si has instalado Rust correctamente, abra una shell y escribe esta
línea:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Deberías ver el número de versión, el hash de confirmación y la fecha de
confirmación de la última versión estable que se ha publicado, en el siguiente
formato:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Si ves esta información, ¡has instalado Rust correctamente! Si no ves esta
información, verifica que Rust esté en la variable de sistema <code>%PATH%</code> de la
siguiente manera.</p>
<p>En Windows CMD, usa:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>En PowerShell, usa:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>En Linux y macOS, usa:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>Si todo está correcto y Rust aún no funciona, hay varios lugares donde puedes
obtener ayuda. Obten información sobre cómo comunicarte con otros Rustaceans
(un apodo tonto que nos llamamos a nosotros mismos) en <a href="https://www.rust-lang.org/community">la página de la
comunidad</a>.</p>
<h3 id="actualización-y-desinstalación"><a class="header" href="#actualización-y-desinstalación">Actualización y desinstalación</a></h3>
<p>Una vez que Rust se instala a través de <code>rustup</code>, actualizar a una versión
recién lanzada es fácil. Desde tu shell, ejecuta el siguiente script de
actualización:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Para desinstalar Rust y <code>rustup</code>, ejecuta el siguiente script de desinstalación
desde tu shell:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="documentación-local"><a class="header" href="#documentación-local">Documentación local</a></h3>
<p>La instalación de Rust también incluye una copia local de la documentación para
que puedas leerla sin conexión. Ejecuta <code>rustup doc</code> para abrir la documentación
local en tu navegador.</p>
<p>En cualquier momento en que se proporcione un tipo o una función de la biblioteca
estándar y no estés seguro de lo que hace o cómo usarlo, usa la documentación de
la interfaz de programación de aplicaciones (API) para averiguarlo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hola-mundo"><a class="header" href="#hola-mundo">¡Hola, mundo!</a></h2>
<p>Ahora que has instalado Rust, es hora de escribir tu primer programa en Rust.
Es tradicional cuando se aprende un nuevo lenguaje escribir un pequeño programa
que imprima el texto <code>¡Hola, mundo!</code> en la pantalla, ¡así que haremos lo mismo
aquí!</p>
<blockquote>
<p>Nota: Este libro asume una familiaridad básica con la línea de comandos. Rust
no asume cosas específicas sobre tu editor o herramientas o dónde vive tu
código, por lo que si prefieres usar un entorno de desarrollo integrado (IDE)
en lugar de la línea de comandos, siéntete libre de usar tu IDE favorito. 
Muchos IDEs ahora tienen algún grado de soporte para Rust; consulta la
documentación del IDE para obtener más detalles. El equipo de Rust se ha
centrado en habilitar un gran soporte a IDEs a través de <code>rust-analyzer</code>.
Consulta <a href="appendix-04-useful-development-tools.html">Apéndice D</a><!-- ignore --> para obtener más detalles.</p>
</blockquote>
<h3 id="creando-un-directorio-de-proyecto"><a class="header" href="#creando-un-directorio-de-proyecto">Creando un directorio de proyecto</a></h3>
<p>Comenzarás creando un directorio para almacenar tu código Rust. A Rust no le
importa dónde vive tu código, pero para los ejercicios y proyectos de este libro,
sugerimos que hagas un directorio <em>proyectos</em> en tu directorio de inicio y
mantengas todos tus proyectos allí.</p>
<p>Abre una terminal y escribe los siguientes comandos para crear un directorio
<em>proyectos</em> y un directorio para el proyecto “¡Hola, mundo!” dentro del
directorio <em>proyectos</em>.</p>
<p>Para Linux, macOS y PowerShell en Windows, escribe esto:</p>
<pre><code class="language-console">$ mkdir ~/proyectos
$ cd ~/proyectos
$ mkdir hola_mundo
$ cd hola_mundo
</code></pre>
<p>Para Windows CMD, escribe esto:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\proyectos&quot;
&gt; cd /d &quot;%USERPROFILE%\proyectos&quot;
&gt; mkdir hola_mundo
&gt; cd hola_mundo
</code></pre>
<h3 id="escribir-y-ejecutar-un-programa-en-rust"><a class="header" href="#escribir-y-ejecutar-un-programa-en-rust">Escribir y ejecutar un programa en Rust</a></h3>
<p>A continuación, crea un nuevo archivo de texto y llámalo <em>main.rs</em>. Los archivos
Rust siempre terminan con la extensión <em>.rs</em>. Si estás usando más de una palabra
en tu nombre de archivo, la convención es usar un guión bajo para separarlos.
Por ejemplo, usa <em>hola_mundo.rs</em> en lugar de <em>holamundo.rs</em>.</p>
<p>Ahora abre el archivo <em>main.rs</em> que acabas de crear y escribe el código en el
Listado 1-1.</p>
<Listing number="1-1" file-name="main.rs" caption="Un programa que imprime `¡Hola, mundo!`">
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¡Hola, mundo!&quot;);
}</code></pre></pre>
</Listing>
<p>Guarda el archivo y vuelve a la ventana de la terminal en el directorio
<em>~/proyectos/hola_mundo</em>. En Linux o macOS, escribe los siguientes comandos para
compilar y ejecutar el archivo:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
¡Hola, mundo!
</code></pre>
<p>En Windows, escribe el comando <code>.\main.exe</code> en lugar de <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
¡Hola, mundo!
</code></pre>
<p>Independientemente de tu sistema operativo, la cadena <code>¡Hola, mundo!</code> debe
imprimirse en la terminal. Si no ves esta salida, consulta la parte
<a href="ch01-01-installation.html#solucion-de-problemas">“Solución de problemas”</a><!-- ignore --> de la sección de
Instalación para obtener formas de obtener ayuda.</p>
<p>Si <code>¡Hola, mundo!</code> se imprimió, ¡felicidades! Acabas de escribir oficialmente un
programa en Rust. Eso te convierte en un programador de Rust, ¡bienvenido!</p>
<h3 id="anatomía-de-un-programa-en-rust"><a class="header" href="#anatomía-de-un-programa-en-rust">Anatomía de un programa en Rust</a></h3>
<p>Revisemos este programa “¡Hola, mundo!” en detalle. Aquí está la primera
parte del rompecabezas:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}</code></pre></pre>
<p>Estas líneas definen una función llamada <code>main</code>. La función <code>main</code> es especial:
siempre es el primer código que se ejecuta en cada programa ejecutable de Rust.
Aquí, la primera línea declara una función llamada <code>main</code> que no tiene
parámetros y no devuelve nada. Si hubiera parámetros, irían dentro de los
paréntesis <code>()</code>.</p>
<p>El cuerpo de la función está envuelto en <code>{}</code>. Rust requiere llaves alrededor de
todos los cuerpos de función. Es buena costumbre colocar la llave de apertura en
la misma línea que la declaración de la función, agregando un espacio entre
ambos.</p>
<blockquote>
<p>Nota: Si deseas mantener un estilo estándar en todos los proyectos de Rust, 
puedes usar una herramienta de formateo automático llamada <code>rustfmt</code> para
formatear tu código en un estilo particular (más sobre <code>rustfmt</code> en
<a href="appendix-04-useful-development-tools.html">Apéndice D</a><!-- ignore -->). El equipo de Rust ha incluido esta
herramienta con la distribución estándar de Rust, como <code>rustc</code>, por lo que
debería estar instalado en tu computadora.</p>
</blockquote>
<p>El cuerpo de la función <code>main</code> contiene el siguiente código:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;¡Hola, mundo!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Esta línea hace todo el trabajo en este pequeño programa: imprime texto en la
pantalla. Hay cuatro detalles importantes que hay que notar aquí.</p>
<p>Primero, el estilo de Rust es indentar con cuatro espacios, no con una tabulación.</p>
<p>Segundo, <code>println!</code> llamamos a una macro de Rust. Si hubiéramos llamado a una
función en su lugar, habríamos ingresado <code>println</code> (sin el <code>!</code>). Discutiremos las
macros de Rust en más detalle en el Capítulo 19. Por ahora, solo necesitas saber
que usar un <code>!</code> significa que estamos llamando a una macro en lugar de una función
normal y que las macros no siempre siguen las mismas reglas que las funciones.</p>
<p>Tercero, ve la cadena <code>&quot;¡Hola, mundo!&quot;</code>. Pasamos esta cadena como argumento a
<code>println!</code>, y la cadena se imprime en la pantalla.</p>
<p>Cuarto, terminamos la línea con un punto y coma (<code>;</code>), lo que indica que esta
expresión ha terminado y la siguiente está lista para comenzar. La mayoría de
las líneas de código de Rust terminan con un punto y coma.</p>
<h3 id="compilar-y-ejecutar-son-pasos-separados"><a class="header" href="#compilar-y-ejecutar-son-pasos-separados">Compilar y ejecutar son pasos separados</a></h3>
<p>Acabas de ejecutar un programa recién creado, así que examinemos cada paso en el
proceso.</p>
<p>Antes de ejecutar un programa de Rust, debes compilarlo usando el compilador de
Rust ingresando el comando <code>rustc</code> y pasándole el nombre de tu archivo de
código fuente, así:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Si tienes un trasfondo en C o C ++, notarás que esto es similar a <code>gcc</code> o
<code>clang</code>. Después de compilar con éxito, Rust genera un ejecutable binario.</p>
<p>En Linux, macOS y PowerShell en Windows, puedes ver el ejecutable ingresando el
comando <code>ls</code> en tu shell:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>En Linux y macOS, verás dos archivos. Con PowerShell en Windows, verás los mismos
tres archivos que verías con CMD. Con CMD en Windows, ingresarías lo siguiente:</p>
<pre><code class="language-cmd">&gt; dir /B %= la /B significa que solo mostrara los nombres de los archivos =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Esto muestra el archivo de código fuente con la extensión <em>.rs</em>, el archivo
ejecutable (<em>main.exe</em> en Windows, pero <em>main</em> en todas las otras plataformas),
y, cuando se usa Windows, un archivo que contiene información de depuración con
la extensión <em>.pdb</em>. Desde aquí, ejecuta el archivo <em>main</em> o <em>main.exe</em>, así:</p>
<pre><code class="language-console">$ ./main # o .\main.exe en Windows
</code></pre>
<p>Si tu <em>main.rs</em> es tu programa &quot;¡Hola, mundo!&quot;, Esta línea imprime <code>¡Hola, mundo!</code> en tu terminal.</p>
<p>Si estás más familiarizado con un lenguaje dinámico, como Ruby, Python o
JavaScript, puede que no estés acostumbrado a compilar y ejecutar un programa
como pasos separados. Rust es un lenguaje <em>compilado de antemano</em>, lo que
significa que puedes compilar un programa y dar el ejecutable a otra persona, y
pueden ejecutarlo incluso sin tener Rust instalado. Si le das a alguien un
archivo <em>.rb</em>, <em>.py</em> o <em>.js</em>, necesitan tener una implementación de Ruby,
Python o JavaScript instalada (respectivamente). Pero en esos lenguajes, sólo
necesitas un comando para compilar y ejecutar tu programa. Todo depende de las
concesiones hechas al momento de diseñar un lenguaje.</p>
<p>Solo compilar con <code>rustc</code> está bien para programas simples, pero a medida que
tu proyecto crece, querrás administrar todas las opciones y facilitar el 
compartir tu código. A continuación, te presentaremos la herramienta
Cargo, que te ayudará a escribir programas de Rust reales.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hola-cargo"><a class="header" href="#hola-cargo">¡Hola, Cargo!</a></h2>
<p>Cargo es el sistema de compilación y administrador de paquetes de Rust. La
mayoría de los Rustaceans usan esta herramienta para administrar sus proyectos
Rust porque Cargo maneja muchas tareas para ti, como compilar tu código,
descargar las bibliotecas de las que depende tu código y compilar esas
bibliotecas. (Llamamos <em>dependencias</em> a las bibliotecas de las que depende tu
código).</p>
<p>Los programas Rust más simples, como el que hemos escrito hasta ahora, no
tienen dependencias. Si hubiéramos construido el proyecto “¡Hola, mundo!” con
Cargo, sólo usaría la parte de Cargo que maneja la compilación de tu código. A
medida que escribas programas Rust más complejos, agregarás dependencias, y si
comienzas un proyecto usando Cargo, agregar dependencias será mucho más fácil
de hacer.</p>
<p>Debido a que la gran mayoría de los proyectos Rust usan Cargo, el resto de este
libro asume que también estás usando Cargo. Cargo viene instalado con Rust si
usaste los instaladores oficiales que se discuten en la sección
<a href="ch01-01-installation.html#instalacion">“Installation”</a><!-- ignore -->. Si instalaste Rust a través de
algunos otros medios, verifica si Cargo está instalado ingresando lo siguiente
en tu terminal:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Si ves un número de versión, ¡lo tienes! Si ves un error, como <code>command not found</code>,
consulta la documentación de tu método de instalación para determinar cómo
instalar Cargo por separado.</p>
<h3 id="creación-de-un-proyecto-con-cargo"><a class="header" href="#creación-de-un-proyecto-con-cargo">Creación de un proyecto con Cargo</a></h3>
<p>Vamos a crear un nuevo proyecto usando Cargo y ver cómo difiere de nuestro
proyecto original “¡Hola, mundo!”. Navega de vuelta a tu directorio
<em>proyectos</em> (o dondequiera que hayas decidido almacenar tu código). Luego, en
cualquier sistema operativo, ejecuta lo siguiente:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>El primer comando crea un nuevo directorio y proyecto llamado <em>hello_cargo</em>.
Hemos nombrado a nuestro proyecto <em>hello_cargo</em>, y Cargo crea sus archivos en
un directorio con el mismo nombre.</p>
<p>Ve al directorio <em>hello_cargo</em> y lista los archivos. Verás que Cargo ha
generado dos archivos y un directorio para nosotros: un archivo <em>Cargo.toml</em> y
un directorio <em>src</em> con un archivo <em>main.rs</em> dentro.</p>
<p>También ha inicializado un nuevo repositorio Git junto con un archivo
<em>.gitignore</em>. Los archivos Git no se generarán si ejecutas <code>cargo new</code> dentro
de un repositorio Git existente; puedes anular este comportamiento usando
<code>cargo new --vcs=git</code>.</p>
<blockquote>
<p>Nota: Git es un sistema de control de versiones común. Puedes cambiar <code>cargo new</code> para usar un sistema de control de versiones diferente o ningún sistema
de control de versiones usando la bandera <code>--vcs</code>. Ejecuta <code>cargo new --help</code>
para ver las opciones disponibles.</p>
</blockquote>
<p>Abre <em>Cargo.toml</em> en tu editor de texto de elección. Debería verse similar al
código del Listado 1-2.</p>
<Listing number="1-2" file-name="Cargo.toml" caption="Contenido de *Cargo.toml* generado por `cargo new`">
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
</Listing>
<p>Este archivo está en el formato <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tom’s Obvious,
Minimal Language</em>), que es el formato de configuración de Cargo.</p>
<p>La primera línea, <code>[package]</code>, es un encabezado de sección que indica que las
siguientes declaraciones están configurando un paquete. A medida que agreguemos
más información a este archivo, agregaremos otras secciones.</p>
<p>Las próximas tres líneas establecen la información de configuración que Cargo
necesita para compilar tu programa: el nombre, la versión y la edición de Rust
que se usará. Hablaremos sobre la entrada <code>edition</code> en <a href="appendix-05-editions.html">Apéndice E</a></p>
<!-- ignore -->.
<p>La última línea, <code>[dependencies]</code>, es el comienzo de una sección para que
enumere cualquier dependencia de tu proyecto. En Rust, los paquetes de código
se denominan <em>crates</em>. No necesitaremos otros crates para este proyecto, pero
lo haremos en el primer proyecto del Capítulo 2, por lo que usaremos esta
sección de dependencias hasta entonces.</p>
<p>Ahora abre <em>src/main.rs</em> y echa un vistazo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>¡Cargo ha generado un programa “Hello, world!”/“¡Hola, mundo!” para ti, 
¡igual que el que escribimos enl Listado 1-1! Hasta ahora, las diferencias 
entre nuestro proyecto y el proyecto generado por Cargo son que Cargo 
colocó el código en el directorio <em>src</em> y tenemos un archivo de 
configuración <em>Cargo.toml</em> en el directorio superior.</p>
<p>Cargo espera que tus archivos de origen vivan dentro del directorio <em>src</em>. El
directorio del proyecto de nivel superior es solo para archivos README, 
información de licencia, archivos de configuración y cualquier otra cosa 
que no esté relacionada con tu código. Usar Cargo te ayuda a organizar 
tus proyectos. Hay un lugar para todo, y todo está en su lugar.</p>
<p>Si comenzaste un proyecto que no usa Cargo, como hicimos con el proyecto
“¡Hola, mundo!”, puedes convertirlo en un proyecto que sí use Cargo. Mueve el
código del proyecto al directorio <em>src</em> y crea un archivo <em>Cargo.toml</em>
adecuado.</p>
<h3 id="construir-y-ejecutar-un-proyecto-de-cargo"><a class="header" href="#construir-y-ejecutar-un-proyecto-de-cargo">Construir y ejecutar un proyecto de Cargo</a></h3>
<p>Ahora veamos qué es diferente cuando construimos y ejecutamos el programa
“¡Hola, mundo!” con Cargo. ¡Desde tu directorio <em>hello_cargo</em>, construye tu
proyecto ingresando el siguiente comando:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Este comando crea un archivo ejecutable en <em>target/debug/hello_cargo</em> (o
<em>target\debug\hello_cargo.exe</em> en Windows) en lugar de en tu directorio
actual. Debido a que la compilación predeterminada es una compilación de
depuración, Cargo coloca el binario en un directorio llamado <em>debug</em>. Puedes
llamar al ejecutable con este comando:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # o .\target\debug\hello_cargo.exe en Windows
Hello, world!
</code></pre>
<p>Si todo va bien, <code>Hello, world!</code> debería imprimirse en la terminal. Ejecutar
<code>cargo build</code> por primera vez también hace que Cargo cree un nuevo archivo en
el nivel superior: <em>Cargo.lock</em>. Este archivo rastrea las versiones exactas de
las dependencias de tu proyecto. Este proyecto no tiene dependencias, por lo
que el archivo es un poco escaso. Nunca necesitarás cambiar este archivo
manualmente; Cargo administra su contenido para ti.</p>
<p>Acabamos de construir un proyecto con <code>cargo build</code> y ejecutarlo con
<code>./target/debug/hello_cargo</code>, pero también podemos usar <code>cargo run</code> para
compilar el código y luego llamar al ejecutable resultante en un solo
comando:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Usar <code>cargo run</code> es más conveniente que tener que recordar ejecutar <code>cargo build</code> y luego usar la ruta completa al binario, por lo que la mayoría de los
desarrolladores usan <code>cargo run</code>.</p>
<p>Ten en cuenta que esta vez no vimos salida que indicara que Cargo estaba
compilando <code>hello_cargo</code>. Cargo supo que los archivos no habían cambiado, por
lo que no volvió a construir, sino que solo ejecutó el binario. Si hubieras
modificado tu código fuente, Cargo habría reconstruido el proyecto antes de
ejecutarlo, y habrías visto esta salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo también proporciona un comando llamado <code>cargo check</code>. Este comando
comprueba rápidamente tu código para asegurarse de que compila, pero no
produce un ejecutable:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>¿Por qué no querrías un ejecutable? A menudo, <code>cargo check</code> es mucho más rápido
que <code>cargo build</code> porque omite el paso de producir un ejecutable. Si estás
verificando continuamente tu trabajo mientras escribes el código, usar
<code>cargo check</code> acelerará el proceso de informarte si tu proyecto todavía aún está
compilando. ¡Por lo tanto, muchos Rustaceans ejecutan <code>cargo check</code>
periódicamente mientras escriben su programa para asegurarse de que compila!
Luego ejecutan <code>cargo build</code> cuando están listos para usar el ejecutable.</p>
<p>Resumamos lo que hemos aprendido hasta ahora sobre Cargo:</p>
<ul>
<li>Podemos crear un proyecto usando <code>cargo new</code>.</li>
<li>Podemos construir un proyecto usando <code>cargo build</code>.</li>
<li>Podemos construir y ejecutar un proyecto en un solo paso usando <code>cargo run</code>.</li>
<li>Podemos construir un proyecto sin producir un binario para verificar errores
usando <code>cargo check</code>.</li>
<li>En lugar de guardar el resultado de la compilación en el mismo directorio que
nuestro código, Cargo lo almacena en el directorio <em>target/debug</em>.</li>
</ul>
<p>Una ventaja adicional de usar Cargo es que los comandos son los mismos sin
importar en qué sistema operativo estés trabajando. Por lo tanto, en este
punto, ya no proporcionaremos instrucciones específicas para Linux y macOS
versus Windows.</p>
<h3 id="construyendo-una-versión-de-lanzamiento"><a class="header" href="#construyendo-una-versión-de-lanzamiento">Construyendo una versión de lanzamiento</a></h3>
<p>Cuando tu proyecto finalmente esté listo para su lanzamiento, puedes usar <code>cargo build --release</code> para compilarlo con optimizaciones. Este comando creará un
ejecutable en <em>target/release</em> en lugar de <em>target/debug</em>. Las optimizaciones
hacen que tu código Rust se ejecute más rápido, pero al activarlos se alarga el
tiempo que tarda tu programa en compilarse. Es por eso que hay dos perfiles
diferentes: uno para el desarrollo, cuando deseas reconstruir rápidamente y
con frecuencia, y otro para construir el programa final que le darás al usuario,
que no se reconstruirá repetidamente y que se ejecutará lo más rápido posible.
Si estás midiendo el tiempo de ejecución de tu código, asegúrate de ejecutar
<code>cargo build --release</code> y realizar la prueba de rendimiento con el ejecutable
en <em>target/release</em>.</p>
<h3 id="cargo-como-convención"><a class="header" href="#cargo-como-convención">Cargo como convención</a></h3>
<p>Con proyectos simples, Cargo no proporciona mucho valor por sobre sólo usar
<code>rustc</code>, pero demostrará su valor a medida que tus programas se vuelvan más
intrincados. Una vez que los programas crecen a múltiples archivos o necesitan
una dependencia, es mucho más fácil dejar que Cargo coordine la construcción.</p>
<p>Aunque el proyecto <code>hello_cargo</code> es simple, ahora usas muchas de las herramientas
reales que usarás en el resto de tu carrera en Rust. De hecho, para trabajar en
cualquier proyecto existente, puedes usar los siguientes comandos para verificar
el código usando Git, cambiar al directorio del proyecto y construir:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Para obtener más información sobre Cargo, consulta <a href="https://doc.rust-lang.org/cargo/">su documentación</a>.</p>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>¡Ya estás en un gran comienzo en tu viaje de Rust! En este capítulo, has
aprendido cómo:</p>
<ul>
<li>Instalar la última versión estable de Rust usando <code>rustup</code></li>
<li>Actualizar a una versión más reciente de Rust</li>
<li>Abrir documentación instalada localmente</li>
<li>Escribir y ejecutar un programa &quot;¡Hola, mundo!&quot; usando <code>rustc</code> directamente</li>
<li>Crear y ejecutar un nuevo proyecto usando las convenciones de Cargo</li>
</ul>
<p>Es un buen momento para construir un programa más sustancial para acostumbrarse
a leer y escribir código Rust. Entonces, en el capítulo 2, construiremos un
programa de juego de adivinanzas. Si prefieres comenzar aprendiendo cómo
funcionan los conceptos de programación comunes en Rust, consulta el capítulo 3
y luego regresa al capítulo 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programando-un-juego-de-adivinanzas"><a class="header" href="#programando-un-juego-de-adivinanzas">Programando un juego de adivinanzas</a></h1>
<p>¡Vamos a empezar con Rust trabajando en un proyecto práctico! Este capítulo te
introduce a algunos conceptos comunes de Rust mostrándote cómo usarlos en un
programa real. ¡Aprenderás sobre <code>let</code>, <code>match</code>, métodos, funciones asociadas,
paquetes externos y más! En los capítulos siguientes, exploraremos estos
conceptos en más detalle. En este capítulo, solo practicarás los fundamentos.</p>
<p>Implementaremos un clásico problema de programación para principiantes: un
juego de adivinanzas. Así es como funciona: el programa generará un número
entero aleatorio entre 1 y 100. Luego le pedirá al jugador que ingrese una
adivinanza. Después de ingresar una adivinanza, el programa indicará si la
adivinanza es demasiado baja o demasiado alta. Si la adivinanza es correcta, el
juego imprimirá un mensaje de felicitación y saldrá.</p>
<h2 id="configurando-un-nuevo-proyecto"><a class="header" href="#configurando-un-nuevo-proyecto">Configurando un nuevo proyecto</a></h2>
<p>Para configurar un nuevo proyecto, vaya al directorio <em>proyectos</em> que creó en
el Capítulo 1 y cree un nuevo proyecto usando Cargo, así:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>El primer comando, <code>cargo new</code>, toma el nombre del proyecto (<code>guessing_game</code>)
como el primer argumento. El segundo comando cambia al directorio del nuevo
proyecto.</p>
<p>Mira el archivo <em>Cargo.toml</em> generado:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Como viste en el Capítulo 1, <code>cargo new</code> genera un programa “Hola, mundo!” para
ti. Mira el archivo <em>src/main.rs</em>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Ahora compilemos este programa “Hola, mundo!” y ejecutémoslo en el mismo paso
usando el comando <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>El comando <code>run</code> es útil cuando necesitas iterar rápidamente en un proyecto,
como haremos en este juego, probando rápidamente cada iteración antes de
pasar a la siguiente.</p>
<p>Vuelve a abrir el archivo <em>src/main.rs</em>. Escribirás todo el código en este</p>
<h2 id="procesando-una-adivinanza"><a class="header" href="#procesando-una-adivinanza">Procesando una adivinanza</a></h2>
<p>La primera parte del programa del juego de adivinanzas pedirá al usuario que
ingrese un valor, procesará ese valor y verificará que el valor esté en el
formato esperado. Para comenzar, permitiremos al jugador ingresar una adivinanza.
Ingresa el código de la Lista 2-1 en <em>src/main.rs</em>.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}</code></pre>
<p><span class="caption">Lista 2-1: Código que obtiene una adivinanza del usuario
y la imprime</span></p>
<p>Este código contiene mucha información, así que repasémoslo línea por línea.
Para obtener la entrada del usuario y luego imprimir el resultado como salida,
necesitamos traer la biblioteca de entrada/salida <code>io</code> al alcance. La biblioteca
<code>io</code> viene de la biblioteca estándar, conocida como <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="prelude-meaning"></a></p>
<p>Por defecto, Rust tiene un conjunto de elementos definidos en la biblioteca
estándar que trae al alcance de cada programa. Este conjunto se llama
<em>prelude</em>, y puedes ver todo lo que contiene <a href="https://doc.rust-lang.org/std/prelude/index.html">en la documentación de la
biblioteca estándar</a>.</p>
<p>Si un tipo que quieres usar no está en el prelude, tienes que traer ese tipo
al alcance explícitamente con una declaración <code>use</code>. Usar la biblioteca <code>std::io</code>
te proporciona una serie de características útiles, incluyendo la capacidad de
aceptar la entrada del usuario.</p>
<p>Como viste en el Capítulo 1, la función <code>main</code> es el punto de entrada al
programa:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>La sintaxis <code>fn</code> declara una nueva función; los paréntesis, <code>()</code>, indican que
no hay parámetros; y la llave, <code>{</code>, inicia el cuerpo de la función.</p>
<p>Como también aprendiste en el Capítulo 1, <code>println!</code> es una macro que imprime
una cadena en la pantalla:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Este código está imprimiendo una solicitud que indica qué es el juego y está
solicitando la entrada del usuario.</p>
<h3 id="almacenando-valores-con-variables"><a class="header" href="#almacenando-valores-con-variables">Almacenando valores con variables</a></h3>
<p>A continuación, crearemos una <em>variable</em> para almacenar la entrada del usuario,
como esto:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>¡Ahora el programa está interesante! Hay mucho que está pasando en esta pequeña
línea. Usamos la declaración <code>let</code> para crear la variable. Aquí hay otro
ejemplo:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Esta línea crea una nueva variable llamada <code>apples</code> y la enlaza con el valor 5.
En Rust, las variables son inmutables por defecto, lo que significa que una vez
que le damos a la variable un valor, el valor no cambiará. Vamos a discutir
este concepto en detalle en la sección <a href="ch03-01-variables-and-mutability.html#variables-y-mutabilidad">“Variables y Mutabilidad”</a><!-- ignore -->
del Capítulo 3. Para hacer una variable mutable, agregamos <code>mut</code> antes del
nombre de la variable:</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable</code></pre>
<blockquote>
<p>Nota: La sintaxis <code>//</code> inicia un comentario que continúa hasta el final de la
línea. Rust ignora todo lo que está en los comentarios. Vamos a discutir los
comentarios en más detalle en el <a href="ch03-04-comments.html">Capítulo 3</a><!-- ignore -->.</p>
</blockquote>
<p>Regresando al programa del juego de adivinanzas, ahora sabes que <code>let mut guess</code>
introducirá una variable mutable llamada <code>guess</code>. El signo igual (<code>=</code>) le dice
a Rust que queremos enlazar algo a la variable ahora. A la derecha del signo
igual está el valor al que <code>guess</code> está enlazado, que es el resultado de llamar
a <code>String::new</code>, una función que devuelve una nueva instancia de un <code>String</code>.
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> es un tipo de cadena proporcionado por la
biblioteca estándar que es una parte de texto codificada en UTF-8 que puede
crecer.</p>
<p>La sintaxis <code>::</code> en la línea <code>::new</code> indica que <code>new</code> es una función asociada
del tipo <code>String</code>. Una <em>función asociada</em> es una función que está implementada
en un tipo, en este caso <code>String</code>. Esta función <code>new</code> crea una nueva cadena
vacía. Encontrarás una función <code>new</code> en muchos tipos porque es un nombre
común para una función que crea un nuevo valor de algún tipo.</p>
<p>En total, la línea <code>let mut guess = String::new();</code> ha creado una variable
mutable que está actualmente enlazada a una nueva instancia vacía de un
<code>String</code>. ¡Uf!</p>
<h3 id="recibiendo-la-entrada-del-usuario"><a class="header" href="#recibiendo-la-entrada-del-usuario">Recibiendo la entrada del usuario</a></h3>
<p>Recuerda que incluimos la funcionalidad de entrada/salida de la biblioteca
estándar con <code>use std::io;</code> en la primera línea del programa. Ahora llamaremos
a la función <code>stdin</code> del módulo <code>io</code>, que nos permitirá manejar la entrada del
usuario:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Si no hubiéramos importado la biblioteca <code>io</code> con <code>use std::io;</code> al comienzo del
programa, aún podríamos usar la función escribiendo esta llamada de función
como <code>std::io::stdin</code>. La función <code>stdin</code> devuelve una instancia de
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, que es un tipo que representa un
manejador de la entrada estándar para tu terminal.</p>
<p>A continuación, la línea <code>.read_line(&amp;mut guess)</code> llama al método
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> en el manejador de entrada estándar para
obtener la entrada del usuario. También estamos pasando <code>&amp;mut guess</code> como
argumento a <code>read_line</code> para decirle qué cadena almacenar la entrada del
usuario. El trabajo completo de <code>read_line</code> es tomar lo que el usuario escribe
en la entrada estándar y agregar eso a una cadena (sin sobrescribir su
contenido), por lo que, por lo tanto, pasamos esa cadena como argumento. La
cadena de argumentos debe ser mutable para que el método pueda cambiar el
contenido de la cadena.</p>
<p>El <code>&amp;</code> indica que este argumento es una <em>referencia</em>, que te da una forma de
permitir que varias partes de tu código accedan a una pieza de datos sin
necesidad de copiar esos datos en la memoria varias veces. Las referencias son
una característica compleja, y una de las principales ventajas de Rust es lo
seguro y fácil que es usar referencias. No necesitas saber mucho de esos
detalles para terminar este programa. Por ahora, todo lo que necesitas saber es
que, como las variables, las referencias son inmutables por defecto. Por lo
tanto, necesitas escribir <code>&amp;mut guess</code> en lugar de <code>&amp;guess</code> para hacerlo
mutable. (El capítulo 4 explicará las referencias con más detalle.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="manejando-el-posible-fallo-con-result"><a class="header" href="#manejando-el-posible-fallo-con-result">Manejando el posible fallo con <code>Result</code></a></h3>
<p>Todavía estamos trabajando en esta línea de código. Ahora estamos discutiendo
una tercera línea de texto, pero ten en cuenta que aún es parte de una sola
línea lógica de código. La siguiente parte es este método:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Podríamos haber escrito este código como:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);</code></pre>
<p>Sin embargo, una línea larga es difícil de leer, por lo que es mejor dividirla.
A menudo es sabio introducir un salto de línea y otros espacios en blanco para
ayudar a dividir líneas largas cuando llamas a un método con la sintaxis
<code>.method_name()</code>. Ahora discutamos lo que hace esta línea.</p>
<p>Como se mencionó anteriormente, <code>read_line</code> coloca lo que el usuario ingresa en
la cadena que le pasamos, pero también devuelve un valor <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> es una <a href="ch06-00-enums.html"><em>enumeración</em></a><!-- ignore -->, a menudo
llamada <em>enum</em>, que es un tipo que puede estar en uno de varios estados
posibles. Llamamos a cada estado posible a una <em>variante</em>.</p>
<p>El <a href="ch06-00-enums.html">Capítulo 6</a><!-- ignore --> cubrirá las enumeraciones con más
detalles. El propósito de estos tipos <code>Result</code> es codificar información de
manejo de errores.</p>
<p>Las variantes de <code>Result</code> son <code>Ok</code> y <code>Err</code>. La variante <code>Ok</code> indica que la
operación fue exitosa, y dentro de <code>Ok</code> está el valor generado con éxito. La
variante <code>Err</code> significa que la operación falló, y <code>Err</code> contiene información
sobre cómo o por qué la operación falló.</p>
<p>Los valores del tipo <code>Result</code>, como los valores de cualquier tipo, tienen
métodos definidos en ellos. Una instancia de <code>Result</code> tiene un método
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a><!-- ignore --> que puedes llamar. Si esta instancia de
<code>Result</code> es un valor <code>Err</code>, <code>expect</code> hará que el programa se bloquee y muestre
el mensaje que pasaste como argumento a <code>expect</code>. Si el método <code>read_line</code>
devuelve un <code>Err</code>, probablemente sea el resultado de un error proveniente del
sistema operativo subyacente. Si esta instancia de <code>Result</code> es un valor <code>Ok</code>,
<code>expect</code> tomará el valor de retorno que <code>Ok</code> está sosteniendo y devolverá solo
ese valor para que lo puedas usar. En este caso, ese valor es el número de
bytes en la entrada del usuario.</p>
<p>Si no llamas a <code>expect</code>, el programa se compilará, pero obtendrás una advertencia:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust advierte que no has usado el valor <code>Result</code> devuelto por <code>read_line</code>,
indicando que el programa no ha manejado un posible error.</p>
<p>La forma correcta de suprimir la advertencia es escribir realmente código de
manejo de errores, pero en nuestro caso solo queremos bloquear este programa
cuando ocurra un problema, por lo que podemos usar <code>expect</code>. Aprenderás a
recuperarte de los errores en el <a href="ch09-02-recoverable-errors-with-result.html">Capítulo 9</a><!-- ignore -->.</p>
<h3 id="imprimiendo-valores-con-marcadores-de-posición-println"><a class="header" href="#imprimiendo-valores-con-marcadores-de-posición-println">Imprimiendo valores con marcadores de posición <code>println!</code></a></h3>
<p>Además del corchete de cierre, solo hay una línea más que discutir en el código
hasta ahora:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>    println!(&quot;You guessed: {}&quot;, guess);
<span class="boring">}</span></code></pre>
<p>Esta línea imprime la cadena que ahora contiene la entrada del usuario. El
conjunto de llaves <code>{}</code> es un marcador de posición: piensa en <code>{}</code> como pequeñas
pinzas de cangrejo que mantienen un valor en su lugar. Al imprimir el valor de
una variable, el nombre de la variable puede ir dentro de las llaves
curvas. Al imprimir el resultado de evaluar una expresión, coloca llaves
curvas vacías en la cadena de formato, luego sigue la cadena de formato con una
lista separada por comas de expresiones para imprimir en cada marcador de
posición vacío de llaves curvas en el mismo orden. Imprimir una variable y el
resultado de una expresión en una llamada a <code>println!</code> se vería así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {x} and y + 2 = {}&quot;, y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Este código imprimiría <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="probando-la-primera-parte"><a class="header" href="#probando-la-primera-parte">Probando la primera parte</a></h3>
<p>Probemos la primera parte del juego de adivinanzas. Ejecútalo usando <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>En este punto, la primera parte del juego está terminada: estamos obteniendo
entrada del teclado y luego la imprimimos.</p>
<h2 id="generando-un-número-secreto"><a class="header" href="#generando-un-número-secreto">Generando un número secreto</a></h2>
<p>A continuación, necesitamos generar un número secreto que el usuario intentará
adivinar. El número secreto debe ser diferente cada vez para que el juego sea
divertido de jugar más de una vez. Usaremos un número aleatorio entre 1 y 100
para que el juego no sea demasiado difícil. Rust aún no incluye la
funcionalidad de números aleatorios en su biblioteca estándar. Sin embargo, el
equipo de Rust proporciona un <a href="https://crates.io/crates/rand"><code>rand</code> crate</a> con dicha
funcionalidad.</p>
<h3 id="usando-un-crate-para-obtener-más-funcionalidad"><a class="header" href="#usando-un-crate-para-obtener-más-funcionalidad">Usando un Crate para obtener más funcionalidad</a></h3>
<p>Recuerda que un crate es una colección de archivos de código fuente de Rust. El
proyecto que hemos estado construyendo es un <em>binary crate</em>, que es un
ejecutable. El crate <code>rand</code> es un <em>library crate</em>, que contiene código que se
pretende usar en otros programas y no se puede ejecutar por sí solo.</p>
<p>La coordinación de los crates externos de Cargo es donde realmente brilla
Cargo. Antes de poder escribir código que use <code>rand</code>, necesitamos modificar el
archivo <em>Cargo.toml</em> para incluir el crate <code>rand</code> como una dependencia. Abre ese
archivo ahora y agrega la siguiente línea al final, debajo del encabezado de la
sección <code>[dependencies]</code> que Cargo creó para ti. Asegúrate de especificar <code>rand</code>
exactamente como lo tenemos aquí, con este número de versión, o los ejemplos de
código en este tutorial pueden no funcionar:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>En el archivo <em>Cargo.toml</em>, todo lo que sigue a un encabezado es parte de esa
sección que continúa hasta que comienza otra sección. En <code>[dependencies]</code> le
dices a Cargo qué crates externos depende tu proyecto y qué versiones de esos
crates requieres. En este caso, especificamos el crate <code>rand</code> con el
especificador de versión semántica <code>0.8.5</code>. Cargo entiende <a href="http://semver.org">Semantic
Versioning</a><!-- ignore --> (a veces llamado <em>SemVer</em>), que es un
estándar para escribir números de versión. El especificador <code>0.8.5</code> es
realmente un atajo para <code>^0.8.5</code>, lo que significa cualquier versión que sea
al menos 0.8.5 pero inferior a 0.9.0.</p>
<p>Cargo considera que estas versiones tienen APIs públicas compatibles con la
versión 0.8.5, y esta especificación asegura que obtendrá la última versión de
corrección que aún se compilará con el código de este capítulo. Cualquier
versión 0.9.0 o superior no está garantizada de tener la misma API que lo que
usarán los siguientes ejemplos.</p>
<p>Ahora, sin cambiar ningún código, construyamos el proyecto, como se muestra en
el Listado 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Listado 2-2: La salida de ejecutar <code>cargo build</code> después
de agregar el crate rand como una dependencia</span></p>
<p>Es posible que veas números de versión diferentes (¡pero todos serán
compatibles con el código, gracias a SemVer!) y líneas diferentes (dependiendo
del sistema operativo), y las líneas pueden estar en un orden diferente.</p>
<p>Cuando incluimos una dependencia externa, Cargo obtiene las últimas versiones de
todo lo que la dependencia necesita del <em>registro</em>, que es una copia de datos
de <a href="https://crates.io/">Crates.io</a>. Crates.io es donde las personas en el ecosistema de
Rust publican sus proyectos de Rust de código abierto para que otros los
utilicen.</p>
<p>Después de actualizar el registro, Cargo verifica la sección <code>[dependencies]</code>
y descarga cualquier crate que se haya enumerado que aún no se haya
descargado. En este caso, aunque solo enumeramos <code>rand</code> como una dependencia,
Cargo también tomó otros crates que <code>rand</code> depende para funcionar. Después de
descargar los crates, Rust los compila y luego compila el proyecto con las
dependencias disponibles.</p>
<p>Si ejecuta <code>cargo build</code> nuevamente sin hacer ningún cambio, no obtendrá
ninguna salida aparte de la línea <code>Finished</code>. Cargo sabe que ya ha descargado y
compilado las dependencias, y no ha cambiado nada sobre ellas en su archivo
<em>Cargo.toml</em>. Cargo también sabe que no ha cambiado nada sobre su código, por
lo que tampoco lo vuelve a compilar. Sin nada que hacer, simplemente sale.</p>
<p>Si abre el archivo <em>src/main.rs</em>, realiza un cambio trivial y luego lo guarda y
vuelve a construir, solo verá dos líneas de salida:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Estas líneas muestran que Cargo solo actualiza la compilación con su pequeño
cambio en el archivo <em>src/main.rs</em>. Sus dependencias no han cambiado, por lo
que Cargo sabe que puede reutilizar lo que ya ha descargado y compilado para
esas.</p>
<h4 id="garantizar-compilaciones-reproducibles-con-el-archivo-cargolock"><a class="header" href="#garantizar-compilaciones-reproducibles-con-el-archivo-cargolock">Garantizar compilaciones reproducibles con el archivo <em>Cargo.lock</em></a></h4>
<p>Cargo tiene un mecanismo que le garantiza que puede reconstruir el mismo
artefacto cada vez que usted o cualquier otra persona construye su código:
Cargo solo usará las versiones de las dependencias que haya especificado hasta
que indique lo contrario. Por ejemplo, digamos que la semana que viene sale la
versión 0.8.6 del crate <code>rand</code>, y que esa versión contiene una corrección de
error importante, pero también contiene una regresión que romperá su código.
Para manejar esto, Rust crea el archivo <em>Cargo.lock</em> la primera vez que ejecuta
<code>cargo build</code>, por lo que ahora tenemos esto en el directorio <em>guessing_game</em></p>
<p>Cuando construye un proyecto por primera vez, Cargo determina todas las
versiones de las dependencias que cumplen con los criterios y luego las escribe
en el archivo <em>Cargo.lock</em>. Cuando construye su proyecto en el futuro, Cargo
verá que el archivo <em>Cargo.lock</em> existe y usará las versiones especificadas
allí en lugar de hacer todo el trabajo de averiguar las versiones nuevamente.
Esto le permite tener una compilación reproducible de forma automática. En
otras palabras, su proyecto permanecerá en 0.8.5 hasta que actualice
explícitamente, gracias al archivo <em>Cargo.lock</em>. Debido a que el archivo
<em>Cargo.lock</em> es importante para las compilaciones reproducibles, a menudo se
verifica en el control de versiones con el resto del código en su proyecto.</p>
<h4 id="actualizar-un-crate-para-obtener-una-nueva-versión"><a class="header" href="#actualizar-un-crate-para-obtener-una-nueva-versión">Actualizar un crate para obtener una nueva versión</a></h4>
<p>Cuando <em>quiera</em> actualizar un crate, Cargo proporciona el comando <code>update</code>,
que ignorará el archivo <em>Cargo.lock</em> y determinará todas las últimas versiones
que cumplan con sus especificaciones en <em>Cargo.toml</em>. Cargo luego escribirá
esas versiones en el archivo <em>Cargo.lock</em>. En este caso, Cargo solo buscará 
versiones mayores que 0.8.5 y menores que 0.9.0. Si el crate <code>rand</code> ha lanzado 
las dos nuevas versiones 0.8.6 y 0.9.0, vería lo siguiente si ejecutara 
<code>cargo update</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo ignora el lanzamiento 0.9.0. En este punto, también notaría un cambio en
su archivo <em>Cargo.lock</em> que indica que la versión del crate <code>rand</code> que ahora
está usando es 0.8.6. Para usar la versión 0.9.0 o cualquier versión en la
serie 0.9.<em>x</em>, tendría que actualizar el archivo <em>Cargo.toml</em> para que se
vea así:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>La próxima vez que ejecute <code>cargo build</code>, Cargo actualizará el registro de
crates disponibles y volverá a evaluar sus requisitos de <code>rand</code> de acuerdo con
la nueva versión que ha especificado.</p>
<p>Hay mucho más que decir sobre <a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore --> y <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">su
ecosistema</a><!-- ignore -->, que discutiremos en el Capítulo 14, pero
por ahora, eso es todo lo que necesita saber. Cargo hace muy fácil reutilizar
bibliotecas, por lo que los Rustaceans pueden escribir proyectos más pequeños
que se ensamblan a partir de un número de paquetes.</p>
<h3 id="generar-un-numero-aleatorio"><a class="header" href="#generar-un-numero-aleatorio">Generar un numero aleatorio</a></h3>
<p>Comencemos a usar <code>rand</code> para generar un número para adivinar. El siguiente
paso es actualizar <em>src/main.rs</em>, como se muestra en el Listado 2-3.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;The secret number is: {secret_number}&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}</code></pre>
<p><span class="caption">Listado 2-3: Agregando código para generar un número
aleatorio</span></p>
<p>Primero agregamos la línea <code>use rand::Rng;</code>. El trait <code>Rng</code> define métodos que
los generadores de números aleatorios implementan, y este trait debe estar en
el alcance para que podamos usar esos métodos. El Capítulo 10 cubrirá los
traits en detalle.</p>
<p>A continuación, estamos agregando dos líneas en el medio. En la primera línea,
llamamos a la función <code>rand::thread_rng</code> que nos da el generador de números
aleatorios particular que vamos a usar: uno que es local al hilo de ejecución
actual y está sembrado por el sistema operativo. Luego llamamos al método
<code>gen_range</code> en el generador de números aleatorios. Este método está definido
por el trait <code>Rng</code> que traemos al alcance con la declaración <code>use rand::Rng;</code>.
El método <code>gen_range</code> toma una expresión de rango como argumento y genera un
número aleatorio en el rango. El tipo de expresión de rango que estamos
utilizando aquí toma la forma <code>start..=end</code> y es inclusivo en los límites
inferior y superior, por lo que necesitamos especificar <code>1..=100</code> para solicitar
un número entre 1 y 100.</p>
<blockquote>
<p>Nota: No sabrá solo qué traits usar y qué métodos y funciones llamar desde un
crate, por lo que cada crate tiene documentación con instrucciones para
usarlo. Otra característica interesante de Cargo es que ejecutar el comando
<code>cargo doc --open</code> construirá la documentación proporcionada por todas sus
dependencias localmente y la abrirá en su navegador. Si está interesado en
otra funcionalidad en el crate <code>rand</code>, por ejemplo, ejecute <code>cargo doc --open</code> y haga clic en <code>rand</code> en la barra lateral a la izquierda.</p>
</blockquote>
<p>La segunda línea nueva imprime el número secreto. Esto es útil mientras
desarrollamos el programa para poder probarlo, pero lo eliminaremos de la
versión final. ¡No es mucho un juego si el programa imprime la respuesta tan
pronto como comienza!</p>
<p>Intente ejecutar el programa varias veces:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Debería obtener números aleatorios diferentes, y todos deberían ser números
entre 1 y 100. ¡Gran trabajo!</p>
<p><a id="comparando-la-adivinanza-con-el-numero-secreto"></a></p>
<h2 id="comparando-la-adivinanza-con-el-número-secreto"><a class="header" href="#comparando-la-adivinanza-con-el-número-secreto">Comparando la Adivinanza con el Número Secreto</a></h2>
<p>Ahora que tenemos la entrada del usuario y un número aleatorio, podemos
compararlos. Ese paso se muestra en el Listado 2-4. Tenga en cuenta que este
código aún no se compilará, como explicaremos.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}</code></pre>
<p><span class="caption">Listado 2-4: Manejo de los posibles valores de retorno
de la comparación de dos números</span></p>
<p>Primero agregamos otra declaración <code>use</code>, que trae un tipo llamado
<code>std::cmp::Ordering</code> al alcance de la biblioteca estándar. El tipo <code>Ordering</code>
es otro enum y tiene las variantes <code>Less</code>, <code>Greater</code> y <code>Equal</code>. Estos son los
tres resultados posibles cuando compara dos valores.</p>
<p>Luego agregamos cinco nuevas líneas al final que usan el tipo <code>Ordering</code>. El
método <code>cmp</code> compara dos valores y se puede llamar en cualquier cosa que se
pueda comparar. Toma una referencia a lo que quiera comparar: aquí está
comparando <code>guess</code> con <code>secret_number</code>. Luego devuelve una variante del enum
<code>Ordering</code> que importamos al alcance con la declaración <code>use</code>. Usamos una
expresión <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> para decidir qué hacer a continuación
basándonos en qué variante de <code>Ordering</code> se devolvió de la llamada a <code>cmp</code> con
los valores en <code>guess</code> y <code>secret_number</code>.</p>
<p>Una expresión <code>match</code> está compuesta por <em>brazos</em>. Un brazo consta de un
<em>patrón</em> para coincidir y el código que se debe ejecutar si el valor dado a
<code>match</code> se ajusta al patrón del brazo. Rust toma el valor dado a <code>match</code> y
busca cada patrón de brazo en orden. Los patrones y la construcción <code>match</code> son
potentes características de Rust: le permiten expresar una variedad de
situaciones que su código puede encontrar y se aseguran de que los maneje
todos. Estas características se cubrirán en detalle en el Capítulo 6 y el
Capítulo 18, respectivamente.</p>
<p>Vamos a repasar un ejemplo con la expresión <code>match</code> que usamos aquí. Digamos
que el usuario ha adivinado 50 y el número secreto generado aleatoriamente
esta vez es 38.</p>
<p>Cuando el código compara 50 con 38, el método <code>cmp</code> devolverá
<code>Ordering::Greater</code> porque 50 es mayor que 38. La expresión <code>match</code> obtiene el
valor <code>Ordering::Greater</code> y comienza a verificar el patrón de cada brazo. Mira
el patrón del primer brazo, <code>Ordering::Less</code>, y ve que el valor
<code>Ordering::Greater</code> no coincide con <code>Ordering::Less</code>, ¡así que ignora el código
en ese brazo y se mueve al siguiente brazo! El patrón del siguiente brazo es
<code>Ordering::Greater</code>, ¡que <em>sí</em> coincide con <code>Ordering::Greater</code>! El código
asociado en ese brazo se ejecutará y mostrará <code>Too big!</code> en la pantalla. La
expresión <code>match</code> termina después de la primera coincidencia exitosa, ¡así que
no mirará el último brazo en este escenario.</p>
<p>Sin embargo, el código del Listado 2-4 aún no se compilará. Vamos a intentarlo:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/cmp.rs:836:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin &quot;guessing_game&quot;) due to 1 previous error
</code></pre>
<p>El núcleo del error indica que hay <em>tipos no coincidentes</em>. Rust tiene un
sistema de tipos fuerte y estático. Sin embargo, también tiene inferencia de
tipo. Cuando escribimos <code>let mut guess = String::new()</code>, Rust pudo inferir que
<code>guess</code> debería ser un <code>String</code> y no nos obligó a escribir el tipo. El
<code>secret_number</code>, por otro lado, es un tipo de número. Algunos de los tipos de
números de Rust pueden tener un valor entre 1 y 100: <code>i32</code>, un número de 32 bits;
<code>u32</code>, un número sin signo de 32 bits; <code>i64</code>, un número de 64 bits; así como
otros. A menos que se especifique lo contrario, Rust predetermina un <code>i32</code>, que
es el tipo de <code>secret_number</code> a menos que agregue información de tipo en otro
lugar que haga que Rust infiera un tipo numérico diferente. La razón del error
es que Rust no puede comparar una cadena y un tipo numérico.</p>
<p>Finalmente, queremos convertir la <code>String</code> que el programa lee como entrada en
un tipo de número real para que podamos compararlo numéricamente con el número
secreto. Lo hacemos agregando esta línea al cuerpo de la función <code>main</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
<span class="boring">}</span></code></pre>
<p>La línea es:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);</code></pre>
<p>Creamos una variable llamada <code>guess</code>. Pero espera, ¿no tiene el programa ya una
variable llamada <code>guess</code>? Lo hace, pero Rust nos permite redefinir el valor
anterior de <code>guess</code> con uno nuevo. Este concepto en Rust se le conoce como
<em>Shadowing</em>, nos permite volver a usar el nombre de la variable <code>guess</code>
en lugar de obligarnos a crear dos variables únicas, como <code>guess_str</code>
y <code>guess</code>, por ejemplo. Lo cubriremos con más detalle en el
<a href="ch03-01-variables-and-mutability.html#shadowing">Capítulo 3</a><!-- ignore -->, pero por ahora, sé que esta
característica se usa a menudo cuando desea convertir un valor de un tipo a
otro tipo.</p>
<p>Enlazamos esta nueva variable a la expresión <code>guess.trim().parse()</code>. La <code>guess</code>
en la expresión se refiere a la variable <code>guess</code> original que contenía la
entrada como una cadena. El método <code>trim</code> en una instancia <code>String</code> eliminará
cualquier espacio en blanco al principio y al final, lo que debemos hacer para
poder comparar la cadena con el <code>u32</code>, que solo puede contener datos numéricos.
El usuario debe presionar <span class="keystroke">enter</span> para satisfacer
<code>read_line</code> e ingresar su conjetura, lo que agrega un carácter de nueva línea
a la cadena. Por ejemplo, si el usuario escribe <span class="keystroke">5</span>
y presiona <span class="keystroke">enter</span>, <code>guess</code> se ve así: <code>5\n</code>. El
<code>\n</code> representa &quot;nueva línea&quot;. (En Windows, presionar <span
class="keystroke">enter</span> resulta en un retorno de carro y una nueva
línea, <code>\r\n</code>). El método <code>trim</code> elimina <code>\n</code> o <code>\r\n</code>, lo que resulta en solo
<code>5</code>.</p>
<p>El <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">método <code>parse</code> en las cadenas</a><!-- ignore --> convierte una cadena
en otro tipo. Aquí, lo usamos para convertir de una cadena a un número. Debemos
decirle a Rust el tipo de número exacto que queremos usando <code>let guess: u32</code>.
Los dos puntos (<code>:</code>) después de <code>guess</code> le dicen a Rust que anotaremos el tipo
de variable. Rust tiene algunos tipos de número integrados; el <code>u32</code> visto
aquí es un entero sin signo de 32 bits. Es una buena opción predeterminada para
un número positivo pequeño. Aprenderá sobre otros tipos de números en el
<a href="ch03-02-data-types.html#tipos-de-enteros">Capítulo 3</a><!-- ignore -->.</p>
<p>Además, la anotación <code>u32</code> en este programa de ejemplo y la comparación con
<code>secret_number</code> significa que Rust inferirá que <code>secret_number</code> también
debería ser <code>u32</code>. ¡Entonces la comparación será entre dos valores del mismo
tipo!</p>
<p>El método <code>parse</code> solo funcionará en caracteres que se puedan convertir
lógicamente en números y, por lo tanto, pueden causar fácilmente errores. Si,
por ejemplo, la cadena contiene <code>A👍%</code>, no habría manera de convertir eso en un
número. Debido a que podría fallar, el método <code>parse</code> devuelve un tipo <code>Result</code>,
tal como lo hace el método <code>read_line</code> (discutido anteriormente en
<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“Manejo de posibles fallas con <code>Result</code>”</a><!-- ignore-->).
Trataremos este <code>Result</code> de la misma manera usando el método <code>expect</code> de nuevo.
Si <code>parse</code> devuelve una variante <code>Err</code> del tipo <code>Result</code> porque no pudo crear
un número a partir de la cadena, la llamada <code>expect</code> hará que el juego se
bloquee y muestre el mensaje que le damos. Si <code>parse</code> puede convertir
exitosamente la cadena en un número, devolverá la variante <code>Ok</code> del tipo
<code>Result</code>, y <code>expect</code> devolverá el número que queremos del valor <code>Ok</code>.</p>
<p>¡Corramos el programa ahora!</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>¡Bien! Aunque se agregaron espacios antes de la adivinanza, el programa aún
sabía que el usuario adivinó 76. Ejecute el programa varias veces para
verificar el comportamiento diferente con diferentes tipos de entrada: adivine
el número correctamente, adivine un número que sea demasiado alto y adivine un
número que sea demasiado bajo.</p>
<p>Tenemos la mayoría del juego funcionando ahora, pero el usuario solo puede
adivinar una vez. ¡Cambiamos eso agregando un bucle!</p>
<h2 id="permitir-múltiples-adivinanzas-con-bucles"><a class="header" href="#permitir-múltiples-adivinanzas-con-bucles">Permitir múltiples adivinanzas con bucles</a></h2>
<p>La palabra clave <code>loop</code> crea un bucle infinito. Agregaremos un bucle para darle
a los usuarios más oportunidades para adivinar el número:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;The secret number is: {secret_number}&quot;);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}</code></pre>
<p>Como puede ver, hemos movido todo desde la solicitud de entrada de adivinanzas
hacia adelante en un bucle. Asegúrese de indentar las líneas dentro del bucle
otras cuatro veces y ejecute el programa nuevamente. ¡El programa ahora pedirá
otra adivinanza para siempre, lo que introduce un nuevo problema! ¡Parece que el
usuario no puede salir!</p>
<p>El usuario siempre podría interrumpir el programa usando el atajo de teclado
<span class="keystroke">ctrl-c</span>. Pero hay otra forma de escapar de este
monstruo insaciable, como se mencionó en la discusión de <code>parse</code> en
<a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">“Comparando la adivinanza con el número secreto”</a><!--
ignore -->: si el usuario ingresa una respuesta que no es un número, el
programa se bloqueará. Podemos aprovechar eso para permitir que el usuario
salga, como se muestra aquí:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Al escribir <code>quit</code> se cerrará el juego, pero como notará, también lo hará al
ingresar cualquier otra entrada que no sea un número. Esto es lo menos
óptimo, para decir lo menos; queremos que el juego también se detenga cuando se
adivine el número correcto.</p>
<p><a id="salir-despues-de-una-adivinanza-correcta"></a></p>
<h3 id="salir-después-de-una-adivinanza-correcta"><a class="header" href="#salir-después-de-una-adivinanza-correcta">Salir después de una adivinanza correcta</a></h3>
<p>Programemos el juego para que se cierre cuando el usuario gane agregando una
declaración <code>break</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p>Agregando la línea <code>break</code> después de <code>You win!</code> hace que el programa salga del
bucle cuando el usuario adivina el número secreto correctamente. Salir del
bucle también significa salir del programa, porque el bucle es la última parte
de <code>main</code>.</p>
<h3 id="manejo-de-entrada-no-válida"><a class="header" href="#manejo-de-entrada-no-válida">Manejo de entrada no válida</a></h3>
<p>Para mejorar aún más el comportamiento del juego, en lugar de bloquear el
programa cuando el usuario ingresa un número no válido, hagamos que el juego
ignore un número no válido para que el usuario pueda seguir adivinando. Podemos
hacer eso alterando la línea donde <code>guess</code> se convierte de un <code>String</code> a un
<code>u32</code>, como se muestra en el Listado 2-5.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 2-5: Ignorar una adivinanza que no es un número
y pedir otra adivinanza en lugar de bloquear el programa</span></p>
<p>Cambiamos de una llamada <code>expect</code> a una expresión <code>match</code> para pasar de
bloquear el programa en un error a manejar el error. Recuerde que <code>parse</code>
devuelve un tipo <code>Result</code> y <code>Result</code> es un enum que tiene las variantes <code>Ok</code> y
<code>Err</code>. Aquí estamos usando una expresión <code>match</code>, como hicimos con el resultado
<code>Ordering</code> del método <code>cmp</code>.</p>
<p>Si <code>parse</code> es capaz de convertir exitosamente la cadena en un número, devolverá
un valor <code>Ok</code> que contiene el número resultante. Ese valor <code>Ok</code> coincidirá con
el patrón de la primera rama y la expresión <code>match</code> devolverá el valor <code>num</code>
que <code>parse</code> produjo y puso dentro del valor <code>Ok</code>. Ese número terminará en el
lugar correcto en la nueva variable <code>guess</code> que estamos creando.</p>
<p>Si <code>parse</code> <em>no</em> es capaz de convertir la cadena en un número, devolverá un
valor <code>Err</code> que contiene más información sobre el error. El valor <code>Err</code> no
coincide con el patrón <code>Ok(num)</code> en la primera rama de <code>match</code>, pero sí
coincide con el patrón <code>Err(_)</code> en la segunda rama. El guión bajo, <code>_</code>, es un
valor de captura; en este ejemplo, estamos diciendo que queremos coincidir con
todos los valores <code>Err</code>, sin importar qué información tengan dentro. ¡Así que
el programa ejecutará el código de la segunda rama, <code>continue</code>, que le dice al
programa que vaya a la siguiente iteración del <code>loop</code> y pida otra adivinanza.
¡Así que, efectivamente, el programa ignora todos los errores que <code>parse</code> puede
encontrar!</p>
<p>Ahora todo en el programa debería funcionar como se espera. Vamos a probarlo:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>¡Genial! Con un pequeño ajuste final, terminaremos el juego de adivinanzas.
Recuerde que el programa todavía está imprimiendo el número secreto. Eso
funcionó bien para las pruebas, pero arruina el juego. Vamos a eliminar el
<code>println!</code> que muestra el número secreto. El listado 2-6 muestra el código
final.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p><span class="caption">Listado 2-6: Código completo del juego de adivinanzas</span></p>
<p>En este punto, ha construido exitosamente el juego de adivinanzas. ¡Felicidades!</p>
<h2 id="resumen-1"><a class="header" href="#resumen-1">Resumen</a></h2>
<p>Este proyecto fue una manera práctica de introducirle a muchos nuevos conceptos
de Rust: <code>let</code>, <code>match</code>, funciones, el uso de paquetes externos, y más. En los
próximos capítulos, aprenderá sobre estos conceptos en más detalle. El capítulo
3 cubre conceptos que la mayoría de los lenguajes de programación tienen, como
variables, tipos de datos y funciones, y muestra cómo usarlos en Rust. El
capítulo 4 explora la propiedad, una característica que hace que Rust sea
diferente de otros lenguajes. El capítulo 5 discute las estructuras y la
sintaxis de los métodos, y el capítulo 6 explica cómo funcionan los enums.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conceptos-comunes-de-programación"><a class="header" href="#conceptos-comunes-de-programación">Conceptos Comunes de Programación</a></h1>
<p>Este capítulo cubre conceptos que aparecen en casi todos los lenguajes de
programación y cómo funcionan en Rust. Muchos lenguajes de programación tienen
mucho en común en su núcleo. Ninguno de los conceptos presentados en este
capítulo son únicos de Rust, pero los discutiremos en el contexto de Rust y
explicaremos las convenciones alrededor de su uso.</p>
<p>Específicamente, aprenderás sobre variables, tipos básicos, funciones,
comentarios y flujo de control. Estas bases estarán en todos los programas de
Rust, y aprenderlas temprano te dará un núcleo fuerte para comenzar.</p>
<blockquote>
<h4 id="palabras-clave"><a class="header" href="#palabras-clave">Palabras clave</a></h4>
<p>El lenguaje Rust tiene un conjunto de <em>palabras clave</em> que están reservadas
para su uso exclusivo por el lenguaje, al igual que en otros lenguajes. Tenga
en cuenta que no puede usar estas palabras como nombres de variables o
funciones. La mayoría de las palabras clave tienen significados especiales,
y las usará para realizar varias tareas en sus programas de Rust; algunas no
tienen ninguna funcionalidad actual asociada con ellas, pero se han reservado
para funcionalidad que podría agregarse a Rust en el futuro. Puede encontrar
una lista de las palabras clave en <a href="appendix-01-keywords.html">Apéndice A</a><!-- ignore -->.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variables-y-mutabilidad"><a class="header" href="#variables-y-mutabilidad">Variables y Mutabilidad</a></h2>
<p>Como se mencionó en la sección
<a href="ch02-00-guessing-game-tutorial.html#almacenando-valores-con-variables">“Almacenando valores con variables”</a><!-- ignore -->
, por defecto, las variables
son inmutables. Este es uno de los muchos empujes que Rust le da para que
escriba su código de una manera que aproveche la seguridad y la fácil
concurrencia que ofrece Rust. Sin embargo, todavía tiene la opción de hacer
sus variables mutables. Exploremos cómo y por qué Rust le anima a favorecer
la inmutabilidad y por qué a veces podría querer optar por no hacerlo.</p>
<p>Cuando una variable es inmutable, una vez que un valor está vinculado a un
nombre, no puede cambiar ese valor. Para ilustrar esto, genere un nuevo
proyecto llamado <em>variables</em> en su directorio <em>proyectos</em> usando <code>cargo new variables</code>.</p>
<p>Luego, en su nuevo directorio <em>variables</em>, abra <em>src/main.rs</em> y reemplace su
código con el siguiente código, que aún no se compilará:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}</code></pre>
<p>Guarde y ejecute el programa usando <code>cargo run</code>. Debería recibir un mensaje de
error relacionado con un error de inmutabilidad, como se muestra en esta
salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {x}&quot;);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error
</code></pre>
<p>Este ejemplo muestra cómo el compilador le ayuda a encontrar errores en sus
programas. Los errores de compilación pueden ser frustrantes, pero realmente
solo significa que su programa aún no está realizando de manera segura lo que
desea que haga; <em>no</em> significa que no es un buen programador! Los Rustaceans
experimentados aún reciben errores de compilación.</p>
<p>Recibió el mensaje de error <code>cannot assign twice to immutable variable `x`</code> porque intentó asignar un segundo valor a la variable inmutable <code>x</code>.</p>
<p>Es importante que obtengamos errores en tiempo de compilación cuando intentamos
cambiar un valor que está designado como inmutable, porque esta situación
puede conducir a errores. Si una parte de nuestro código opera bajo la
suposición de que un valor nunca cambiará y otra parte de nuestro código
cambia ese valor, es posible que la primera parte del código no haga lo que
estaba diseñado para hacer. La causa de este tipo de error puede ser difícil
de rastrear después del hecho, especialmente cuando la segunda pieza de código
cambia el valor solo <em>algunas veces</em>. El compilador de Rust garantiza que
cuando afirma que un valor no cambiará, realmente no cambiará, por lo que no
tiene que rastrearlo usted mismo. Su código es, por lo tanto, más fácil de
razonar.</p>
<p>Pero la mutabilidad puede ser muy útil y puede hacer que el código sea más
conveniente de escribir. Aunque las variables son inmutables por defecto, puede
hacerlas mutables agregando <code>mut</code> delante del nombre de la variable como lo
hizo en el <a href="ch02-00-guessing-game-tutorial.html#almacenando-valores-con-variables">Capitulo 2</a><!-- ignore -->.
Agregando <code>mut</code> también comunica la intención a los lectores futuros del código
indicando que otras partes del código cambiarán el valor de esta variable.</p>
<p>Por ejemplo, cambiemos <em>src/main.rs</em> a lo siguiente:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<p>Cuando ejecutamos el programa ahora, obtenemos esto:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Se nos permite cambiar el valor vinculado a <code>x</code> de <code>5</code> a <code>6</code> cuando se usa
<code>mut</code>. En última instancia, decidir si usar o no la mutabilidad depende de
usted y depende de lo que crea que es más claro en esa situación particular.</p>
<h3 id="constantes"><a class="header" href="#constantes">Constantes</a></h3>
<p>Al igual que las variables inmutables, las <em>constantes</em> son valores que están
vinculados a un nombre y no se les permite cambiar, pero hay algunas
diferencias entre las constantes y las variables.</p>
<p>Primero, no se le permite usar <code>mut</code> con constantes. Las constantes no son solo
inmutables por defecto, siempre son inmutables. Declara constantes usando la
palabra clave <code>const</code> en lugar de la palabra clave <code>let</code>, y el tipo del valor
<em>debe</em> estar anotado. Cubriremos los tipos y las anotaciones de tipo en la
siguiente sección, <a href="ch03-02-data-types.html#tipos-de-datos">“Tipos de datos”</a><!-- ignore -->, por lo que no se
preocupe por los detalles ahora. Solo sepa que siempre debe anotar el tipo.</p>
<p>Las constantes se pueden declarar en cualquier ámbito, incluido el ámbito
global, lo que las hace útiles para valores que muchas partes del código
necesitan conocer.</p>
<p>La última diferencia es que las constantes solo se pueden establecer en una
expresión constante, no en el resultado de un valor que solo se podría calcular
en tiempo de ejecución.</p>
<p>Aquí hay un ejemplo de una declaración constante:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>El nombre de la constante es <code>THREE_HOURS_IN_SECONDS</code> y su valor se establece
en el resultado de multiplicar 60 (el número de segundos en un minuto) por 60
(el número de minutos en una hora) por 3 (el número de horas que queremos
contar en este programa). La convención de nombramiento de Rust para constantes
es usar mayúsculas con guiones bajos entre palabras. El compilador es capaz de
evaluar un conjunto limitado de operaciones en tiempo de compilación, lo que
nos permite elegir escribir este valor de una manera que sea más fácil de
entender y verificar, en lugar de establecer esta constante en el valor 10,800.
Vea la <a href="https://doc.rust-lang.org/reference/const_eval.html">&quot;sección de la Referencia de Rust sobre la evaluación constante&quot;</a>
para más información sobre qué operaciones se pueden usar al declarar constantes.</p>
<p>Las constantes son válidas durante todo el tiempo que se ejecuta un programa,
dentro del ámbito en el que se declararon. Esta propiedad hace que las
constantes sean útiles para los valores en el dominio de su aplicación que
varias partes del programa podrían necesitar conocer, como el número máximo de
puntos que cualquier jugador de un juego puede obtener o la velocidad de la
luz.</p>
<p>Nombrar valores codificados en su programa como constantes es útil para
transmitir el significado de ese valor a los futuros mantenedores del código.
También ayuda a tener solo un lugar en su código en el que necesitaría cambiar
si el valor codificado tuviera que actualizarse en el futuro.</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>Como vio en el tutorial del juego de adivinanzas en <a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">Capítulo
2</a><!-- ignore -->, puede declarar una
nueva variable con el mismo nombre que una variable anterior. Los Rustaceans
dicen que la primera variable es <em>ocultada</em> por la segunda, lo que significa
que la segunda variable es lo que el compilador verá cuando use el nombre de la
variable. En efecto, la segunda variable oculta la primera, tomando
cualquier uso del nombre de la variable para sí misma hasta que se haga
<em>shadowing</em> sobre la misma variable o el ámbito finalice.
Podemos ocultar una variable usando el mismo nombre de variable y repitiendo
el uso de la palabra clave <code>let</code> de la siguiente manera:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {x}&quot;);
    }

    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<p>Este programa primero vincula a <code>x</code> el valor de <code>5</code>. Luego crea una nueva
variable <code>x</code> repitiendo <code>let x =</code>, tomando el valor original y agregando <code>1</code>
para que el valor de <code>x</code> sea entonces <code>6</code>. Luego, dentro de un ámbito interno
creado con las llaves, la tercera declaración <code>let</code> también proyecta <code>x</code> y
crea una nueva variable, multiplicando el valor anterior por <code>2</code> para darle a
<code>x</code> un valor de <code>12</code>. Cuando ese ámbito finaliza, la proyección interna finaliza
y <code>x</code> vuelve a ser <code>6</code>. Cuando ejecutamos este programa, se mostrará lo
siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>El <em>Shadowing</em> es diferente de marcar una variable como <code>mut</code> porque obtendremos
un error de tiempo de compilación si accidentalmente intentamos volver a
asignar esta variable sin usar la palabra clave <code>let</code>. Al usar <code>let</code>, podemos
realizar algunas transformaciones en un valor, pero la variable debe ser
inmutable después de que se hayan completado esas transformaciones.</p>
<p>La otra diferencia entre <code>mut</code> y el <em>shadowing</em> es que, debido a que
efectivamente estamos creando una nueva variable cuando usamos la palabra clave
<code>let</code> nuevamente, podemos cambiar el tipo de valor pero reutilizar el mismo
nombre. Por ejemplo, digamos que nuestro programa le pide al usuario que muestre
cuántos espacios desea entre algún texto ingresando caracteres de espacio, y
luego queremos almacenar esa entrada como un número:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>La primera variable <code>spaces</code> es de tipo <em>string</em> y la segunda variable <code>spaces</code>
es de tipo <em>numérico</em>. El <em>shadowing</em> nos ahorra tener que pensar en nombres
diferentes, como <code>spaces_str</code> y <code>spaces_num</code>; en su lugar, podemos reutilizar
el nombre más simple <code>spaces</code>. Sin embargo, si intentamos usar <code>mut</code> para esto,
como se muestra aquí, obtendremos un error de tiempo de compilación:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>El error dice que no se permite mutar el tipo de una variable:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error
</code></pre>
<p>Ahora que hemos explorado cómo funcionan las variables, veamos más tipos de
datos que pueden tener.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-de-datos"><a class="header" href="#tipos-de-datos">Tipos de datos</a></h2>
<p>Cada valor en Rust es de un cierto <em>tipo de dato</em>, que le dice a Rust qué tipo
de dato se está especificando para que sepa cómo trabajar con ese dato. Veremos 
dos subconjuntos de tipos de datos: escalares y compuestos.</p>
<p>Tenga en cuenta que Rust es un lenguaje <em>estáticamente tipado</em>, lo que significa
que debe conocer los tipos de todas las variables en tiempo de compilación. El
compilador generalmente puede inferir qué tipo queremos usar en función del
valor y cómo lo usamos. En los casos en que muchos tipos son posibles, como
cuando convertimos un <code>String</code> en un tipo numérico usando <code>parse</code> en la sección
<a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">“Comparando la Adivinanza con el Número Secreto”</a>
del capítulo 2, debemos agregar una anotación de tipo, como
esta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Si no agregamos la anotación de tipo <code>: u32</code> mostrada en el código anterior,
Rust mostrará el siguiente error, lo que significa que el compilador necesita
más información de nosotros para saber qué tipo queremos usar:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin &quot;no_type_annotations&quot;) due to 1 previous error
</code></pre>
<p>Verá diferentes anotaciones de tipo para otros tipos de datos.</p>
<h3 id="tipos-escalares"><a class="header" href="#tipos-escalares">Tipos Escalares</a></h3>
<p>Un tipo <em>escalar</em> representa un solo valor. Rust tiene cuatro tipos escalares
principales: enteros, números de punto flotante, booleanos y caracteres. Puede
reconocerlos de otros lenguajes de programación. Vamos a ver cómo funcionan en
Rust.</p>
<h4 id="tipos-de-enteros"><a class="header" href="#tipos-de-enteros">Tipos de Enteros</a></h4>
<p>Un <em>entero</em> es un número sin componente fraccionario. Usamos un tipo de entero
en el capítulo 2, el tipo <code>u32</code>. Esta declaración de tipo indica que el valor
con el que está asociado debe ser un entero sin signo (los tipos de enteros con
signo comienzan con <code>i</code> en lugar de <code>u</code>) que ocupa 32 bits de espacio. La tabla
3-1 muestra los tipos de enteros integrados en Rust. Podemos usar cualquiera de
estas variantes para declarar el tipo de un valor entero.</p>
<p><span class="caption">Tabla 3-1: Tipos Enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Tamaño</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Cada variante puede ser <em>signed</em> (con signo) o <em>unsigned</em> (sin signo) y tiene
un tamaño explícito. <em>Signed</em> y <em>unsigned</em> se refieren a si es posible que el
número sea negativo, es decir, si el número necesita tener un signo con él
(signed) o si solo será positivo y por lo tanto puede representarse sin signo
(unsigned). Es como escribir números en papel: cuando el signo importa,
un número se muestra con un signo más o un signo menos; sin embargo, cuando es
seguro suponer que el número es positivo, se muestra sin signo.
Los números con signo se almacenan usando la
representación de <a href="https://es.wikipedia.org/wiki/Complemento_a_dos">complemento a dos</a>.</p>
<p>Cada variante con signo puede almacenar números de -(2<sup>n - 1</sup>)
a 2<sup>n - 1</sup> - 1, donde <em>n</em> es el número de bits que usa la variante.
Así, un <code>i8</code> puede almacenar números de -(2<sup>7</sup>) a 2<sup>7</sup> - 1,
lo que equivale a -128 a 127. Las variantes sin signo pueden almacenar números
de 0 a 2<sup>n</sup> - 1, por lo que un <code>u8</code> puede almacenar números de 0 a 2<sup>8</sup> - 1,
lo que equivale a 0 a 255.</p>
<p>Además, los tipos <code>isize</code> y <code>usize</code> dependen de la arquitectura de la
computadora en la que se ejecuta su programa, que se denota en la tabla como
“arch”: 64 bits si está en una arquitectura de 64 bits y 32 bits si está en una
arquitectura de 32 bits.</p>
<p>Puede escribir literales enteros en cualquiera de las formas que se muestran en
la Tabla 3-2. Tenga en cuenta que los literales numéricos que pueden ser
múltiples tipos numéricos permiten un sufijo de tipo, como <code>57u8</code>, para
designar el tipo. Los literales numéricos también pueden usar <code>_</code> como un
separador visual para facilitar la lectura del número, como <code>1_000</code>, que tendrá
el mismo valor que si hubiera especificado <code>1000</code>.</p>
<p><span class="caption">Tabla 3-2: Literales enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Literales numéricos</th><th>Ejemplo</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binario</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> solamente)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Entonces, ¿cómo sabe qué tipo de entero usar? Si no está seguro, los valores
predeterminados de Rust son generalmente buenos lugares para comenzar: los
tipos enteros se configuran predeterminadamente en <code>i32</code>. La situación
principal en la que usaría <code>isize</code> o <code>usize</code> es cuando indexa algún tipo de
colección.</p>
<blockquote>
<h5 id="desbordamiento-de-enteros"><a class="header" href="#desbordamiento-de-enteros">Desbordamiento de enteros</a></h5>
<p>Digamos que tiene una variable de tipo <code>u8</code> que puede contener valores entre 0
y 255. Si intenta cambiar la variable a un valor fuera de ese rango, como 256,
<em>se producirá un desbordamiento de enteros</em>, que puede resultar en uno de dos
comportamientos. Cuando está compilando en modo de depuración, Rust incluye
comprobaciones para el desbordamiento de enteros que hacen que su programa
<em>se desborde</em> en tiempo de ejecución si ocurre este comportamiento.
Rust usa el término <em>desbordamiento</em> cuando un programa sale con un error;
discutiremos los desbordamientos con más profundidad en la sección <a href="ch09-01-unrecoverable-errors-with-panic.html">“Errores
irrecuperables con <code>panic!</code>”</a><!-- ignore -->
del Capítulo 9.</p>
<p>Cuando está compilando en modo de lanzamiento con la bandera <code>--release</code>,
Rust <em>no</em> incluye comprobaciones para el desbordamiento de enteros que
provocan desbordamientos. En su lugar, si ocurre un desbordamiento, Rust
realiza una <em>envoltura de complemento a dos</em>. En resumen, los valores mayores que
el valor máximo que el tipo puede contener “se envuelven” al mínimo de los
valores que el tipo puede contener. En el caso de un <code>u8</code>, el valor 256 se
convierte en 0, el valor 257 se convierte en 1, y así sucesivamente. El
programa no se desbordará, pero la variable tendrá un valor que probablemente
no sea el que esperaba que tuviera. Depender del comportamiento de la envoltura
del desbordamiento de enteros se considera un error.</p>
<p>Para manejar explícitamente la posibilidad de desbordamiento, puede usar estas
familias de métodos proporcionados por la biblioteca estándar para tipos
numéricos primitivos:</p>
<ul>
<li>Envolver en todos los modos con los métodos <code>wrapping_*</code>, como
<code>wrapping_add</code>.</li>
<li>Devolver el valor <code>None</code> si hay desbordamiento con los métodos <code>checked_*</code>.</li>
<li>Devolver el valor y un booleano que indica si hubo desbordamiento con los
métodos <code>overflowing_*</code>.</li>
<li>Saturar en los valores mínimos o máximos del valor con los métodos
<code>saturating_*</code>.</li>
</ul>
</blockquote>
<h4 id="tipos-de-punto-flotante"><a class="header" href="#tipos-de-punto-flotante">Tipos de punto flotante</a></h4>
<p>Rust también tiene dos tipos primitivos para <em>números de punto flotante</em>, que
son números con puntos decimales. Los tipos de punto flotante de Rust son <code>f32</code>
y <code>f64</code>, que tienen 32 bits y 64 bits de tamaño, respectivamente. El tipo
predeterminado es <code>f64</code> porque en CPUs modernas, es aproximadamente la misma
velocidad que <code>f32</code> pero es capaz de más precisión. Todos los tipos de punto
flotante son con signo.</p>
<p>Aquí hay un ejemplo que muestra números de punto flotante en acción:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Los números de punto flotante se representan de acuerdo con el estándar
IEEE-754. El tipo <code>f32</code> es un punto flotante de precisión simple, y <code>f64</code> tiene
doble precisión.</p>
<h4 id="operaciones-numéricas"><a class="header" href="#operaciones-numéricas">Operaciones numéricas</a></h4>
<p>Rust admite las operaciones matemáticas básicas que esperaría para todos los
tipos de números: adición, sustracción, multiplicación, división y resto.
La división entera se trunca hacia cero al entero más cercano. El siguiente
código muestra cómo usaría cada operación numérica en una declaración <code>let</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<p>Cada expresión en estas instrucciones usa un operador matemático y se evalúa a
un solo valor, que luego se vincula a una variable. El <a href="appendix-02-operators.html">Apéndice
B</a> contiene una lista de todos los operadores que
Rust proporciona.</p>
<h4 id="el-tipo-booleano"><a class="header" href="#el-tipo-booleano">El tipo booleano</a></h4>
<p>Como en la mayoría de los otros lenguajes de programación, un tipo booleano en
Rust tiene dos posibles valores: <code>true</code> y <code>false</code>. Los booleanos tienen un
byte de tamaño. El tipo booleano en Rust se especifica usando <code>bool</code>. Por
ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre></pre>
<p>La forma principal de usar valores booleanos es a través de condicionales, como
una expresión <code>if</code>. Cubriremos cómo funcionan las expresiones <code>if</code> en Rust en
la sección <a href="ch03-05-control-flow.html#flujo-de-control">“Control de flujo”</a><!-- ignore -->.</p>
<h4 id="el-tipo-de-carácter"><a class="header" href="#el-tipo-de-carácter">El tipo de carácter</a></h4>
<p>El tipo <code>char</code> de Rust es el tipo alfabético más primitivo del lenguaje. Estos son algunos ejemplos de declaración de valores <code>char</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>Tenga en cuenta que especificamos literales <code>char</code> con comillas simples, en
oposición a literales de cadena, que usan comillas dobles. El tipo <code>char</code> de 
Rust tiene un tamaño de cuatro bytes y representa un valor escalar Unicode, lo 
que significa que puede representar mucho más que ASCII. Letras
acentuadas; Caracteres chinos, japoneses y coreanos; Emojis; y espacios de ancho
cero son todos valores <code>char</code> válidos en Rust. Los valores escalar de Unicode
van desde <code>U+0000</code> a <code>U+D7FF</code> y <code>U+E000</code> a <code>U+10FFFF</code> inclusive. Sin embargo,
un &quot;carácter&quot; no es realmente un concepto en Unicode, por lo que su intuición
humana sobre lo que es un &quot;carácter&quot; puede no coincidir con lo que es un <code>char</code>
en Rust. Discutiremos este tema en detalle en <a href="ch08-02-strings.html#almacenando-texto-codificado-en-utf-8-con-strings">“Almacenar texto codificado en
UTF-8 con cadenas”</a><!-- ignore --> en el capítulo 8.</p>
<h3 id="tipos-compuestos"><a class="header" href="#tipos-compuestos">Tipos compuestos</a></h3>
<p><em>Tipos compuestos</em> pueden agrupar múltiples valores en un solo tipo. Rust
tiene dos tipos compuestos primitivos: tuplas y arreglos.</p>
<h4 id="el-tipo-tupla"><a class="header" href="#el-tipo-tupla">El Tipo Tupla</a></h4>
<p>Una <em>tupla</em> es una forma general de agrupar varios valores de distintos tipos en 
un tipo compuesto. Las tuplas tienen una longitud fija: una vez declaradas, su 
tamaño no puede aumentar ni disminuir.</p>
<p>Creamos una tupla escribiendo una lista de valores separados por comas dentro de
paréntesis. Cada posición de la tupla tiene un tipo, y los tipos de los 
distintos valores de la tupla no tienen por qué ser iguales. En este ejemplo 
hemos añadido anotaciones de tipo opcionales:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>La variable <code>tup</code> se vincula a toda la tupla porque una tupla se considera un 
único elemento compuesto. Para obtener los valores individuales de una tupla, 
podemos utilizar la concordancia de patrones para desestructurar un valor de 
tupla, así:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {y}&quot;);
}</code></pre></pre>
<p>Este programa primero crea una tupla y la vincula a la variable <code>tup</code>. Luego
usa un patrón con <code>let</code> para tomar <code>tup</code> y convertirla en tres variables
separadas, <code>x</code>, <code>y</code> y <code>z</code>. Esto se llama <em>desestructuración</em> porque rompe la
única tupla en tres partes. Finalmente, el programa imprime el valor de <code>y</code>,
que es <code>6.4</code>.</p>
<p>También podemos acceder directamente a un elemento de la tupla usando un punto
(<code>.</code>) seguido del índice del valor que queremos acceder. Por ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>Este programa crea la tupla <code>x</code> y luego accede a cada elemento de la tupla
usando sus respectivos índices. Al igual que la mayoría de los lenguajes de
programación, el primer índice en una tupla es 0.</p>
<p>La tupla sin ningún valor tiene un nombre especial, <em>unit</em>. Este valor y su
tipo correspondiente están escritos ambos como <code>()</code> y representan un valor
vacío o un tipo de retorno vacío. Las expresiones devuelven implícitamente el
valor unit si no devuelven ningún otro valor.</p>
<h4 id="el-tipo-arreglo"><a class="header" href="#el-tipo-arreglo">El Tipo Arreglo</a></h4>
<p>Otra forma de tener una colección de múltiples valores es con un <em>arreglo</em>.
A diferencia de una tupla, cada elemento de un arreglo debe tener el mismo
tipo. A diferencia de los arreglos en algunos otros lenguajes, los arreglos en
Rust tienen una longitud fija.</p>
<p>Escribimos los valores en un arreglo como una lista separada por comas dentro
de corchetes:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Los arreglos son útiles cuando desea que sus datos se asignen en el stack (pila)
en lugar del heap (montículo) (hablaremos más sobre el stack y el heap en el
<a href="ch04-01-what-is-ownership.html#el-stack-y-el-heap">Capítulo 4</a><!-- ignore -->) o cuando desea asegurarse de que
siempre tenga un número fijo de elementos. Sin embargo, un arreglo no es tan
flexible como el tipo vector. Un <em>vector</em> es un tipo de colección similar
proporcionado por la biblioteca estándar que <em>puede</em> crecer o reducir su tamaño.
Si no está seguro de si debe usar un arreglo o un vector, es probable que deba
usar un vector. El <a href="ch08-01-vectors.html">Capítulo 8</a><!-- ignore --> discute los vectores en
más detalle.</p>
<p>Sin embargo, los arreglos son más útiles cuando sabe que el número de elementos
no cambiará. Por ejemplo, si está utilizando los nombres del mes en un
programa, probablemente usaría un arreglo en lugar de un vector porque sabe que
siempre contendrá 12 elementos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}</span></code></pre></pre>
<p>Escribe el tipo de un arreglo usando corchetes con el tipo de cada elemento,
un punto y coma y luego el número de elementos en el arreglo, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Aquí, <code>i32</code> es el tipo de cada elemento. Después del punto y coma, el número
<code>5</code> indica que el arreglo contiene cinco elementos.</p>
<p>También puede inicializar un arreglo para contener el mismo valor para cada
elemento especificando el valor inicial, seguido de un punto y coma y luego la
longitud del arreglo en corchetes, como se muestra aquí:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>El arreglo llamado <code>a</code> contendrá <code>5</code> elementos que inicialmente se establecerán
en el valor <code>3</code>. Esto es lo mismo que escribir <code>let a = [3, 3, 3, 3, 3];</code> pero
de una manera más concisa.</p>
<h5 id="accediendo-a-los-elementos-del-arreglo"><a class="header" href="#accediendo-a-los-elementos-del-arreglo">Accediendo a los Elementos del Arreglo</a></h5>
<p>Un arreglo es un trozo de memoria de tamaño fijo y conocido que puede asignarse 
a la pila. Se puede acceder a los elementos de una arreglo utilizando la 
indexación, de la siguiente manera:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>En este ejemplo, la variable llamada <code>first</code> obtendrá el valor <code>1</code> porque ese
es el valor en el índice <code>[0]</code> en el arreglo. La variable llamada <code>second</code>
obtendrá el valor <code>2</code> del índice <code>[1]</code> en el arreglo.</p>
<h5 id="acceso-inválido-a-los-elementos-del-arreglo"><a class="header" href="#acceso-inválido-a-los-elementos-del-arreglo">Acceso Inválido a los Elementos del Arreglo</a></h5>
<p>Veamos qué sucede si intenta acceder a un elemento de un arreglo que está más
allá del final del arreglo. Digamos que ejecuta este código, similar al juego
de adivinanzas del Capítulo 2, para obtener un índice de arreglo del usuario:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(&quot;The value of the element at index {index} is: {element}&quot;);
}</code></pre>
<p>Este código se compila con éxito. Si ejecuta este código usando <code>cargo run</code> y
ingresa <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> o <code>4</code>, el programa imprimirá el valor
correspondiente en ese índice en el arreglo. Si en cambio ingresa un número
más allá del final del arreglo, como <code>10</code>, verá una salida como esta:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>El programa dio lugar a un <em>error en tiempo de ejecución</em> al momento de utilizar 
un valor no válido en la operación de indexación. El programa salió con un 
mensaje de error y no ejecutó la sentencia final <code>println!</code>. Cuando intentas 
acceder a un elemento utilizando la indexación, Rust comprobará que el índice 
que has especificado es menor que la longitud del array. Si el índice es mayor o 
igual que la longitud, Rust entrará en pánico. Esta comprobación tiene que 
ocurrir en tiempo de ejecución, especialmente en este caso, porque el compilador 
no puede saber qué valor introducirá el usuario cuando ejecute el código más 
tarde.</p>
<p>Este es un ejemplo de los principios de seguridad de memoria de Rust en acción. 
En muchos lenguajes de bajo nivel, este tipo de comprobación no se hace, y 
cuando proporcionas un índice incorrecto, se puede acceder a memoria inválida. 
Rust te protege contra este tipo de error saliendo inmediatamente en lugar de 
permitir el acceso a la memoria y continuar. El Capítulo 9 discute más sobre el 
manejo de errores de Rust y cómo puedes escribir código legible y seguro que no 
entre en pánico ni permita el acceso a memoria inválida.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funciones"><a class="header" href="#funciones">Funciones</a></h2>
<p>Las Funciones son muy comunes en el código Rust. Ya has visto una de las
funciones más importantes del lenguaje: la función <code>main</code>, que es el punto de
entrada de muchos programas. También has visto la palabra clave <code>fn</code>, que te
permite declarar nuevas funciones.</p>
<p>El código en Rust usa <em>snake case</em> como estilo convencional para los nombres
de funciones y variables, en el que todas las letras son minúsculas y los
guiones bajos separan las palabras. Aquí hay un programa que contiene un
ejemplo de definición de una función:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}</code></pre></pre>
<p>Definimos una función en Rust escribiendo <code>fn</code> seguido del nombre de la función
y un conjunto de paréntesis. Las llaves indican al compilador donde comienza y
termina el cuerpo de la función.</p>
<p>Podemos llamar a cualquier función que hayamos definido escribiendo su nombre
seguido de un conjunto de paréntesis. Como <code>another_function</code> está definida en
el programa, se puede llamar desde dentro de la función <code>main</code>. Ten en cuenta
que definimos <code>another_function</code> <em>después</em> de la función <code>main</code> en el código
fuente; también podríamos haberla definido antes. A Rust no le importa dónde
definas tus funciones, sólo que estén definidas en algún lugar en un ámbito que
pueda ser visto por el invocador.</p>
<p>Empecemos un nuevo proyecto binario llamado <em>functions</em> para explorar las
funciones más a fondo. Coloca el ejemplo de <code>another_function</code> en
<em>src/main.rs</em> y ejecútalo. Deberías ver la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>Las líneas se ejecutan en el orden en que aparecen en la función <code>main</code>. Primero
se imprime el mensaje “Hello, world!”, y luego se llama a <code>another_function</code> y
se imprime su mensaje.</p>
<h3 id="parámetros"><a class="header" href="#parámetros">Parámetros</a></h3>
<p>Podemos definir funciones para que tengan <em>parámetros</em>, que son variables
especiales que forman parte de la firma de una función. Cuando una función
tiene parámetros, puedes proporcionarle valores concretos para esos
parámetros. Técnicamente, los valores concretos se llaman <em>argumentos</em>, pero coloquialmente,
la gente tiende a usar las palabras <em>parámetro</em> y
<em>argumento</em> indistintamente para las variables en la definición de una función
o los valores concretos que se pasan cuando llamas a una función.</p>
<p>En esta versión de <code>another_function</code> agregamos un parámetro:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<p>Intenta ejecutar este programa; deberías obtener la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>La declaración de <code>another_function</code> tiene un parámetro llamado <code>x</code>. El tipo de
<code>x</code> se especifica como <code>i32</code>. Cuando pasamos <code>5</code> a <code>another_function</code>, la
macro <code>println!</code> pone <code>5</code> donde estaba el par de llaves que contenía <code>x</code> en la
cadena de formato.</p>
<p>En las firmas de las funciones, <em>debes</em> declarar el tipo de cada parámetro. Esta
es una decisión deliberada en el diseño de Rust: requerir anotaciones de tipo en
las definiciones de las funciones significa que el compilador casi nunca necesita
que las uses en otro lugar del código para averiguar a qué tipo te refieres. El
compilador también puede dar mensajes de error más útiles si sabe qué tipos espera la función.</p>
<p>Al definir múltiples parámetros, separa las declaraciones de parámetros con
comas, como esto:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;The measurement is: {value}{unit_label}&quot;);
}</code></pre></pre>
<p>Este ejemplo crea una función llamada <code>print_labeled_measurement</code> con dos
parámetros. El primer parámetro se llama <code>value</code> y es un <code>i32</code>. El segundo parámetro se
llama <code>unit_label</code> y es de tipo <code>char</code>. Luego, la función imprime texto que
contiene tanto el <code>value</code> como el <code>unit_label</code>.</p>
<p>Intentemos ejecutar este código. Reemplaza el programa actual en tu
proyecto <em>functions</em> en el archivo <em>src/main.rs</em> con el ejemplo anterior y
ejecútalo usando <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p>Como hemos llamamos a la función con <code>5</code> como valor para <code>value</code> y <code>'h'</code> como
valor para <code>unit_label</code>, la salida del programa contiene esos valores.</p>
<h3 id="sentencias-y-expresiones"><a class="header" href="#sentencias-y-expresiones">Sentencias y Expresiones</a></h3>
<p>Los cuerpos de las funciones están compuestos por una serie de sentencias
opcionalmente terminadas en una expresión. Hasta ahora, las funciones que hemos
visto no incluyen una expresión final, pero has visto una expresión como parte
de una sentencia. Debido a que Rust es un lenguaje basado en expresiones, esta
es una distinción importante de entender. Otros lenguajes no tienen las mismas
distinciones, así que veamos qué son las sentencias y las expresiones y cómo
sus diferencias afectan a los cuerpos de las funciones.</p>
<ul>
<li><strong>Sentencias</strong> son instrucciones que realizan alguna acción y no devuelven un
valor.</li>
<li><strong>Expresiones</strong> evalúan a un valor resultante. Veamos algunos ejemplos.</li>
</ul>
<p>Hemos usado realmente sentencias y expresiones. Crear una variable y asignarle
un valor con la palabra clave <code>let</code> es una sentencia. En el Listado 3-1,
<code>let y = 6;</code> es una sentencia.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}</code></pre></pre>
<p><span class="caption">Listado 3-1: Una declaración de la función <code>main</code> que contiene una sentencia</span></p>
<p>Las definiciones de las funciones también son sentencias; todo el ejemplo
anterior es una sentencia en sí misma.</p>
<p>Las sentencias no devuelven valores. Por lo tanto, no puedes asignar una
sentencia <code>let</code> a otra variable, como intenta hacer el siguiente código;
obtendrás un error:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>Cuando ejecutes este programa, el error que obtendrás se verá así:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error; 1 warning emitted
</code></pre>
<p>La sentencia <code>let y = 6</code> no devuelve un valor, por lo que no hay nada a lo
que <code>x</code> se pueda vincular. Esto es diferente a lo que ocurre en otros lenguajes,
como C y Ruby, donde la asignación devuelve el valor de la asignación. En esos
lenguajes, puedes escribir <code>x = y = 6</code> y hacer que tanto <code>x</code> como <code>y</code> tengan el valor <code>6</code>;
eso no es el caso en Rust.</p>
<p>Las expresiones evalúan a un valor y componen la mayor parte del resto del
código que escribirás en Rust. Considera una operación matemática, como <code>5 + 6</code>,
que es una expresión que evalúa al valor <code>11</code>. Las expresiones pueden ser parte
de las sentencias: en el Listado 3-1, el <code>6</code> en la sentencia <code>let y = 6;</code> es
una expresión que evalúa al valor <code>6</code>. Llamar a una función es una expresión.
Llamar a una macro es una expresión. Un nuevo bloque de ámbito creado con
llaves es una expresión, por ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {y}&quot;);
}</code></pre></pre>
<p>Esta expresión:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>es un bloque que, en este caso, evalúa a <code>4</code>. Ese valor se enlaza a <code>y</code> como
parte de la sentencia <code>let</code>. Ten en cuenta que la línea <code>x + 1</code> no tiene un
punto y coma al final, lo que es diferente a la mayoría de las líneas que has
visto hasta ahora. Las expresiones no incluyen punto y coma al final. Si
agregas un punto y coma al final de una expresión, la conviertes en una
sentencia, y entonces no devolverá un valor. Ten esto en cuenta a medida que
exploras los valores de retorno de las funciones y las expresiones a continuación.</p>
<h3 id="funciones-con-valores-de-retorno"><a class="header" href="#funciones-con-valores-de-retorno">Funciones con valores de retorno</a></h3>
<p>Las funciones pueden devolver valores al código que las llama. No nombramos los
valores de retorno, pero debemos declarar su tipo después de una flecha (<code>-&gt;</code>).
En Rust, el valor de retorno de la función es sinónimo del valor de la última
expresión en el bloque del cuerpo de una función. Puedes devolver un valor antes de que la función finalice utilizando la palabra clave<code>return</code> y especificando un valor, pero la
mayoría de las funciones devuelven la última expresión implícitamente. Aquí
hay un ejemplo de una función que devuelve un valor:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<p>No hay llamadas a funciones, macros, ni siquiera sentencias <code>let</code> en la función
<code>five</code> - solo el número <code>5</code> por sí solo. Esa es una función perfectamente
válida en Rust. Ten en cuenta que también se especifica el tipo de retorno de
la función, como <code>-&gt; i32</code>. Intenta ejecutar este código; la salida debería
verse así:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>El <code>5</code> en <code>five</code> es el valor de retorno de la función, por eso el tipo de
retorno es <code>i32</code>. Veamos esto con más detalle. Hay dos partes importantes:
primero, la línea <code>let x = five();</code> muestra que estamos usando el valor de
retorno de una función para inicializar una variable. Debido a que la función
<code>five</code> devuelve un <code>5</code>, esa línea es la misma que la siguiente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Segundo, la función <code>five</code> no tiene parámetros y define el tipo del valor de
retorno, pero el cuerpo de la función es un solitario <code>5</code> sin punto y coma
porque es una expresión cuyo valor queremos devolver.</p>
<p>Veamos otro ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>La ejecución de este código imprimirá <code>The value of x is: 6</code>. Pero si colocamos
un punto y coma al final de la línea que contiene <code>x + 1</code>, cambiándolo de una
expresión a una sentencia, obtendremos un error:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>La compilación de este código produce un error, como sigue:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error
</code></pre>
<p>El mensaje de error principal, <code>mismatched types</code>, revela el problema principal
con este código. La definición de la función <code>plus_one</code> dice que devolverá un
<code>i32</code>, pero las sentencias no evalúan un valor, lo que se expresa por <code>()</code>, el
tipo unitario. Por lo tanto, no se devuelve nada, lo que contradice la
definición de la función y da como resultado un error. En esta salida, Rust
proporciona un mensaje para posiblemente ayudar a corregir este problema:
sugiere eliminar el punto y coma, lo que arreglaría el error.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h2>
<p>Todos los programadores se esfuerzan por hacer que su código sea fácil de
entender, pero a veces se requiere una explicación adicional. En estos casos,
los programadores dejan <em>comentarios</em> en su código fuente que el compilador
ignorará pero que las personas que lean el código fuente pueden encontrar
útiles.</p>
<p>Aquí hay un comentario simple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hola, mundo
<span class="boring">}</span></code></pre></pre>
<p>En Rust, el estilo de comentario idiomático comienza un comentario con dos
barras inclinadas y el comentario continúa hasta el final de la línea. Para
comentarios que se extienden más allá de una sola línea, deberá incluir <code>//</code> en
cada línea, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Así que estamos haciendo algo complicado aquí, lo suficientemente largo
// como para necesitar varias líneas de comentarios para hacerlo. ¡Uf!
// ¡Espero que este comentario explique lo que está sucediendo!
<span class="boring">}</span></code></pre></pre>
<p>Los comentarios también se pueden colocar al final de las líneas que contienen
código:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero_de_la_suerte = 7; // Me siento afortunado hoy
}</code></pre></pre>
<p>Pero más a menudo verás que se usan en este formato, con el comentario en una
línea separada por encima del código que está anotando:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Me siento afortunado hoy
    let numero_de_la_suerte = 7;
}</code></pre></pre>
<p>Rust también tiene otro tipo de comentario, comentarios de documentación, que
discutiremos en la sección 
<a href="ch14-02-publishing-to-crates-io.html">“Publicando una Caja en Crates.io”</a><!-- ignore --> del Capítulo 14.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flujo-de-control"><a class="header" href="#flujo-de-control">Flujo de Control</a></h2>
<p>La capacidad de ejecutar algún código dependiendo de si una condición es <code>true</code>
y ejecutar algún código repetidamente mientras una condición es <code>true</code> son
elementos básicos en la mayoría de los lenguajes de programación.
Las construcciones más comunes que le permiten controlar el flujo de ejecución
del código Rust son las expresiones <code>if</code> y los bucles.</p>
<h3 id="expresiones-if"><a class="header" href="#expresiones-if">Expresiones <code>if</code></a></h3>
<p>Una expresión <code>if</code> le permite dividir su código según las condiciones.
Proporciona una condición y luego dice: “Si se cumple esta condición, ejecute
este bloque de código. Si la condición no se cumple, no ejecute este bloque de
código.”</p>
<p>Cree un nuevo proyecto llamado <em>branches</em> en su directorio <em>projects</em> para
explorar la expresión <code>if</code>. En el archivo <em>src/main.rs</em>, ingrese lo siguiente:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}</code></pre></pre>
<p>Todas las expresiones <code>if</code> comienzan con la palabra clave <code>if</code>, seguida de una
condición. En este caso, la condición comprueba si la variable <code>number</code> tiene un
valor menor que 5. Colocamos el bloque de código para ejecutar si la condición
es <code>true</code> inmediatamente después de la condición dentro de llaves. Los bloques
de código asociados con las condiciones en las expresiones <code>if</code> a veces se
llaman <em>brazos</em>, al igual que los brazos en las expresiones <code>match</code> que
discutimos en la sección
<a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">“Comparando la Adivinanza
con el Número Secreto”</a><!--ignore -->
del Capítulo 2.</p>
<p>Opcionalmente, también podemos incluir una expresión <code>else</code>, que elegimos
hacer aquí, para dar al programa un bloque de código alternativo para ejecutar
si la condición evaluada es <code>false</code>. Si no proporciona una expresión <code>else</code>
y la condición es <code>false</code>, el programa va a ignorar el bloque <code>if</code> y continuará
con el siguiente fragmento de código.</p>
<p>Intente ejecutar este código; Debería ver la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Vamos a intentar cambiar el valor de <code>number</code> a un valor que haga que la
condición sea <code>false</code> para ver qué sucede:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;condition was true&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;condition was false&quot;);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ejecute el programa nuevamente y observe la salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>También vale la pena señalar que la condición en este código <em>debe</em> ser un
<code>bool</code>. Si la condición no es un <code>bool</code>, obtendremos un error. Por ejemplo,
intente ejecutar el siguiente código:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}</code></pre>
<p>La condición <code>if</code> se evalúa como un valor de <code>3</code> esta vez, y Rust arroja un
error:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin &quot;branches&quot;) due to 1 previous error
</code></pre>
<p>El error indica que Rust esperaba un <code>bool</code> pero obtuvo un entero. A diferencia
de los lenguajes como Ruby y JavaScript, Rust no intentará convertir
automáticamente los tipos no booleanos en un booleano. Debes ser explícito y
siempre proporcionar a <code>if</code> un booleano como su condición. Si queremos que el
bloque de código <code>if</code> se ejecute solo cuando un número no sea igual a <code>0</code>, por
ejemplo, podemos cambiar la expresión <code>if</code> a lo siguiente:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}</code></pre></pre>
<p>Ejecutando este código imprimirá <code>number was something other than zero</code>.</p>
<h4 id="manejo-de-múltiples-condiciones-con-else-if"><a class="header" href="#manejo-de-múltiples-condiciones-con-else-if">Manejo de múltiples condiciones con <code>else if</code></a></h4>
<p>Puede usar múltiples condiciones combinando <code>if</code> y <code>else</code> en una expresión
<code>else if</code>. Por ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}</code></pre></pre>
<p>Este programa tiene cuatro posibles caminos que puede tomar. Después de
ejecutarlo, debería ver la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>Cuando se ejecuta este programa, verifica cada expresión <code>if</code> en orden y
ejecuta el primer cuerpo para el cual la condición se evalúa como <code>true</code>. Tenga
en cuenta que incluso si 6 es divisible por 2, no vemos la salida <code>number is divisible by 2</code>, ni vemos el texto <code>number is not divisible by 4, 3, or 2</code> del
bloque <code>else</code>. Esto se debe a que Rust solo ejecuta el bloque para la primera
condición <code>true</code>, y una vez que encuentra una, ni siquiera verifica el resto.</p>
<p>El uso de demasiadas expresiones <code>else if</code> puede ensuciar su código, por lo que
si tiene más de una, es posible que desee refactorizar su código. El capítulo 6
describe una poderosa construcción de ramificación de Rust llamada <code>match</code> para
estos casos.</p>
<h4 id="usando-if-en-una-declaración-let"><a class="header" href="#usando-if-en-una-declaración-let">Usando <code>if</code> en una declaración <code>let</code></a></h4>
<p>Dado que <code>if</code> es una expresión, podemos usarlo en el lado derecho de una
declaración <code>let</code> para asignar el resultado a una variable, como en el Listado
3-2.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {number}&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 3-2: Asignando el resultado de una expresión
<code>if</code> a una variable</span></p>
<p>La variable <code>number</code> estará vinculada a un valor basado en el resultado de la
expresión <code>if</code>. Ejecute este código para ver qué sucede:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Recuerde que los bloques de código se evalúan en la última expresión de ellos y
los números por sí mismos también son expresiones. En este caso, el valor de
la expresión <code>if</code> en su conjunto depende de qué bloque de código se ejecuta.
Esto significa que los valores que tienen el potencial de ser resultados de cada
rama del <code>if</code> deben ser del mismo tipo; en el Listado 3-2, los resultados de
ambas ramas del <code>if</code> y la rama <code>else</code> fueron enteros <code>i32</code>. Si los tipos no
coinciden, como en el siguiente ejemplo, obtendremos un error:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;The value of number is: {number}&quot;);
}</code></pre>
<p>Cuando intentamos compilar este código, obtendremos un error. Las ramas <code>if</code> y
<code>else</code> tienen tipos de valor que son incompatibles, y Rust indica exactamente
dónde encontrar el problema en el programa:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin &quot;branches&quot;) due to 1 previous error
</code></pre>
<p>La expresión en el bloque <code>if</code> se evalúa como un entero, y la expresión en el
bloque <code>else</code> se evalúa como una cadena. Esto no funcionará porque las
variables deben tener un solo tipo, y Rust necesita saber en tiempo de
compilación qué tipo tiene la variable <code>number</code>, definitivamente. Conocer el
tipo de <code>number</code> permite al compilador verificar que el tipo sea válido en
cualquier lugar que usemos <code>number</code>. Rust no podría hacerlo si el tipo de
<code>number</code> solo se determinara en tiempo de ejecución; el compilador sería más
complejo y haría menos garantías sobre el código si tuviera que rastrear
diversos tipos hipotéticos para cualquier variable.</p>
<h3 id="repetición-con-bucles"><a class="header" href="#repetición-con-bucles">Repetición con bucles</a></h3>
<p>A menudo es útil ejecutar un bloque de código más de una vez. Para esta tarea,
Rust proporciona varios <em>bucles</em>, que ejecutarán el código dentro del cuerpo del
bucle hasta el final y luego comenzarán de inmediato desde el principio. Para
experimentar con los bucles, hagamos un nuevo proyecto llamado <em>loops</em>.</p>
<p>Rust tiene tres tipos de bucles: <code>loop</code>, <code>while</code> y <code>for</code>. Vamos a probar cada
uno.</p>
<h4 id="repetir-código-con-loop"><a class="header" href="#repetir-código-con-loop">Repetir código con <code>loop</code></a></h4>
<p>La palabra clave <code>loop</code> le dice a Rust que ejecute un bloque de código una y
otra vez para siempre o hasta que le indique explícitamente que se detenga.</p>
<p>Como ejemplo, cambie el archivo <em>src/main.rs</em> en su directorio <em>loops</em> para
que se vea así:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}</code></pre>
<p>Cuando ejecutemos este programa, veremos <code>again!</code> impreso una y otra vez
continuamente hasta que detengamos manualmente el programa. La mayoría de los
terminales admiten el atajo de teclado <span class="keystroke">ctrl-c</span>
para interrumpir un programa que está atascado en un bucle continuo.
Inténtelo:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>El símbolo <code>^C</code> representa dónde presionó <span
class="keystroke">ctrl-c</span>. Puede que vea o no la palabra <code>again!</code>
impresa después del <code>^C</code>, dependiendo de dónde estaba el código en el bucle
cuando recibió la señal de interrupción.</p>
<p>Afortunadamente, Rust también proporciona una forma de salir de un bucle
utilizando código. Puede colocar la palabra clave <code>break</code> dentro del bucle para
decirle al programa cuándo dejar de ejecutar el bucle. Recuerde que hicimos
esto en el juego de adivinanzas en la sección <a href="ch02-00-guessing-game-tutorial.html#salir-despues-de-una-adivinanza-correcta">“Salir después de una
adivinanza correcta”</a><!-- ignore --> del
capítulo 2 para salir del programa cuando el usuario ganó el juego adivinando
el número correcto.</p>
<p>También usamos <code>continue</code> en el juego de adivinanzas, que en un bucle le dice
al programa que omita cualquier código restante en esta iteración del bucle y
pase a la siguiente iteración.</p>
<h4 id="devolviendo-valores-de-los-bucles"><a class="header" href="#devolviendo-valores-de-los-bucles">Devolviendo valores de los bucles</a></h4>
<p>Una de las aplicaciones de un <code>loop</code> es volver a intentar una operación que
sabe que puede fallar, como verificar si un hilo ha completado su trabajo. Es
posible que también necesite pasar el resultado de esa operación fuera del
bucle al resto de su código. Para hacer esto, puede agregar el valor que desea
devolver después de la expresión <code>break</code> que usa para detener el bucle; ese
valor se devolverá fuera del bucle para que pueda usarlo, como se muestra aquí:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {result}&quot;);
}</code></pre></pre>
<p>Antes del bucle, declaramos una variable llamada <code>counter</code> e inicializamos en
<code>0</code>. Luego declaramos una variable llamada <code>result</code> para contener el valor
devuelto del bucle. En cada iteración del bucle, agregamos <code>1</code> a la variable
<code>counter</code>, y luego verificamos si el <code>counter</code> es igual a <code>10</code>. Cuando lo es,
usamos la palabra clave <code>break</code> con el valor <code>counter * 2</code>. Después del bucle,
usamos un punto y coma para terminar la instrucción que asigna el valor a
<code>result</code>. Finalmente, imprimimos el valor en <code>result</code>, que en este caso es
<code>20</code>.</p>
<p>Tu puedes también usar <code>return</code> dentro de un loop. Mientras <code>break</code> solo existe
para el loop actual, <code>return</code> siempre existe para la función actual.</p>
<h4 id="etiquetas-de-bucle-para-distinguir-entre-varios-bucles"><a class="header" href="#etiquetas-de-bucle-para-distinguir-entre-varios-bucles">Etiquetas de bucle para distinguir entre varios bucles</a></h4>
<p>Si tiene bucles dentro de bucles, <code>break</code> y <code>continue</code> se aplican al bucle más
interior en ese punto. Opcionalmente, puede especificar una <em>etiqueta de bucle</em>
en un bucle que luego puede usar con <code>break</code> o <code>continue</code> para especificar que
esas palabras clave se aplican al bucle etiquetado en lugar del bucle más
interior. Las etiquetas de bucle deben comenzar con una comilla simple. Aquí
hay un ejemplo con dos bucles anidados:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
}</code></pre></pre>
<p>El bucle externo tiene la etiqueta <code>'counting_up</code>, y contará de 0 a 2. El bucle
interior sin etiqueta cuenta de 10 a 9. El primer <code>break</code> que no especifique
una etiqueta solo saldrá del bucle interno. La instrucción <code>break 'counting_up;</code> saldrá del bucle externo. Este código imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="bucles-condicionales-con-while"><a class="header" href="#bucles-condicionales-con-while">Bucles condicionales con <code>while</code></a></h4>
<p>Un programa a menudo necesitará evaluar una condición dentro de un bucle.
Mientras la condición sea <code>true</code>, el bucle se ejecuta. Cuando la condición deja
de ser <code>true</code>, el programa llama a <code>break</code>, deteniendo el bucle. Es posible
implementar un comportamiento como este usando una combinación de <code>loop</code>, <code>if</code>,
<code>else</code> y <code>break</code>; puede intentarlo ahora en un programa, si lo desea. Sin
embargo, este patrón es tan común que Rust tiene una construcción de lenguaje
integrada para ello, llamada <code>while</code> loop. En el Listado 3-3, usamos <code>while</code>
para ejecutar el programa tres veces, contando hacia atrás cada vez, y luego,
después del bucle, imprimir un mensaje y salir.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{number}!&quot;);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 3-3: Usando un bucle <code>while</code> para ejecutar código
mientras una condición es verdadera</span></p>
<p>Esta expresion elimina mucho anidamiento que sería necesario si usara <code>loop</code>,
<code>if</code>, <code>else</code> y <code>break</code>, y es más claro. Mientras una condición se evalúa como
<code>true</code>, el código se ejecuta; de lo contrario, sale del bucle.</p>
<p><a id="bucle-a-traves-de-una-coleccion-con-for"></a></p>
<h4 id="bucle-a-traves-de-una-colección-con-for"><a class="header" href="#bucle-a-traves-de-una-colección-con-for">Bucle a traves de una colección con <code>for</code></a></h4>
<p>Tu puedes también puedes usar el <code>while</code> para recorrer los elementos de una 
colección, justo como un arreglo. Por ejemplo, el bucle en el Listado 3-4
muestra cada elemento en el arreglo <code>a</code>.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index += 1;
    }
}</code></pre></pre>
<p><span class="caption">Listado 3-4: Bucle a través de cada elemento de una
colección usando un bucle <code>while</code></span></p>
<p>Aquí, el código cuenta hacia arriba a través de los elementos en el arreglo. Se
inicia en el índice <code>0</code>, y luego se ejecuta hasta que alcanza el índice final
en el arreglo (es decir, cuando <code>index &lt; 5</code> ya no es <code>true</code>). Ejecutar este
código imprimirá cada elemento en el arreglo:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>Los cinco valores del arreglo aparecen en la terminal, como se esperaba.
Aunque <code>index</code> llegará a un valor de <code>5</code> en algún momento, el bucle deja de
ejecutarse antes de intentar obtener un sexto valor del arreglo.</p>
<p>Sin embargo, este enfoque es propenso a errores; podríamos causar que el
programa se descomponga si el valor del índice o la condición de prueba es
incorrecta. Por ejemplo, si cambia la definición del arreglo <code>a</code> para tener
cuatro elementos, pero olvida actualizar la condición a <code>while index &lt; 4</code>, el
código se descompondría. También es lento, porque el compilador agrega código
de tiempo de ejecución para realizar la verificación condicional de si el
índice está dentro de los límites del arreglo en cada iteración del bucle.</p>
<p>Como una alternativa más concisa, puede usar un bucle <code>for</code> y ejecutar algún
código para cada elemento en una colección. Un bucle <code>for</code> se ve como el código
en el Listado 3-5.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;the value is: {element}&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listado 3-5: Bucle a través de cada elemento de una
colección usando un bucle <code>for</code></span></p>
<p>Cuando ejecutamos este código, veremos la misma salida que en el Listado 3-4.
Lo más importante es que ahora hemos aumentado la seguridad del código y
eliminado la posibilidad de errores que podrían deberse a ir más allá del final
del arreglo o no ir lo suficientemente lejos y perder algunos elementos.</p>
<p>Usando el bucle <code>for</code>, no necesitaría recordar cambiar cualquier otro código si
cambiara el número de valores en el arreglo, como lo haría con el método usado en
el Listado 3-4.</p>
<p>La seguridad y concisión de los bucles <code>for</code> los convierten en la
estructura de bucle más utilizada en Rust. Incluso en situaciones en las que
quiera ejecutar algún código un cierto número de veces, como en el ejemplo de
cuenta regresiva que usó un bucle <code>while</code> en el Listado 3-3, la mayoría de los
Rustaceans usarían un bucle <code>for</code>. La forma de hacerlo sería usar un <code>Range</code>,
proporcionado por la biblioteca estándar, que genera todos los números en
secuencia a partir de un número y termina antes de otro número.</p>
<p>Así es como se vería la cuenta regresiva usando un bucle <code>for</code> y otro método que
aún no hemos hablado, <code>rev</code>, para invertir el rango:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{number}!&quot;);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p>Este código es un poco más agradable, ¿verdad?</p>
<h2 id="resumen-2"><a class="header" href="#resumen-2">Resumen</a></h2>
<p>¡Lo lograste! Este fue un capítulo de gran tamaño: aprendiste sobre variables,
tipos de datos escalares y compuestos, funciones, comentarios, expresiones <code>if</code>
y bucles. Para practicar con los conceptos discutidos en este capítulo, intente
construir programas para hacer lo siguiente:</p>
<ul>
<li>Convertir temperaturas entre Fahrenheit y Celsius.</li>
<li>Generar el número de Fibonacci <em>n</em>.</li>
<li>Imprimir las letras de la canción navideña &quot;Los doce días de Navidad&quot;,
aprovechando la repetición en la canción.</li>
</ul>
<p>Cuando esté listo para continuar, hablaremos sobre un concepto en Rust que
<em>no</em> existe comúnmente en otros lenguajes de programación: la propiedad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entendiendo-el-ownership"><a class="header" href="#entendiendo-el-ownership">Entendiendo el Ownership</a></h1>
<p>El Ownership es la característica más única de Rust y tiene implicaciones
profundas para el resto del lenguaje. Permite a Rust hacer garantías de
seguridad de memoria sin necesidad de un recolector de basura, por lo que es
importante entender cómo funciona el Ownership. En este capítulo, hablaremos
sobre el Ownership así como varias características relacionadas: préstamo 
(borrowing), slices, y cómo Rust organiza los datos en la memoria.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="qué-es-el-ownership"><a class="header" href="#qué-es-el-ownership">¿Qué es el Ownership?</a></h2>
<p>El <em>ownership</em> es un conjunto de reglas que definen cómo un programa de Rust
administra la memoria. Todos los programas tienen que administrar la forma en
que usan la memoria de un computador mientras se ejecutan. Algunos lenguajes
tienen recolección de basura que busca regularmente la memoria que ya no se
usa mientras el programa se ejecuta; en otros lenguajes, el programador debe
asignar y liberar la memoria explícitamente. Rust usa un tercer enfoque: la
memoria se administra a través de un sistema de ownership con un conjunto de
reglas que el compilador verifica. Si alguna de las reglas se viola, el
programa no se compilará. Ninguna de las características del ownership
ralentizará su programa mientras se ejecuta.</p>
<p>Porque el ownership es un concepto nuevo para muchos programadores, toma un
tiempo acostumbrarse. La buena noticia es que a medida que se vuelva más
experimentado con Rust y las reglas del sistema de ownership, más fácil le
resultará desarrollar naturalmente código que sea seguro y eficiente. ¡Sigue
intentándolo!</p>
<p>Cuando entienda el ownership, tendrá una base sólida para comprender las
características que hacen que Rust sea único. En este capítulo, aprenderá
ownership trabajando en algunos ejemplos que se centran en una estructura de
datos muy común: las cadenas de caracteres.</p>
<blockquote>
<p>Nota:
La traducción de Ownership seria &quot;Propiedad&quot;, la mayor parte de la comunidad
habla de este sistema como Ownsership pero también es valido este termino.
El motivo es que el sistema de ownership es solo una analogía.</p>
<p>La analogía es que el ownership es como la propiedad de un objeto, por ejemplo
si tienes un libro, el libro es tuyo. Si lo prestas a alguien, el libro sigue
siendo tuyo, pero ahora el libro esta en posesión de otra persona. Cuando
te devuelven el libro, el libro regresa a tu posesión.</p>
</blockquote>
<blockquote>
<h3 id="el-stack-y-el-heap"><a class="header" href="#el-stack-y-el-heap">El Stack y el Heap</a></h3>
<p>Muchos lenguajes de programación no requieren que piense mucho en el stack y
el heap. Pero en un lenguaje de programación de sistemas como Rust, si un
valor está en el stack o en el heap afecta cómo el lenguaje se comporta y por
qué debe tomar ciertas decisiones. Partes del ownership se describirán en
relación con el stack y el heap más adelante en este capítulo, por lo que
aquí hay una breve explicación en preparación.</p>
<p>Tanto el stack como el heap son partes de la memoria disponible para su código
para usar en tiempo de ejecución, pero están estructurados de formas
diferentes. El stack almacena valores en el orden en que los recibe y elimina
los valores en el orden opuesto. Esto se conoce como LIFO que es el acrónimo inglés de <em>Last In, First Out</em> o en español <em>El último en entrar, es el primero en salir</em>. Piense en una pila de platos: cuando agrega más platos, los coloca en
la parte superior de la pila, y cuando necesita un plato, toma uno de la
parte superior. Agregar o eliminar platos del medio o de la parte inferior no
funcionaría tan bien! Agregar datos se llama <em>empujar en el stack</em>, y
eliminar datos se llama <em>sacar del stack</em>. Todos los datos almacenados en el
stack deben tener un tamaño conocido y fijo. Los datos con un tamaño
desconocido en tiempo de compilación o un tamaño que puede cambiar deben
almacenarse en el heap en su lugar.</p>
<p>El heap es menos organizado: cuando coloca datos en el heap, solicita una
cierta cantidad de espacio. El administrador de memoria encuentra un lugar
vacío en el heap que sea lo suficientemente grande, lo marca como en uso y
devuelve un <em>puntero</em>, que es la dirección de esa ubicación. Este proceso se
llama <em>asignar en el heap</em> y a veces se abrevia como solo <em>asignar</em> (empujar
valores en el stack no se considera asignar). Debido a que el puntero al heap
es un tamaño conocido y fijo, puede almacenar el puntero en el stack, pero
cuando desea los datos reales, debe seguir el puntero. Piense en estar sentado
en un restaurante. Cuando ingresa, indica la cantidad de personas en su
grupo, y el anfitrión encuentra una mesa vacía que quepa a todos y los lleva
allí. Si alguien en su grupo llega tarde, puede preguntar dónde se ha
sentado para encontrarlo.</p>
<p>Empujar en el stack es más rápido que asignar en el heap porque el
administrador de memoria nunca tiene que buscar un lugar para almacenar nuevos
datos; esa ubicación siempre está en la parte superior de la pila. En
comparación, asignar espacio en el heap requiere más trabajo porque el
administrador de memoria debe encontrar primero un espacio lo suficientemente
grande para contener los datos y luego realizar tareas administrativas para
prepararse para la siguiente asignación.</p>
<p>Acceder a los datos en el heap es más lento que acceder a los datos en el
stack porque debe seguir un puntero para llegar allí. Los procesadores
contemporáneos son más rápidos si saltan menos en la memoria. Continuando con
la analogía, considere un servidor en un restaurante que toma pedidos de
muchas mesas. Es más eficiente obtener todos los pedidos de una mesa antes de
pasar a la siguiente mesa. Tomar un pedido de la mesa A, luego un pedido de la
mesa B, luego uno de la A nuevamente y luego uno de la B nuevamente sería un
proceso mucho más lento. Del mismo modo, un procesador puede hacer su trabajo
mejor si trabaja con datos que están cerca de otros datos (como lo están en
el stack) en lugar de más lejos (como pueden estar en el heap).</p>
<p>Cuando su código llama a una función, los valores que se pasan a la función
(incluidos, posiblemente, punteros a datos en el heap) y las variables locales
de la función se empujan en el stack. Cuando la función termina, esos valores
se sacan del stack.</p>
<p>Mantener un registro de qué partes del código están utilizando qué datos en
el heap, minimizar la cantidad de datos duplicados en el heap y limpiar los
datos no utilizados en el heap para que no se quede sin espacio son todos
problemas que ownership aborda. Una vez que comprenda ownership, no tendrá
que pensar mucho en el stack y el heap, pero saber que el principal propósito
de ownership es administrar datos en el heap puede ayudar a explicar por qué
funciona de la manera en que lo hace.</p>
</blockquote>
<h3 id="reglas-de-ownership"><a class="header" href="#reglas-de-ownership">Reglas de Ownership</a></h3>
<p>Primero, echemos un vistazo a las reglas de ownership. Mantenga estas reglas en
mente mientras trabajamos a través de los ejemplos que las ilustran:</p>
<ul>
<li>Cada valor en Rust tiene un <em>propietario</em>.</li>
<li>Solo puede haber un propietario a la vez.</li>
<li>Cuando el propietario sale del alcance, el valor se descartará.</li>
</ul>
<h3 id="Ámbito-de-las-variables"><a class="header" href="#Ámbito-de-las-variables">Ámbito de las Variables</a></h3>
<p>Ahora que hemos pasado la sintaxis básica de Rust, no incluiremos todo el código
<code>fn main() {</code> en los ejemplos, por lo que si está siguiendo, asegúrese de
colocar los siguientes ejemplos dentro de una función <code>main</code> manualmente. Como
resultado, nuestros ejemplos serán un poco más concisos, permitiéndonos
centrarnos en los detalles reales en lugar del código repetitivo.</p>
<p>Como primer ejemplo de ownership, veremos el <em>contexto de ejecución</em> de algunas variables.
Un contexto de ejecución es el rango o espacio dentro de un programa para el que un elemento es válido.
Toma la siguiente variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hola&quot;;
<span class="boring">}</span></code></pre></pre>
<p>La variable <code>s</code> se refiere a un literal de cadena, donde el valor de la cadena
está codificado en el texto de nuestro programa. La variable es válida desde el
punto en que se declara hasta el final del <em>contexto de ejecución</em> actual. El listado 4-1
muestra un programa con comentarios que anotan dónde sería válida la variable
<code>s</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s no es valido aquí, aún no está declarado
        let s = &quot;hola&quot;;   // s es valido desde aquí

        // Hacer algo con s
    }                      // este ámbito termina aquí, s ya no es valido
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 4-1: Una variable y el contexto de ejecución en el que es válida</span></p>
<p>En otras palabras, hay dos puntos importantes en el tiempo aquí:</p>
<ul>
<li>Cuando <code>s</code> está el <em>contexto de ejecución</em>, es válido.</li>
<li>Permanece válido hasta que sale de <em>contexto de ejecución</em>.</li>
</ul>
<p>En este punto, la relación entre los contextos de ejecución y cuándo las variables son válidas
es similar a la de otros lenguajes de programación. Ahora construiremos sobre
este entendimiento al introducir el tipo <code>String</code>.</p>
<h3 id="el-tipo-string"><a class="header" href="#el-tipo-string">El Tipo <code>String</code></a></h3>
<p>Para ilustrar las reglas de ownership, necesitamos un tipo de datos más complejo
que los que cubrimos en la sección <a href="ch03-02-data-types.html#tipos-de-datos">“Tipos de Datos”</a><!-- ignore -->
del Capítulo 3. Los tipos cubiertos anteriormente son de un tamaño conocido,
pueden almacenarse en el stack y se pueden sacar del stack cuando su contexto de ejecución termina, y se pueden copiar rápidamente y trivialmente para crear una nueva
instancia independiente si otra parte del código necesita usar el mismo valor
en un contexto de ejecución diferente. Pero queremos ver los datos que se almacenan en el heap
y explorar cómo Rust sabe cuándo limpiar esos datos, y el tipo <code>String</code> es un
gran ejemplo.</p>
<p>Nos centraremos en las partes de <code>String</code> que se relacionan con el ownership.
Estos aspectos también se aplican a otros tipos de datos complejos, ya sean
suministrados por la biblioteca estándar o creados por usted. Discutiremos
<code>String</code> con más profundidad en el <a href="ch08-02-strings.html">Capítulo 8</a><!-- ignore -->.</p>
<p>Ya hemos visto literales de cadena, donde un valor de cadena está codificado en
nuestro programa. Los literales de cadena son convenientes, pero no son
adecuados para todas las situaciones en las que podríamos querer usar texto.
Una razón es que son inmutables. Otra es que no todos los valores de cadena se
pueden conocer cuando escribimos nuestro código: ¿y si queremos tomar la
entrada del usuario y almacenarla? Para estas situaciones, Rust tiene un segundo
tipo de cadena, <code>String</code>. Este tipo administra datos asignados en el heap y,
como tal, es capaz de almacenar una cantidad de texto que no conocemos en el
tiempo de compilación. Puede crear un <code>String</code> a partir de un literal de cadena
usando la función <code>from</code>, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p>El operador doble dos puntos <code>::</code> nos permite usar el namespace (nombre
de espacio) de esta función <code>from</code> particular bajo el tipo <code>String</code> en lugar
de usar algún tipo de nombre como <code>string_from</code>. Discutiremos esta sintaxis
más en la sección <a href="ch05-03-method-syntax.html#sintaxis-de-metodos">“Sintaxis de Método”</a><!-- ignore --> del
Capítulo 5, y cuando hablamos sobre el uso de namespaces con módulos en
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Rutas para Referir a un Elemento en el Árbol de Módulos”</a><!-- ignore --></p>
<p>Este tipo de cadena <em>puede</em> ser mutable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hola&quot;);

    s.push_str(&quot;, mundo!&quot;); // push_str() agrega un literal a un String

    println!(&quot;{s}&quot;); // Esto imprime &quot;hola, mundo!&quot;
<span class="boring">}</span></code></pre></pre>
<p>Entonces, ¿cuál es la diferencia aquí? ¿Por qué <code>String</code> puede ser mutable pero
los literales no pueden? La diferencia está en cómo estos dos tipos manejan la
memoria.</p>
<h3 id="memoria-y-asignación"><a class="header" href="#memoria-y-asignación">Memoria y Asignación</a></h3>
<p>En el caso de un literal de cadena, conocemos los contenidos en tiempo de
compilación, por lo que el texto está codificado directamente en el ejecutable
final. Es por eso que los literales de cadena son rápidos y eficientes. Pero
estas propiedades solo vienen de la inmutabilidad del literal de cadena.
Desafortunadamente, no podemos poner un blob de memoria en el binario para
cada pieza de texto cuyo tamaño es desconocido en tiempo de compilación y cuyo
tamaño puede cambiar mientras se ejecuta el programa.</p>
<p>Con el tipo <code>String</code>, para poder soportar una pieza mutable y extensible de
texto, necesitamos asignar una cantidad de memoria en el heap, desconocida en
tiempo de compilación, para contener el contenido. Esto significa:</p>
<ul>
<li>La memoria debe solicitarse al administrador de memoria en tiempo de ejecución.</li>
<li>Necesitamos una forma de devolver esta memoria al administrador cuando
terminemos con nuestro <code>String</code>.</li>
</ul>
<p>Esa primera parte la hacemos nosotros: cuando llamamos a <code>String::from</code>, su
implementación solicita la memoria que necesita. Esto es prácticamente
universal en los lenguajes de programación.</p>
<p>Sin embargo, la segunda parte es diferente. En los lenguajes con un <em>recolector
de basura (Garbage Collector)</em>, el recolector de basura rastrea y limpia la
memoria que ya no se está usando y no necesitamos pensar en ello. En la mayoría
de los lenguajes sin un recolector de basura, es nuestra responsabilidad identificar cuándo la
memoria ya no se está usando y llamar al código para liberarla explícitamente,
tal como lo hicimos para solicitarla. Hacer esto correctamente ha sido
históricamente un problema difícil de programación. Si lo olvidamos,
desperdiciaremos memoria. Si lo hacemos demasiado pronto, tendremos una variable
inválida. Si lo hacemos dos veces, eso también es un error. Necesitamos
emparejar exactamente una <code>asignación</code> con exactamente una <code>liberación</code>.</p>
<p>Rust toma un camino diferente: la memoria se devuelve automáticamente una vez
que la variable que la posee sale del contexto de ejecución. Aquí hay una versión de nuestro
ejemplo de alcance de la Lista 4-1 usando un <code>String</code> en lugar de un literal
de cadena:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hola&quot;); // s es valido desde aquí

        // Hacer algo con s
    }                                  // este ámbito termina aquí, 
                                       // s ya no es valido
<span class="boring">}</span></code></pre></pre>
<p>Hay un punto natural en el que podemos devolver la memoria que necesita nuestro
<code>String</code> al administrador: cuando <code>s</code> sale del alcance. Cuando una variable
sale del contexto de ejecución, Rust llama a una función especial para nosotros. Esta
función se llama <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, y es donde el autor de <code>String</code>
puede poner el código para devolver la memoria. Rust llama a <code>drop</code>
automáticamente en la llave de cierre.</p>
<blockquote>
<p>Nota: En C++, este patrón de desasignación de recursos al final de la vida
útil de un elemento a veces se denomina <em>Resource Acquisition Is
Initialization (RAII)</em>. La función <code>drop</code> en Rust será familiar para usted si
ha utilizado patrones RAII.</p>
</blockquote>
<p>Este patrón tiene un profundo impacto en la forma en que se escribe el código
Rust. Puede parecer simple ahora, pero el comportamiento del código puede ser
inesperado en situaciones más complejas cuando queremos que varias variables
usen los datos que hemos asignado en el heap. Exploremos algunas de esas
situaciones ahora.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="variables-y-datos-interactuando-con-move"><a class="header" href="#variables-y-datos-interactuando-con-move">Variables y datos interactuando con Move</a></h4>
<p>Varias variables pueden interactuar con los mismos datos de diferentes formas
en Rust. Veamos un ejemplo usando un entero en la Lista 4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Lista 4-2: Asignando el valor entero de la variable <code>x</code>
a <code>y</code></span></p>
<p>Podemos adivinar lo que está haciendo: &quot;vincular el valor <code>5</code> a <code>x</code>; luego
hacer una copia del valor en <code>x</code> y vincularlo a <code>y</code>&quot;. Ahora tenemos dos
variables, <code>x</code> y <code>y</code>, y ambos son <code>5</code>. Esto es lo que está sucediendo, porque
los enteros son valores simples con un tamaño conocido y fijo, y estos dos
valores <code>5</code> se empujan en la pila.</p>
<p>Ahora veamos la versión <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hola&quot;);
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>Esto se ve muy similar, por lo que podríamos suponer que la forma en que
funciona sería la misma: es decir, la segunda línea haría una copia del valor en
<code>s1</code> y lo vincularía a <code>s2</code>. Pero esto no es exactamente lo que sucede.</p>
<p>Mire la Figura 4-1 para ver lo que está sucediendo en realidad con el <code>String</code>.
Un <code>String</code> está compuesto por tres partes, mostradas a la izquierda:
un puntero a la memoria que contiene el contenido de la cadena, una longitud y
una capacidad. Este grupo de datos se almacena en la pila. A la derecha está la
memoria en el heap que contiene el contenido.</p>
<div style="width:50%; max-width: 100%;">
<svg class="center" role="img" aria-labelledby="desc" 
 viewBox="0.00 400.00 1000.00 500.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 238)">
<title>Dos tablas: la primera tabla contiene la representación de s1 en la pila, que consta de su longitud (5), capacidad (5) y un puntero al primer valor en la segunda tabla. La segunda tabla contiene la representación de los datos en el heap, byte por byte.</title>
<desc >Dos tablas: la primera tabla contiene la representación de s1 en la pila, que consta de su longitud (5), capacidad (5) y un puntero al primer valor en la segunda tabla. La segunda tabla contiene la representación de los datos en el heap, byte por byte.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-152 233,-152 233,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-124 96,-124 "/>
<text text-anchor="start" x="45.7759" y="-129.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="0,-104 0,-124 60,-124 60,-104 8,-104"/>
<text text-anchor="start" x="2.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="currentColor">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-104 60,-124 96,-124 96,-104 60,-104"/>
<text text-anchor="start" x="62.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-84 0,-104 60,-104 60,-84 8,-84"/>
<text text-anchor="start" x="2.2241" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">ptr</text>
<polygon fill="none" stroke="var(--fg)" points="60,-84 60,-104 96,-104 96,-84 60,-84"/>
<polygon fill="none" stroke="var(--fg)" points="0,-64 0,-84 60,-84 60,-64 8,-64"/>
<text text-anchor="start" x="2.4482" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-64 60,-84 96,-84 96,-64 60,-64"/>
<text text-anchor="start" x="74.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-44 0,-64 60,-64 60,-44 8,-44"/>
<text text-anchor="start" x="2.6826" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-44 60,-64 96,-64 96,-44 60,-44"/>
<text text-anchor="start" x="74.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table1 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="140.5,-104 140.5,-124 185.5,-124 185.5,-104 148.5,-104"/>
<text text-anchor="start" x="143.4482" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-104 185.5,-124 221.5,-124 221.5,-104 185.5,-104"/>
<text text-anchor="start" x="188.3413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-84 140.5,-104 185.5,-104 185.5,-84 148.5,-84"/>
<text text-anchor="start" x="155.5" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-84 185.5,-104 221.5,-104 221.5,-84 185.5,-84"/>
<text text-anchor="start" x="200" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-64 140.5,-84 185.5,-84 185.5,-64 148.5,-64"/>
<text text-anchor="start" x="155.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-64 185.5,-84 221.5,-84 221.5,-64 185.5,-64"/>
<text text-anchor="start" x="200.3931" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-44 140.5,-64 185.5,-64 185.5,-44 148.5,-44"/>
<text text-anchor="start" x="155.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-44 185.5,-64 221.5,-64 221.5,-44 185.5,-44"/>
<text text-anchor="start" x="201.5552" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-24 140.5,-44 185.5,-44 185.5,-24 148.5,-24"/>
<text text-anchor="start" x="155.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-24 185.5,-44 221.5,-44 221.5,-24 185.5,-24"/>
<text text-anchor="start" x="201.5552" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-94C78,-94 109.3406,-94 130.3797,-94"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.5,-97.5001 140.5,-94 130.5,-90.5001 130.5,-97.5001"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-1: Representación en memoria de un <code>String</code>
que contiene el valor <code>&quot;hola&quot;</code> vinculado a <code>s1</code></span></p>
<p>La longitud es cuánta memoria, en bytes, los contenidos del <code>String</code> están
utilizando actualmente. La capacidad es la cantidad total de memoria, en bytes,
que el <code>String</code> ha recibido del administrador. La diferencia entre longitud y
capacidad importa, pero no en este contexto, por lo que por ahora está bien
ignorar la capacidad.</p>
<p>Cuando asignamos <code>s1</code> a <code>s2</code>, los datos de <code>String</code> se copian, lo que significa
que copiamos el puntero, la longitud y la capacidad que están en la pila. No
copiamos los datos en el heap al que hace referencia el puntero. En otras
palabras, la representación de datos en memoria se ve como la Figura 4-2.</p>
<div style="width:50%; max-width: 100%;">
<svg class="center" role="img" aria-labelledby="desc" 
 viewBox="0.00 0.00 1000.00 1000.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 238)">
<title>Tres tablas: tablas s1 y s2 que representan esas cadenas en la
pila, respectivamente, y ambas apuntando a los mismos datos de cadena en el
heap.</title>
<desc >Tres tablas: tablas s1 y s2 que representan esas cadenas en la
pila, respectivamente, y ambas apuntando a los mismos datos de cadena en el
heap.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-238 233,-238 233,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<title>table0</title>
<polyline fill="none" stroke="var(--fg)" points="0,-210 96,-210 "/>
<text text-anchor="start" x="45.7759" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="0,-190 0,-210 60,-210 60,-190 8,-190"/>
<text text-anchor="start" x="8.8413" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-190 60,-210 96,-210 96,-190 60,-190"/>
<text text-anchor="start" x="62.8413" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-170 0,-190 60,-190 60,-170 8,-170"/>
<text text-anchor="start" x="2.2241" y="-175.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-170 60,-190 96,-190 96,-170 60,-170"/>
<polygon fill="none" stroke="var(--fg)" points="0,-150 0,-170 60,-170 60,-150 8,-150"/>
<text text-anchor="start" x="2.4482" y="-155.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-150 60,-170 96,-170 96,-150 60,-150"/>
<text text-anchor="start" x="74.5" y="-155.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-130 0,-150 60,-150 60,-130 8,-130"/>
<text text-anchor="start" x="2.6826" y="-135.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-130 60,-150 96,-150 96,-130 60,-130"/>
<text text-anchor="start" x="74.5" y="-135.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table1 -->
<g  class="node">
<title>table1</title>
<polygon fill="none" stroke="currentColor" points="140.5,-127 140.5,-147 185.5,-147 185.5,-127 148.5,-127"/>
<text text-anchor="start" x="145.4482" y="-132.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-127 185.5,-147 221.5,-147 221.5,-127 185.5,-127"/>
<text text-anchor="start" x="188.3413" y="-132.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-107 140.5,-127 185.5,-127 185.5,-107 148.5,-107"/>
<text text-anchor="start" x="158.5" y="-112.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-107 185.5,-127 221.5,-127 221.5,-107 185.5,-107"/>
<text text-anchor="start" x="200" y="-112.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-87 140.5,-107 185.5,-107 185.5,-87 148.5,-87"/>
<text text-anchor="start" x="158.5" y="-92.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-87 185.5,-107 221.5,-107 221.5,-87 185.5,-87"/>
<text text-anchor="start" x="200.3931" y="-92.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-67 140.5,-87 185.5,-87 185.5,-67 148.5,-67"/>
<text text-anchor="start" x="158.5" y="-72.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-67 185.5,-87 221.5,-87 221.5,-67 185.5,-67"/>
<text text-anchor="start" x="201.5552" y="-72.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-47 140.5,-67 185.5,-67 185.5,-47 148.5,-47"/>
<text text-anchor="start" x="158.5" y="-52.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-47 185.5,-67 221.5,-67 221.5,-47 185.5,-47"/>
<text text-anchor="start" x="201.5552" y="-52.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<title>table0:c&#45;&gt;table1:pointee</title>
<path fill="none" stroke="var(--fg)" d="M78,-180C78,-180 101.9982,-126.912 130.4405,-118.2023"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.986,-121.6621 140.5,-117 130.1553,-114.7115 130.986,-121.6621"/>
</g>
<!-- table3 -->
<g  class="node">
<title>table3</title>
<polyline fill="none" stroke="var(--fg)" points="0,-84 96,-84 "/>
<text text-anchor="start" x="45.7759" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s2</text>
<polygon fill="none" stroke="var(--fg)" points="0,-64 0,-84 60,-84 60,-64 8,-64"/>
<text text-anchor="start" x="8.8413" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-64 60,-84 96,-84 96,-64 60,-64"/>
<text text-anchor="start" x="62.8413" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-44 0,-64 60,-64 60,-44 8,-44"/>
<text text-anchor="start" x="2.2241" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-44 60,-64 96,-64 96,-44 60,-44"/>
<polygon fill="none" stroke="var(--fg)" points="0,-24 0,-44 60,-44 60,-24 8,-24"/>
<text text-anchor="start" x="2.4482" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-24 60,-44 96,-44 96,-24 60,-24"/>
<text text-anchor="start" x="74.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-4 0,-24 60,-24 60,-4 8,-4"/>
<text text-anchor="start" x="2.6826" y="-9.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-4 60,-24 96,-24 96,-4 60,-4"/>
<text text-anchor="start" x="74.5" y="-9.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table3&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-54C78,-54 101.9982,-107.088 130.4405,-115.7977"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.1553,-119.2885 140.5,-117 130.986,-112.3379 130.1553,-119.2885"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-2: Representación en memoria de la variable
<code>s2</code> que tiene una copia del puntero, la longitud y la capacidad de <code>s1</code>.</span></p>
<p>La representación <em>no</em> se ve como la Figura 4-3, que es lo que la memoria
parecería si Rust copiara además los datos del heap. Si Rust hiciera esto, la
operación <code>s2 = s1</code> podría ser muy costosa en términos de rendimiento de tiempo
de ejecución si los datos en el heap fueran grandes.</p>
<div style="width:50%; max-width: 100%;">
<svg
 viewBox="0.00 0.00 1000.00 1200.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 298)">
<title>Cuatro tablas: dos tablas que representan los datos de la pila para s1 y s2, y cada una apunta a su propia copia de datos de cadena en el heap.</title>
<desc >Cuatro tablas: dos tablas que representan los datos de la pila para s1 y s2, y cada una apunta a su propia copia de datos de cadena en el heap.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-298 233,-298 233,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-124 96,-124 "/>
<text text-anchor="start" x="45.7759" y="-129.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s2</text>
<polygon fill="none" stroke="var(--fg)" points="0,-104 0,-124 60,-124 60,-104 8,-104"/>
<text text-anchor="start" x="8.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-104 60,-124 96,-124 96,-104 60,-104"/>
<text text-anchor="start" x="62.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-84 0,-104 60,-104 60,-84 8,-84"/>
<text text-anchor="start" x="2.2241" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-84 60,-104 96,-104 96,-84 60,-84"/>
<polygon fill="none" stroke="var(--fg)" points="0,-64 0,-84 60,-84 60,-64 8,-64"/>
<text text-anchor="start" x="2.4482" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-64 60,-84 96,-84 96,-64 60,-64"/>
<text text-anchor="start" x="74.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-44 0,-64 60,-64 60,-44 8,-44"/>
<text text-anchor="start" x="2.6826" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-44 60,-64 96,-64 96,-44 60,-44"/>
<text text-anchor="start" x="74.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table1 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="140.5,-104 140.5,-124 185.5,-124 185.5,-104 148.5,-104"/>
<text text-anchor="start" x="145.4482" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-104 185.5,-124 221.5,-124 221.5,-104 185.5,-104"/>
<text text-anchor="start" x="188.3413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-84 140.5,-104 185.5,-104 185.5,-84 148.5,-84"/>
<text text-anchor="start" x="158.5" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-84 185.5,-104 221.5,-104 221.5,-84 185.5,-84"/>
<text text-anchor="start" x="200" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-64 140.5,-84 185.5,-84 185.5,-64 148.5,-64"/>
<text text-anchor="start" x="158.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-64 185.5,-84 221.5,-84 221.5,-64 185.5,-64"/>
<text text-anchor="start" x="200.3931" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-44 140.5,-64 185.5,-64 185.5,-44 148.5,-44"/>
<text text-anchor="start" x="158.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-44 185.5,-64 221.5,-64 221.5,-44 185.5,-44"/>
<text text-anchor="start" x="201.5552" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-24 140.5,-44 185.5,-44 185.5,-24 148.5,-24"/>
<text text-anchor="start" x="158.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-24 185.5,-44 221.5,-44 221.5,-24 185.5,-24"/>
<text text-anchor="start" x="201.5552" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-94C78,-94 109.3406,-94 130.3797,-94"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.5,-97.5001 140.5,-94 130.5,-90.5001 130.5,-97.5001"/>
</g>
<!-- table3 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-270 96,-270 "/>
<text text-anchor="start" x="45.7759" y="-275.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="0,-250 0,-270 60,-270 60,-250 8,-250"/>
<text text-anchor="start" x="8.8413" y="-255.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-250 60,-270 96,-270 96,-250 60,-250"/>
<text text-anchor="start" x="62.8413" y="-255.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-230 0,-250 60,-250 60,-230 8,-230"/>
<text text-anchor="start" x="2.2241" y="-235.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-230 60,-250 96,-250 96,-230 60,-230"/>
<polygon fill="none" stroke="var(--fg)" points="0,-210 0,-230 60,-230 60,-210 8,-210"/>
<text text-anchor="start" x="2.4482" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-210 60,-230 96,-230 96,-210 60,-210"/>
<text text-anchor="start" x="74.5" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-190 0,-210 60,-210 60,-190 8,-190"/>
<text text-anchor="start" x="2.6826" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-190 60,-210 96,-210 96,-190 60,-190"/>
<text text-anchor="start" x="74.5" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table4 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="140.5,-250 140.5,-270 185.5,-270 185.5,-250 148.5,-250"/>
<text text-anchor="start" x="145.4482" y="-255.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-250 185.5,-270 221.5,-270 221.5,-250 185.5,-250"/>
<text text-anchor="start" x="188.3413" y="-255.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-230 140.5,-250 185.5,-250 185.5,-230 148.5,-230"/>
<text text-anchor="start" x="158.5" y="-235.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-230 185.5,-250 221.5,-250 221.5,-230 185.5,-230"/>
<text text-anchor="start" x="200" y="-235.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-210 140.5,-230 185.5,-230 185.5,-210 148.5,-210"/>
<text text-anchor="start" x="158.5" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-210 185.5,-230 221.5,-230 221.5,-210 185.5,-210"/>
<text text-anchor="start" x="200.3931" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-190 140.5,-210 185.5,-210 185.5,-190 148.5,-190"/>
<text text-anchor="start" x="158.5" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-190 185.5,-210 221.5,-210 221.5,-190 185.5,-190"/>
<text text-anchor="start" x="201.5552" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-170 140.5,-190 185.5,-190 185.5,-170 148.5,-170"/>
<text text-anchor="start" x="158.5" y="-175.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-170 185.5,-190 221.5,-190 221.5,-170 185.5,-170"/>
<text text-anchor="start" x="201.5552" y="-175.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table3&#45;&gt;table4 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-240C78,-240 109.3406,-240 130.3797,-240"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.5,-243.5001 140.5,-240 130.5,-236.5001 130.5,-243.5001"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-3: Otra posibilidad de lo que <code>s2 = s1</code> podría
hacer si Rust copiara también los datos del heap</span></p>
<p>Anteriormente, dijimos que cuando una variable sale de contexto de ejecución, Rust llama
automáticamente a la función <code>drop</code> y limpia la memoria del heap para esa
variable. Pero la Figura 4-2 muestra que ambos punteros de datos apuntan al
mismo lugar. Esto es un problema: cuando <code>s2</code> y <code>s1</code> salen de contexto de ejecución, ambos
intentarán liberar la misma memoria. Esto se conoce como un error de <em>doble
liberación</em> y es uno de los errores de seguridad de la memoria que mencionamos
anteriormente. Liberar la memoria dos veces puede conducir a la corrupción de
memoria, lo que puede conducir a vulnerabilidades de seguridad.</p>
<p>Para garantizar la seguridad de la memoria, después de la línea <code>let s2 = s1;</code>,
Rust considera a <code>s1</code> como no válida. Por lo tanto, Rust no necesita liberar
nada cuando <code>s1</code> sale de ámbito. Echa un vistazo a lo que sucede cuando intentas
usar <code>s1</code> después de que se crea <code>s2</code>; no funcionará:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hola&quot;);
    let s2 = s1;

    println!(&quot;{s1}, mundo!&quot;);
<span class="boring">}</span></code></pre>
<p>Obtendrás un error como este porque Rust te impide usar la referencia
invalidada:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from(&quot;hola&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!(&quot;{s1}, mundo!&quot;);
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>Si has escuchado los términos <em>copia superficial</em> y <em>copia profunda</em> mientras
trabajabas con otros lenguajes, el concepto de copiar el puntero, la longitud y
la capacidad sin copiar los datos probablemente suene a hacer una copia
superficial. Pero debido a que Rust también invalida la primera variable, en
vez de llamarse una copia superficial, se conoce como un <em>movimiento</em>. En este
ejemplo, diríamos que <code>s1</code> fue <em>movido</em> a <code>s2</code>. Entonces, lo que realmente
sucede se muestra en la Figura 4-4.</p>
<div style="width:50%; max-width: 100%;">
<svg
 viewBox="0.00 0.00 1000.00 1000.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 238)">
<title>Tres tablas: las tablas s1 y s2 que representan esas cadenas en la pila, respectivamente, y ambas apuntando a la misma cadena de datos en el heap. La tabla s1 está desactivada porque s1 ya no es válida; solo s2 se puede usar para acceder a los datos del heap.</title>
<desc >Tres tablas: las tablas s1 y s2 que representan esas cadenas en la pila, respectivamente, y ambas apuntando a la misma cadena de datos en el heap. La tabla s1 está desactivada porque s1 ya no es válida; solo s2 se puede usar para acceder a los datos del heap.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-238 233,-238 233,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<polygon class="opacity-background" stroke="transparent" points="0,-130 0,-230 96,-230 96,-130 8,-130"/>
<polyline fill="none" stroke="var(--fg)" points="0,-210 96,-210 "/>
<text text-anchor="start" x="45.7759" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="0,-190 0,-210 60,-210 60,-190 8,-190"/>
<text text-anchor="start" x="8.8413" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-190 60,-210 96,-210 96,-190 60,-190"/>
<text text-anchor="start" x="62.8413" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-170 0,-190 60,-190 60,-170 8,-170"/>
<text text-anchor="start" x="2.2241" y="-175.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-170 60,-190 96,-190 96,-170 60,-170"/>
<polygon fill="none" stroke="var(--fg)" points="0,-150 0,-170 60,-170 60,-150 8,-150"/>
<text text-anchor="start" x="2.4482" y="-155.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-150 60,-170 96,-170 96,-150 60,-150"/>
<text text-anchor="start" x="74.5" y="-155.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-130 0,-150 60,-150 60,-130 8,-130"/>
<text text-anchor="start" x="2.6826" y="-135.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-130 60,-150 96,-150 96,-130 60,-130"/>
<text text-anchor="start" x="74.5" y="-135.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table1 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="140.5,-127 140.5,-147 185.5,-147 185.5,-127 148.5,-127"/>
<text text-anchor="start" x="145.4482" y="-132.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-127 185.5,-147 221.5,-147 221.5,-127 185.5,-127"/>
<text text-anchor="start" x="188.3413" y="-132.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-107 140.5,-127 185.5,-127 185.5,-107 148.5,-107"/>
<text text-anchor="start" x="158.5" y="-112.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-107 185.5,-127 221.5,-127 221.5,-107 185.5,-107"/>
<text text-anchor="start" x="200" y="-112.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-87 140.5,-107 185.5,-107 185.5,-87 148.5,-87"/>
<text text-anchor="start" x="158.5" y="-92.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-87 185.5,-107 221.5,-107 221.5,-87 185.5,-87"/>
<text text-anchor="start" x="200.3931" y="-92.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-67 140.5,-87 185.5,-87 185.5,-67 148.5,-67"/>
<text text-anchor="start" x="158.5" y="-72.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-67 185.5,-87 221.5,-87 221.5,-67 185.5,-67"/>
<text text-anchor="start" x="201.5552" y="-72.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-47 140.5,-67 185.5,-67 185.5,-47 148.5,-47"/>
<text text-anchor="start" x="158.5" y="-52.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-47 185.5,-67 221.5,-67 221.5,-47 185.5,-47"/>
<text text-anchor="start" x="201.5552" y="-52.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-180C78,-180 101.9982,-126.912 130.4405,-118.2023"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.986,-121.6621 140.5,-117 130.1553,-114.7115 130.986,-121.6621"/>
</g>
<!-- table3 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-84 96,-84 "/>
<text text-anchor="start" x="45.7759" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s2</text>
<polygon fill="none" stroke="var(--fg)" points="0,-64 0,-84 60,-84 60,-64 8,-64"/>
<text text-anchor="start" x="8.8413" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-64 60,-84 96,-84 96,-64 60,-64"/>
<text text-anchor="start" x="62.8413" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-44 0,-64 60,-64 60,-44 8,-44"/>
<text text-anchor="start" x="2.2241" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-44 60,-64 96,-64 96,-44 60,-44"/>
<polygon fill="none" stroke="var(--fg)" points="0,-24 0,-44 60,-44 60,-24 8,-24"/>
<text text-anchor="start" x="2.4482" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-24 60,-44 96,-44 96,-24 60,-24"/>
<text text-anchor="start" x="74.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-4 0,-24 60,-24 60,-4 8,-4"/>
<text text-anchor="start" x="2.6826" y="-9.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-4 60,-24 96,-24 96,-4 60,-4"/>
<text text-anchor="start" x="74.5" y="-9.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table3&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-54C78,-54 101.9982,-107.088 130.4405,-115.7977"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.1553,-119.2885 140.5,-117 130.986,-112.3379 130.1553,-119.2885"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-4: Representación en memoria después de que
<code>s1</code> se haya invalidado</span></p>
<p>¡Eso resuelve nuestro problema! Con solo <code>s2</code> válido, cuando sale de ámbito
solo él liberará la memoria, y ya está.</p>
<p>Además, hay una elección de diseño que se infiere de esto: Rust nunca
creará automáticamente &quot;copias profundas&quot; de tus datos. Por lo tanto, cualquier
copia <em>automática</em> se puede asumir que es económica en términos de rendimiento
en tiempo de ejecución.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="variables-y-datos-interactuando-con-clone"><a class="header" href="#variables-y-datos-interactuando-con-clone">Variables y datos interactuando con Clone</a></h4>
<p>Si <em>queremos</em> copiar profundamente los datos del heap de la <code>String</code>, no solo
los datos de la pila, podemos usar un método común llamado <code>clone</code>. Discutiremos
la sintaxis del método en el Capítulo 5, pero debido a que los métodos son una
característica común en muchos lenguajes de programación, probablemente los
hayas visto antes.</p>
<p>Aquí hay un ejemplo del método <code>clone</code> en acción:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hola&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {s1}, s2 = {s2}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Esto funciona bien y produce explícitamente el comportamiento mostrado en la
Figura 4-3, donde los datos del heap <em>se copian</em>.</p>
<p>Cuando veas una llamada a <code>clone</code>, sabrás que se está ejecutando algún código
arbitrario y que ese código puede ser costoso. Es un indicador visual de que
algo diferente está sucediendo.</p>
<h4 id="solo-datos-del-stack-copiar"><a class="header" href="#solo-datos-del-stack-copiar">Solo datos del stack: Copiar</a></h4>
<p>Hay otro problema que aún no hemos hablado. Este código usando enteros - parte
de lo que se mostró en el Listado 4-2 - funciona y es válido:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {x}, y = {y}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Pero este código parece contradecir lo que acabamos de aprender: no tenemos una
llamada a <code>clone</code>, pero <code>x</code> sigue siendo válido y no se movió a <code>y</code>.</p>
<p>La razón es que los tipos como los enteros que tienen un tamaño conocido en el
momento de la compilación se almacenan completamente en la pila, por lo que
copiar los valores reales es rápido. Eso significa que no hay razón para que
queramos evitar que <code>x</code> sea válido después de crear la variable <code>y</code>. En otras
palabras, no hay diferencia entre copiar superficial y profunda aquí, por lo que
llamar a <code>clone</code> no haría nada diferente de la copia superficial habitual, y
podemos dejarlo fuera.</p>
<p>Rust tiene una anotación especial llamada <code>Copy</code> que podemos colocar en tipos
que se almacenan en la pila, como los enteros (hablaremos más sobre los
<em>traits</em> en el <a href="ch10-02-traits.html">Capítulo 10</a><!-- ignore -->). Si un tipo implementa el
<code>Copy</code> <em>trait</em>, las variables que lo usan no se mueven, sino que se copian
trivialmente, haciendo que sigan siendo válidas después de asignarlas a otra
variable.</p>
<p>Rust no nos permitirá anotar un tipo con <code>Copy</code> si el tipo, o cualquiera de sus
partes, ha implementado el <em>trait</em> <code>Drop</code>. Si el tipo necesita que algo
especial suceda cuando el valor sale del alcance y agregamos la anotación <code>Copy</code>
a ese tipo, obtendremos un error de tiempo de compilación. Para aprender cómo
agregar la anotación <code>Copy</code> a tu tipo para implementar el <em>trait</em>, consulta
<a href="appendix-03-derivable-traits.html">“Traits derivables”</a><!-- ignore --> en el Apéndice C.</p>
<p>Entonces, ¿qué tipos implementan el <em>trait</em> <code>Copy</code>? Puedes consultar la
documentación del tipo dado para asegurarte, pero como regla general, cualquier
grupo de valores escalares simples puede implementar <code>Copy</code>, y nada que
requiera asignación o sea alguna forma de recurso puede implementar <code>Copy</code>.
Aquí hay algunos de los tipos que implementan <code>Copy</code>:</p>
<ul>
<li>Todos los tipos enteros, como <code>u32</code>.</li>
<li>El tipo booleano, <code>bool</code>, con valores <code>true</code> y <code>false</code>.</li>
<li>Todos los tipos de punto flotante, como <code>f64</code>.</li>
<li>El tipo de carácter, <code>char</code>.</li>
<li>Tuplas, si solo contienen tipos que también implementan <code>Copy</code>. Por ejemplo,
<code>(i32, i32)</code> implementa <code>Copy</code>, pero <code>(i32, String)</code> no lo hace.</li>
</ul>
<h3 id="propiedad-y-funciones"><a class="header" href="#propiedad-y-funciones">Propiedad y funciones</a></h3>
<p>Las mecánicas de pasar un valor a una función son similares a las de asignar un
valor a una variable. Pasar una variable a una función moverá o copiará, como
hace la asignación. La Lista 4-3 tiene un ejemplo con algunas anotaciones que
muestran dónde entran y salen las variables del alcance.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hola&quot;);  // s aparece en el ámbito

    tomar_ownership(s);             // El valor de s se mueve a la función...
                                    // ... y ya no es valido aquí

    let x = 5;                      // x aparece en el ámbito

    hacer_una_copia(x);                  // x deberia moverse a la función,
                                    // pero i32 implementa Copy, entonces es
                                    // valido aún despues de llamar a la función

} // Aquí termina el ámbito, x es destruido con drop. La memoria es liberada.
  // s ya no existia porque habia sido movido a la función.
  // Nada especial ocurre.

fn tomar_ownership(un_string: String) { // un_string aparece en el ámbito
    println!(&quot;{un_string}&quot;);
} // Aquí termina el ámbito, un_string es destruido con drop. 
  // La memoria es liberada.

fn hacer_una_copia(un_entero: i32) { // un_entero aparece en el ámbito
    println!(&quot;{un_entero}&quot;);
} // Aquí termina el ámbito, un_entero es destruido. Nada especial ocurre.</code></pre></pre>
<p><span class="caption">Lista 4-3: Funciones con propiedad y alcance
anotados</span></p>
<p>Si intentamos usar <code>s</code> después de llamar a <code>tomar_ownership</code>, Rust lanzaría un
error de tiempo de compilación. Estas comprobaciones estáticas nos protegen de
errores. Intenta agregar código a <code>main</code> que use <code>s</code> y <code>x</code> para ver dónde puedes
usarlos y dónde las reglas de propiedad te impiden hacerlo.</p>
<h3 id="valores-de-retorno-y-alcance"><a class="header" href="#valores-de-retorno-y-alcance">Valores de retorno y alcance</a></h3>
<p>Los valores de retorno también pueden transferir la propiedad. La Lista 4-4
muestra un ejemplo de una función que devuelve algún valor, con anotaciones
similares a las de la Lista 4-3.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = da_un_ownership();         // da_un_ownership es llamado y
                                        // devuelve el valor de retorno
                                        // a s1

    let s2 = String::from(&quot;hola&quot;);     // s2 aparece en el ámbito

    let s3 = toma_y_devuelve(s2);  // s2 es movido a la función
                                        // toma_y_devuelve, que también
                                        // retorna el valor de s2 a s3
} // Fin el ámbito, s3 es destruido con drop y se libera la memoria. 
  // s2 fue movido previamente, entonces no pasa nada. 
  // s1 es destruido con drop y se libera la memoria.

fn da_un_ownership() -&gt; String {             // da_un_ownership mueve su
                                             // retorno a la función que la
                                             // llama

    let un_string = String::from(&quot;tuyo&quot;);    // un_string aparece en el ámbito

    un_string                                // un_string es retornado y
                                             // mueve su valor
}

// Esta función toma un String y devuelve uno
fn toma_y_devuelve(un_string: String) -&gt; String { // un_string aparece 
                                                  // en el ámbito

    un_string  // un_string es retornado y mueve su valor
}</code></pre></pre>
<p><span class="caption">Lista 4-4: Transferencia de propiedad de los valores
de retorno</span></p>
<p>La propiedad (ownership) de una variable sigue el mismo patrón cada vez:
asignar un valor a otra variable lo mueve. Cuando una variable que incluye datos
en el heap sale del contexto de ejecución, el valor se limpiará por <code>drop</code> a menos que la
propiedad de los datos se haya movido a otra variable.</p>
<p>Aunque esto funciona, tomar la propiedad y luego devolver la propiedad con cada
función es un poco tedioso. ¿Qué pasa si queremos que una función use un valor
pero no tome la propiedad? Es bastante molesto que todo lo que pasamos también
necesite volver a pasar si queremos usarlo de nuevo, además de cualquier dato
que resulte del cuerpo de la función que también podríamos querer devolver.</p>
<p>Rust nos permite devolver múltiples valores usando una tupla, como se muestra
en la Lista 4-5.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hola&quot;);

    let (s2, len) = calcular_longitud(s1);

    println!(&quot;La longitud de '{s2}' es {len}.&quot;);
}

fn calcular_longitud(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() retorna la longitud de un String

    (s, length)
}</code></pre></pre>
<p><span class="caption">Lista 4-5: Devolución de la propiedad de los
parámetros</span></p>
<p>Pero esto es demasiado ceremonioso y mucho trabajo para un concepto que debería
ser común. Afortunadamente para nosotros, Rust tiene una característica para
usar un valor sin transferir la propiedad, llamada <em>referencias</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referencias-y-prestamos"><a class="header" href="#referencias-y-prestamos">Referencias y Prestamos</a></h2>
<p>El problema con la tupla de código en el Listado 4-5 es que tenemos que devolver
el <code>String</code> a la función que lo llama para que podamos seguir usando el
<code>String</code> después de la llamada a <code>calcular_longitud</code>, porque el <code>String</code> se
movió a <code>calcular_longitud</code>. En lugar de eso, podemos proporcionar una
referencia al valor <code>String</code>. Una <em>referencia</em> es como un puntero en que es una
dirección que podemos seguir para acceder a los datos almacenados en esa
dirección; esos datos son propiedad de otra variable. A diferencia de un
puntero, una referencia garantiza que apunte a un valor válido de un tipo
particular para la vida de esa referencia.</p>
<p>Aquí está cómo definirías y usarías una función <code>calcular_longitud</code> que tiene
una referencia a un objeto como parámetro en lugar de tomar la propiedad del valor.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hola&quot;);

    let len = calcular_longitud(&amp;s1);

    println!(&quot;La longitud de '{s1}' es {len}.&quot;);
}

fn calcular_longitud(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>Primero, ten en cuenta que todo el código de la tupla en la declaración de la
variable y el valor de retorno de la función ha desaparecido. En segundo
lugar, observe que pasamos <code>&amp;s1</code> a <code>calcular_longitud</code> y, en su definición,
tomamos <code>&amp;String</code> en lugar de <code>String</code>. Este signo ampersands (&amp;) representa
<em>referencia</em>, y te permiten referirte a algún valor sin tomar la propiedad de
él. La Figura 4-5 representa este concepto.</p>
<div class="center">
<svg
 viewBox="0.00 0.00 1500.00 650.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 152)">
<title>Tres tablas: la tabla para s contiene solo un puntero a la tabla para s1. La tabla para s1 contiene los datos de la pila para s1 y apunta a los datos de la cadena en la pila.</title>
<desc >Tres tablas: la tabla para s contiene solo un puntero a la tabla para s1. La tabla para s1 contiene los datos de la pila para s1 y apunta a los datos de la cadena en la pila.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-152 357,-152 357,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-124 90,-124 "/>
<text text-anchor="start" x="41.2759" y="-129.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s</text>
<polygon fill="none" stroke="var(--fg)" points="0,-104 0,-124 54,-124 54,-104 8,-104"/>
<text text-anchor="start" x="2.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="54,-104 54,-124 90,-124 90,-104 54,-104"/>
<text text-anchor="start" x="56.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-84 0,-104 54,-104 54,-84 8,-84"/>
<text text-anchor="start" x="2.2241" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="54,-84 54,-104 90,-104 90,-84 54,-84"/>
</g>
<!-- table1 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="122,-124 220,-124 "/>
<text text-anchor="start" x="169.7759" y="-129.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="122,-104 122,-124 184,-124 184,-104 122,-104"/>
<text text-anchor="start" x="132.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="184,-104 184,-124 220,-124 220,-104 184,-104"/>
<text text-anchor="start" x="186.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="122,-84 122,-104 184,-104 184,-84 122,-84"/>
<text text-anchor="start" x="124.2241" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="184,-84 184,-104 220,-104 220,-84 184,-84"/>
<polygon fill="none" stroke="var(--fg)" points="122,-64 122,-84 184,-84 184,-64 122,-64"/>
<text text-anchor="start" x="124.4482" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="184,-64 184,-84 220,-84 220,-64 184,-64"/>
<text text-anchor="start" x="198.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="122,-44 122,-64 184,-64 184,-44 122,-44"/>
<text text-anchor="start" x="124.6826" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="184,-44 184,-64 220,-64 220,-44 184,-44"/>
<text text-anchor="start" x="198.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M62,-94C62,-94 93.1184,-94 121.9514,-94"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="112,-97.5001 122,-94 112,-90.5001 112,-97.5001"/>
</g>
<!-- table2 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="272.5,-104 272.5,-124 309.5,-124 309.5,-104 272.5,-104"/>
<text text-anchor="start" x="275.4482" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-104 309.5,-124 345.5,-124 345.5,-104 309.5,-104"/>
<text text-anchor="start" x="312.3413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="272.5,-84 272.5,-104 309.5,-104 309.5,-84 272.5,-84"/>
<text text-anchor="start" x="287.5" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-84 309.5,-104 345.5,-104 345.5,-84 309.5,-84"/>
<text text-anchor="start" x="324" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="272.5,-64 272.5,-84 309.5,-84 309.5,-64 272.5,-64"/>
<text text-anchor="start" x="287.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-64 309.5,-84 345.5,-84 345.5,-64 309.5,-64"/>
<text text-anchor="start" x="324.3931" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="272.5,-44 272.5,-64 309.5,-64 309.5,-44 272.5,-44"/>
<text text-anchor="start" x="287.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-44 309.5,-64 345.5,-64 345.5,-44 309.5,-44"/>
<text text-anchor="start" x="325.5552" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="272.5,-24 272.5,-44 309.5,-44 309.5,-24 272.5,-24"/>
<text text-anchor="start" x="287.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-24 309.5,-44 345.5,-44 345.5,-24 309.5,-24"/>
<text text-anchor="start" x="325.5552" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table1&#45;&gt;table2 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M202,-94C202,-94 233.3406,-94 262.3797,-94"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="262.5,-97.5001 272.5,-94 262.5,-90.5001 262.5,-97.5001"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-5: Un diagrama de <code>&amp;String s</code> apuntando a <code>String s1</code></span></p>
<blockquote>
<p>Nota: Lo opuesto a la referencia usando <code>&amp;</code> es <em>desreferenciar</em>, que se
logra con el operador de desreferencia, <code>*</code>. Veremos algunos usos del
operador de desreferencia en el Capítulo 8 y discutiremos detalles de la
desreferenciación en el Capítulo 15.</p>
</blockquote>
<p>Vamos a echar un vistazo más de cerca a la llamada de función aquí:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hola&quot;);

    let len = calcular_longitud(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;La longitud de '{s1}' es {len}.&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calcular_longitud(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p>La sintaxis <code>&amp;s1</code> nos permite crear una referencia que <em>se refiere</em> al valor de
<code>s1</code> pero sin ser el propietario. Por este motivo, el valor al que apunta no se
descartará cuando la referencia deje de usarse.</p>
<p>Del mismo modo, la firma de la función usa <code>&amp;</code> para indicar que el tipo del
parámetro <code>s</code> es una referencia. Vamos a agregar algunas anotaciones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hola&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calcular_longitud(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;La longitud de '{s1}' es {len}.&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn calcular_longitud(s: &amp;String) -&gt; usize { // es una referencia a un String
    s.len()
} // Aquí, s sale de ámbito. Pero como no tiene el ownership/la propiedad sino 
  // que s es solo un prestamo, no se destruye, se regresa al propietario, s1.</code></pre></pre>
<p>El contexto de ejecución en el que la variable <code>s</code> es válida es el mismo que el contexto de ejecución de
cualquier parámetro de función, pero el valor al que apunta la referencia no se
descarta cuando <code>s</code> deja de usarse, porque <code>s</code> no tiene la propiedad. Cuando
las funciones tienen referencias como parámetros en lugar de los valores
reales, no necesitaremos devolver los valores para devolver la propiedad,
porque nunca tuvimos la propiedad.</p>
<p>Llamamos a la acción de crear una referencia <em>prestar</em> (borrowing en ingles).
Como en la vida real, si una persona posee algo, puedes pedir prestado.
Cuando termines, tienes que devolverlo. No lo posees.</p>
<p>Entonces, ¿qué pasa si intentamos modificar algo que estamos prestando? Prueba
el código en el Listado 4-6. Spoiler alert: ¡no funciona!</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hola&quot;);

    modificar(&amp;s);
}

fn modificar(un_string: &amp;String) {
    un_string.push_str(&quot;, mundo&quot;);
}</code></pre>
<p><span class="caption">Listado 4-6: Intentando modificar un valor prestado</span></p>
<p>Aquí está el error:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*un_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     un_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ `un_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn modificar(un_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>Al igual que las variables son inmutables por defecto, también lo son las
referencias. No se nos permite modificar algo al que tenemos una referencia.</p>
<h3 id="referencias-mutables"><a class="header" href="#referencias-mutables">Referencias Mutables</a></h3>
<p>Podemos arreglar el código del Listado 4-6 para permitirnos modificar un valor
prestado con solo unos pequeños cambios que usen, en su lugar, una
<em>referencia mutable</em>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hola&quot;);

    modificar(&amp;mut s);
}

fn modificar(un_string: &amp;mut String) {
    un_string.push_str(&quot;, mundo&quot;);
}</code></pre></pre>
<p>Primero cambiamos <code>s</code> a <code>mut</code>. Luego creamos una referencia mutable con <code>&amp;mut s</code> donde llamamos a la función <code>modificar</code>, y actualizamos la firma de la función
para aceptar una referencia mutable con <code>un_string: &amp;mut String</code>. Esto hace
muy claro que la función <code>modificar</code> mutará el valor que presta.</p>
<p>Las referencias mutables tienen una gran restricción: si tienes una referencia
mutable a un valor, no puedes tener otras referencias a ese valor. Este código
que intenta crear dos referencias mutables a <code>s</code> fallará:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hola&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}</span></code></pre>
<p>Aquí está el error:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>Este error dice que este código es inválido porque no podemos prestar <code>s</code> como
mutable más de una vez. El primer préstamo mutable está en <code>r1</code> y debe
durar hasta que se use en el <code>println!</code>, pero entre la creación de esa
referencia mutable y su uso, intentamos crear otra referencia mutable en <code>r2</code>
que presta los mismos datos que <code>r1</code>.</p>
<p>La restricción que impide múltiples referencias mutables a los mismos datos al
mismo tiempo permite la mutación pero de una manera muy controlada. Es algo
con lo que los nuevos Rustaceans luchan porque la mayoría de los lenguajes te
permiten mutar cuando quieras. El beneficio de tener esta restricción es que
Rust puede prevenir las carreras de datos en tiempo de compilación. Una
<em>carrera de datos</em> es similar a una condición de carrera y ocurre cuando
ocurren estos tres comportamientos:</p>
<ul>
<li>Dos o más punteros acceden a los mismos datos al mismo tiempo.</li>
<li>Al menos uno de los punteros se está utilizando para escribir en los datos.</li>
<li>No hay ningún mecanismo que se esté utilizando para sincronizar el acceso a
los datos.</li>
</ul>
<p>Las carreras de datos causan un comportamiento indefinido y pueden ser
difíciles de diagnosticar y corregir cuando intentas rastrearlas en tiempo de
ejecución; ¡Rust evita este problema al negarse a compilar código con carreras
de datos!</p>
<p>Como siempre, podemos usar llaves para crear un nuevo contexto de ejecución, permitiendo
múltiples referencias mutables, solo no <em>simultáneas</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hola&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 se sale de su ámbito aquí, por lo que no hay problema 
      // si creamos otra referencia mutable

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>Rust impone una regla similar para combinar referencias mutables e inmutables.
Este código da como resultado un error:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hola&quot;);

    let r1 = &amp;s; // no hay problema
    let r2 = &amp;s; // no hay problema
    let r3 = &amp;mut s; // ¡ UN GRAN PROBLEMA !

    println!(&quot;{}, {}, y {}&quot;, r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>Aquí está el error:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no hay problema
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no hay problema
6 |     let r3 = &amp;mut s; // ¡ UN GRAN PROBLEMA !
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, y {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>¡Uf! <em>También</em> no podemos tener una referencia mutable mientras tenemos una
inmutable al mismo valor.</p>
<p>¡Los usuarios de una referencia inmutable no esperan que el valor cambie
repentinamente debajo de ellos! Sin embargo, se permiten múltiples referencias
inmutables porque nadie que solo está leyendo los datos tiene la capacidad de
afectar la lectura de los datos de nadie más.</p>
<p>Tenga en cuenta que el contexto de ejecución de una referencia comienza desde donde se
introduce y continúa hasta la última vez que se usa la referencia. Por
ejemplo, este código se compilará porque el último uso de las referencias
inmutables, el <code>println!</code>, ocurre antes de que se introduzca la referencia
mutable:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no hay problema
    let r2 = &amp;s; // no hay problema
    println!(&quot;{r1} y {r2}&quot;);
    // variables r1 y r2 no se usaran más a partir de aquí

    let r3 = &amp;mut s; // no hay problema
    println!(&quot;{r3}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Los contextos de ejecución de las referencias inmutables <code>r1</code> y <code>r2</code> terminan después del
<code>println!</code> donde se usan por última vez, que es antes de que se cree la
referencia mutable <code>r3</code>. Estos contextos de ejecución no se superponen, por lo que este código
está permitido: ¡el compilador puede decir que la referencia ya no se está
utilizando en un punto antes del final del ámbito!</p>
<p>Aunque los errores de préstamo a veces pueden ser frustrantes, recuerda que
es el compilador de Rust que señala un error potencial temprano (en tiempo de
compilación en lugar de en tiempo de ejecución) y te muestra exactamente dónde
está el problema. Entonces no tienes que rastrear por qué tus datos no son lo
que pensabas que eran.</p>
<h3 id="referencias-colgantes"><a class="header" href="#referencias-colgantes">Referencias colgantes</a></h3>
<p>En lenguajes con punteros, es fácil crear accidentalmente un <em>puntero colgante</em>:
un puntero que hace referencia a una ubicación en la memoria que puede haber
sido otorgada a otra persona, al liberar algo de memoria mientras se preserva
un puntero a esa memoria. En Rust, por el contrario, el compilador garantiza
que las referencias nunca serán referencias colgantes: si tiene una referencia
a algún dato, el compilador asegurará que los datos no salgan de contexto de ejecución antes
de que la referencia a los datos lo haga.</p>
<p>Intentemos crear una referencia colgante para ver cómo Rust los previene con un
error de tiempo de compilación:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let referencia_a_la_nada = colgar();
}

fn colgar() -&gt; &amp;String {
    let s = String::from(&quot;hola&quot;);

    &amp;s
}</code></pre>
<p>Aquí está el error:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn colgar() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn colgar() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 2 previous errors
</code></pre>
<p>Este mensaje de error se refiere a una característica que aún no hemos cubierto:
los tiempos de vida. Discutiremos los tiempos de vida en detalle en el Capítulo 
10. Pero, si ignora las partes sobre los tiempos de vida, el mensaje contiene la
clave para saber por qué este código es un problema:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Se traduciría algo así como:</p>
<pre><code class="language-text">el tipo de retorno de la función contiene un valor prestado, pero no hay ningún 
valor que pueda ser prestado
```

&lt;span class=&quot;filename&quot;&gt;Nombre de archivo: src/main.rs&lt;/span&gt;

```rust,ignore,does_not_compile
# fn main() {
#     let referencia_a_la_nada = colgar();
# }
# 
fn colgar() -&gt; &amp;String { // colgar retorna una referencia a un String

    let s = String::from(&quot;hola&quot;); // s es un nuevo String

    &amp;s // retornamos una referencia a la String, s
} // Aquí, s sale de ámbito y se libera su memoria. 
  // ¡Pero retornamos una referencia a ella!
  // ¡Peligro! ¡Esta referencia apunta a memoria que ya no existe!
</code></pre>
<p>Porque <code>s</code> se crea dentro de <code>colgar</code>, cuando el código de <code>colgar</code> finaliza,
<code>s</code> se desalocará. Pero intentamos devolver una referencia a él. Eso significa
que esta referencia estaría apuntando a una <code>String</code> inválida. ¡Eso no está
bien! Rust no nos dejará hacer esto.</p>
<p>La solución aquí es devolver la <code>String</code> directamente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_colgante();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_colgante() -&gt; String {
    let s = String::from(&quot;hola&quot;);

    s
}</code></pre></pre>
<p>Esto funciona sin problemas. La propiedad se mueve fuera y nada se desaloca.</p>
<h3 id="las-reglas-de-las-referencias"><a class="header" href="#las-reglas-de-las-referencias">Las reglas de las referencias</a></h3>
<p>Repasemos lo que hemos discutido sobre las referencias:</p>
<ul>
<li>En cualquier momento dado, puedes tener <em>o bien</em> una referencia mutable <em>o</em>
cualquier número de referencias inmutables.</li>
<li>Las referencias deben ser siempre válidas.</li>
</ul>
<p>A continuación, veremos un tipo diferente de referencia: los slices.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="el-tipo-slice"><a class="header" href="#el-tipo-slice">El Tipo Slice</a></h2>
<p>Los <em>Slices</em> te permiten referenciar a una secuencia contigua de elementos
en una <a href="ch08-00-common-collections.html">colección</a> en lugar de la colección completa. Un slice es una especie de
referencia, por lo que no tiene ownership.</p>
<p>Aquí hay un pequeño problema de programación: escribe una función que tome un
string de palabras separadas por espacios y retorne la primera palabra que
encuentre en ese string.
Si la función no encuentra ningún espacio en el string, todo el string debe ser
una sola palabra, por lo que se debe retornar todo el string.</p>
<p>Trabajemos en cómo escribiríamos la firma de esta función sin usar slices,
para entender el problema que los slices resolverán:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>La función <code>first_word</code> tiene un <code>&amp;String</code> como parámetro. No queremos el
ownership, así que esto está bien. Pero ¿Que deberíamos retornar? Realmente no
tenemos una forma de hablar sobre &quot;una <em>porción</em> de un string&quot;. Sin embargo,
podríamos retornar el índice del final de la palabra, indicado por un espacio.
Probemos eso, como se muestra en Listing 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 4-7: La función <code>first_word</code> retorna un
valor de índice en bytes dentro de un parámetro <code>String</code></span></p>
<p>Dado que necesitamos recorrer el <code>String</code> elemento por elemento y comprobar si
un valor es un espacio, convertiremos nuestro <code>String</code> a un array de bytes
usando el método <code>as_bytes</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>A continuación, creamos un iterator sobre el array de bytes utilizando el método
<code>iter</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Hablaremos más detalladamente sobre los iterators en <a href="ch13-02-iterators.html">Procesando una serie de
elementos con Iteradores</a><!-- ignore -->. Por ahora, sabemos que <code>iter</code> es
un método que retorna cada elemento en una colección y que <code>enumerate</code> envuelve
el resultado de <code>iter</code> y retorna cada elemento como parte de una tupla. El
primer elemento de la tupla que retorna <code>enumerate</code> es el índice, y el segundo
elemento es una referencia al elemento.
Esto es un poco más conveniente que calcular el índice nosotros mismos.</p>
<p>Debido a que el método <code>enumerate</code> retorna una tupla, podemos usar patrones para
desestructurar esa tupla. Hablaremos más sobre los patrones en
<a href="ch06-02-match.html#patrones-que-vinculan-valores">Patrones que vinculan valores</a><!-- ignore -->. En el ciclo <code>for</code>,
especificamos un patrón que tiene <code>i</code> para el índice de la tupla e <code>&amp;item</code> para
el byte único en la tupla. Debido a que tomamos una referencia al elemento de
<code>.iter().enumerate()</code>, podemos usar<code>&amp;</code> en el patrón.</p>
<p>Dentro del ciclo <code>for</code>, buscamos el byte que representa el espacio usando
la sintaxis literal del byte. Si encontramos un espacio, retornamos su posición.
De lo contrario, retornamos la longitud del string usando <code>s.len()</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Ahora tenemos una forma de averiguar el índice del final de la primera palabra
en el string, pero tenemos un problema. Estamos retornando un <code>usize</code> por si
solo, pero es solo un número significativo en el contexto de él <code>&amp;String</code>.
En otras palabras, debido a que es un valor separado del <code>String</code>, no hay
garantía de que siga siendo válido en el futuro. Considera el programa en
Listing 4-8 que usa la función <code>first_word</code> del Listing 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word obtendrá el valor 5

    s.clear(); // esto &quot;vacía&quot; el String, dejando s igual a &quot;&quot;

    // word aún tiene el valor 5 aquí, pero ya no hay un string para que
    // usar el valor 5 tenga sentido, ¡word es totalmente invalida!
}</code></pre></pre>
<p><span class="caption">Listing 4-8: Almacenando el resultado de llamar a
la función <code>first_word</code> y luego cambiar el contenido del <code>String</code></span></p>
<p>Este programa compila sin errores y también lo hará si usáramos <code>word</code> después
de llamar a <code>s.clear()</code>. Debido a que <code>word</code> no está conectado al estado de <code>s</code>
en absoluto, <code>word</code> aún contiene el valor <code>5</code>. Podríamos usar el valor <code>5</code> con
la variable <code>s</code> para intentar extraer la primera palabra, pero esto sería un
error porque el contenido de <code>s</code> ha cambiado desde que guardamos <code>5</code> en <code>word</code>.</p>
<p>¡Tener que preocuparse de que el índice de <code>word</code> no esté sincronizado con los
datos en <code>s</code> es tedioso y propenso a errores! El manejo de estos índices es aún
más frágil si escribimos una segunda función llamada <code>second_word</code>.
Su firma debería ser algo como esto:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Ahora que estamos rastreando tanto el índice de inicio como el de fin, <em>y</em>
tenemos aún más que se calcularon a partir de los datos en un estado particular,
pero que no están vinculados a ese estado en absoluto. Tenemos tres variables no
relacionados flotando por ahi que necesitan mantenerse sincronizadas.</p>
<p>Afortunadamente, Rust tiene una solución a este problema: los string slices.</p>
<h3 id="string-slices"><a class="header" href="#string-slices">String Slices</a></h3>
<p>Un <em>string slice</em> es una referencia de parte de un <code>String</code>, y se ve algo como
esto:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>En lugar de referenciar todo el <code>String</code>, <code>hello</code> es una referencia a una
porción del <code>String</code>, especificada en el segmento adicional <code>[0..5]</code>. Creamos
slices usando un rango dentro de corchetes, especificando
<code>[starting_index..ending_index]</code>, donde <code>starting_index</code> es la primera posición
en el slice y <code>ending_index</code> es una posición más que la última posición en el
slice. Internamente, la estructura de datos del slice almacena la posición
inicial y la longitud del slice, lo que corresponde a <code>ending_index</code> menos
<code>starting_index</code>. Por lo tanto, en el caso de <code>let world = &amp;s[6..11];</code>, <code>world</code>
sería un slice que contiene un puntero al byte en el índice 6 de <code>s</code> con un
valor de longitud de <code>5</code>.</p>
<p>Figure 4-6 muestra esto en el diagrama.</p>
<p><img alt="Three tables: a table representing the stack data of s, which points
to the byte at index 0 in a table of the string data &quot;hello world&quot; on
the heap. The third table rep-resents the stack data of the slice world, which
has a length value of 5 and points to byte 6 of the heap data table."
src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-6: String slice referencia una parte de un
<code>String</code></span></p>
<p>Con la sintaxis de rango <code>..</code> de Rust, si queremos comenzar en el índice 0,
podemos dejar el valor antes de los dos puntos. En otras palabras, estos son
iguales:</p>
<pre><code class="language-rut">let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
</code></pre>
<p>Del mismo modo, si el slice incluye el último byte del <code>String</code>, podemos
eliminar el número final. Esto significa que son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>También podemos omitir ambos valores para tomar un slice de todo el string.
Entonces estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Nota: Los índices del rango del string slice deben ocurrir en límites válidos
de caracteres UTF-8. Si intentamos crear un string slice en medio de un
caracter multibyte, tu programa saldrá con un error. Para fines de
introducción a los string slices, estamos asumiendo solo ASCII en esta
sección; una discusión más completa sobre el manejo de UTF-8 se encuentra
en la sección <a href="ch08-02-strings.html#almacenando-texto-codificado-en-utf-8-con-strings">Almacenando texto codificado en UTF-8 con Strings</a><!-- ignore --> del
Capítulo 8.</p>
</blockquote>
<p>Con toda esta información en mente, reescribamos <code>first_word</code> para retornar un
slice. El tipo que significa “string slice” se escribe como <code>&amp;str</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Obtenemos el índice para el final de la palabra de la misma manera que lo
hicimos en el Listing 4-7, buscando la primera aparición de un espacio. Cuando
encontramos un espacio, retornamos un string slice usando el inicio del string
y el índice del espacio como índices de inicio y final.</p>
<p>Ahora cuando llamamos a <code>first_word</code>, obtenemos un único valor que está
vinculado a los datos subyacentes. El valor se compone de una referencia al
punto de inicio del slice y el número de elementos en el slice.</p>
<p>Retornando el slice también funcionaría para la función <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Ahora tenemos una API sencilla que es mucho más difícil de estropear porque el
compilador se asegurará de que las referencias dentro del <code>String</code> sigan siendo
válidas. ¿Recuerdas el error en el programa en Listing 4-8, cuando obtuvimos
el índice para el final de la primera palabra, pero luego limpiamos el string
de modo que nuestro índice era inválido? Ese código era lógicamente incorrecto,
pero no mostraba errores inmediatos. Los problemas aparecerían más tarde si
seguimos intentando usar el índice de la primera palabra con un string vacío.
Los Slices hacen que este error sea imposible y nos permiten saber que tenemos
un problema en nuestro código mucho antes. El uso de la versión slice de
<code>first_word</code> arrojará un error en tiempo de compilación:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {word}&quot;);
}</code></pre>
<p>Aquí está el error del compilador:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!(&quot;the first word is: {word}&quot;);
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>Recordemos que las reglas del borrowing si tenemos una referencia immutable a
algo, no podemos tomar también una referencia mutable. Debido a que <code>clear</code>
necesita truncar el <code>String</code>, necesita obtener una referencia mutable.
El <code>println!</code> después de la llamada a <code>clear</code> usa la referencia en <code>word</code>,
por lo que la referencia inmutable debe seguir activa en ese punto. Rust
impide que la referencia mutable en <code>clear</code> y la referencia inmutable en <code>word</code>
existan al mismo tiempo, y la compilación falla. No solo Rust ha hecho más fácil
nuestra API, sino que también ha eliminado una clase entera de errores en tiempo
de compilación.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="string-literales-como-slices"><a class="header" href="#string-literales-como-slices">String Literales como Slices</a></h4>
<p>Recordemos que hablamos sobre que los string literales se almacenan dentro
del binario. Ahora que sabemos sobre los slices, podemos entender correctamente
los string literales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}</span></code></pre></pre>
<p>El tipo de <code>s</code> aquí es <code>&amp;str</code>: es un slice apuntando a ese punto específico
del binario. Esto también es por qué los literales de string son inmutables;
<code>&amp;str</code> es una referencia inmutable.</p>
<h4 id="string-slices-as-parameters"><a class="header" href="#string-slices-as-parameters">String Slices as Parameters</a></h4>
<p>Conociendo que puedes tomar slices de literales y valores <code>String</code> nos lleva
a una mejora más en <code>first_word</code>, y es su firma:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Un Rustacean más experimentado escribiría la firma mostrada en el Listing 4-9
en su lugar porque nos permite usar la misma función en ambos valores <code>&amp;String</code>
y <code>&amp;str</code>.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `first_word` funciona con slices de un string, sean parciales o completos.
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` también funciona con referencias de un string, que son equivalentes
</span><span class="boring">    // a un slice completo de un String
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `first_word` funciona con slices de string literales, sean parciales o completos
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Por que los strings literales son slices de strings,esto también funciona,
</span><span class="boring">    // sin necesidad de usar la sintaxis de slices.
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 4-9:
Mejorando la función <code>first_word</code> usando un string slice como parámetro
para el tipo del parámetro de<code>s</code></span></p>
<p>Si tenemos un string slice, podemos pasar directamente ese valor. Si tenemos
un <code>String</code>, podemos pasar un slice del <code>String</code> o una referencia al <code>String</code>.
Esta flexibilidad aprovecha las <em>deref coercions</em>, una característica que
veremos en la sección
<a href="ch15-02-deref.html#coerciones-implicitas-de-deref-con-funciones-y-metodos">&quot;Tratando los Smart Pointers como Referencias Regulares con el Trait Deref&quot;</a><!--ignore-->
del Capítulo 15.</p>
<p>Definir una función para tomar un string slice en lugar de una referencia a un
<code>String</code> hace que nuestra API sea más general y útil sin perder ninguna
funcionalidad:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // `first_word` funciona con slices de un string, sean parciales o completos.
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` también funciona con referencias de un string, que son equivalentes
    // a un slice completo de un String
    let word = first_word(&amp;my_string);

    let my_string_literal = &quot;hello world&quot;;

    // `first_word` funciona con slices de string literales, sean parciales o completos
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Por que los strings literales son slices de strings,esto también funciona,
    // sin necesidad de usar la sintaxis de slices.
    let word = first_word(my_string_literal);
}</code></pre></pre>
<h3 id="otros-slices"><a class="header" href="#otros-slices">Otros Slices</a></h3>
<p>Los string slices, como puedes imaginar, son específicos para strings. Pero
hay un tipo de slice más general. Considera este array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Así como podemos querer referirnos a parte de un string, también podemos querer
referirnos a parte de un array. Lo haríamos de esta manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>Este slice tiene el tipo <code>&amp;[i32]</code>. Funciona de la misma manera que los slices
de string, almacenando una referencia al primer elemento y una longitud. Usarás
este tipo de slice para todo tipo de colecciones. Hablaremos de estas
colecciones en detalle cuando veamos vectores en el Capítulo 8.</p>
<h2 id="resumen-3"><a class="header" href="#resumen-3">Resumen</a></h2>
<p>Los conceptos de ownership, borrowing, y slices aseguran la seguridad de la
memoria en los programas Rust en tiempo de compilación. El lenguaje Rust te
da control sobre el uso de la memoria de la misma manera que otros lenguajes
de programación de sistemas, pero el hecho de que el propietario de los datos
limpie automáticamente esos datos cuando salen del scope significa que no tienes
que escribir y depurar código extra para obtener este control.</p>
<p>El ownership afecta a cómo funcionan otras partes de Rust, así que hablaremos
de estos conceptos más adelante en el libro. Vamos a pasar al Capítulo 5 y
ver cómo agrupar piezas de datos en un <code>struct</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usando-structs-para-estructurar-datos-relacionados"><a class="header" href="#usando-structs-para-estructurar-datos-relacionados">Usando Structs para Estructurar Datos Relacionados</a></h1>
<p>Un <em>struct</em>, o <em>estructura</em>, es un tipo de dato personalizado que te permite 
empaquetar y nombrar múltiples valores relacionados que forman un grupo
significativo. Si estás familiarizado con un lenguaje orientado a objetos, 
un <em>struct</em> es como los atributos de un objeto. En este capítulo, 
compararemos y contrastaremos tuplas con structs para desarrollar lo que ya
sabes y demostrar cuando los structs son una mejor manera de agrupar datos.</p>
<p>Demostraremos cómo definir e instanciar structs. Discutiremos como definir
funciones asociadas, especialmente, el tipo de funciones asociadas llamadas
<em>métodos</em>, para especificar el comportamiento asociado con un tipo de struct. 
Los structs y enums (discutidos en el capítulo 6) son los bloques de 
construcción para crear nuevos tipos en el dominio de tu programa para
aprovechar al máximo la comprobación de tipos en tiempo de compilación de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definiendo-e-instanciando-structs"><a class="header" href="#definiendo-e-instanciando-structs">Definiendo e Instanciando Structs</a></h2>
<p>Los Structs son similares a las tuplas, discutido en la sección
<a href="ch03-02-data-types.html#el-tipo-tupla">“The Tuple Type”</a><!--ignore --> en ambos casos mantenemos múltiples
valores relativos. Como en las tuplas, las partes de un struct pueden ser de
diferentes tipos. A diferencia de las tuplas, en un struct tú nombras a cada
pieza de datos para que quede claro, que significan estos valores.
Agregando estos nombres significa que los structs son más flexibles
que las tuplas: no tienes que confiar en el orden de los datos para especificar o
acceder a los valores de una instancia.</p>
<p>Para definir un struct, debemos usar la palabra clave <code>struct</code> y el nombre del struct completo.
El nombre del struct debe describir el significado de los datos que se agrupan.
Entonces, entre llaves, definimos los nombres y tipos de datos, que llamaremos
<em>campos</em>. Por ejemplo, en el Listing 5-1 mostramos una definición de un struct
que almacena información sobre una cuenta de usuario.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 5-1: Una definición de struct <code>User</code></span></p>
<p>Para usar un struct después de haberlo definido, creamos una <em>instancia</em> de ese
struct especificando valores concretos para cada uno de los campos. Creamos una
instancia al declarar el nombre del struct y luego agregar llaves que contienen
<em>clave: valor</em> pares, donde las claves son los nombres de los campos y los
valores son los datos que queremos almacenar en esos campos. No tenemos que
especificar los campos en el mismo orden en el que los declaramos en el struct.
En otras palabras, la definición del struct es como una plantilla general para
el tipo, y las instancias llenan esa plantilla con datos particulares para
crear valores del tipo. Por ejemplo, podemos declarar un usuario en particular
como se muestra en el Listing 5-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from(&quot;someusername123&quot;),
        email: String::from(&quot;someone@example.com&quot;),
        sign_in_count: 1,
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-2: Creando una instancia del struct <code>User</code>
</span></p>
<p>Para acceder a un valor específico de un struct, usamos la notación de punto.
Por ejemplo, para acceder a la dirección de correo electrónico de este usuario,
usamos <code>user1.email</code>. Si la instancia es mutable, podemos cambiar un valor
asignando en un campo particular. El Listing 5-3 muestra cómo cambiar el valor
en el campo <code>email</code> de una instancia mutable de <code>User</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from(&quot;someusername123&quot;),
        email: String::from(&quot;someone@example.com&quot;),
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 5-3: Cambiando el valor en el campo <code>email</code> de una
instancia <code>User</code></span></p>
<p>Nota que toda la instancia debe ser mutable; Rust no nos permite marcar solo
ciertos campos como mutables. Como cualquier expresión, podemos construir una
nueva instancia del struct como la última expresión en el cuerpo de la función
para devolver implícitamente esa nueva instancia.</p>
<p>Listing 5-4 muestra una función <code>build_user</code> que devuelve una instancia de
<code>User</code> con el correo electrónico y el nombre de usuario dados. El campo
<code>active</code> obtiene el valor de <code>true</code>, y el campo <code>sign_in_count</code> obtiene el
valor de <code>1</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-4: Una función <code>build_user</code> que toma un email
y username y devuelve una instancia <code>User</code></span></p>
<p>Tiene sentido nombrar los parámetros de la función con el mismo nombre que los
campos del struct, pero tener que repetir los nombres de los campos y
variables <code>email</code> y <code>username</code> es un poco tedioso. Si el struct tuviera más
campos, repetir cada nombre sería aún más molesto. Afortunadamente, hay una
conveniente forma abreviada.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="usando-la-abreviatura-field-init"><a class="header" href="#usando-la-abreviatura-field-init">Usando la abreviatura Field Init</a></h3>
<p>Debido a que los nombres de los parámetros y los nombres de los campos del
struct son exactamente los mismos en el Listing 5-4, podemos usar la <em>abreviatura
Field Init</em> para reescribir <code>build_user</code> para que se comporte exactamente igual
pero no tenga la repetición de <code>username</code> y <code>email</code>, como se muestra en el
Listing 5-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-5: Una función <code>build_user</code> que usa field init
abreviado porque los parámetros <code>username</code> e <code>email</code> tienen el mismo nombre que
los campos del struct</span></p>
<p>Aquí, estamos creando una nueva instancia del struct <code>User</code>, que tiene un
campo llamado <code>email</code>. Queremos establecer el valor del campo <code>email</code> en el
valor del parámetro <code>email</code> de la función <code>build_user</code>. Debido a que el campo
<code>email</code> y el parámetro <code>email</code> tienen el mismo nombre, solo necesitamos escribir
<code>email</code> en lugar de <code>email: email</code>.</p>
<h3 id="creando-instancias-de-otras-instancias-con-sintaxis-de-struct-update"><a class="header" href="#creando-instancias-de-otras-instancias-con-sintaxis-de-struct-update">Creando Instancias de Otras Instancias con Sintaxis de Struct Update</a></h3>
<p>Suele ser útil crear una nueva instancia de un struct que incluya la mayoría de
los valores de otra instancia, pero cambie algunos. Puede hacer esto usando la
<em>sintaxis de struct update</em>.</p>
<p>Primero, en el Listing 5-6 mostramos cómo crear una nueva instancia de <code>User</code>
regularmente, sin la sintaxis de actualización. Establecemos un nuevo valor para
<code>email</code>, pero de lo contrario usamos los mismos valores de <code>user1</code> que creamos
en el Listing 5-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-6: Creando una nueva instancia <code>User</code> usando uno
de los valores de <code>user1</code></span></p>
<p>Usando la sintaxis de struct update, podemos lograr el mismo efecto con menos
código, como se muestra en el Listing 5-7. La sintaxis <code>..</code> especifica que los
campos restantes que no se establecen explícitamente deben tener el mismo valor
que los campos en la instancia dada.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-7: Usando una sintaxis de struct update para
introducir un nuevo valor <code>email</code> para una instancia <code>User</code> pero para usar el
resto de los valores de <code>user1</code></span></p>
<p>El código en el Listing 5-7 también crea una instancia en <code>user2</code> que tiene un
valor diferente para <code>email</code> pero tiene los mismos valores para los campos
<code>username</code>, <code>active</code> y <code>sign_in_count</code> de <code>user1</code>. Él <code>..user1</code> debe ir al
final para especificar que cualquier campo restante debe obtener sus valores
del campo correspondiente en <code>user1</code>, pero podemos elegir especificar valores
para tantos campos como queramos en cualquier orden, independientemente del
orden de los campos en la definición del struct.</p>
<p>Nota que la sintaxis de update struct usa <code>=</code> como una asignación; esto es
porque mueve los datos, como vimos en la sección <a href="ch04-01-what-is-ownership.html#variables-y-datos-interactuando-con-move">“Variables y datos
interactuando con Move”</a><!-- ignore -->. En este ejemplo, ya no podemos
usar <code>user1</code> como un todo después de crear <code>user2</code> porque el <code>String</code> en el
campo <code>username</code> de <code>user1</code> se movió a <code>user2</code>. Si hubiéramos dado a <code>user2</code>
nuevos valores <code>String</code> para <code>email</code> y <code>username</code>, y por lo tanto solo usamos
los valores de <code>active</code> y <code>sign_in_count</code> de <code>user1</code>, entonces <code>user1</code> todavía
sería válido después de crear <code>user2</code>. Tanto <code>active</code> como <code>sign_in_count</code> son
tipos que implementan la trait <code>Copy</code>, por lo que el comportamiento que
discutimos en la sección <a href="ch04-01-what-is-ownership.html#solo-datos-del-stack-copiar">“Datos de pila: Copy”</a><!-- ignore --> se
aplicaría.</p>
<h3 id="usando-structs-de-tuplas-sin-campos-nombrados-para-crear-diferentes-tipos"><a class="header" href="#usando-structs-de-tuplas-sin-campos-nombrados-para-crear-diferentes-tipos">Usando Structs de Tuplas sin Campos Nombrados para Crear Diferentes Tipos</a></h3>
<p>Rust también admite structs que se parecen a tuplas, llamados <em>structs de
tuplas</em>. Los structs de tuplas tienen el significado adicional que proporciona
el nombre del struct, pero no tienen nombres asociados a sus campos; en su
lugar, solo tienen los tipos de los campos. Los structs de tuplas son útiles
cuando desea darle un nombre al conjunto completo y hacer que el conjunto sea
un tipo diferente de otros conjuntos, y cuando nombrar cada campo como en un
struct regular sería verboso o redundante.</p>
<p>Para definir un struct de tupla, comience con la palabra clave <code>struct</code> y el
nombre del struct seguido por los tipos en la tupla. Por ejemplo, aquí
definimos y usamos dos structs de tupla llamados <code>Color</code> y <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
<p>Nota que los valores <code>black</code> y <code>origin</code> son diferentes tipos porque son
instancias de diferentes structs de tupla. Cada struct que defina es su propio
tipo, incluso si los campos dentro del struct tienen los mismos tipos. Por
ejemplo, una función que toma un parámetro de tipo <code>Color</code> no puede tomar un
<code>Point</code> como argumento, incluso si ambos tipos están compuestos por tres
valores <code>i32</code>. De lo contrario, las instancias de structs de tupla son
similares a las tuplas en que puede descomponerlas en sus piezas individuales,
y puede usar un <code>.</code> seguido por el índice para acceder a un valor individual.</p>
<h3 id="structs-de-unidad-sin-campos"><a class="header" href="#structs-de-unidad-sin-campos">Structs de Unidad sin Campos</a></h3>
<p>También puede definir structs que no tienen ningún campo. Estos se llaman
<em>structs de unidad</em> porque se comportan de manera similar a <code>()</code>, el tipo de
unidad que mencionamos en la sección <a href="ch03-02-data-types.html#el-tipo-tupla">“El tipo de tupla”</a><!-- ignore
-->. Los structs de unidad pueden ser útiles cuando necesita implementar un
trait en algún tipo, pero no tiene datos que desea almacenar en el tipo
propio. Discutiremos los traits en el Capítulo 10. Aquí hay un ejemplo de
declarar e instanciar un struct de unidad llamado <code>AlwaysEqual</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<p>Para definir <code>AlwaysEqual</code>, usamos la palabra clave <code>struct</code>, el nombre que
queremos y luego un punto y coma. ¡No se necesitan llaves ni paréntesis! Luego
podemos obtener una instancia de <code>AlwaysEqual</code> en la variable <code>subject</code> de la
misma manera: usando el nombre que definimos, sin llaves ni paréntesis.
Imagina que más tarde implementaremos un comportamiento para este tipo de tal
manera que cada instancia de <code>AlwaysEqual</code> siempre sea igual a cada instancia
de cualquier otro tipo, tal vez para tener un resultado conocido para fines de
prueba. No necesitaríamos ningún dato para implementar ese comportamiento.
Verás en el Capítulo 10 cómo definir traits e implementarlos en cualquier
tipo, incluidos los structs de unidad.</p>
<blockquote>
<h3 id="ownership-de-los-datos-de-struct"><a class="header" href="#ownership-de-los-datos-de-struct">Ownership de los datos de Struct</a></h3>
<p>En el struct <code>User</code> de la definición en el Listing 5-1, usamos el tipo
<code>String</code> en lugar del tipo <code>&amp;str</code> de la cadena de caracteres. Esta es una
elección deliberada porque queremos que cada instancia de este struct tenga
todos sus datos y que esos datos sean válidos durante todo el tiempo que el
struct sea válido.</p>
<p>También es posible para los structs almacenar referencias a datos que son
propiedad de algo más, pero para hacerlo requiere el uso de <em>lifetimes</em>, una
característica de Rust que discutiremos en el Capítulo 10. Los lifetimes
garantizan que los datos referenciados por un struct sean válidos durante el
tiempo que el struct sea válido. Digamos que intentas almacenar una
referencia en un struct sin especificar lifetimes, como el siguiente; esto
no funcionará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: &quot;someusername123&quot;,
        email: &quot;someone@example.com&quot;,
        sign_in_count: 1,
    };
}</code></pre>
<p>El compilador se quejará de que necesita especificadores de lifetime:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin &quot;structs&quot;) due to 2 previous errors
</code></pre>
<p>En el Capítulo 10, discutiremos como solucionar estos errores para que puedas
almacenar referencias en structs, pero por ahora, solucionaremos los errores
usando tipos propios como <code>String</code> en lugar de referencias como <code>&amp;str</code>.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="un-programa-de-ejemplo-usando-structs"><a class="header" href="#un-programa-de-ejemplo-usando-structs">Un Programa de Ejemplo Usando Structs</a></h2>
<p>Para entender cuándo podríamos querer usar structs, vamos a escribir un
programa que calcule el área de un rectángulo. Empezaremos usando variables
individuales, y luego refactorizaremos el programa hasta que estemos usando
structs.</p>
<p>Hagamos un nuevo proyecto binario con Cargo llamado <em>rectangles</em> que tomará
el ancho y el alto de un rectángulo especificado en píxeles y calculará el área
del rectángulo. La lista 5-8 muestra un programa corto con una forma de hacer
exactamente eso en el <em>src/main.rs</em> de nuestro proyecto.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<p><span class="caption">Listing 5-8: Calculando el área de un rectángulo
especificado por separado en variables ancho y alto</span></p>
<p>Ahora, ejecuta este programa usando <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>Este código logra calcular el área del rectángulo llamando a la función <code>area</code>
con cada dimensión, pero podemos hacer más para hacer este código claro y
legible.</p>
<p>El problema con este código es evidente en la firma de <code>area</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>La función <code>area</code> está supuestamente para calcular el área de un rectángulo, pero
la función que escribimos tiene dos parámetros, y no está claro en ningún
lugar de nuestro programa que los parámetros están relacionados. Sería más
legible y más manejable agrupar el ancho y el alto juntos. Ya hemos discutido
una forma de hacerlo en la sección <a href="ch03-02-data-types.html#el-tipo-tupla">“El Tipo Tupla”</a><!-- ignore
--> del Capítulo 3: usando tuplas.</p>
<h3 id="refactorizando-con-tuplas"><a class="header" href="#refactorizando-con-tuplas">Refactorizando con Tuplas</a></h3>
<p>Listings 5-9 muestra otra versión de nuestro programa que usa tuplas.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<p><span class="caption">Listing 5-9: Especificando el ancho y alto del
rectángulo con una tupla</span></p>
<p>En un sentido, este programa es mejor. Las tuplas nos permiten agregar un poco
de estructura, y ahora estamos pasando solo un argumento. Pero en otro sentido,
esta versión es menos clara: las tuplas no nombran sus elementos, por lo que
tenemos que indexar los componentes de la tupla, haciendo que nuestro
cálculo sea menos obvio.</p>
<p>Mezclar el ancho y el alto no importaría para el cálculo del área, pero si
queremos dibujar el rectángulo en la pantalla, ¡importaría! Tendríamos que
tener en cuenta que <code>width</code> es el índice de la tupla <code>0</code> y <code>height</code> es el índice
de la tupla <code>1</code>. ¡Esto sería aún más difícil para que otra persona lo
descubriera y lo tuviera en cuenta si usara nuestro código! Debido a que no
hemos transmitido el significado de nuestros datos en nuestro código, ahora es
más fácil introducir errores.</p>
<h3 id="refactorizando-con-structs-añadiendo-más-significado"><a class="header" href="#refactorizando-con-structs-añadiendo-más-significado">Refactorizando con Structs: Añadiendo Más Significado</a></h3>
<p>Hemos usado structs para agregar significado al etiquetar los datos. Podemos
transformar la tupla que estamos usando en un struct con un nombre para la estructura y nombres para los campos, como se muestra en la lista 5-10.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<p><span class="caption">Listing 5-10: Definiendo un struct <code>Rectangle</code></span></p>
<p>Hemos definido un struct y lo hemos llamado <code>Rectangle</code>. Dentro de las llaves,
hemos definido los campos como <code>width</code> y <code>height</code>, ambos de los cuales tienen
el tipo <code>u32</code>. Luego, en <code>main</code>, hemos creado una instancia particular de
<code>Rectangle</code> que tiene un ancho de <code>30</code> y un alto de <code>50</code>.</p>
<p>Nuestra función <code>area</code> ahora toma un argumento que es una referencia a una
instancia de <code>Rectangle</code> en lugar de dos parámetros numéricos. En la función,
usamos el punto para acceder a los campos de la instancia de <code>Rectangle</code> que
recibimos como argumento. En <code>main</code>, creamos una instancia de <code>Rectangle</code> y
llamamos a la función <code>area</code> con la instancia de <code>Rectangle</code> como argumento.</p>
<p>La función <code>area</code> accede a los campos de <code>width</code> y <code>height</code> de la instancia de
<code>Rectangle</code> (tenga en cuenta que acceder a los campos de una instancia de
estructura prestada no mueve los valores de los campos, por lo que a menudo
ve préstamos de estructuras). Nuestra firma de función para <code>area</code> ahora dice
exactamente lo que queremos: calcular el área de <code>Rectangle</code>, usando sus
campos <code>width</code> y <code>height</code>. Esto conduce a que el ancho y el alto estén
relacionados entre sí, y da nombres descriptivos a los valores en lugar de
usar los valores de índice de tupla de <code>0</code> y <code>1</code>. ¡Esto es una victoria para
la claridad!</p>
<h3 id="añadiendo-funcionalidad-Útil-con-traits-derivados"><a class="header" href="#añadiendo-funcionalidad-Útil-con-traits-derivados">Añadiendo Funcionalidad Útil con Traits Derivados</a></h3>
<p>Sería útil poder imprimir una instancia de <code>Rectangle</code> mientras estamos
depurando nuestro programa y ver los valores de todos sus campos. La lista 5-11
intenta usar la macro <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a><!-- ignore --> como hemos usado en
capítulos anteriores. Sin embargo, esto no funcionará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {}&quot;, rect1);
}</code></pre>
<p><span class="caption">Listing 5-11: Intentando imprimir una instancia de
<code>Rectangle</code></span></p>
<p>Cuando compilamos este código, obtenemos un error con este mensaje principal:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>La macro <code>println!</code> puede hacer muchos tipos de formateo, y por defecto, las
llaves curvas le dicen a <code>println!</code> que use el formateo conocido como
<code>Display</code>: salida destinada al consumo directo del usuario final. Los tipos
primitivos que hemos visto hasta ahora implementan <code>Display</code> por defecto
porque solo hay una forma en que querrías mostrar un <code>1</code> u otro tipo
primitivo a un usuario. Pero con las estructuras, la forma en que <code>println!</code>
debe formatear la salida es menos clara porque hay más posibilidades de
visualización: ¿Quieres comas o no? ¿Quieres imprimir las llaves curvas? ¿Deben
mostrarse todos los campos? Debido a esta ambigüedad, Rust no intenta adivinar
lo que queremos, y las estructuras no tienen una implementación proporcionada
de <code>Display</code> para usar con <code>println!</code> y el marcador de posición <code>{}</code>.</p>
<p>Si seguimos leyendo los errores, encontraremos esta nota útil:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Intentemos eso. La llamada a la macro <code>println!</code> ahora se verá así:
<code>println!(&quot;rect1 es {rect1:?}&quot;);</code>. Poner el especificador <code>:?</code> dentro de
los corchetes curvos le dice a <code>println!</code> que queremos usar un formato de
salida llamado <code>Debug</code>. El rasgo <code>Debug</code> nos permite imprimir nuestra estructura
de una manera que sea útil para los desarrolladores para que podamos ver su
valor mientras depuramos nuestro código.</p>
<p>Compilamos el código con este cambio. ¡Oh, no! Todavía obtenemos un error:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Pero otra vez, el compilador nos da una nota útil:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>si</em> incluye la funcionalidad para imprimir información de depuración,
pero tenemos que optar explícitamente para hacer que esa funcionalidad esté
disponible para nuestra estructura. Para hacer eso, agregamos el atributo
externo <code>#[derive(Debug)]</code> justo antes de la definición de la estructura, como
se muestra en la lista 5-12.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {rect1:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 5-12: Agregando el atributo para derivar el trait
<code>Debug</code> e imprimiendo la instancia <code>Rectangle</code> usando el formato debug</span></p>
<p>Ahora, cuando compilamos el código, no obtendremos ningún error, y veremos la
siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>¡Bien! No es la salida más bonita, pero muestra los valores de todos los
campos de esta instancia, lo que definitivamente ayudaría durante la
depuración. Cuando tenemos estructuras más grandes, es útil tener una salida
que sea un poco más fácil de leer; en esos casos, podemos usar <code>{:#?}</code> en
lugar de <code>{:?}</code> en el string <code>println!</code>. En este ejemplo, el uso del estilo
<code>{:#?}</code> producirá la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Otra forma de imprimir un valor usando el formato <code>Debug</code> es usar la macro
<a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code></a><!-- ignore -->, que toma el ownership de una expresión (en
oposición a <code>println!</code>, que toma una referencia), imprime el archivo y el
número de línea donde se produce esa llamada a la macro <code>dbg!</code> en su código
junto con el valor resultante de esa expresión, y devuelve el ownership del
valor.</p>
<blockquote>
<p>Nota: Llamar a la macro <code>dbg!</code> imprime en el flujo de consola de error
estándar (<code>stderr</code>), en oposición a <code>println!</code>, que imprime en el flujo de
consola de salida estándar (<code>stdout</code>). Hablaremos más sobre <code>stderr</code> y
<code>stdout</code> en la <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">sección “Escribiendo mensajes de error en el error estándar
en lugar de la salida estándar” del capítulo 12</a><!-- ignore -->.</p>
</blockquote>
<p>Aquí hay un ejemplo en el que estamos interesados en el valor que se asigna al
campo <code>width</code>, así como el valor de todo el struct en <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>Podemos poner <code>dbg!</code> alrededor de la expresión <code>30 * scale</code> y, porque <code>dbg!</code>
devuelve el ownership del valor de la expresión, el campo <code>width</code> tendrá el
mismo valor que si no tuviéramos la llamada <code>dbg!</code> allí. No queremos que <code>dbg!</code>
tome el ownership de <code>rect1</code>, así que usamos una referencia a <code>rect1</code> en la
siguiente llamada. Aquí está el output de este ejemplo:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Podemos ver que el primer bit de salida proviene de la linea 10 de <em>src/main.rs</em> donde estamos depurando la expresión <code>30 * scale</code>, y su valor resultante es
<code>60</code> (el formato de <code>Debug</code> implementado para enteros es imprimir sólo su valor).
La llamada a <code>dbg!</code> en la línea 14 de <em>src/main.rs</em> produce el valor de <code>&amp;rect1</code>,
que es la estructura de <code>Rectangle</code>. Esta salida usa el formato <code>Debug</code> de la
estructura <code>Rectangle</code>. La macro <code>dbg!</code> puede ser realmente útil cuando está
tratando de averiguar qué está haciendo su código.</p>
<p>Además del trait <code>Debug</code>, Rust nos ha proporcionado un número de traits para
que podamos usar con el atributo <code>derive</code> que pueden agregar un comportamiento
útil a nuestros tipos personalizados. Esos traits y sus comportamientos se
enumeran en <a href="appendix-03-derivable-traits.html">el Apéndice C</a><!-- ignore -->. Cubriremos cómo implementar
estos traits con un comportamiento personalizado, así como cómo crear sus
propios traits en el Capítulo 10. También hay muchos atributos más allá de
<code>derive</code>; para obtener más información, consulte <a href="https://doc.rust-lang.org/reference/attributes.html">la sección “Atributos” de la
Referencia de Rust</a>.</p>
<p>Nuestra función <code>area</code> es muy específica: solo calcula el área de
rectángulos. Sería útil vincular este comportamiento más estrechamente a nuestra
estructura <code>Rectangle</code> porque no funcionará con ningún otro tipo. Veamos cómo
podemos continuar refactorizando este código al convertir la función <code>area</code> en
un <em>método</em> <code>area</code> definido en nuestro tipo <code>Rectangle</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p><a id="sintaxis-de-metodos"></a></p>
<h2 id="sintaxis-de-métodos"><a class="header" href="#sintaxis-de-métodos">Sintaxis de Métodos</a></h2>
<p>Los métodos son similares a las funciones: los declaramos con la palabra clave
<code>fn</code> y un nombre, pueden tener parámetros y un valor de retorno, y contienen
alguno código que se ejecuta cuando el método es llamado desde otro lugar.
A diferencia de las funciones, los métodos se definen dentro del contexto de
una estructura (o un enum o un objeto de tipo trait, que cubriremos en el
<a href="ch06-00-enums.html">Capítulo 6</a><!-- ignore --> y el <a href="ch17-02-trait-objects.html">Capítulo 17</a><!-- ignore
-->, respectivamente), y su primer parámetro siempre es <code>self</code>, que representa
la instancia de la estructura en la que se está llamando al método.</p>
<h3 id="definiendo-metodos"><a class="header" href="#definiendo-metodos">Definiendo Metodos</a></h3>
<p>Vamos a cambiar la función <code>area</code> que tiene una instancia de <code>Rectangle</code> como
parámetro y en vez de eso definamos un método <code>area</code> en el struct <code>Rectangle</code>,
como se muestra en el Listado 5-13.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}</code></pre></pre>
<p><span class="caption">Listing 5-13: Definición de un método <code>area</code> en el struct
<code>Rectangle</code> </span></p>
<p>Para definir la función dentro del contexto de <code>Rectangle</code>, iniciamos un bloque
<code>impl</code> (implementación). Todo lo que esté dentro de este bloque <code>impl</code> estará
asociado al tipo <code>Rectangle</code>. Luego movemos la función <code>area</code> dentro de las
llaves del bloque <code>impl</code> y cambiamos el primer (y en este caso, único) parámetro para
ser <code>self</code> en la firma y en todas partes dentro del cuerpo. En <code>main</code>, donde
llamamos a la función <code>area</code> y pasamos <code>rect1</code> como argumento, podemos en vez
de eso usar la <em>sintaxis de método</em> para llamar al método <code>area</code> en nuestra
instancia de <code>Rectangle</code>. La sintaxis de método va después de una instancia: se
agrega un punto seguido del nombre del método, paréntesis y cualquier argumento.</p>
<p>En la firma para <code>area</code>, usamos <code>&amp;self</code> en vez de <code>rectangle: &amp;Rectangle</code>. El
<code>&amp;self</code> es en realidad una abreviatura para <code>self: &amp;Self</code>. Dentro de un bloque
<code>impl</code>, el tipo <code>Self</code> es un alias para el tipo al que pertenece el bloque
<code>impl</code>. Los métodos deben tener un parámetro llamado <code>self</code> de tipo <code>Self</code> para
su primer parámetro, por lo que Rust nos permite abreviar esto con solo el
nombre <code>self</code> en el primer parámetro. Ten en cuenta que aún necesitamos usar el
<code>&amp;</code> antes de la abreviatura <code>self</code> para indicar que este método toma prestada la
instancia <code>Self</code>, al igual que hicimos en <code>rectangle: &amp;Rectangle</code>. Los métodos
pueden tomar la propiedad de <code>self</code>, tomarlo prestado de forma inmutable, como
hemos hecho aquí, o tomarlo prestado de forma mutable, al igual que pueden hacerlo con
cualquier otro parámetro.</p>
<p>Elegimos <code>&amp;self</code> aquí por la misma razón que usamos <code>&amp;Rectangle</code> en la versión
de la función: no queremos tomar la propiedad, y solo queremos leer los datos
en la estructura, no escribir en ella. Si quisiéramos cambiar la instancia en
la que hemos llamado al método como parte de lo que el método hace, usaríamos
<code>&amp;mut self</code> como primer parámetro. Tener un método que tome la propiedad de la
instancia usando solo <code>self</code> como primer parámetro es raro; esta técnica se
usa normalmente cuando el método transforma <code>self</code> en otra cosa y quieres
evitar que el que llama al método use la instancia original después de la
transformación.</p>
<p>La razón principal para usar métodos en vez de funciones, además de proveer la
sintaxis de método y no tener que repetir el tipo de <code>self</code> en cada firma de
método, es para la organización. Hemos puesto todas las cosas que podemos hacer
con una instancia de un tipo en un bloque <code>impl</code> en vez de hacer que los
usuarios futuros de nuestro código busquen las capacidades de <code>Rectangle</code> en
varios lugares en la biblioteca que proveemos.</p>
<p>Nota que podemos elegir darle al método el mismo nombre que uno de los campos
del struct. Por ejemplo, podemos definir un método en <code>Rectangle</code> que se llame
<code>width</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}</code></pre></pre>
<p>Aquí, estamos eligiendo que el método <code>width</code> retorne <code>true</code> si el valor en el
campo <code>width</code> de la instancia es mayor que <code>0</code> y <code>false</code> si el valor es <code>0</code>:
podemos usar un campo dentro de un método del mismo nombre para cualquier
propósito. En <code>main</code>, cuando seguimos <code>rect1.width</code> con paréntesis, Rust sabe
que queremos decir el método <code>width</code>. Cuando no usamos paréntesis, Rust sabe
que queremos decir el campo <code>width</code>.</p>
<p>A veces, pero no siempre, cuando damos un método el mismo nombre que un campo
queremos que solo retorne el valor en el campo y no haga nada más. Los métodos
como este se llaman <em>getters</em>, y Rust no los implementa automáticamente para
los campos de un struct como lo hacen otros lenguajes. Los getters son útiles
porque puedes hacer que el campo sea privado, pero el método sea público, y así
permitir acceso de solo lectura a ese campo como parte de la API pública del
tipo. Hablaremos de qué es público y privado y cómo designar un campo o método
como público o privado en el <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exponiendo-rutas-con-la-palabra-clave-pub">Capítulo 7</a><!-- ignore -->.</p>
<blockquote>
<h3 id="donde-esta-el-operador--"><a class="header" href="#donde-esta-el-operador--">¿Donde esta el Operador <code>-&gt;</code>?</a></h3>
<p>En C y C++, se usan dos operadores diferentes para llamar a métodos: se usa
<code>.</code> si se está llamando a un método en el objeto directamente y <code>-&gt;</code> si se
está llamando al método en un puntero al objeto y se necesita desreferenciar
el puntero primero. En otras palabras, si <code>object</code> es un puntero,
<code>object-&gt;something()</code> es similar a <code>(*object).something()</code>.</p>
<p>Rust no tiene un equivalente al operador <code>-&gt;</code>; en su lugar, Rust tiene una
característica llamada <em>referenciación y desreferenciación automáticas</em>.
Llamar a métodos es uno de los pocos lugares en Rust donde se tiene este
comportamiento.</p>
<p>Así es como funciona: cuando llamas a un método con <code>object.something()</code>,
Rust automáticamente agrega <code>&amp;</code>, <code>&amp;mut</code>, o <code>*</code> para que <code>object</code> coincida
con la firma del método. En otras palabras, lo siguiente es lo mismo:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>El primer ejemplo es más limpio. Este comportamiento de referencia y
desreferenciación automática funciona porque los métodos tienen un receptor
claro: el tipo de <code>self</code>. Dado el receptor y el nombre de un método, Rust
puede determinar con certeza si el método está leyendo (<code>&amp;self</code>), mutando
(<code>&amp;mut self</code>), o consumiendo (<code>self</code>). El hecho de que Rust haga que el
préstamo sea implícito para los receptores de método es una gran parte de
hacer que la propiedad sea ergonómica en la práctica.</p>
</blockquote>
<h3 id="métodos-con-más-parámetros"><a class="header" href="#métodos-con-más-parámetros">Métodos con más parámetros</a></h3>
<p>Practiquemos usando métodos implementando un segundo método en la estructura
<code>Rectangle</code>. Esta vez queremos que una instancia de <code>Rectangle</code> tome otra
instancia de <code>Rectangle</code> y retorne <code>true</code> si el segundo <code>Rectangle</code> puede
completamente caber dentro de <code>self</code> (el primer <code>Rectangle</code>); de lo
contrario, debería retornar <code>false</code>. Es decir, una vez que hayamos definido el
método <code>can_hold</code>, queremos poder escribir el programa mostrado en el
Listing 5-14.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}</code></pre>
<p><span class="caption">Listing 5-14: Uso del método <code>can_hold</code> aún no escrito
</span></p>
<p>La salida esperada se vería como la siguiente porque ambas dimensiones de
<code>rect2</code> son más pequeñas que las dimensiones de <code>rect1</code>, pero <code>rect3</code> es más
ancha que <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Sabemos que queremos definir un método, por lo que estará dentro del bloque
<code>impl Rectangle</code>. El nombre del método será <code>can_hold</code>, y tomará un préstamo
inmutable de otro <code>Rectangle</code> como parámetro. Podemos decir cuál será el tipo
del parámetro mirando el código que llama al método: <code>rect1.can_hold(&amp;rect2)</code>
pasa <code>&amp;rect2</code>, que es un préstamo inmutable a <code>rect2</code>, una instancia de
<code>Rectangle</code>. Esto tiene sentido porque solo necesitamos leer <code>rect2</code> (en lugar
de escribir, lo que significaría que necesitaríamos un préstamo mutable), y
queremos que <code>main</code> conserve la propiedad de <code>rect2</code> para que podamos usarlo
nuevamente después de llamar al método <code>can_hold</code>. El valor de retorno de
<code>can_hold</code> será un Booleano, y la implementación verificará si el ancho y
alto de <code>self</code> son mayores que el ancho y alto del otro <code>Rectangle</code>,
respectivamente. Agreguemos el nuevo método <code>can_hold</code> al bloque <code>impl</code> del
Listing 5-13 que se muestra en el Listing 5-15.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-15: Implementando el método <code>can_hold</code> en
<code>Rectangle</code> que toma otra instancia de <code>Rectangle</code> como un parámetro</span></p>
<p>Cuando ejecutamos este código con la función <code>main</code> en el Listing 5-14,
obtendremos el resultado deseado. Los métodos pueden tomar múltiples parámetros
que agregamos a la firma después del parámetro <code>self</code>, y esos parámetros
funcionan igual que los parámetros en las funciones.</p>
<h3 id="funciones-asociadas"><a class="header" href="#funciones-asociadas">Funciones asociadas</a></h3>
<p>Todas las funciones definidas dentro de un bloque <code>impl</code> se llaman <em>funciones
asociadas</em> porque están asociadas con el tipo nombrado después del <code>impl</code>.
Podemos definir funciones asociadas que no tengan <code>self</code> como su primer
parámetro (y, por lo tanto, no sean métodos) porque no necesitan una instancia del
tipo con el que trabajar. Ya hemos usado una función como esta: la función
<code>String::from</code> que está definida en el tipo <code>String</code>.</p>
<p>Las funciones asociadas que no son métodos son a menudo utilizadas para
constructores que devolverán una nueva instancia de la estructura. Estás
a menudo se llaman <code>new</code>, pero <code>new</code> no es un nombre especial y no está
incorporado en el lenguaje. Por ejemplo, podríamos elegir proporcionar una
función asociada llamada <code>square</code> que tendría un parámetro de dimensión y lo
usaría como ancho y alto, de modo que sea más fácil crear un <code>Rectangle</code>
cuadrado en lugar de tener que especificar el mismo valor dos veces:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>La palabra clave <code>Self</code> en el tipo de retorno y en el cuerpo de la función es
un alias para el tipo que aparece después de la palabra clave <code>impl</code>, que en
este caso es <code>Rectangle</code>.</p>
<p>Para llamar a esa función asociada, usamos la sintaxis <code>::</code> con el nombre de
la estructura; <code>let sq = Rectangle::square(3);</code> es un ejemplo. Esta función
está dentro del namespace de la estructura. La sintaxis <code>::</code> se usa tanto
para las funciones asociadas como para los namespaces creados por los
módulos. Discutiremos los módulos en el <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">Capítulo 7</a><!-- ignore -->.</p>
<h3 id="bloques-impl-múltiples"><a class="header" href="#bloques-impl-múltiples">Bloques <code>impl</code> múltiples</a></h3>
<p>Cada struct es permitido tener múltiples bloques <code>impl</code>. Por ejemplo, el
Listing 5-15 es equivalente al código mostrado en el Listing 5-16, que tiene
cada método en su propio bloque <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-16: Reescribiendo Listing 5-15 usando múltiples
bloques <code>impl</code></span></p>
<p>No hay razón para separar estos métodos en múltiples bloques <code>impl</code> aquí, pero
esta es una sintaxis válida. Veremos un caso en el que los múltiples bloques
<code>impl</code> son útiles en el Capítulo 10, donde discutiremos los tipos genéricos y
los traits.</p>
<h2 id="resumen-4"><a class="header" href="#resumen-4">Resumen</a></h2>
<p>Los structs te permiten crear tipos personalizados que son significativos para
su dominio. Al usar structs, puede mantener piezas de datos asociadas entre sí
y nombrar cada pieza para hacer que su código sea claro. En los bloques <code>impl</code>,
puede definir funciones que están asociadas con su tipo, y los métodos son un
tipo de función asociada que le permite especificar el comportamiento que
tienen las instancias de sus structs.</p>
<p>Pero los structs no son la única forma de crear tipos personalizados: pasemos
a la función enum de Rust para agregar otra herramienta a su toolbox.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-y-pattern-matching"><a class="header" href="#enums-y-pattern-matching">Enums y Pattern Matching</a></h1>
<p>En este capítulo, vamos a ver las <em>enumeraciones</em>, también conocidos como
<em>enums</em>. Los enums te permiten definir un tipo enumerando sus posibles
<em>variantes</em>. Primero definiremos y usaremos un enum para mostrar cómo un
enum puede codificar el significado junto con datos. A continuación,
exploraremos un enum particularmente útil, llamado <code>Option</code>, que
expresa que un valor puede ser algo o nada. Luego veremos cómo el
patrón de coincidencia en la expresión <code>match</code> hace que sea fácil
ejecutar un código diferente para diferentes valores de un enum.
Finalmente, veremos cómo la construcción <code>if let</code> es otra expresión
conveniente y concisa disponible para manejar enums en su código.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definiendo-un-enum"><a class="header" href="#definiendo-un-enum">Definiendo un Enum</a></h2>
<p>Los <code>struct</code> te permiten agrupar campos relacionados y datos, como un <code>Rectángulo</code>
con su <code>ancho</code> y <code>largo</code>. Por otro lado, los enums te permiten decir que
un valor es uno de un conjunto de posibles valores. Por ejemplo, podríamos querer
decir que <code>Rectángulo</code> es uno de un conjunto de posibles formas que también
incluye <code>Circulo</code> y <code>Triangulo</code>. Para hacer esto, Rust nos permite codificar estas
posibilidades como un <code>enum</code>.</p>
<p>Vamos a ver una situación que podemos expresar en código y veremos por qué
los enums son útiles y más apropiados que los structs en este caso. Digamos
que tenemos que trabajar con direcciones IP. Actualmente, existen dos estándares
que se usan para direcciones IP: la versión cuatro y la versión seis.
Como estos son los únicos posibles tipos de direcciones IP que nuestro
programa encontrará, podemos <em>enumerar</em> todas las variantes posibles, de
donde viene el nombre de <code>enum</code>.</p>
<p>Cualquier dirección IP puede ser una dirección de la versión cuatro o la versión
seis, pero no ambas al mismo tiempo. Esa propiedad de las direcciones IP hace
que la estructura de datos <code>enum</code> sea apropiada porque un valor <code>enum</code> puede ser
sólo una de sus variantes. Tanto las direcciones de la versión cuatro como la versión seis
siguen siendo fundamentalmente direcciones IP, por lo que deben ser
tratadas como el mismo tipo cuando el código está manejando situaciones que se
aplican a cualquier tipo de dirección IP.</p>
<p>Podemos expresar este concepto en código definiendo el enum <code>IpAddrKind</code>
y enumerando los posibles tipos de direcciones IP, <code>V4</code> y <code>V6</code>. Estas son las
variantes del <code>enum</code>:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> ahora es un tipo de datos personalizado que podemos usar en otras
partes de nuestro código.</p>
<h3 id="valores-enum"><a class="header" href="#valores-enum">Valores Enum</a></h3>
<p>Podemos crear instancias de cada una de las dos variantes de <code>IpAddrKind</code> de
esta manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Nota que las variantes del <code>enum</code> están en el mismo espacio de nombres bajo su
identificador, y usamos dos puntos para separar los dos. Esto es útil porque
ahora ambos valores <code>IpAddrKind::V4</code> e <code>IpAddrKind::V6</code> son del mismo tipo:
<code>IpAddrKind</code>. Podemos entonces, por ejemplo, definir una función que tome
cualquier <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>Y podemos llamar a esta función con cualquiera de las variantes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Usando <code>enum</code> tiene aún más ventajas. Pensando más en nuestro tipo de dirección
IP, en este momento no tenemos una forma de almacenar los datos reales de la
dirección IP; solo sabemos qué tipo es. Dado que acabas de aprender sobre los
structs en el Capítulo 5, podrías estar tentado a abordar este problema con
structs como se muestra en el Listing 6-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 6-1: Almacenando los datos y la variante
<code>IpAddrKind</code> de una dirección IP usando un <code>struct</code></span></p>
<p>Aquí, hemos definido un struct <code>IpAddr</code> que tiene dos campos: un campo <code>kind</code>
que es de tipo <code>IpAddrKind</code> (el <code>enum</code> que definimos anteriormente) y un campo
<code>address</code> de tipo <code>String</code>. Tenemos dos instancias de este struct. La primera
es <code>home</code>, y tiene el valor <code>IpAddrKind::V4</code> como su <code>kind</code> como datos de
dirección asociados de <code>127.0.0.1</code>. La segunda instancia es <code>loopback</code>. Tiene
la otra variante de <code>IpAddrKind</code> como su valor <code>kind</code>, <code>V6</code>, y tiene la
dirección <code>::1</code> asociada con ella. Hemos usado un struct para agrupar los
valores <code>kind</code> y <code>address</code> juntos, así que ahora la variante está asociada con
el valor.</p>
<p>Sin embargo, representar el mismo concepto usando sólo un <code>enum</code> es más conciso:
en lugar de un <code>enum</code> dentro de un struct, podemos poner datos directamente en
cada variante de <code>enum</code>. Esta nueva definición del enum <code>IpAddr</code> dice que tanto
las variantes <code>V4</code> como <code>V6</code> tendrán valores <code>String</code> asociados:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Adjuntamos datos a cada variante del <code>enum</code> directamente, por lo que no hay
necesidad de un struct extra. Aquí, también es más fácil ver otro detalle
de cómo funcionan los enums: el nombre de cada variante de <code>enum</code> que definimos
también se convierte en una función que construye una instancia del tipo <code>enum</code>.
Es decir, <code>IpAddr::V4()</code> es una llamada a función que toma un argumento
<code>String</code> y devuelve una instancia del tipo <code>IpAddr</code>. Obtenemos automáticamente
esta función constructora definida como resultado de definir el <code>enum</code>.</p>
<p>Hay otra ventaja de usar un <code>enum</code> en lugar de un struct: cada variante puede
tener diferentes tipos y cantidades de datos asociados con ella. La versión
cuatro de las direcciones IP siempre tendrá cuatro componentes numéricos que
tendrán valores entre 0 y 255. Si quisiéramos almacenar las direcciones <code>V4</code>
como cuatro valores <code>u8</code> pero aun así expresar las direcciones <code>V6</code> como un
valor <code>String</code>, no podríamos hacerlo con un struct. Los enums manejan este caso
con facilidad:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Hemos mostrado varias formas diferentes de definir estructuras de datos para
almacenar direcciones IP de la versión cuatro y de la versión seis. Sin embargo,
resulta que querer almacenar direcciones IP y codificar de que tipo son es tan común
que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la biblioteca estándar tiene una definición que podemos usar!</a><!-- ignore -->
Veamos cómo define la biblioteca estándar <code>IpAddr</code>: tiene el <code>enum</code> exacto y las
variantes que hemos definido y usado, pero incrusta los datos de dirección
dentro de las variantes en forma de dos structs diferentes, que se definen de
manera diferente para cada variante:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>Este código ilustra que puedes poner cualquier tipo de datos dentro de una
variante de <code>enum</code>: strings, tipos numéricos o structs, por ejemplo. ¡Incluso
puedes incluir otro <code>enum</code>! Además, los tipos de biblioteca estándar a menudo no
son mucho más complicados de lo que podrías idear.</p>
<p>Ten en cuenta que aunque la biblioteca estándar contiene una definición para
<code>IpAddr</code>, aún podemos crear y usar nuestra propia definición sin conflicto
porque no hemos traído la definición de la biblioteca estándar a nuestro
contexto de ejecución. Hablaremos más sobre cómo traer tipos al contexto de ejecución en el Capítulo 7.</p>
<p>Veamos otro ejemplo de una enumeración en el Listing 6-2: este tiene una amplia
variedad de tipos incrustados en sus variantes.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 6-2: Un enum <code>Message</code> cuyas variantes almacenan
diferentes cantidades y tipos de valores</span></p>
<p>Este <code>enum</code> tiene cuatro variantes con diferentes tipos:</p>
<ul>
<li><code>Quit</code> no tiene ningún dato asociado.</li>
<li><code>Move</code> tiene campos nombrados, como lo haría un struct.</li>
<li><code>Write</code> incluye un solo <code>String</code>.</li>
<li><code>ChangeColor</code> incluye tres valores <code>i32</code>.</li>
</ul>
<p>Definiendo un <code>enum</code> con variantes como las del Listing 6-2 es similar a
definir diferentes tipos de definiciones de struct, excepto que el <code>enum</code> no
use la palabra clave <code>struct</code> y todas las variantes están agrupadas juntas
bajo el tipo <code>Message</code>. Los siguientes structs podrían contener los mismos
datos que las variantes de <code>enum</code> anteriores:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Pero si usamos los diferentes structs, cada uno de los cuales tiene su propio
tipo, no podríamos definir tan fácilmente una función para tomar cualquiera
de estos tipos de mensajes como podríamos con el enum <code>Message</code> definido en
el Listing 6-2, que es un solo tipo.</p>
<p>Hay una similitud entre enums y structs que puede ser útil de recordar: al
igual que puedes definir métodos en structs usando <code>impl</code>, puedes definir
métodos en enums. Aquí hay un método llamado <code>call</code> que podemos definir en
nuestro enum <code>Message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>El cuerpo del método usaría <code>self</code> para obtener el valor en el que llamamos
el método. En este ejemplo, hemos creado una variable <code>m</code> que tiene el valor
<code>Message::Write(String::from(&quot;hello&quot;))</code>, y eso es lo que será <code>self</code> en el
cuerpo del método <code>call</code> cuando se ejecute <code>m.call()</code>.</p>
<p>Veamos otro <code>enum</code> en la librería estándar que es muy común y útil: <code>Option</code>.</p>
<h3 id="el-enum-option-y-sus-ventajas-sobre-los-valores-null"><a class="header" href="#el-enum-option-y-sus-ventajas-sobre-los-valores-null">El Enum <code>Option</code> y Sus Ventajas Sobre los Valores Null</a></h3>
<p>Esta sección explora un caso de estudio de <code>Option</code>, que es otro <code>enum</code> definido
por la biblioteca estándar. El tipo <code>Option</code> codifica el escenario muy común en
el que un valor podría ser algo o podría ser nada.</p>
<p>Por ejemplo, si solicita el primer elemento de una lista no vacía, obtendría un
valor. Si solicita el primer elemento de una lista vacía, no obtendría nada.
Expresar este concepto en términos del sistema de tipos significa que el
compilador puede verificar si ha manejado todos los casos que debería estar
manejando; esta funcionalidad puede prevenir errores que son extremadamente
comunes en otros lenguajes de programación.</p>
<p>El diseño del lenguaje de programación a menudo se piensa en términos de qué
características se incluyen, pero las características que se excluyen son
importantes también. Rust no tiene la característica de null que muchos otros
lenguajes tienen. <em>Null</em> es un valor que significa que no hay ningún valor
allí. En los lenguajes con null, las variables siempre pueden estar en uno de
dos estados: null o no null.</p>
<p>En su presentación del 2009 “Null References: The Billion Dollar Mistake”,
Tony Hoare, el inventor de null, tiene esto que decir:</p>
<blockquote>
<p>Llámalo mi error de un billón de dólares. En ese momento, estaba diseñando el
primer sistema de tipos completo para referencias en un lenguaje de
programación orientado a objetos. Mi objetivo era asegurarme de que todo el
uso de referencias fuera absolutamente seguro, con verificación realizada
automáticamente por el compilador. Pero no pude resistir la tentación de
poner un valor null, simplemente porque era tan fácil de implementar. Esto a
dado lugar a innumerables errores, vulnerabilidades y bloqueos del sistema,
que probablemente han causado un billón de dólares de dolor y daños en los
últimos cuarenta años.</p>
</blockquote>
<p>El problema con los valores null es que si intentas utilizar un valor null como
un valor no null, obtendrás un error de algún tipo. Debido a que esta propiedad
nula o no nula es omnipresente, es extremadamente fácil cometer este tipo de error.</p>
<p>Sin embargo, el concepto que null está tratando de expresar sigue siendo
útil: un null es un valor que es actualmente inválido o ausente por alguna
razón.</p>
<p>El problema no es realmente con el concepto, sino con la implementación
particular. Como tal, Rust no tiene null, pero tiene un <code>enum</code> que puede
codificar el concepto de un valor presente o ausente. Este <code>enum</code> es
<code>Option&lt;T&gt;</code>, y está <a href="https://doc.rust-lang.org/std/option/enum.Option.html">definido por la biblioteca estándar</a><!-- ignore -->
de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>El enum <code>Option&lt;T&gt;</code> es tan útil que incluso está incluido en el <a href="ch02-00-guessing-game-tutorial.html#prelude-meaning">prelude</a>; no
necesitas traerlo al contexto de ejecución explícitamente. Sus variantes también están
incluidas en el prelude: puedes usar <code>Some</code> y <code>None</code> directamente sin el
prefijo <code>Option::</code>. El enum <code>Option&lt;T&gt;</code> es aún un <code>enum</code> regular, y <code>Some(T)</code>
y <code>None</code> son aún variantes de tipo <code>Option&lt;T&gt;</code>.</p>
<p>La sintaxis <code>&lt;T&gt;</code> es una característica de Rust que aún no hemos hablado. Es
un parámetro de tipo genérico, y cubriremos los genéricos en más detalle en
el Capítulo 10. Por ahora, todo lo que necesitas saber es que <code>&lt;T&gt;</code> significa
que la variante <code>Some</code> del enum <code>Option</code> puede contener una pieza de datos de
cualquier tipo, y que cada tipo concreto que se usa en lugar de <code>T</code> hace que
el tipo <code>Option&lt;T&gt;</code> general sea un tipo diferente. Aquí hay algunos ejemplos
de usar valores <code>Option</code> para contener tipos de números y tipos de strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>El tipo de <code>some_number</code> es <code>Option&lt;i32&gt;</code>. El tipo de <code>some_string</code> es
<code>Option&lt;String&gt;</code>, que es un tipo diferente. Rust puede inferir estos tipos
porque hemos especificado un valor dentro de la variante <code>Some</code>. Para
<code>absent_number</code>, Rust requiere que anotemos el tipo general <code>Option</code>: el
compilador no puede inferir el tipo que tendrá la variante <code>Some</code> correspondiente
mirando sólo un valor <code>None</code>. Aquí, le decimos a Rust que queremos
que <code>absent_number</code> sea del tipo <code>Option&lt;i32&gt;</code>.</p>
<p>Cuando tenemos un valor <code>Some</code>, sabemos que un valor está presente y el valor
se mantiene dentro del <code>Some</code>. Cuando tenemos un valor <code>None</code>, en cierto
sentido significa lo mismo que null: no tenemos un valor válido. Entonces,
¿por qué tener <code>Option&lt;T&gt;</code> es mejor que tener null?</p>
<p>En resumen, porque <code>Option&lt;T&gt;</code> y <code>T</code> (donde <code>T</code> puede ser cualquier tipo) son
tipos diferentes, el compilador no nos permitirá usar un valor <code>Option&lt;T&gt;</code> como
si fuera definitivamente un valor válido. Por ejemplo, este código no se
compilará, porque está tratando de agregar un <code>i8</code> a un <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>Si ejecutamos este código, obtenemos un mensaje de error como este:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            &lt;i8 as Add&gt;
            &lt;i8 as Add&lt;&amp;i8&gt;&gt;
            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;
            &lt;&amp;i8 as Add&lt;&amp;i8&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error
</code></pre>
<p>¡Intenso! En efecto, este mensaje de error significa que Rust no entiende cómo
agregar un <code>i8</code> y un <code>Option&lt;i8&gt;</code>, porque son tipos diferentes. Cuando tenemos
un valor de un tipo como <code>i8</code> en Rust, el compilador se asegurará de que
siempre tengamos un valor válido. Podemos proceder con confianza sin tener que
comprobar si es null antes de usar ese valor. Solo cuando tenemos un
<code>Option&lt;i8&gt;</code> (o el tipo de valor que estemos trabajando) tenemos que preocuparnos
por posiblemente no tener un valor, y el compilador se asegurará de que
manejemos ese caso antes de usar el valor.</p>
<p>En otras palabras, tienes que convertir un <code>Option&lt;T&gt;</code> a un <code>T</code> antes de que
puedas realizar operaciones <code>T</code> con él. Generalmente, esto ayuda a detectar uno
de los errores más comunes con null: asumiendo que algo no es null cuando
realmente lo es.</p>
<p>Eliminar el riesgo de asumir incorrectamente un valor no null
ayuda a tener más confianza en su código. Para tener un valor que
posiblemente pueda ser null, debe optar explícitamente por hacer que el tipo de ese
valor sea <code>Option&lt;T&gt;</code>. Entonces, cuando use ese valor, se le requerirá
expresar explícitamente el caso cuando el valor es null. Siempre que un valor tenga un tipo que no sea <code>Option&lt;T&gt;</code>, se <em>puede</em>
asumir con seguridad que el valor no es null. Esta fue una decisión
deliberada del diseño de Rust para limitar la omnipresencia de nulls y
aumentar la seguridad del código de Rust.</p>
<p>Entonces ¿cómo obtienes el valor <code>T</code> de un <code>Some</code> cuando tienes un valor de
tipo <code>Option&lt;T&gt;</code> para que puedas usar ese valor? El enum <code>Option&lt;T&gt;</code> tiene una
gran cantidad de métodos que son útiles en una variedad de situaciones; puedes
verlos en <a href="https://doc.rust-lang.org/std/option/enum.Option.html">su documentación</a><!-- ignore -->. Familiarizarse con los
métodos en <code>Option&lt;T&gt;</code> será extremadamente útil en su viaje con Rust.</p>
<p>En general, para usar un valor <code>Option&lt;T&gt;</code>, querrás tener código que maneje
cada variante. Quieres tener algún código que se ejecute solo cuando tienes un
valor <code>Some(T)</code>, y este código está permitido de usar el <code>T</code> interno. Quieres
tener algún otro código que se ejecute solo si tienes un valor <code>None</code>, y ese
código no tiene un valor <code>T</code> disponible. La expresión <code>match</code> es una
construcción de flujo de control que hace exactamente esto cuando se usa con
enums: ejecutará diferente código dependiendo de la variante del <code>enum</code> que
tenga, y ese código puede usar los datos dentro del valor que coincida.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="el-operador-de-control-de-flujo-match"><a class="header" href="#el-operador-de-control-de-flujo-match">El operador de control de flujo <code>match</code></a></h2>
<p>Rust tiene una construcción de flujo de control extremadamente poderosa llamada
<code>match</code> que te permite comparar un valor contra una serie de patrones y luego
ejecutar código basado en qué patrón coincide. Los patrones pueden estar
compuestos de valores literales, nombres de variables, comodines y muchas otras
cosas; El <a href="ch18-00-patterns.html">Capítulo 18</a><!-- ignore --> cubre todos los
diferentes tipos de patrones y lo que hacen. El poder de <code>match</code> viene de la
expresividad de los patrones y el hecho de que el compilador confirma que se
tratan todos los casos posibles.</p>
<p>Piensa en una expresión <code>match</code> como una máquina de clasificación de monedas:
las monedas deslizan a lo largo de una pista con orificios de diversos tamaños
a lo largo de ella, y cada moneda cae a través del primer orificio que encuentra
que se ajusta a ella. De la misma manera, los valores pasan a través de cada
patrón en un <code>match</code>, y en el primer patrón en el que el valor “se ajusta”, el
valor cae en el bloque de código asociado para ser utilizado durante la
ejecución.</p>
<p>Hablando de monedas, ¡usémoslas como un ejemplo usando <code>match</code>! Podemos escribir
una función que tome una moneda desconocida de los Estados Unidos y, de una
manera similar a la máquina de conteo, determine qué moneda es y devuelva su
valor en centavos, como se muestra en el Listing 6-3.</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 6-3: Una expresión <code>enum</code> y <code>match</code> que tiene
las variantes del enum como sus patrones</span></p>
<p>Desglosemos el uso de <code>match</code> en la función <code>value_in_cents</code>.
Primero listamos la palabra clave <code>match</code> seguida de una expresión,
que en este caso es el valor <code>coin</code>. Esto parece muy similar a una expresión
condicional utilizada con <code>if</code>, pero hay una gran diferencia: con <code>if</code>,
la condición debe evaluar a un valor Booleano, pero aquí puede ser cualquier
tipo. El tipo de <code>coin</code> en este ejemplo es el enum <code>Coin</code> que definimos en la
primera línea.</p>
<p>A continuación, dentro de las llaves de <code>match</code>, hay un número de Opciones.
Una Opción tiene dos partes: un patrón y algún código. La primera Opción aquí
tiene un patrón que es el valor <code>Coin::Penny</code> y luego el operador <code>=&gt;</code> que
separa el patrón y el código a ejecutar. El código en este caso es solo el valor
<code>1</code>. Cada Opción está separado del siguiente con una coma.</p>
<p>Cuando la expresión <code>match</code> se ejecuta, compara el valor resultante contra el
patrón de cada Opción, en orden. Si un patrón coincide con el valor, se ejecuta
el código asociado con ese patrón. Si ese patrón no coincide con el valor,
la ejecución continúa en la siguiente Opción, como en una máquina de
clasificación de monedas. Podemos tener tantas Opciones como necesitemos:
en el Listado 6-3, nuestro <code>match</code> tiene cuatro Opciones.</p>
<p>El código asociado con cada Opción es una expresión, y el valor resultante de
la expresión en la Opción coincidente es el valor que se devuelve para la
expresión <code>match</code> completa.</p>
<p>Por lo general, no usamos llaves si el código de la Opción de match es
corto, como lo es en el Listado 6-3, donde cada Opción solo devuelve un valor.
Si desea ejecutar varias líneas de código en una Opción de match, debe
usar llaves, y la coma que sigue a la Opción es opcional. Por ejemplo,
el siguiente código imprime “¡Moneda de la suerte!” cada vez que el método
se llama con un <code>Coin::Penny</code>, pero aún devuelve el último valor del bloque,
<code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="patrones-que-vinculan-valores"><a class="header" href="#patrones-que-vinculan-valores">Patrones que vinculan valores</a></h3>
<p>Otra característica útil de las Opciones de match es que pueden vincularse
a las partes del valor que coinciden con el patrón. Esto es cómo podemos extraer
valores de las variantes de enum.</p>
<p>Como ejemplo, podemos cambiar el código de la función <code>value_in_cents</code> para
que, en lugar de devolver un valor, imprima el valor que tiene. Esto nos
permite ver qué moneda tenemos y cuánto vale. Para hacer esto, necesitamos
convertir el código de cada Opción en una expresión, y luego usar una
expresión <code>println!</code> en lugar de un valor de retorno. También necesitamos
cambiar el tipo de <code>value_in_cents</code> a <code>()</code>, ya que no estamos devolviendo un
valor entero, sino que estamos ejecutando código. El código completo se muestra
en el Listing 6-4.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 6-4: Un enum <code>Coin</code> en el cual la variante
<code>Quarter</code> también contiene un valor <code>UsState</code></span></p>
<p>Imaginemos que tenemos un amigo que está tratando de coleccionar todas las
monedas de 50 estados. Mientras clasificamos nuestra moneda suelta por tipo de
moneda, también llamaremos al nombre del estado asociado con cada moneda de
50 centavos para que si es uno que no tiene, pueda agregarlo a su colección.</p>
<p>En la expresión <code>match</code> en el Listado 6-4, podemos agregar <code>UsState::Alaska</code> a
la variante <code>Coin::Quarter</code> para crear una nueva variante de <code>Coin</code>. Cuando
hacemos esto, el estado de Alaska se adjunta a la moneda. Luego, cuando
ejecutamos el código, podemos ver el valor del estado almacenado en la
moneda de 50 centavos al imprimirlo. El código completo se muestra en el
Listing 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {state:?}!&quot;);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>Si llamáramos a <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code> sería
<code>Coin::Quarter(UsState::Alaska)</code>. Cuando comparamos ese valor con cada una de
las Opciones de match, ninguno coincide hasta que llegamos a
<code>Coin::Quarter(state)</code>. En ese punto, el enlace para <code>state</code> será el valor
<code>UsState::Alaska</code>. Luego podemos usar ese enlace en la expresión <code>println!</code>,
obteniendo así el valor del estado interno de la variante de <code>Coin</code> para
<code>Quarter</code>.</p>
<h3 id="match-con-optiont"><a class="header" href="#match-con-optiont">Match con <code>Option&lt;T&gt;</code></a></h3>
<p>En la sección anterior, queríamos obtener el valor interno <code>T</code> de la variante
<code>Some</code> cuando se usaba <code>Option&lt;T&gt;</code>; también podemos manejar <code>Option&lt;T&gt;</code> usando
<code>match</code>, como lo hicimos con el enum <code>Coin</code>! En lugar de comparar monedas,
compararemos las variantes de <code>Option&lt;T&gt;</code>, pero la forma en que funciona la
expresión <code>match</code> sigue siendo la misma.</p>
<p>Digamos que queremos escribir una función que tome un <code>Option&lt;i32&gt;</code> y, si
hay un valor dentro, agregue 1 a ese valor. Si no hay un valor dentro, la
función debe devolver el valor <code>None</code> y no intentar realizar ninguna
operación.</p>
<p>Esta función es muy fácil de escribir, gracias a <code>match</code>, y se verá como el
Listing 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 6-5: Una función que usa una expresión <code>match</code> en
un <code>Option&lt;i32&gt;</code></span></p>
<p>Examinemos la primera ejecución de <code>plus_one</code> en más detalle. Cuando llamamos
a <code>plus_one(five)</code>, la variable <code>x</code> en el cuerpo de <code>plus_one</code> tendrá el
valor <code>Some(5)</code>. Luego comparamos eso contra cada Opción de match:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>El valor <code>Some(5)</code> no coincide con el patrón <code>None</code>, por lo que seguimos a la
siguiente Opción:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>¿Coincide <code>Some(5)</code> con <code>Some(i)</code>? ¡Lo hace! Tenemos la misma variante. Él
<code>i</code> se vincula al valor contenido en <code>Some</code>, por lo que <code>i</code> toma el valor <code>5</code>.
Luego se ejecuta el código en la Opción de match, por lo que agregamos 1
al valor de <code>i</code> y creamos un nuevo valor <code>Some</code> con nuestro total <code>6</code> dentro.</p>
<p>Ahora consideremos la segunda llamada a <code>plus_one</code> en el Listing 6-5, donde
<code>x</code> es <code>None</code>. Entramos en el <code>match</code> y comparamos con la primera Opción:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>¡Coincide! No hay valor para agregar, por lo que el programa se detiene y
devuelve el valor <code>None</code> en el lado derecho de <code>=&gt;</code>. Debido a que la primera
Opción coincidió, no se comparan otras Opciones.</p>
<p>Combinando <code>match</code> y enums es útil en muchas situaciones. Verás este patrón
mucho en el código Rust: <code>match</code> contra un enum, vincula una variable a los
datos internos y luego ejecuta el código en función de él. Es un poco
complicado al principio, pero una vez que te acostumbras, desearás tenerlo en
todos los lenguajes. Es consistentemente un favorito de los usuarios.</p>
<h3 id="los-matches-son-exhaustivos"><a class="header" href="#los-matches-son-exhaustivos">Los matches son exhaustivos</a></h3>
<p>Hay otro aspecto de <code>match</code> que debemos discutir: los patrones de las Opciones
deben cubrir todas las posibilidades. Considera esta versión de nuestra
función <code>plus_one</code>, que tiene un error y no se compila:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>No manejamos el caso <code>None</code>, por lo que este código causará un error.
Afortunadamente, es un error que Rust sabe cómo detectar. Si intentamos
compilar este código, obtendremos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:572:1
 ::: /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:576:5
  |
  = note: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error
</code></pre>
<p>Rust sabe que no cubrimos todos los casos posibles, e incluso sabe qué
patrón olvidamos! Los matches en Rust son <em>exhaustivos</em>: debemos agotar
todas las posibilidades para que el código sea válido. Especialmente en el
caso de <code>Option&lt;T&gt;</code>, cuando Rust nos impide olvidar manejar el caso <code>None</code>,
nos protege de asumir que tenemos un valor cuando podríamos tener nulo,
haciendo así imposible el error de mil millones de dólares discutido
anteriormente.</p>
<h3 id="patrones-de-captura-y-el-placeholder-_"><a class="header" href="#patrones-de-captura-y-el-placeholder-_">Patrones de captura y el Placeholder <code>_</code></a></h3>
<p>Usando enums, también podemos tomar acciones especiales para algunos valores
particulares, pero para todos los demás valores, tomar una acción
predeterminada. Imagina que estamos implementando un juego donde, si sacas un
3 en un lanzamiento de dados, tu jugador no se mueve, sino que obtiene un nuevo
sombrero elegante. Si sacas un 7, tu jugador pierde un sombrero elegante.
Para todos los demás valores, tu jugador se mueve esa cantidad de espacios
en el tablero de juego. Aquí hay un <code>match</code> que implementa esa lógica, con el
resultado del lanzamiento de dados codificado en lugar de un valor aleatorio,
y toda la lógica representada por funciones sin cuerpos porque implementarlas
realmente está fuera del alcance de este ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>Para las primeras dos Opciones, los patrones son los valores literales <code>3</code> y
<code>7</code>. Para la última Opción que cubre cualquier otro valor posible, el patrón
es la variable que hemos elegido para nombrar <code>other</code>. El código que se
ejecuta para la Opción <code>other</code> usa la variable pasándola a la función
<code>move_player</code>.</p>
<p>Este código compila, aunque no hemos enumerado todos los posibles valores que
puede tener un <code>u8</code>, porque el último patrón coincidirá con todos los valores
no especificados específicamente. Este patrón de captura cumple con el
requisito de que <code>match</code> debe ser exhaustivo. Ten en cuenta que tenemos que
poner la Opción de captura al final porque los patrones se evalúan en orden. Si
ponemos la Opción de captura antes, las otras Opciones nunca se ejecutarían, por
lo que Rust nos advertirá si agregamos Opciones después de un catch-all!</p>
<p>Rust también tiene un patrón que podemos usar cuando queremos un catch-all,
pero no queremos <em>usar</em> el valor en el patrón catch-all: <code>_</code> es un patrón
especial que coincide con cualquier valor y no se vincula a ese valor. Esto le
dice a Rust que no vamos a usar el valor, por lo que Rust no nos advertirá
sobre una variable no utilizada.</p>
<p>Vamos a cambiar las reglas del juego. Ahora, si sacas un número diferente de un 3 o un 7 debes tirar
de nuevo. Ya no necesitamos usar el valor general, por lo que puede cambiar
nuestro código para usar <code>_</code> en lugar de la variable llamada <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>Este ejemplo también cumple con el requisito de exhaustividad porque estamos
explícitamente ignorando todos los demás valores en la última Opción; no hemos
olvidado nada.</p>
<p>Finalmente, cambiaremos las reglas del juego una vez más para que nada más
ocurra en tu turno si sacas algo que no sea un 3 o un 7. Podemos expresar eso
usando el valor de unidad (el tipo de tupla vacía que mencionamos en <a href="ch03-02-data-types.html#el-tipo-tupla">“El tipo
de tupla”</a><!-- ignore --> sección) como el código que va con la Opción
<code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>Aquí, le decimos a Rust explícitamente que no vamos a usar ningún otro valor
que no coincida con un patrón en una Opción anterior, y no queremos ejecutar
ningún código en este caso.</p>
<p>Hay más sobre patrones y coincidencias que cubriremos en el <a href="ch18-00-patterns.html">Capítulo
18</a><!-- ignore -->. Por ahora, vamos a pasar a la sintaxis
<code>if let</code> que puede ser útil en situaciones en las que la expresión <code>match</code> es
un poco larga.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flujo-de-control-conciso-con-if-let"><a class="header" href="#flujo-de-control-conciso-con-if-let">Flujo de Control Conciso con <code>if let</code></a></h2>
<p>La sintaxis <code>if let</code> te permite combinar <code>if</code> y <code>let</code> en una forma menos
verbosa de manejar valores que coinciden con un patrón mientras se ignoran el
resto. Considera el programa en el Listado 6-6 que coincide con un valor
<code>Option&lt;u8&gt;</code> en la variable <code>config_max</code> pero solo quiere ejecutar el código si
el valor es la variante <code>Some</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!(&quot;The maximum is configured to be {max}&quot;),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 6-6: Un <code>match</code> que solo se preocupa por ejecutar
código cuando el valor es <code>Some</code></span></p>
<p>Si el valor es <code>Some</code>, imprimimos el valor en la variante <code>Some</code> vinculando el
valor a la variable <code>max</code> en el patrón. No queremos hacer nada con el valor
<code>None</code>. Para satisfacer la expresión <code>match</code>, tenemos que agregar <code>_ =&gt; ()</code>
después de procesar solo una variante, lo cual es un código de plantilla
molesto para agregar.</p>
<p>En su lugar, podríamos escribir esto de una manera más corta usando <code>if let</code>.
El siguiente código se comporta de la misma manera que el <code>match</code> en el Listado
6-6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!(&quot;The maximum is configured to be {max}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>La sintaxis <code>if let</code> toma un patrón y una expresión separados por un signo
igual. Funciona de la misma manera que un <code>match</code>, donde la expresión se da al
<code>match</code> y el patrón es su primer brazo. En este caso, el patrón es <code>Some(max)</code>,
y el <code>max</code> se vincula al valor dentro del <code>Some</code>. Luego podemos usar <code>max</code> en
el cuerpo del bloque <code>if let</code> de la misma manera que usamos <code>max</code> en el brazo
<code>match</code> correspondiente. El código en el bloque <code>if let</code> no se ejecuta si el
valor no coincide con el patrón.</p>
<p>Usar <code>if let</code> significa menos escritura, menos indentación y menos código repetitivo. Sin embargo, pierdes la verificación exhaustiva que hace cumplir
<code>match</code>. Elegir entre <code>match</code> e <code>if let</code> depende de lo que estés haciendo en tu
situación particular y de si ser más conciso a cambio de la verificación exhaustiva es un intercambio adecuado.</p>
<p>En otras palabras, puedes pensar en <code>if let</code> como una sintaxis dulce para un
<code>match</code> que ejecuta código cuando el valor coincide con un patrón y luego
ignora todos los demás valores.</p>
<p>Podemos incluir un <code>else</code> con un <code>if let</code>. El bloque de código que va con el
<code>else</code> es el mismo que el bloque de código que iría con el caso <code>_</code> en la
expresión <code>match</code> que es equivalente al <code>if let</code> y <code>else</code>. Recuerda la
definición de <code>Coin</code> en el Listado 6-4, donde la variante <code>Quarter</code> también
tenía un valor <code>UsState</code>. Si quisiéramos contar todas las monedas que no son
cuartos que vemos mientras también anunciamos el estado de los cuartos, podríamos
hacerlo con una expresión <code>match</code>, como esta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {state:?}!&quot;),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>O podríamos usar un <code>if let</code> y <code>else</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {state:?}!&quot;);
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<p>Si se encuentra en una situación en la cual tu programa tiene lógica que es
demasiado verbosa para expresar usando un <code>match</code>, recuerda que <code>if let</code> está
en tu caja de herramientas de Rust también.</p>
<h2 id="resumen-5"><a class="header" href="#resumen-5">Resumen</a></h2>
<p>Ahora hemos cubierto cómo usar enums para crear tipos personalizados que pueden
ser uno de un conjunto de valores enumerados. Hemos mostrado cómo el tipo
<code>Option&lt;T&gt;</code> de la biblioteca estándar te ayuda a usar el sistema de tipos para
prevenir errores. Cuando los valores de enum tienen datos dentro de ellos,
podemos usar <code>match</code> o <code>if let</code> para extraer y usar esos valores, dependiendo de
cuántos casos necesites manejar.</p>
<p>Tus programas Rust ahora pueden expresar conceptos en tu dominio usando
structs y enums. Crear tipos personalizados para usar en tu API
asegura la seguridad de tipos: el compilador se asegurará de que tus funciones
solo obtengan valores del tipo que cada función espera.</p>
<p>En orden de proveer una API bien organizada a tus usuarios que sea
sencilla de usar y solo exponga exactamente lo que tus usuarios necesitarán,
ahora vamos a ver los módulos de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="administrando-proyectos-en-crecimiento-con-paquetes-crates-y-módulos"><a class="header" href="#administrando-proyectos-en-crecimiento-con-paquetes-crates-y-módulos">Administrando proyectos en crecimiento con paquetes, crates y módulos</a></h1>
<p>A medida que escribes programas grandes, organizar tu código se volverá cada vez más
importante. Al agrupar funcionalidades relacionadas y separar el código con
características distintas, tendrás más claro dónde encontrar el código que implementa
una característica concreta y dónde ir para cambiar el funcionamiento de una
característica.</p>
<p>Los programas que hemos escrito hasta ahora han estado en un módulo en un
archivo. A medida que un proyecto crece, debes organizar el código dividiéndolo
en múltiples módulos y luego en múltiples archivos. Un paquete puede contener
múltiples <em>crates</em> binarios y opcionalmente un <em>crate</em> de biblioteca. A medida
que un paquete crece, puedes extraer partes en <em>crates</em> separados que se
convierten en dependencias externas. Este capítulo cubre todas estas
técnicas. Para proyectos muy grandes que comprenden un conjunto de paquetes
interrelacionados que evolucionan juntos, Cargo proporciona <em>workspaces</em>, que
cubriremos en la sección <a href="ch14-03-cargo-workspaces.html">“Cargo Workspaces”</a><!-- ignore --> en el
Capítulo 14.</p>
<p>También discutiremos la encapsulación de detalles de implementación, que le
permite reutilizar el código a un nivel superior: una vez que ha implementado
una operación, otro código puede llamar a su código a través de su interfaz
pública sin tener que saber cómo funciona la implementación. La forma en que
escribes el código define qué partes son públicas para que otro código las use
y qué partes son detalles de implementación privados que te reservas el
derecho de cambiar. Esta es otra forma de limitar la cantidad de detalles que
tienes que mantener en tu cabeza.</p>
<p>Un concepto relacionado es el ámbito: el contexto anidado en el que se
escribe el código tiene un conjunto de nombres que se definen como
&quot;en el ámbito&quot;. Al leer, escribir y compilar código, los programadores y
compiladores necesitan saber si un nombre concreto en un punto determinado
se refiere a una variable, función, estructura, enumeración, módulo, constante
u otro elemento, y qué significa ese elemento. Se pueden crear ámbitos y cambiar
los nombres que están dentro o fuera de ellos.
No puede haber dos elementos con el mismo nombre en el mismo ámbito;
existen herramientas para resolver conflictos de nombres.</p>
<p>Rust tiene una serie de características que te permiten administrar la
organización de tu código, incluidos los detalles que se exponen, los detalles
que son privados y los nombres que están en cada ámbito en tus programas. Estas
características, a veces denominadas colectivamente <em>sistema de módulos</em>,
incluyen:</p>
<ul>
<li><strong>Paquetes:</strong> Una característica de Cargo que te permite construir, probar y
compartir <em>crates</em></li>
<li><strong>Crates:</strong> Un árbol de módulos que produce una biblioteca o ejecutable</li>
<li><strong>Módulos</strong> y <strong>use:</strong> Te permiten controlar la organización, el ámbito y
la privacidad de las rutas</li>
<li><strong>Rutas:</strong> Una forma de nombrar un elemento, como una estructura, función o
módulo</li>
</ul>
<p>En este capítulo, cubriremos todas estas características, discutiremos cómo
interactúan y explicaremos cómo usarlas para administrar el ámbito. Al final,
deberías tener una comprensión sólida del sistema de módulos y poder trabajar
con ámbitos como un profesional!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="paquetes-y-crates"><a class="header" href="#paquetes-y-crates">Paquetes y Crates</a></h2>
<p>Las primeras partes del sistema de módulos que cubriremos son los paquetes y los
crates.</p>
<p>Un <em>crate</em> es la cantidad más pequeña de código que el compilador Rust considera
a la vez. Incluso si ejecutas <code>rustc</code> en lugar de <code>cargo</code> y pasas un solo
archivo de código fuente (como lo hicimos en la sección “Escribir y Ejecutar un
Programa Rust” del Capítulo 1), el compilador considera que ese archivo es un
crate. Los crates pueden contener módulos, y los módulos pueden definirse en
otros archivos que se compilan con el crate, como veremos en las próximas
secciones.</p>
<p>Un crate puede venir en una de dos formas: un crate binario o un crate de
biblioteca. Los <em>crates binarios</em> son programas que puedes compilar a un
ejecutable que puedes ejecutar, como un programa de línea de comandos o un
servidor. Cada uno debe tener una función llamada <code>main</code> que defina lo que
sucede cuando se ejecuta el ejecutable. Todos los crates que hemos creado hasta
ahora han sido crates binarios.</p>
<p>Los <em>crates de biblioteca</em> no tienen una función <code>main</code>, y no se compilan a un
ejecutable. En su lugar, definen funcionalidad destinada a ser compartida con
múltiples proyectos. Por ejemplo, el crate <code>rand</code> que usamos en el <a href="ch02-00-guessing-game-tutorial.html#generar-un-numero-aleatorio">Capítulo
2</a><!-- ignore --> proporciona funcionalidad que genera números aleatorios.
La mayor parte del tiempo, cuando los Rustaceans dicen “crate”, se refieren a
crate de biblioteca, y usan “crate” indistintamente con el concepto general de
programación de una “biblioteca”.</p>
<p>El <em>crate root</em> es un archivo fuente que el compilador Rust comienza y forma el
módulo raíz de tu crate (explicaremos los módulos en profundidad en la sección
<a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">“Definir Módulos para Controlar el Alcance y la Privacidad”</a><!-- ignore
-->).</p>
<p>Un <em>paquete</em> es un conjunto de uno o más crates que proporciona un conjunto de
funcionalidades. Un paquete contiene un archivo <em>Cargo.toml</em> que describe cómo
compilar esos crates. Cargo es en realidad un paquete que contiene el crate
binario para la herramienta de línea de comandos que has estado usando para
compilar tu código. El paquete Cargo también contiene un crate de biblioteca en
el que el crate binario depende. Otros proyectos pueden depender del crate de
biblioteca Cargo para usar la misma lógica que la herramienta de línea de
comandos Cargo usa.</p>
<p>Un paquete puede venir en dos formas: un paquete binario o un paquete libreria.
Un paquete puede contener tantos crates binarios como desees, pero como máximo
solo un crate de biblioteca. Un paquete debe contener al menos un crate, ya sea
un crate de biblioteca o un crate binario.</p>
<p>Veamos qué sucede cuando creamos un paquete. Primero, ingresamos el comando
<code>cargo new</code>:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Después de ejecutar <code>cargo new my-project</code>, usamos <code>ls</code> para ver lo que crea 
Cargo. En el directorio del proyecto, hay un archivo <em>Cargo.toml</em>, que nos da un
paquete. También hay un directorio <em>src</em> que contiene <em>main.rs</em>. Abre 
<em>Cargo.toml</em> en tu editor de texto, y observa que no hay mención de 
<em>src/main.rs</em>. Cargo sigue una convención de que <em>src/main.rs</em> es la raíz del 
crate de un crate binario con el mismo nombre que el paquete. Del mismo modo, 
Cargo sabe que si el directorio del paquete contiene <em>src/lib.rs</em>, el paquete 
contiene un crate de biblioteca con el mismo nombre que el paquete, y 
<em>src/lib.rs</em> es su raíz del crate. Cargo pasa los archivos raíz del crate a 
<code>rustc</code> para compilar la biblioteca o el binario.</p>
<p>Aquí, tenemos un paquete que solo contiene <em>src/main.rs</em>, lo que significa que
solo contiene un crate binario llamado <code>my-project</code>. Si un paquete contiene
<em>src/main.rs</em> y <em>src/lib.rs</em>, tiene dos crates: un binario y una biblioteca,
ambos con el mismo nombre que el paquete. Un paquete puede tener múltiples
crates binarios colocando archivos en el directorio <em>src/bin</em>: cada archivo será
un crate binario separado.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definiendo-módulos-para-controlar-el-alcance-y-la-privacidad"><a class="header" href="#definiendo-módulos-para-controlar-el-alcance-y-la-privacidad">Definiendo módulos para controlar el alcance y la privacidad</a></h2>
<p>En esta sección, hablaremos sobre módulos y otras partes del sistema de módulos,
es decir, <em>rutas</em> que permiten nombrar elementos; la palabra clave <code>use</code> que
trae una ruta dentro del ámbito; y la palabra clave <code>pub</code> para hacer elementos
públicos. También discutiremos la palabra clave <code>as</code>, los paquetes externos y el
operador <code>glob</code>.</p>
<p>Primero, vamos a empezar con una lista de reglas para tener a mano cuando
estés organizando tu código en el futuro. Luego explicaremos cada una de las
reglas en detalle.</p>
<h3 id="hoja-de-referencia-de-módulos"><a class="header" href="#hoja-de-referencia-de-módulos">Hoja de referencia de módulos</a></h3>
<p>Antes nosotros debemos obtener los detalles de los módulos y las rutas, aquí te 
proporcionamos una referencia rápida sobre cómo funcionan los módulos,
las rutas, la palabra clave <code>use</code> y la palabra clave <code>pub</code> en el compilador, y
cómo la mayoría de los desarrolladores organizan su código. Vamos a ir
tratando ejemplos de cada una de estas reglas a lo largo de este capítulo, pero
esta es una buena referencia para tener a mano cuando necesites recordar cómo
funcionan los módulos.</p>
<ul>
<li><strong>Empezamos desde la raíz del crate</strong>: Cuando se compila un crate, el
compilador primero busca el código en el archivo raíz del crate (usualmente
<em>src/lib.rs</em> para un crate de librería o <em>src/main.rs</em> para un crate
binario) para compilar.</li>
<li><strong>Declarando módulos</strong>: En el archivo raíz del crate, puedes declarar nuevos
módulos; digamos, que declaras un módulo “garden” con <code>mod garden;</code>. El
compilador buscará el código del módulo en estos lugares:
<ul>
<li>Inline, dentro de llaves que reemplazan el punto y coma que sigue a <code>mod garden</code></li>
<li>En el archivo <em>src/garden.rs</em></li>
<li>En el archivo <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Declarando submódulos</strong>: En cualquier archivo que no sea la raíz del crate,
puedes declarar submódulos. Por ejemplo, podrías declarar <code>mod vegetables;</code> en
<em>src/garden.rs</em>. El compilador buscará el código del submódulo dentro del
directorio que se llama igual que el módulo padre en estos lugares:
<ul>
<li>En línea, directamente después de <code>mod vegetables</code>, dentro de llaves que
reemplazan el punto y coma que sigue a <code>mod garden</code></li>
<li>En el archivo <em>src/garden/vegetables.rs</em></li>
<li>En el archivo <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>Rutas de acceso a código en módulos</strong>: Una vez que un módulo es parte de tu crate, puedes
referirte al código de ese módulo desde cualquier otro lugar del mismo crate,
siempre y cuando las reglas de privacidad lo permitan, usando la ruta al
código. Por ejemplo, un tipo <code>Asparagus</code> en el módulo de vegetales del garden
se encontraría en <code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>Privado vs. público</strong>: El código dentro de un módulo es privado por defecto
desde los módulos padres. Para hacer un módulo público, decláralo con <code>pub mod</code> en vez de <code>mod</code>. Para hacer públicos los elementos dentro de un módulo
público, usa <code>pub</code> antes de sus declaraciones.</li>
<li><strong>La palabra clave <code>use</code></strong>: Dentro de un alcance, la palabra clave <code>use</code> crea
atajos a elementos para reducir la repetición de rutas largas. En cualquier
alcance que pueda referirse a <code>crate::garden::vegetables::Asparagus</code>, puedes
crear un atajo con <code>use crate::garden::vegetables::Asparagus;</code> y a partir de
entonces solo necesitarás escribir <code>Asparagus</code> para hacer uso de ese tipo en
el alcance.</li>
</ul>
<p>Aquí, crearemos un crate binario llamado <code>backyard</code> que ilustra estas reglas. El
directorio del crate, también llamado <code>backyard</code>, contiene estos archivos y
directorios:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>El crate raíz es <em>src/main.rs</em>, y contiene:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!(&quot;I'm growing {plant:?}!&quot;);
}</code></pre>
<p>La línea <code>mod garden;</code> le dice al compilador que incluya el código que encuentra
en <em>src/garden.rs</em>, que es:</p>
<p><span class="filename">Filename: src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
<p>Aquí, <code>pub mod vegetables;</code> significa que el código en <em>src/garden/vegetables.rs</em>
también se incluye. Ese código es:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>¡Ahora entremos en los detalles de estas reglas y demostrémoslas en acción!</p>
<h3 id="agrupando-código-relacionado-en-módulos"><a class="header" href="#agrupando-código-relacionado-en-módulos">Agrupando código relacionado en módulos</a></h3>
<p>Los <em>módulos</em> nos permiten organizar el código dentro de un crate para facilitar
su lectura y reutilización. También nos permiten controlar la privacidad de los
elementos, ya que el código dentro de un módulo es privado por defecto. Los
elementos privados son detalles de la implementación interna que no están
disponibles para su uso externo. Podemos elegir hacer públicos los módulos y los
elementos que contienen para exponerlos y permitir que el código externo los
use y dependa de ellos.</p>
<p>Como un ejemplo, vamos a escribir una librería que provee la funcionalidad de un
restaurante. Vamos a definir las firmas de las funciones, pero dejaremos sus
cuerpos vacíos para concentrarnos en la organización del código, en vez de la
implementación de un restaurante.</p>
<p>En la industria de restaurantes, algunas partes de un restaurante se llaman
<em>front of house</em> y otras <em>back of house</em>. El <em>front of house</em> es donde están
los clientes; esto incluye donde los anfitriones se sientan a los clientes,
los camareros toman los pedidos y el pago, y los bartenders preparan las
bebidas. El <em>back of house</em> es donde los chefs y los cocineros trabajan en la
cocina, los lavaplatos limpian, y los gerentes hacen el trabajo administrativo.</p>
<p>Para estructurar nuestro crate de esta manera, podemos organizar sus funciones
dentro de módulos anidados. Crea una nueva librería llamada <code>restaurant</code>
ejecutando <code>cargo new restaurant --lib</code>. Luego ingresa el código en el 
Listado 7-1 para definir algunos módulos y firmas de funciones. Aquí está la
sección <em>front of house</em>:</p>
<p><span class="filename">Nombre de archivo: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
<p><span class="caption">Listado 7-1: Un módulo <code>front_of_house</code> que contiene otros
módulos que luego contienen funciones</span></p>
<p>Definimos un módulo con la palabra clave <code>mod</code> seguida del nombre del módulo
(en este caso, <code>front_of_house</code>). El cuerpo del módulo va dentro de llaves.
Dentro de los módulos, podemos colocar otros módulos, como en este caso con los
módulos <code>hosting</code> y <code>serving</code>. Los módulos también pueden contener definiciones
de otros elementos, como structs, enums, constantes, traits, y como en la Lista
7-1—funciones.</p>
<p>Mediante el uso de módulos, podemos agrupar definiciones relacionadas y nombrar
por qué están relacionadas. Los programadores que usen este código pueden
navegar el código basándose en los grupos en vez de tener que leer todas las
definiciones, haciendo más fácil encontrar las definiciones relevantes para
ellos. Los programadores que agreguen nueva funcionalidad a este código sabrán
dónde colocar el código para mantener el programa organizado.</p>
<p>Anteriormente, mencionamos que <em>src/main.rs</em> y <em>src/lib.rs</em> se llaman raíces de
crate. La razón de su nombre es que el contenido de cualquiera de estos dos
archivos forma un módulo llamado <code>crate</code> en la raíz de la estructura de módulos
del crate, conocida como el <em>árbol de módulos</em>.</p>
<p>El Listado 7-2 muestra el árbol de módulos para la estructura en el listado 7-1</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Listado 7-2: El árbol de módulos para el código del
listado 7-1</span></p>
<p>Este árbol muestra como algunos de los módulos se anidan dentro de otros módulos; 
por ejemplo, <code>hosting</code> se anida dentro de <code>front_of_house</code>. El árbol también 
muestra que algunos módulos son <em>hermanos</em> entre sí, lo que significa que están
definidos en el mismo módulo; <code>hosting</code> y <code>serving</code> son hermanos definidos
dentro de <code>front_of_house</code>. Si el módulo A está contenido dentro del módulo B,
decimos que el módulo A es el <em>hijo</em> del módulo B y que el módulo B es el
<em>padre</em> del módulo A. Nota que el árbol de módulos completo está enraizado bajo
el módulo implícito llamado <code>crate</code>.</p>
<p>El árbol de módulos puede recordarte al árbol de directorios del sistema de
archivos en tu computadora; ¡esta es una comparación muy apropiada! Al igual que
los directorios en un sistema de archivos, usas módulos para organizar tu
código. Y al igual que los archivos en un directorio, necesitamos una forma de
encontrar nuestros módulos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rutas-para-referirse-a-un-elemento-en-el-árbol-de-módulos"><a class="header" href="#rutas-para-referirse-a-un-elemento-en-el-árbol-de-módulos">Rutas para referirse a un elemento en el árbol de módulos</a></h2>
<p>Para mostrarle a Rust dónde encontrar un item en el árbol de módulos, usamos una
ruta de la misma manera que usamos una ruta cuando navegamos en un sistema de archivos.
Para llamar a una función, necesitamos saber su ruta.</p>
<p>Una ruta puede tomar dos formas:</p>
<ul>
<li>
<p>Una <em>ruta absoluta</em> es la ruta completa que comienza desde la raíz de un <code>crate</code>; para el código de un <code>crate</code> externo, la ruta absoluta comienza con el nombre del <code>crate</code>, y para el código del crate actual, comienza con el <code>crate</code> literal.</p>
</li>
<li>
<p>Una <em>ruta relativa</em> comienza desde el módulo actual y utiliza <code>self</code>, <code>super</code>, o un
identificador del módulo actual.</p>
</li>
</ul>
<p>Tanto las rutas absolutas como las relativas están seguidas por uno o más
identificadores separados por dos puntos dobles (<code>::</code>).</p>
<p>Volviendo al listado 7-1, digamos que queremos llamar a la función
<code>add_to_waitlist</code> desde la función <code>eat_at_restaurant</code> definida en el crate
root. Este es el mismo que preguntar: ¿cuál es la ruta de la función
<code>add_to_waitlist</code>? El listado 7-3 contiene el listado 7-1 con algunos de los
módulos y funciones removidas.</p>
<p>Mostraremos dos formas de llamar a la función <code>add_to_waitlist</code> desde una nueva
función, <code>eat_at_restaurant</code>, definida en el crate de la raíz. Estas rutas son
correctas, pero hay otro problema que impide que este ejemplo compile tal cual.
Explicaremos por qué en un momento.</p>
<p>La función <code>eat_at_restaurant</code> es parte de la API pública del crate de nuestra
librería, así que la marcamos con la palabra clave <code>pub</code>. En la sección
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exponiendo-rutas-con-la-palabra-clave-pub">“Exponiendo Rutas con la palabra clave <code>pub</code>”</a><!-- ignore -->, iremos en
más detalle sobre <code>pub</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-3: Llamando a la función <code>add_to_waitlist</code> usando
rutas absolutas y relativas</span></p>
<p>La primera vez que llamamos a la función <code>add_to_waitlist</code> en <code>eat_at_restaurant</code>,
usamos una ruta absoluta. La función <code>add_to_waitlist</code> está definida en el mismo
crate que <code>eat_at_restaurant</code>, lo que significa que podemos usar la palabra
clave <code>crate</code> para comenzar una ruta absoluta. Luego incluimos cada uno de los
módulos sucesivos hasta que llegamos a <code>add_to_waitlist</code>. Puedes imaginar un
sistema de archivos con la misma estructura: especificaríamos la ruta
<code>/front_of_house/hosting/add_to_waitlist</code> para ejecutar el programa
<code>add_to_waitlist</code>; usar el nombre <code>crate</code> para comenzar desde la raíz del crate
es como usar <code>/</code> para comenzar desde la raíz del sistema de archivos en tu
shell.</p>
<p>La segunda vez que llamamos a <code>add_to_waitlist</code> en <code>eat_at_restaurant</code>, usamos
la ruta relativa. La ruta comienza con <code>front_of_house</code>, el nombre del módulo
definido al mismo nivel del árbol de módulos que <code>eat_at_restaurant</code>. Aquí el
equivalente en el sistema de archivos sería usar la ruta
<code>front_of_house/hosting/add_to_waitlist</code>. Comenzar con el nombre del módulo
significa que la ruta es relativa.</p>
<p>Elegir si usar una ruta relativa o absoluta es una decisión que tomarás basado
en tu proyecto, y depende de si es más probable que muevas la definición de un
item de código separadamente o junto con el código que usa el item. Por
ejemplo, si movemos el módulo <code>front_of_house</code> y la función <code>eat_at_restaurant</code>
a un módulo llamado <code>customer_experience</code>, necesitaríamos actualizar la ruta
absoluta a <code>add_to_waitlist</code>, pero la ruta relativa seguiría siendo válida.
Sin embargo, si movemos la función <code>eat_at_restaurant</code> separadamente a un
módulo llamado <code>dining</code>, la ruta absoluta a la llamada de <code>add_to_waitlist</code>
seguiría siendo la misma, pero la ruta relativa necesitaría ser actualizada.
Nuestra preferencia en general es especificar rutas absolutas porque es más
probable que queramos mover definiciones de código y llamadas de items
independientemente.</p>
<p>¡Intentemos compilar el listado 7-3 y averigüemos por qué aún no compila! Los
errores que obtenemos se muestran en el listado 7-4.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Listado 7-4: Errores de compilación al hacer building del
código del listado 7-3</span></p>
<p>El mensaje de error dice que el módulo <code>hosting</code> es privado. En otras palabras,
tenemos las rutas correctas para el módulo <code>hosting</code> y la función
<code>add_to_waitlist</code>, pero Rust no nos deja usarlos porque no tiene acceso a las
secciones privadas. En Rust, todos los items (funciones, métodos, structs,
enums, módulos, y constantes) son privados a los módulos padres por defecto. Si
quieres hacer un item como una función o struct privado, lo pones en un módulo.</p>
<p>Los elementos en un módulo privado no pueden ser accedidos por una ruta externa
absoluta, porque el módulo padre no puede ver dentro de los módulos privados de
sus hijos. El módulo padre puede ver el contenido de sus módulos hijos porque
los módulos hijos están dentro del módulo padre. Para continuar con nuestra
metáfora, piensa en las reglas de privacidad como la oficina de atrás de un
restaurante: lo que pasa ahí es privado para los clientes del restaurante, pero
los gerentes de la oficina pueden ver y hacer todo en el restaurante que
operan.</p>
<p>Rust elige tener el sistema de módulos funcionando de esta forma para que
ocultar detalles de implementación internos sea lo predeterminado. De esta
forma, sabes qué partes del código interno puedes cambiar sin romper el código
externo. Sin embargo, Rust te da la opción de exponer partes internas del código
de los módulos hijos a los módulos ancestros externos usando la palabra clave
<code>pub</code> para hacer un item público.</p>
<h3 id="exponiendo-rutas-con-la-palabra-clave-pub"><a class="header" href="#exponiendo-rutas-con-la-palabra-clave-pub">Exponiendo rutas con la palabra clave <code>pub</code></a></h3>
<p>Volviendo al error en el listado 7-4 que nos dijo que el módulo <code>hosting</code> es
privado, queremos que la función <code>eat_at_restaurant</code> en el módulo padre tenga
acceso a la función <code>add_to_waitlist</code> en el módulo hijo, así que marcamos el
módulo <code>hosting</code> con la palabra clave <code>pub</code>, como se muestra en el listado 7-5.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-5: Declarando el módulo <code>hosting</code> como <code>pub</code>
para usarlo desde <code>eat_at_restaurant</code></span></p>
<p>Desafortunadamente, el código en el listado 7-5 aún resulta en errores de 
compilador, como se muestra en el listado 7-6.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Listado 7-6: Errores de compilación al hacer building del
código del listado 7-5</span></p>
<p>¿Qué pasó? Agregar la palabra clave <code>pub</code> al frente del módulo <code>hosting</code> hace
que el módulo sea público. Con este cambio, si podemos acceder a
<code>front_of_house</code>, podemos acceder a <code>hosting</code>. Pero el <em>contenido</em> de <code>hosting</code>
sigue siendo privado; hacer el módulo público no hace que su contenido sea
público. La palabra clave <code>pub</code> en un módulo solo permite que el código en sus
módulos ancestros se refiera a él, no acceder a su código interno. Debido a que
los módulos son contenedores, no hay mucho que podamos hacer solo haciendo que
el módulo sea público; necesitamos ir más allá y elegir hacer que uno o más de
los items dentro del módulo sean públicos también.</p>
<p>El error en el listado 7-6 dicen que la función <code>add_to_waitlist</code> es privada.
Las reglas de privacidad se aplican a structs, enums, funciones, y métodos, así
como a módulos.</p>
<p>Para hacer que la función <code>add_to_waitlist</code> sea pública, necesitamos agregar la
palabra clave <code>pub</code> antes de su definición, como se muestra en el listado 7-7.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-7: Agregar la keyword <code>pub</code> a <code>mod hosting</code>
y <code>fn add_to_waitlist</code> nos permite llamar a la función desde
<code>eat_at_restaurant</code></span></p>
<p>¡Ahora el código compilará! Para ver por qué agregar la palabra clave <code>pub</code> nos
permite usar estas rutas en <code>eat_at_restaurant</code> con respecto a las reglas de
privacidad, veamos las rutas absolutas y relativas.</p>
<p>En la ruta absoluta, comenzamos con <code>crate</code>, la raíz del árbol de módulos de nuestro crate.
El módulo <code>front_of_house</code> está definido en la raíz del <code>crate</code>. Si
bien <code>front_of_house</code> no es público, porque la función <code>eat_at_restaurant</code> está
definida en el mismo módulo que <code>front_of_house</code> (es decir, <code>eat_at_restaurant</code>
y <code>front_of_house</code> son hermanos), podemos referirnos a <code>front_of_house</code> desde
<code>eat_at_restaurant</code>. A continuación está el módulo <code>hosting</code> marcado con <code>pub</code>.
Podemos acceder al módulo padre de <code>hosting</code>, por lo que podemos acceder a
<code>hosting</code>. ¡Finalmente, la función <code>add_to_waitlist</code> está marcada con <code>pub</code> y
podemos acceder a su módulo padre, por lo que está llamada a función funciona!</p>
<p>En la ruta relativa, la lógica es la misma que la ruta absoluta, excepto por el
primer paso: en lugar de comenzar desde la raíz del <code>crate</code>, la ruta comienza
desde <code>front_of_house</code>. El módulo <code>front_of_house</code> está definido dentro del
mismo módulo que <code>eat_at_restaurant</code>, por lo que la ruta relativa que comienza
desde el módulo en el que se define <code>eat_at_restaurant</code> funciona. Luego,
porque <code>hosting</code> y <code>add_to_waitlist</code> están marcados con <code>pub</code>, el resto de la ruta
funciona, ¡y está llamada a función es válida!</p>
<p>Si planeas compartir tu biblioteca crate para que otros proyectos puedan usar
tu código, tu API pública es tu contrato con los usuarios de tu crate que
determina cómo pueden interactuar con tu código. Hay muchas consideraciones
sobre cómo administrar los cambios en tu API pública para que sea más fácil que
la gente dependa de tu crate. Estas consideraciones están fuera del alcance de
este libro; si estás interesado en este tema, consulta <a href="https://rust-lang.github.io/api-guidelines/">The Rust API
Guidelines</a>.</p>
<blockquote>
<h4 id="buenas-prácticas-para-paquetes-con-un-binario-y-una-biblioteca"><a class="header" href="#buenas-prácticas-para-paquetes-con-un-binario-y-una-biblioteca">Buenas prácticas para paquetes con un binario y una biblioteca</a></h4>
<p>Mencionamos que un paquete puede contener tanto un binario <em>src/main.rs</em> como
una biblioteca <em>src/lib.rs</em>, y ambos tendrán el nombre del paquete de forma
predeterminada. Típicamente, los paquetes con este patrón de contener tanto
una biblioteca como un binario tendrán solo el código suficiente en el binario
para iniciar un ejecutable que llame al código con la biblioteca. Esto permite
que otros proyectos se beneficien de que la mayor funcionalidad que 
proporciona el paquete, porque el código de la biblioteca se puede compartir.</p>
<p>El árbol de módulos debería ser definido en <em>src/lib.rs</em>. Luego, cualquier
item público puede ser usado en el binario comenzando las rutas con el nombre
del paquete. El binario se convierte en un usuario de la biblioteca de la
misma forma que un crate completamente externo usaría la biblioteca: solo
puede usar la API pública. Esto te ayuda a diseñar una buena API; no solo eres
el autor, ¡también eres un cliente!</p>
<p>En el <a href="ch12-00-an-io-project.html">Capítulo 12</a><!-- ignore -->, demostraremos esta práctica
organizativa con un programa de línea de comandos que contendrá tanto un
paquete binario como una biblioteca.</p>
</blockquote>
<h3 id="comenzando-rutas-relativas-con-super"><a class="header" href="#comenzando-rutas-relativas-con-super">Comenzando rutas relativas con <code>super</code></a></h3>
<p>Podemos construir rutas relativas que comiencen en el módulo padre, en lugar de en el módulo actual o en la raíz del <code>crate</code>,
usando <code>super</code> al comienzo de la ruta. Esto es
como comenzar una ruta del sistema de archivos con la sintaxis <code>..</code>. Usar <code>super</code>
nos permite hacer referencia a un item que sabemos que está en el módulo padre,
lo que puede facilitar la reorganización del árbol de módulos cuando el módulo
está estrechamente relacionado con el padre, pero el padre podría moverse a
otro lugar en el árbol de módulos algún día.</p>
<p>Considere el código en el listado 7-8 que modela la situación en la que un chef
arregla un pedido incorrecto y lo trae personalmente al cliente. La función
<code>fix_incorrect_order</code> definida en el módulo <code>back_of_house</code> llama a la función
<code>deliver_order</code> definida en el módulo padre especificando la ruta a
<code>deliver_order</code>, comenzando con <code>super</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<p><span class="caption">Listado 7-8: Llamar a una función usando una ruta relativa
que comienza con <code>super</code></span></p>
<p>La función <code>fix_incorrect_order</code> está en el módulo <code>back_of_house</code>, por lo que
podemos usar <code>super</code> para ir al módulo padre de <code>back_of_house</code>, que en este
caso es <code>crate</code>, la raíz. Desde allí, buscamos <code>deliver_order</code> y lo encontramos.
¡Éxito! Pensamos que el módulo <code>back_of_house</code> y la función <code>deliver_order</code>
probablemente permanecerán en la misma relación entre sí y se moverán juntos si
decidimos reorganizar el árbol de módulos del crate. Por lo tanto, usamos
<code>super</code> para tener menos lugares para actualizar el código en el futuro si este
código se mueve a un módulo diferente.</p>
<h3 id="haciendo-públicos-los-structs-y-enums"><a class="header" href="#haciendo-públicos-los-structs-y-enums">Haciendo públicos los structs y enums</a></h3>
<p>También podemos usar <code>pub</code> para designar structs y enums como públicos, pero hay
algunos detalles adicionales para el uso de <code>pub</code> con structs y enums. Si
usamos <code>pub</code> antes de una definición de struct, hacemos que el struct sea
público, pero los campos del struct seguirán siendo privados. Podemos hacer que
cada campo sea público o no caso por caso. En el listado 7-9, hemos definido un
struct <code>back_of_house::Breakfast</code> público con un campo <code>toast</code> público pero un
campo <code>seasonal_fruit</code> privado. Esto modela el caso en un restaurante donde el
cliente puede elegir el tipo de pan que viene con una comida, pero el chef
decide qué fruta acompaña la comida según lo que está en temporada y en stock.
La fruta disponible cambia rápidamente, por lo que los clientes no pueden
elegir la fruta o incluso ver qué fruta obtendrán.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}</code></pre>
<p><span class="caption">Listado 7-9: Un struct con algunos campos públicos y
algunos campos privados</span></p>
<p>Debido a que el campo <code>toast</code> es público, podemos cambiar el valor de <code>toast</code>
en una instancia de <code>Breakfast</code> en la función <code>eat_at_restaurant</code> en el listado
7-10. Ten en cuenta que no podemos usar el campo <code>seasonal_fruit</code> en
<code>eat_at_restaurant</code>, porque <code>seasonal_fruit</code> es privado. ¡Intenta descomentar la
línea que modifica el valor del campo <code>seasonal_fruit</code> para ver qué error
obtiene!</p>
<p>Además, ten en cuenta que debido a que <code>back_of_house::Breakfast</code> tiene un
campo privado, el struct debe proporcionar una función asociada pública que
construya una instancia de <code>Breakfast</code> (lo hemos llamado <code>summer</code> aquí). Si
<code>Breakfast</code> no tuviera tal función, no podríamos crear una instancia de
<code>Breakfast</code> en <code>eat_at_restaurant</code> porque no podríamos establecer el valor del
campo privado <code>seasonal_fruit</code> en <code>eat_at_restaurant</code>.</p>
<p>Por el contrario, si hacemos un enum público, todos sus variantes son públicas.
Solo necesitamos el <code>pub</code> antes de la palabra clave <code>enum</code>, como se muestra en
el listado 7-10.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<p><span class="caption">Listado 7-10: Designar un enum como público hace que todas
sus variantes sean públicas</span></p>
<p>Debido a que hicimos el enum <code>Appetizer</code> público, podemos usar las variantes
<code>Appetizer::Soup</code> y <code>Appetizer::Salad</code> en <code>eat_at_restaurant</code>.</p>
<p>Los Enums no son muy útiles a menos que sus variantes sean públicas; sería
molesto tener que anotar todas las variantes de enum con <code>pub</code> en todos los
casos, por lo que el valor predeterminado para las variantes de enum es ser
público. Los structs a menudo son útiles sin que sus campos sean públicos, por
lo que los campos de struct siguen la regla general de que todo es privado por
defecto a menos que se anote con <code>pub</code>.</p>
<p>Hay una situación más relacionada con <code>pub</code> que no hemos cubierto, y es
nuestra última característica del sistema de módulos: la palabra clave <code>use</code>.
Cubriremos <code>use</code> por sí solo primero, y luego mostraremos cómo combinar <code>pub</code> y
<code>use</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="incluyendo-rutas-al-ámbito-con-la-palabra-clave-use"><a class="header" href="#incluyendo-rutas-al-ámbito-con-la-palabra-clave-use">Incluyendo rutas al ámbito con la palabra clave <code>use</code></a></h2>
<p>Tener que escribir las rutas para llamar a las funciones puede sentirse
inconveniente y repetitivo. En el Listado 7-7, si elegimos la ruta absoluta o
relativa para la función <code>add_to_waitlist</code>, cada vez que queríamos llamar a
<code>add_to_waitlist</code> teníamos que especificar <code>front_of_house</code> y <code>hosting</code> también.
Afortunadamente, hay una manera de simplificar este proceso: podemos crear un
atajo a una ruta con la palabra clave <code>use</code> una vez, y luego usar el nombre
más corto en todas partes en el ámbito.</p>
<p>En el listado 7-11, traemos el módulo <code>crate::front_of_house::hosting</code> al ámbito
de la función <code>eat_at_restaurant</code> para que solo tengamos que especificar
<code>hosting::add_to_waitlist</code> para llamar a la función <code>add_to_waitlist</code> en
<code>eat_at_restaurant</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-11: Introducir un módulo en el ámbito de aplicación con <code>use</code></span></p>
<p>Agregar <code>use</code> y una ruta en un ámbito es similar a crear un enlace simbólico
en el sistema de archivos. Al agregar <code>use crate::front_of_house::hosting</code> en
la raíz del crate, hace que <code>hosting</code> sea ahora un nombre válido en ese ámbito, como si
el módulo <code>hosting</code> hubiera sido definido en la raíz del crate. Las rutas
traídas al ámbito con <code>use</code> también verifican la privacidad, como cualquier
otra ruta.</p>
<p>Ten en cuenta que <code>use</code> solo crea el atajo para el ámbito particular en el que
ocurre él <code>use</code>. El Listado 7-12 mueve la función <code>eat_at_restaurant</code> a un
nuevo módulo hijo llamado <code>customer</code>, que es entonces un ámbito diferente al de la sentencia <code>use</code>,
por lo que el cuerpo de la función no compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<p><span class="caption">Listado 7-12: La sentencia <code>use</code> solo aplica en el
ámbito donde se encuentra declarado</span></p>
<p>El error del compilador muestra que el acceso directo ya no se aplica dentro del módulo del
<code>customer</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Observe que también hay una advertencia de que él <code>use</code> ya no se utiliza en su
ámbito. Para solucionar este problema, mueva también él <code>use</code> dentro del módulo
<code>customer</code>, o haga referencia al acceso directo en el módulo padre con
<code>super::hosting</code> dentro del módulo hijo <code>customer</code>.</p>
<h3 id="creando-rutas-de-use-idiomaticas"><a class="header" href="#creando-rutas-de-use-idiomaticas">Creando rutas de <code>use</code> idiomaticas</a></h3>
<p>En el Listado 7-11, podrías haberte preguntado por qué especificamos
<code>use crate::front_of_house::hosting</code> y luego llamamos a <code>hosting::add_to_waitlist</code>
en <code>eat_at_restaurant</code>, en lugar de especificar toda la ruta
hasta la función <code>add_to_waitlist</code> para lograr el mismo resultado, como en el
Listado 7-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-13: Incorporando la función <code>add_to_waitlist</code>
en el ámbito con <code>use</code>, que no es idiomático</span></p>
<p>Aunque el Listado 7-11 y 7-13 logran la misma tarea, el Listado 7-11 es la
forma idiomática de traer una función al ámbito con <code>use</code>. Traer el módulo
padre de la función al ámbito con <code>use</code> significa que tenemos que especificar
el módulo padre cuando llamamos a la función. Especificar el módulo padre
cuando llamamos a la función hace que quede claro que la función no está
definida localmente, al tiempo que minimiza la repetición de la ruta completa.
El código en el Listado 7-13 no es claro en cuanto a dónde se define
<code>add_to_waitlist</code>.</p>
<p>Por otro lado, cuando traemos structs, enums y otros items con <code>use</code>, es
idiomático especificar la ruta completa. El Listado 7-14 muestra la forma
idiomática de traer la struct <code>HashMap</code> de la biblioteca estándar al ámbito de
un crate binario.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<p><span class="caption">Listado 7-14: Trayendo <code>HashMap</code> al ámbito de una
manera idiomática</span></p>
<p>No hay una razón fuerte detrás de este idioma: es solo la convención que ha
surgido, y la gente se ha acostumbrado a leer y escribir código Rust de esta
manera.</p>
<p>La excepción a este idioma es si estamos trayendo dos elementos con el mismo nombre
al ámbito con declaraciones <code>use</code>, porque Rust no lo permite. El Listado
7-15 muestra cómo traer dos tipos <code>Result</code> al ámbito que tienen el mismo nombre
pero módulos padres diferentes, y cómo referirse a ellos.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Listado 7-15: Incorporando dos tipos con el mismo nombre
en el mismo ámbito requiere el uso de sus módulos principales.</span></p>
<p>Como puedes ver, usar los módulos padres distingue los dos tipos <code>Result</code>. Sí,
en cambio, especificamos <code>use std::fmt::Result</code> y <code>use std::io::Result</code>,
tendríamos dos tipos <code>Result</code> en el mismo ámbito, y Rust no sabría a cuál nos
referimos cuando usamos <code>Result</code>.</p>
<h3 id="proporcionando-nuevos-nombres-con-el-keyword-as"><a class="header" href="#proporcionando-nuevos-nombres-con-el-keyword-as">Proporcionando nuevos nombres con el Keyword <code>as</code></a></h3>
<p>Hay otra solución a este problema de traer dos elementos con el mismo nombre al
ámbito con <code>use</code>: después de la ruta, podemos especificar <code>as</code> y un nuevo
nombre local, o <em>alias</em>, para el tipo. El Listado 7-16 muestra otra forma de
escribir el código en el Listado 7-15 renombrando uno de los dos tipos
<code>Result</code> usando <code>as</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Listado 7-16: Cambiando el nombre de un tipo cuando se
introduce en el ámbito con la keyword <code>as</code></span></p>
<p>En la segunda declaración <code>use</code>, elegimos el nuevo nombre <code>IoResult</code> para el
tipo <code>std::io::Result</code>, que no entrará en conflicto con el <code>Result</code> de
<code>std::fmt</code> que también hemos traído al ámbito. El Listado 7-15 y 7-16 se
consideran idiomáticos, ¡así que la elección depende de ti!</p>
<h3 id="re-exportando-nombres-con-pub-use"><a class="header" href="#re-exportando-nombres-con-pub-use">Re-exportando nombres con <code>pub use</code></a></h3>
<p>Cuando traemos un nombre al ámbito con la keyword <code>use</code>, el nombre está
disponible en ese ámbito de forma privada. Si queremos que el nombre esté
disponible para que el código que llama a nuestro código lo use, podemos
combinar <code>pub</code> y <code>use</code>. Esta técnica se llama <em>re-exporting</em> porque estamos
trayendo un elemento al ámbito, pero también haciendo que ese elemento esté 
disponible para que otros lo traigan a su ámbito.</p>
<p>El listado 7-17 muestra el código del listado 7-11 con <code>use</code> en el módulo
<code>front_of_house</code> cambiado a <code>pub use</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-17: Hacer que un nombre esté disponible para que
lo use cualquier código desde un nuevo ámbito con <code>pub use</code></span></p>
<p>Antes de este cambio, el código externo tendría que llamar a la función
<code>add_to_waitlist</code> usando la ruta
<code>restaurant::front_of_house::hosting::add_to_waitlist()</code>, el cual también 
debería tener requerido el modulo <code>front_of_house</code> para ser marcado como <code>pub</code>. 
Ahora que este <code>pub use</code> ha reexportado el módulo <code>hosting</code> desde el módulo raíz,
el código externo puede usar la ruta <code>restaurant::hosting::add_to_waitlist()</code> en
su lugar.</p>
<p>Re-exportar es útil cuando la estructura interna de tu código es diferente de
cómo los programadores que llaman a tu código pensarían sobre el dominio. Por
ejemplo, en esta metáfora de un restaurante, la gente que dirige el restaurante
piensa en “front of house” y “back of house”. Pero los clientes que visitan un
restaurante probablemente no pensarán en las partes del restaurante en esos
términos. Con <code>pub use</code>, podemos escribir nuestro código con una estructura
pero exponer una estructura diferente. Hacerlo hace que nuestra biblioteca esté
bien organizada para los programadores que trabajan en la biblioteca y los
programadores que llaman a la biblioteca. Veremos otro ejemplo de <code>pub use</code> y
cómo afecta la documentación de tu crate en la sección <a href="ch14-02-publishing-to-crates-io.html#exportando-una-api-publica-conveniente-con-pub-use">“Exportando una API
pública conveniente con <code>pub use</code>”</a><!-- ignore --> del Capítulo 14.</p>
<h3 id="usando-paquetes-externos"><a class="header" href="#usando-paquetes-externos">Usando paquetes externos</a></h3>
<p>En el Capítulo 2, programamos un proyecto de juego de adivinanzas que usaba un
paquete externo llamado <code>rand</code> para obtener números aleatorios. Para usar
<code>rand</code> en nuestro proyecto, agregamos esta línea a <em>Cargo.toml</em>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.5&quot;
</code></pre>
<p>Añadir <code>rand</code> como dependencia en <em>Cargo.toml</em> le dice a Cargo que descargue el
paquete <code>rand</code> y cualquier dependencia de <a href="https://crates.io/">crates.io</a> y
haga que <code>rand</code> esté disponible para nuestro proyecto.</p>
<p>Luego, para llevar las definiciones de <code>rand</code> al ámbito de nuestro paquete,
agregamos una línea <code>use</code> que comienza con el nombre del paquete, <code>rand</code>, y
enumera los items que queremos traer al ámbito. Recuerda que en la sección
<a href="ch02-00-guessing-game-tutorial.html#generar-un-numero-aleatorio">“Generando un número aleatorio”</a><!-- ignore --> del Capítulo 2,
traíamos el trait <code>Rng</code> al ámbito y llamábamos a la función <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span>}</code></pre>
<p>Los miembros de la comunidad de Rust han puesto muchos paquetes disponibles en
<a href="https://crates.io/">crates.io</a>, y traer cualquiera de ellos a tu paquete
involucra estos mismos pasos: listarlos en el archivo <em>Cargo.toml</em> de tu
paquete y usar <code>use</code> para traer items de sus crates al ámbito.</p>
<p>Ten en cuenta que la biblioteca estándar <code>std</code> también es una crate externa a
nuestro paquete. Debido a que la biblioteca estándar se envía con el lenguaje
Rust, no necesitamos cambiar <em>Cargo.toml</em> para incluir <code>std</code>. Pero sí
necesitamos referirnos a él con <code>use</code> para traer items de allí al ámbito de
nuestro paquete. Por ejemplo, con <code>HashMap</code> usaríamos esta línea:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Esta es una ruta absoluta que comienza con <code>std</code>, el nombre del crate de la
biblioteca estándar. También podríamos escribir este <code>use</code> como:</p>
<h3 id="usando-rutas-anidadas-para-limpiar-listas-use-grandes"><a class="header" href="#usando-rutas-anidadas-para-limpiar-listas-use-grandes">Usando rutas anidadas para limpiar listas <code>use</code> grandes</a></h3>
<p>Si estamos usando varios elementos definidos en el mismo crate o el mismo módulo,
enumerar cada elemento en su propia línea puede ocupar mucho espacio vertical en
nuestros archivos. Por ejemplo, estas dos declaraciones <code>use</code> que teníamos en
el juego de adivinanzas en el Listado 2-4 traen items de <code>std</code> al ámbito:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>En su lugar, podemos utilizar rutas anidadas para incluir los mismos elementos en una sola línea.
Hacemos esto especificando la parte común de la ruta, seguida de
dos puntos y luego entre llaves los elementos, como se muestra en el Listado 7-18.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 7-18: Especificación de una ruta anidada para incluir en el ámbito varios elementos con el mismo prefijo</span></p>
<p>En programas más grandes, traer muchos items al ámbito desde el mismo crate o
módulo usando rutas anidadas puede reducir la cantidad de declaraciones <code>use</code>
necesarias en gran medida.</p>
<p>Podemos usar una ruta anidada en cualquier nivel de una ruta, lo que es útil cuando
combinamos dos sentencias <code>use</code> que comparten una sub-ruta. Por ejemplo, el Listado
7-19 muestra dos sentencias use: una que trae <code>std::io</code> al ámbito y
otra que trae <code>std::io::Write</code> al ámbito.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<p><span class="caption">Listado 7-19: Dos sentencias <code>use</code> donde una es una sub-ruta de la otra</span></p>
<p>La parte común de estas dos rutas es <code>std::io</code>, así que podemos usar una ruta
anidada para traer ambos al ámbito en una línea, como se muestra en el Listado
7-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<p><span class="caption">Listado 7-20: Combinando las rutas del listado 7-19 en
una sentencia <code>use</code></span></p>
<p>Esta línea trae <code>std::io</code> y <code>std::io::Write</code> al ámbito.</p>
<h3 id="el-operador-asterisco-glob"><a class="header" href="#el-operador-asterisco-glob">El Operador Asterisco (Glob)</a></h3>
<p>Si queremos incluir al ámbito <em>todos</em> los elementos públicos definidos en una ruta,
podemos especificar esa ruta seguido del operador glob <code>*</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>Esta sentencia <code>use</code> trae todos los elementos públicos definidos en <code>std::collections</code> al ámbito actual. Tenga cuidado al utilizar el operador <code>glob</code>. El operador <code>glob</code> puede hacer más difícil saber qué elementos están en el ámbito y dónde se definió un elemento que este siendo utilizado en su programa.</p>
<p>El operador glob se utiliza a menudo cuando se realizan pruebas para llevar todo lo que se está probando al módulo de <code>pruebas</code>; hablaremos de ello en la sección <a href="ch11-01-writing-tests.html#como-escribir-tests">&quot;Cómo escribir pruebas&quot;</a><!-- ignore --> del capítulo 11. El operador glob también se utiliza a veces como parte del patrón prelude: consulte <a href="../std/prelude/index.html#other-preludes">la documentación de la biblioteca estándar</a><!-- ignore --> para obtener más información sobre ese patrón.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="separando-módulos-en-diferentes-archivos"><a class="header" href="#separando-módulos-en-diferentes-archivos">Separando módulos en diferentes archivos</a></h2>
<p>Hasta ahora, todos los ejemplos en este capítulo definían varios módulos en un archivo. Cuando los módulos se vuelven grandes, es posible que
desees mover sus definiciones a un archivo separado para que el código sea más
fácil de navegar.</p>
<p>Por ejemplo, comencemos desde el código en el listado 7-17 que tenía múltiples
módulos de restaurante. Extraeremos los módulos en archivos en lugar de tener
todos los módulos definidos en el archivo raíz del crate. En este caso, el
archivo raíz del crate es <em>src/lib.rs</em>, pero este procedimiento también
funciona con crates binarios cuyo archivo raíz del crate es <em>src/main.rs</em>.</p>
<p>Primero, extraeremos el módulo <code>front_of_house</code> a su propio archivo. Elimine el
código dentro de las llaves para el módulo <code>front_of_house</code>, dejando solo la
declaración <code>mod front_of_house;</code>, de modo que <em>src/lib.rs</em> contenga el código
que se muestra en el listado 7-21. Ten en cuenta que esto no compilará hasta
que creemos el archivo <em>src/front_of_house.rs</em> en el listado 7-22.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-21: Declarando el módulo <code>front_of_house</code> cuyo
cuerpo estará en <em>src/front_of_house.rs</em></span></p>
<p>Luego, coloca el código que estaba entre las llaves en un nuevo archivo
llamado <em>src/front_of_house.rs</em>, como se muestra en el Listado 7-22. El
compilador sabe que debe buscar en este archivo porque se encontró con la declaración
del módulo en la raíz del crate con el nombre <code>front_of_house</code>.</p>
<p><span class="filename">Filename: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
<p><span class="caption">Listado 7-22: Definiciones dentro del módulo <code>front_of_house</code>
en <em>src/front_of_house.rs</em></span></p>
<p>Ten en cuenta que solo necesitas cargar un archivo usando una declaración <code>mod</code>
<em>una vez</em> en tu árbol de módulos. Una vez que el compilador sabe que el archivo
es parte del proyecto (y sabe en qué parte del árbol de módulos reside el código
debido a dónde has puesto la declaración <code>mod</code>), otros archivos en tu proyecto
deben hacer referencia al código del archivo cargado usando una ruta que indique donde se
declaró, como se cubre en la sección <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Rutas para referirse a un elemento en el
árbol de módulos”</a><!-- ignore -->. En otras palabras, <code>mod</code> no es una
operación de “incluir” que puede haber visto en otros lenguajes de
programación.</p>
<p>Luego, extraeremos el módulo <code>hosting</code> a su propio archivo. El proceso es un
poco diferente porque <code>hosting</code> es un módulo secundario de <code>front_of_house</code>, no
del módulo raíz. Colocaremos el archivo para <code>hosting</code> en un nuevo directorio
que se llamará por sus antepasados en el árbol de módulos, en este caso
<em>src/front_of_house/</em>.</p>
<p>Para comenzar a mover <code>hosting</code>, cambiamos <em>src/front_of_house.rs</em> para
contener solo la declaración del módulo <code>hosting</code>:</p>
<p><span class="filename">Filename: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
<p>Luego creamos un directorio <em>src/front_of_house</em> y un archivo <em>hosting.rs</em> para
contener las definiciones realizadas en el módulo <code>hosting</code>:</p>
<p><span class="filename">Filename: src/front_of_house/hosting.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}</code></pre>
<p>Sí, en cambio, colocamos <em>hosting.rs</em> en el directorio <em>src</em>, el compilador
esperaría que el código de <em>hosting.rs</em> estuviera en un módulo <code>hosting</code>
declarado en la raíz del crate, y no declarado como un hijo del módulo
<code>front_of_house</code>. Las reglas del compilador sobre qué archivos comprobar
para cada código de módulo hacen que los directorios y archivos se ajusten más
al árbol de módulos.</p>
<blockquote>
<h3 id="rutas-alternativas-de-archivos"><a class="header" href="#rutas-alternativas-de-archivos">Rutas alternativas de archivos</a></h3>
<p>Hasta ahora hemos cubierto las rutas de archivos más idiomáticas que utiliza
el compilador de Rust, pero Rust también admite un estilo más antiguo de ruta de
archivo. Para un módulo llamado <code>front_of_house</code> declarado en la raíz del
crate, el compilador buscará el código del módulo en:</p>
<ul>
<li><em>src/front_of_house.rs</em> (lo que cubrimos)</li>
<li><em>src/front_of_house/mod.rs</em> (estilo antiguo, ruta aún soportada)</li>
</ul>
<p>Para un módulo llamado <code>hosting</code> que es un submódulo de <code>front_of_house</code>, el
compilador buscará el código del módulo en:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (lo que cubrimos)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (estilo antiguo, ruta aún soportada)</li>
</ul>
<p>Si usas ambos estilos para el mismo módulo, obtendrás un error del
compilador. Usar una mezcla de ambos estilos para diferentes módulos en el
mismo proyecto está permitido, pero podría ser confuso para las personas que
navegan por tu proyecto.</p>
<p>La principal desventaja del estilo que usa archivos llamados <em>mod.rs</em> es que
tu proyecto puede terminar con muchos archivos llamados <em>mod.rs</em>, lo que puede
ser confuso cuando los tienes abiertos en tu editor al mismo tiempo.</p>
</blockquote>
<p>Hemos movido el código de cada módulo a un archivo separado, y el árbol de
módulos permanece igual. Las llamadas a las funciones de <code>eat_at_restaurant</code>
funcionarán sin ninguna modificación, incluso si las definiciones viven en
archivos diferentes. Esta técnica le permite mover módulos a nuevos archivos a
medida que crecen en tamaño.</p>
<p>Ten en cuenta que la declaración <code>pub use crate::front_of_house::hosting</code> en
<em>src/lib.rs</em> tampoco ha cambiado, ni <code>use</code> tiene ningún impacto en qué archivos
se compilan como parte del crate. La palabra clave <code>mod</code> declara módulos, y
Rust busca en un archivo con el mismo nombre que el módulo para el código que
va en ese módulo.</p>
<h2 id="resumen-6"><a class="header" href="#resumen-6">Resumen</a></h2>
<p>Rust te permite dividir un paquete en múltiples crates y un crate en módulos
para que puedas referirte a elementos definidos en un módulo desde otro módulo.
Puedes hacer esto especificando rutas absolutas o relativas. Estas rutas se
pueden traer al ámbito con una declaración <code>use</code> para que puedas usar una ruta
más corta para múltiples usos del elemento en ese ámbito. El código de los módulos
es privado por defecto, pero puedes hacer que las definiciones sean
públicas agregando la palabra clave <code>pub</code>.</p>
<p>En el siguiente capítulo, veremos algunas estructuras de datos de colección en
la biblioteca estándar que puedes usar en tu código bien organizado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colecciones-comunes"><a class="header" href="#colecciones-comunes">Colecciones comunes</a></h1>
<p>La biblioteca estándar de Rust incluye una serie de estructuras de datos muy
útiles llamadas <em>colecciones</em>. La mayoría de los otros tipos de datos
representan un valor específico, pero las colecciones pueden contener varios
valores. A diferencia de los tipos de datos built-in array y tupla, los
datos a los que apuntan estas colecciones se almacenan en el heap, lo que
significa que la cantidad de datos no necesita conocerse en el momento de la
compilación y puede crecer o disminuir a medida que se ejecuta el programa. Cada
tipo de colección tiene diferentes capacidades y costos, y elegir uno
apropiado para su situación actual es una habilidad que desarrollará con el
tiempo. En este capítulo, discutiremos tres colecciones que se usan muy a menudo
en los programas Rust:</p>
<ul>
<li>Un <em>vector</em> le permite almacenar un número variable de valores uno al lado del
otro.</li>
<li>Un <em>string</em> es una colección de caracteres. Hemos mencionado el tipo <code>String</code>
anteriormente, pero en este capítulo hablaremos de él en profundidad.</li>
<li>Un <em>hash map</em> le permite asociar un valor con una clave especifica. Es una
implementación particular de la estructura de datos más general llamada <em>map</em>.</li>
</ul>
<p>Para aprender sobre los otros tipos de colecciones proporcionados por la
biblioteca estándar, consulte <a href="https://doc.rust-lang.org/std/collections/index.html">la documentación</a>.</p>
<p>Discutiremos cómo crear y actualizar vectores, strings y hash maps, así como
lo que hace que cada uno sea especial.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenando-listas-de-valores-con-vectores"><a class="header" href="#almacenando-listas-de-valores-con-vectores">Almacenando listas de valores con vectores</a></h2>
<p>El primer tipo de colección que veremos es <code>Vec&lt;T&gt;</code>, también conocido como un
<em>vector</em>. Los vectores te permiten almacenar más de un valor en una sola
estructura de datos que pone todos los valores uno al lado del otro en la
memoria. Los vectores solo pueden almacenar valores del mismo tipo. Son útiles
cuando tienes una lista de elementos, como las líneas de texto en un archivo o
los precios de los artículos en un carrito de compras.</p>
<h3 id="creando-un-nuevo-vector"><a class="header" href="#creando-un-nuevo-vector">Creando un nuevo vector</a></h3>
<p>Para crear un nuevo vector vacío, llamamos a la función <code>Vec::new</code>, como se
muestra en el listado 8-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-1: Creando un nuevo vector vacío para mantener
valores de tipo <code>i32</code></span></p>
<p>Ten en cuenta que agregamos una anotación de tipo aquí. Como no estamos
insertando ningún valor en este vector, Rust no sabe qué tipo de elementos
queremos almacenar. Este es un punto importante. Los vectores se implementan
usando genéricos; cubriremos cómo usar genéricos con tus propios tipos en el
Capítulo 10. Por ahora, sepa que el tipo <code>Vec&lt;T&gt;</code> proporcionado por la
biblioteca estándar puede contener cualquier tipo. Cuando creamos un vector
para contener un tipo específico, podemos especificar el tipo dentro de
corchetes angulares. En el listado 8-1, le hemos dicho a Rust que el <code>Vec&lt;T&gt;</code>
en <code>v</code> contendrá elementos del tipo <code>i32</code>.</p>
<p>A menudo, crearás un <code>Vec&lt;T&gt;</code> con valores iniciales y Rust inferirá el tipo de
valor que deseas almacenar, por lo que rara vez necesitarás hacer esta
anotación de tipo. Rust proporciona convenientemente la macro <code>vec!</code>, que
creará un nuevo vector que contenga los valores que le des. El listado 8-2
crea un nuevo <code>Vec&lt;i32&gt;</code> que contiene los valores <code>1</code>, <code>2</code> y <code>3</code>. El tipo
entero es <code>i32</code> porque ese es el tipo entero predeterminado, como discutimos
en la sección <a href="ch03-02-data-types.html#tipos-de-datos">&quot;Tipos de datos&quot;</a><!-- ignore --> del Capítulo 3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-2: Creando un nuevo vector que contiene
valores</span></p>
<p>Debido a que hemos dado valores iniciales <code>i32</code>, Rust puede inferir que el tipo
de <code>v</code> es <code>Vec&lt;i32&gt;</code>, y la anotación de tipo no es necesaria. A continuación,
veremos cómo modificar un vector.</p>
<h3 id="actualizando-un-vector"><a class="header" href="#actualizando-un-vector">Actualizando un vector</a></h3>
<p>Para crear un vector y luego agregar elementos a él, podemos usar el método
<code>push</code>, como se muestra en el listado 8-3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-3: Usando el método <code>push</code> para añadir valores
a un vector</span></p>
<p>Como con cualquier variable, si queremos poder cambiar su valor, necesitamos
hacerlo mutable usando la palabra clave <code>mut</code>, como se discutió en el Capítulo
3. Los números que colocamos dentro son todos del tipo <code>i32</code>, y Rust infiere
esto de los datos, por lo que no necesitamos la anotación <code>Vec&lt;i32&gt;</code>.</p>
<h3 id="leyendo-elementos-de-vectores"><a class="header" href="#leyendo-elementos-de-vectores">Leyendo elementos de vectores</a></h3>
<p>Hay dos formas de hacer referencia a un valor almacenado en un vector: a través
de la indexación o usando el método <code>get</code>. En los siguientes ejemplos,
hemos anotado los tipos de los valores que se devuelven de estas funciones para
obtener una mayor claridad.</p>
<p>En el listado 8-4 se muestran ambos métodos de acceso a un valor en un vector,
con sintaxis de indexación y el método <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {third}&quot;);

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!(&quot;The third element is {third}&quot;),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-4: Usando la sintaxis de indexación o el método
<code>get</code> accediendo a un objeto en un vector</span></p>
<p>Ten en cuenta algunos detalles aquí. Usamos el valor de índice <code>2</code> para obtener
el tercer elemento porque los vectores se indexan por número, comenzando en
cero. Usar <code>&amp;</code> y <code>[]</code> nos da una referencia al elemento en el índice. Cuando
usamos el método <code>get</code> con el índice pasado como argumento, obtenemos un
<code>Option&lt;&amp;T&gt;</code> que podemos usar con <code>match</code>.</p>
<p>La razón por la que Rust proporciona estas dos formas de hacer referencia a un
elemento es para que puedas elegir cómo se comporta el programa cuando intentas
usar un valor de índice fuera del rango de elementos existentes. Como ejemplo,
veamos qué sucede cuando tenemos un vector de cinco elementos y luego intentamos
acceder a un elemento en el índice 100 con cada técnica, como se muestra en el
listado 8-5.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-5: Intentando acceder al elemento en el índice
100 en un vector que contiene 5 elementos</span></p>
<p>Cuando ejecutamos este código, el primer método <code>[]</code> causará que el programa
falle porque intenta acceder a un elemento que no existe. Este método es mejor
usarlo cuando quieres que tu programa se bloquee si hay un intento de acceder a
un elemento más allá del final del vector.</p>
<p>Cuando el método <code>get</code> se pasa un índice que está fuera del rango del vector,
simplemente devuelve <code>None</code> sin entrar en pánico. Tendrías que usar este método
si acceder a un elemento más allá del rango del vector puede suceder con
frecuencia en circunstancias normales. Tu código tendrá entonces la lógica
necesaria para gestionar la presencia de Some(&amp;element) o None, tal y como se explica en el capítulo 6. Por
ejemplo, el índice podría provenir de una persona que ingresa un número. Si
ingresan accidentalmente un número que es demasiado grande y el programa obtiene
un valor <code>None</code>, podrías decirle al usuario cuántos elementos hay en el vector
actual y darle otra oportunidad de ingresar un valor válido. Eso sería más
amigable para el usuario que bloquear el programa debido a un error tipográfico.</p>
<p>Cuando el programa tiene una referencia válida, el borrow checker hace cumplir
las reglas de ownership y borrowing (cubiertas en el Capítulo 4) para asegurar
que esta referencia y cualquier otra referencia a los contenidos del vector
permanezcan válidas. Recuerda la regla que establece que no puedes tener
referencias mutables e inmutables en el mismo ámbito. Esa regla se aplica en el
listado 8-6, donde tenemos una referencia inmutable al primer elemento en un
vector e intentamos agregar un elemento al final. Este programa no funcionará si
también intentamos referirnos a ese elemento más adelante en la función.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {first}&quot;);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listado 8-6: Intentando agregar un elemento a un vector
mientras se mantiene una referencia a un elemento</span></p>
<p>Al compilar este código se producirá este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;The first element is: {first}&quot;);
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin &quot;collections&quot;) due to 1 previous error
</code></pre>
<p>El código en el listado 8-6 podría parecer que debería funcionar: ¿por qué una
referencia al primer elemento se preocuparía por los cambios al final del
vector? Este error se debe a la forma en que funcionan los vectores: porque los
vectores colocan los valores uno al lado del otro en la memoria, agregar un
nuevo elemento al final del vector puede requerir asignar nueva memoria y
copiar los elementos antiguos al nuevo espacio, si no hay suficiente espacio
para poner todos los elementos uno al lado del otro donde se almacena el vector
actualmente. En ese caso, la referencia al primer elemento apuntaría a la
memoria desasignada. Las reglas de borrowing evitan que los programas terminen en
esa situación.</p>
<blockquote>
<p>Nota: Para más información sobre los detalles de implementación del tipo <code>Vec&lt;T&gt;</code>,
véase <a href="https://doc.rust-lang.org/nomicon/vec/vec.html">&quot;The Rustonomicon&quot;</a>.</p>
</blockquote>
<h3 id="iterando-sobre-los-valores-en-un-vector"><a class="header" href="#iterando-sobre-los-valores-en-un-vector">Iterando sobre los valores en un vector</a></h3>
<p>Para acceder a cada elemento en un vector a su vez, iteramos a través de todos
los elementos, en lugar de usar índices para acceder a uno a la vez. El listado
8-7 muestra cómo usar un bucle <code>for</code> para obtener referencias inmutables a cada
elemento en un vector de valores <code>i32</code> e imprimirlos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{i}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-7: Imprimiendo cada elemento en un vector
iterando sobre los elementos usando un ciclo <code>for</code></span></p>
<p>También podemos iterar sobre referencias mutables a cada elemento en un vector
mutable, lo que nos permite cambiar los valores en un vector en el lugar. El
código en el listado 8-8 agregará <code>50</code> a cada elemento en un vector.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-8: Iterando sobre referencias mutables a
elementos en un vector</span></p>
<p>Para cambiar el valor al que se refiere la referencia mutable, tenemos que usar
el operador de desreferencia <code>*</code> para llegar al valor en <code>i</code> antes de poder
usar el operador <code>+=</code>. Hablaremos más sobre el operador de desreferencia en la
sección <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">“Siguiendo el puntero al valor con el operador de
desreferencia”</a><!-- ignore --> del Capítulo 15.</p>
<p>Iterando sobre un vector, ya sea inmutable o mutable, es seguro debido a las
reglas del borrow checker. Si intentáramos insertar o eliminar elementos en los
cuerpos del ciclo <code>for</code> en el listado 8-7 y el listado 8-8, obtendríamos un
error del compilador similar al que obtuvimos con el código en el listado 8-6.
La referencia al vector que el ciclo <code>for</code> contiene evita la modificación
simultánea de todo el vector.</p>
<h3 id="usar-un-enum-para-almacenar-múltiples-tipos"><a class="header" href="#usar-un-enum-para-almacenar-múltiples-tipos">Usar un <code>enum</code> para almacenar múltiples tipos</a></h3>
<p>Los vectores solo pueden almacenar valores del mismo tipo. Esto puede ser
inconveniente; definitivamente hay casos de uso para necesitar almacenar una
lista de elementos de diferentes tipos. Afortunadamente, las variantes de un
<code>enum</code> se definen bajo el mismo tipo de <code>enum</code>, por lo que cuando necesitamos
que un tipo represente elementos de diferentes tipos, ¡podemos definir y usar un
<code>enum</code>!</p>
<p>Por ejemplo, digamos que queremos almacenar en una lista los elementos de una
tabla de hoja de cálculo: algunas columnas pueden contener números, y otras
cadenas de texto. Podemos definir un <code>enum</code> cuyas variantes contendrán los
diferentes tipos de datos, y todas las variantes se considerarán del mismo tipo:
el del <code>enum</code>. Luego podemos crear un vector para contener ese <code>enum</code> y, por lo
tanto, en última instancia, contener diferentes tipos. Hemos demostrado esto en
el listado 8-9.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-9: Definiendo un <code>enum</code> para almacenar valores
de diferentes tipos en un vector</span></p>
<p>Rust necesita saber qué tipos habrá en el vector en tiempo de compilación para
saber exactamente cuánta memoria en el montón se necesitará para almacenar cada
elemento. También debemos ser explícitos sobre qué tipos están permitidos en
este vector. Si Rust permitiera que un vector contenga cualquier tipo, existiría
la posibilidad de que uno o más de los tipos causaran errores con las
operaciones realizadas en los elementos del vector. Usar un <code>enum</code> más una
expresión <code>match</code> significa que Rust se asegurará en tiempo de compilación de
que se maneje cada caso posible, como se discutió en el Capítulo 6.</p>
<p>Si tu no sabes el conjunto exhaustivo de tipos que un programa obtendrá en
tiempo de ejecución para almacenar en un vector, la técnica de <code>enum</code> no
funcionará. En su lugar, puede usar un objeto de rasgo, que cubriremos en el
Capítulo 17.</p>
<p>Ahora que hemos discutido algunas de las formas más comunes de usar vectores,
asegúrese de revisar <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">la documentación de la API</a><!-- ignore --> para
todos los muchos métodos útiles definidos en <code>Vec&lt;T&gt;</code> por la biblioteca
estándar. Por ejemplo, además de <code>push</code>, un método <code>pop</code> elimina y devuelve el
último elemento.</p>
<h3 id="liberar-un-vector-libera-sus-elementos"><a class="header" href="#liberar-un-vector-libera-sus-elementos">Liberar un vector libera sus elementos</a></h3>
<p>Como cualquier otro <code>struct</code>, un vector se libera cuando sale del ámbito, como
se anota en el listado 8-10.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-10: Mostrando dónde se colocan el vector y sus
elementos</span></p>
<p>Cuando se libera el vector, también se libera todo su contenido, lo que
significa que se limpiarán los enteros que contiene. El borrow checker garantiza
que cualquier referencia al contenido de un vector solo se utilice mientras el
vector en sí sea válido.</p>
<p>Pasemos al siguiente tipo de colección: ¡<code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenando-texto-codificado-en-utf-8-con-strings"><a class="header" href="#almacenando-texto-codificado-en-utf-8-con-strings">Almacenando texto codificado en UTF-8 con Strings</a></h2>
<p>Hemos hablado de strings en el Capítulo 4, pero las veremos con más detalle
Los nuevos Rustaceans suelen quedarse atascados en las cadenas por una
combinación de tres razones: la propensión de Rust a exponer posibles errores,
los strings son una estructura de datos más complicada de lo que muchos
programadores le dan crédito, y UTF-8. Estos factores se combinan de una manera
que puede parecer difícil cuando se viene de otros lenguajes de programación.</p>
<p>Discutiremos strings en el contexto de las colecciones porque las strings se
implementan como una colección de bytes, más algunos métodos para proporcionar
funcionalidad útil cuando esos bytes se interpretan como texto. En esta
sección, hablaremos sobre las operaciones en <code>String</code> que cada tipo de
colección tiene, como crear, actualizar y leer. También discutiremos las
formas en que <code>String</code> es diferente de las otras colecciones, es decir, cómo
indexar en un <code>String</code> se complica por las diferencias entre cómo las personas
y las computadoras interpretan los datos de <code>String</code>.</p>
<h3 id="qué-es-un-string"><a class="header" href="#qué-es-un-string">¿Qué es un string?</a></h3>
<p>Bien primero definamos lo que queremos decir con el término <em>string</em>. Rust solo
tiene un tipo de string en el lenguaje principal, que es el string slice <code>str</code>
que generalmente se ve en su forma prestada <code>&amp;str</code>. En el Capítulo 4, hablamos
sobre <em>string slices</em>, que son referencias a algunos datos de cadena codificados
en UTF-8 almacenados en otro lugar. Las literales de cadena, por ejemplo, se
almacenan en el binario del programa y, por lo tanto, son trozos de cadena.</p>
<p>El tipo <code>String</code>, que es proporcionado por la biblioteca estándar en lugar de
codificado en el lenguaje principal, es un tipo de cadena que puede crecer, mutable,
de propiedad, codificado en UTF-8. Cuando los Rustaceans se refieren a &quot;strings&quot; en Rust,
pueden estar refiriéndose a cualquiera de los tipos <code>String</code> o <code>str</code>, no solo
a uno de esos tipos. Aunque esta sección trata principalmente de <code>String</code>, ambos
tipos se usan mucho en la biblioteca estándar de Rust, y tanto <code>String</code> como
las rebanadas de cadena son codificadas en UTF-8.</p>
<h3 id="creando-un-nuevo-string"><a class="header" href="#creando-un-nuevo-string">Creando un nuevo String</a></h3>
<p>Muchas de las mismas operaciones disponibles con <code>Vec&lt;T&gt;</code> también están
disponibles con <code>String</code>, ya que <code>String</code> se implementa en realidad como un
envoltorio alrededor de un vector de bytes con algunas garantías, restricciones
y capacidades adicionales. Un ejemplo de una función que funciona de la misma
manera con <code>Vec&lt;T&gt;</code> y <code>String</code> es la función <code>new</code> para crear una instancia,
que se muestra en el listado 8-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-11: Creando un nuevo y vacío <code>String</code></span></p>
<p>Esta línea crea un nuevo <code>String</code> vacío llamado <code>s</code>, el cual podemos luego cargar
con datos. A menudo, tendremos algunos datos iniciales que queremos comenzar
en el string. Para eso, usamos el método <code>to_string</code>, que está disponible en
cualquier tipo que implemente el trait <code>Display</code>, como lo hacen los String
Literals. El listado 8-12 muestra dos ejemplos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = &quot;initial contents&quot;;

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = &quot;initial contents&quot;.to_string();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-12: Usando el método <code>to_string</code> para crear un
<code>String</code> a partir de un string literal</span></p>
<p>Este código crea un string que contiene <code>initial contents</code>.</p>
<p>Podemos también usar la función <code>String::from</code> para crear un <code>String</code> a partir
de un string literal. El código en el listado 8-13 es equivalente al código del
listado 8-12 que usa <code>to_string</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;initial contents&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-13: Usando la función <code>String::from</code> para crear
un <code>String</code> a partir de un string literal</span></p>
<p>Debido a que los strings se usan para muchas cosas, podemos usar muchas APIs
genéricas diferentes para strings, lo que nos proporciona muchas opciones.
Algunos de ellos pueden parecer redundantes, ¡pero todos tienen su lugar! En
este caso, <code>String::from</code> y <code>to_string</code> hacen lo mismo, por lo que elegir
depende del estilo y la legibilidad.</p>
<p>Recuerda que los strings son UTF-8 codificados, por lo que podemos incluir
cualquier dato codificado correctamente en ellos, Como se muestra en el listado
8-14.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;السلام عليكم&quot;);
    let hello = String::from(&quot;Dobrý den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;שלום&quot;);
    let hello = String::from(&quot;नमस्ते&quot;);
    let hello = String::from(&quot;こんにちは&quot;);
    let hello = String::from(&quot;안녕하세요&quot;);
    let hello = String::from(&quot;你好&quot;);
    let hello = String::from(&quot;Olá&quot;);
    let hello = String::from(&quot;Здравствуйте&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-14: Almacenamiento de saludos en diferentes
idiomas en strings</span></p>
<p>Todos estos strings son valores válidos de <code>String</code>.</p>
<h3 id="actualizando-un-string"><a class="header" href="#actualizando-un-string">Actualizando un String</a></h3>
<p>Un <code>String</code> puede crecer en tamaño y su contenido puede cambiar, al igual que
el contenido de un <code>Vec&lt;T&gt;</code>, si se introducen más datos en el. Además, puedes usar
convenientemente el operador <code>+</code> o el macro <code>format!</code> para concatenar valores de
<code>String</code>.</p>
<h4 id="agregando-a-un-string-con-push_str-y-push"><a class="header" href="#agregando-a-un-string-con-push_str-y-push">Agregando a un String con <code>push_str</code> y <code>push</code></a></h4>
<p>Podemos hacer crecer un <code>String</code> usando el método <code>push_str</code> para agregar un
string slice, como se muestra en el listado 8-15.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-15: Agregando un string slice a un <code>String</code>
usando el método <code>push_str</code></span></p>
<p>Después de estas dos líneas, <code>s</code> contendrá <code>foobar</code>. El método <code>push_str</code> toma
un string slice porque no necesariamente queremos tomar posesión del parámetro.
Por ejemplo, en el código del listado 8-16, queremos poder usar <code>s2</code> después de
agregar su contenido a <code>s1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {s2}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-16: Uso de un string slice después de agregar
su contenido a un <code>String</code></span></p>
<p>Si el método <code>push_str</code> tomara posesión de <code>s2</code>, no podríamos imprimir su valor
en la última línea. ¡Sin embargo, este código funciona como esperamos!</p>
<p>El método <code>push</code> toma un solo carácter como parámetro y lo agrega al <code>String</code>.
El listado 8-17 agrega la letra <code>l</code> a un <code>String</code> usando el método <code>push</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-17: Agregando un carácter a un valor <code>String</code>
usando <code>push</code></span></p>
<p>Como resultado, <code>s</code> contendrá <code>lol</code>.</p>
<h4 id="concatenacion-con-el-operador--o-la-macro-format"><a class="header" href="#concatenacion-con-el-operador--o-la-macro-format">Concatenacion con el operador <code>+</code> o la Macro <code>format!</code></a></h4>
<p>A veces, necesitarás combinar dos strings. Sin embargo, no es tan simple como
usar el operador <code>+</code> con dos referencias a <code>String</code>. El código en el listado
8-18 no compilará:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-18: Usando el operador <code>+</code> para combinar dos
valores <code>String</code> en un nuevo valor <code>String</code></span></p>
<p>El string <code>s3</code> contendrá <code>Hello, world!</code>. La razón por la que <code>s1</code> ya no es
válido después de la adición, y la razón por la que usamos una referencia a
<code>s2</code>, tiene que ver con la firma del método que se llama cuando usamos el
operador <code>+</code>. El operador <code>+</code> usa el método <code>add</code>, cuya firma se ve algo como
esto:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>En la biblioteca estándar, verás <code>add</code> definido usando genéricos y tipos
asociados. Aquí, hemos sustituido tipos concretos, que es lo que sucede cuando
llamamos a este método con valores <code>String</code>. Discutiremos los genéricos en el
Capítulo 10. Esta firma nos da las pistas que necesitamos para entender las
partes complicadas del operador <code>+</code>.</p>
<p>Primero, <code>s2</code> tiene un <code>&amp;</code>, lo que significa que estamos agregando una referencia
del segundo string al primer string. Esto se debe al parámetro <code>s</code> en la
función <code>add</code>: solo podemos agregar un <code>&amp;str</code> a un <code>String</code>; no podemos agregar
dos valores <code>String</code> juntos. Pero espera, el tipo de <code>&amp;s2</code> es <code>&amp;String</code>, no
<code>&amp;str</code>, como se especifica en el segundo parámetro de <code>add</code>. ¿Entonces por qué
compila el listado 8-18?</p>
<p>La razón por la que podemos usar <code>s2</code> en la llamada a <code>add</code> es que el
compilador puede <em>convertir</em> el argumento <code>&amp;String</code> en un <code>&amp;str</code>. Cuando<br />
llamamos al método <code>add</code>, Rust usa una <em>coerción de dereferencia</em>, que aquí
convierte <code>&amp;s2</code> en <code>&amp;s2[..]</code>. Discutiremos la coerción de dereferencia con más
detalle en el Capítulo 15. Debido a que <code>add</code> no toma posesión del parámetro
<code>s</code>, <code>s2</code> seguirá siendo un <code>String</code> válido después de esta operación.</p>
<p>En segundo lugar, podemos ver en la firma que <code>add</code> toma el ownership de <code>self</code>,
porque <code>self</code> no tiene un <code>&amp;</code>. Esto significa que <code>s1</code> en el listado 8-18 se
moverá a la llamada de <code>add</code> y ya no será válido después de eso. Entonces,
aunque <code>let s3 = s1 + &amp;s2;</code> parece que copiará ambos strings y creará uno
nuevo, esta declaración realmente toma posesión de <code>s1</code>, agrega una copia del
contenido de <code>s2</code> y luego devuelve la propiedad del resultado. En otras
palabras, parece que está haciendo muchas copias, pero no lo está; la
implementación es más eficiente que copiar.</p>
<p>Si necesitamos concatenar múltiples strings, el comportamiento del operador <code>+</code>
se vuelve difícil de manejar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>En este punto, <code>s</code> contendrá <code>tic-tac-toe</code>. Con todos los caracteres <code>+</code> y <code>&quot;</code>
es difícil ver qué está pasando. Para una combinación de cadenas más
complicada, podemos usar la macro <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{s1}-{s2}-{s3}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Este código también establece <code>s</code> en <code>tic-tac-toe</code>. La macro <code>format!</code> funciona
como <code>println!</code>, pero en lugar de imprimir la salida en la pantalla, devuelve
un <code>String</code> con el contenido. La versión del código que usa <code>format!</code> es mucho
más fácil de leer, y el código generado por la macro <code>format!</code> usa referencias
para que esta llamada no tome posesión de ninguno de sus parámetros.</p>
<h3 id="indexando-en-strings"><a class="header" href="#indexando-en-strings">Indexando en Strings</a></h3>
<p>En muchos otros lenguajes de programación, acceder a caracteres individuales en
un string referenciándolos por índice es una operación válida y común. Sin
embargo, si intentas acceder a partes de un <code>String</code> usando la sintaxis de
indexación en Rust, obtendrás un error. Considera el código inválido en el
listado 8-19.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}</span></code></pre>
<p><span class="caption">Listado 8-19: Intentando usar la sintaxis de indexación con
un String</span></p>
<p>Este código dará como resultado el siguiente error:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`, which is required by `String: Index&lt;_&gt;`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin &quot;collections&quot;) due to 1 previous error
</code></pre>
<p>El error y la nota cuentan la historia: los strings de Rust no admiten
indexación. Pero, ¿por qué no? Para responder a esa pregunta, necesitamos
discutir cómo Rust almacena los strings en la memoria.</p>
<h4 id="representación-interna"><a class="header" href="#representación-interna">Representación Interna</a></h4>
<p>Un <code>String</code> es un wrapper sobre un <code>Vec&lt;u8&gt;</code>. Veamos algunos de nuestros
strings de ejemplo UTF-8 correctamente codificados del listado 8-14. Primero,
este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שלום&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span><span class="boring">    let hello = String::from(&quot;Здравствуйте&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p>En este caso, <code>len</code> será <code>4</code>, lo que significa que el vector que almacena el
string <code>“Hola”</code> tiene 4 bytes de largo. Cada una de estas letras toma un byte
cuando se codifica en UTF-8. La siguiente línea, sin embargo, puede
sorprenderte. (Nota que este string comienza con la letra cirílica <em>Ze</em> mayúscula,
no con el número árabe 3.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שלום&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span>    let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}</span></code></pre></pre>
<p>Si tu te preguntas que tan largo es el string, podrías decir 12. De hecho, la
respuesta de Rust es 24: ese es el número de bytes que se necesitan para
codificar “Здравствуйте” en UTF-8, porque cada valor escalar Unicode en ese
string toma 2 bytes de almacenamiento. Por lo tanto, un índice en los bytes del
string no siempre se correlacionará con un valor escalar Unicode válido. Para
demostrarlo, considera este código inválido de Rust:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];</code></pre>
<p>Tu Ahora sabes que <code>answer</code> no será <code>З</code>, la primera letra. Cuando codificado
en UTF-8, el primer byte de <code>З</code> es <code>208</code> y el segundo es <code>151</code>, por lo que
parecería que <code>answer</code> debería ser <code>208</code>, pero <code>208</code> no es un carácter válido
por sí solo. Devolver <code>208</code> probablemente no sea lo que un usuario querría si
pidieran la primera letra de esta cadena; sin embargo, esos son los únicos
datos que Rust tiene en el índice de bytes 0. Los usuarios generalmente no
quieren que se devuelva el valor de byte, incluso si la cadena contiene solo
letras latinas: si <code>&amp;&quot;hello&quot;[0]</code> fuera un código válido que devolviera el valor
de byte, devolvería <code>104</code>, no <code>h</code>.</p>
<p>La respuesta, entonces, es que para evitar devolver un valor inesperado y
causar errores que podrían no descubrirse de inmediato, Rust no compila este
código en absoluto y evita malentendidos al comienzo del proceso de
desarrollo.</p>
<h4 id="bytes-valores-escalares-y-grupos-de-grafemas"><a class="header" href="#bytes-valores-escalares-y-grupos-de-grafemas">Bytes, valores escalares y grupos de grafemas</a></h4>
<p>Otro punto sobre UTF-8 es que hay tres formas relevantes de ver las cadenas
desde la perspectiva de Rust: como bytes, valores escalares y grupos de
grafemas (lo más parecido a lo que llamaríamos <em>letras</em>).</p>
<p>Si observamos la palabra “नमस्ते” en escritura Devanagari, se almacena como un
vector de valores <code>u8</code> que se ve así:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Eso es 18 bytes y es como las computadoras almacenan los datos. Si los
observamos como valores escalares Unicode, que es lo que es el tipo <code>char</code> de
Rust, esos bytes se ven así:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Aquí hay seis valores <code>char</code>, pero el cuarto y el sexto no son letras: son
diacríticos que no tienen sentido por sí mismos. Finalmente, si los miramos
como grupos de grafemas, obtendríamos lo que una persona llamaría las cuatro
letras que componen la palabra hindi:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust proporciona diferentes formas de interpretar los datos de string sin
procesar que las computadoras almacenan para que cada programa pueda elegir la
interpretación que necesita, sin importar en qué idioma humano estén los datos.</p>
<p>Una última razón por la que Rust no permite indexar en un <code>String</code> para obtener
un carácter es que se espera que las operaciones de indexación siempre tomen
tiempo constante (O(1)). Pero no es posible garantizar ese rendimiento con un
<code>String</code>, porque Rust tendría que recorrer el contenido desde el principio
hasta el índice para determinar cuántos caracteres válidos había.</p>
<h3 id="slicing-strings"><a class="header" href="#slicing-strings">Slicing Strings</a></h3>
<p>La indexación en un <code>String</code> suele ser una mala idea porque no está claro cuál
debería ser el tipo de retorno de la operación de indexación de string: un
valor de byte, un carácter, un grupo de grafemas o una rebanada de string. Si
realmente necesita usar índices para crear rebanadas de string, por lo tanto,
Rust le pide que sea más específico.</p>
<p>En lugar de indexar usando <code>[]</code> con un solo número, puede usar <code>[]</code> con un
rango para crear un string slice conteniendo bytes particulares:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>Aquí, <code>s</code> será un <code>&amp;str</code> que contiene los primeros cuatro bytes del string. Antes,
mencionamos que cada uno de estos caracteres era de dos bytes, lo que significa
que <code>s</code> será <code>Зд</code>.</p>
<p>Si intentáramos hacer un slice con solo una parte de los bytes de un carácter,
algo como <code>&amp;hello[0..1]</code>, Rust entraría en pánico en tiempo de
ejecución de la misma manera que si se accediera a un índice no válido
en un vector:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Debemos tener cuidado cuando creamos string slices, porque hacerlo puede 
bloquear su programa.</p>
<h3 id="métodos-para-iterar-sobre-strings"><a class="header" href="#métodos-para-iterar-sobre-strings">Métodos para iterar sobre Strings</a></h3>
<p>La mejor manera de operar en partes de strings es ser explícito sobre si
desea caracteres o bytes. Para valores escalares Unicode individuales, use el
método <code>chars</code>. Llamar a <code>chars</code> en “Зд” separa y devuelve dos valores de tipo
<code>char</code>, y puede iterar sobre el resultado para acceder a cada elemento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;Зд&quot;.chars() {
    println!(&quot;{c}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Este código imprimirá lo siguiente:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>Alternativamente, el método <code>bytes</code> devuelve cada byte sin procesar, que puede
ser apropiado para su dominio:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;Зд&quot;.bytes() {
    println!(&quot;{b}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Este código imprimirá los cuatro bytes que componen el string:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Pero asegúrate de recordar que los valores escalares de Unicode válidos pueden 
estar compuestos por más de un byte.</p>
<p>Obtener grupos de grafemas a partir de cadenas, como en el caso del alfabeto 
Devanagari, es complejo, por lo que esta funcionalidad no está proporcionada por
la biblioteca estándar. Hay paquetes disponibles en 
<a href="https://crates.io/">crates.io</a><!-- ignore --> si necesitas esta funcionalidad.</p>
<h3 id="los-strings-no-son-tan-simples"><a class="header" href="#los-strings-no-son-tan-simples">Los Strings no son tan simples</a></h3>
<p>Para resumir, los strings son complicados. Los diferentes lenguajes de
programación hacen diferentes elecciones sobre cómo presentar esta complejidad
al programador. Rust ha elegido hacer que el manejo correcto de los datos
<code>String</code> sea el comportamiento predeterminado para todos los programas de Rust,
lo que significa que los programadores tienen que pensar más en el manejo de
datos UTF-8 por adelantado. Este compromiso expone más de la complejidad de
las cadenas de lo que parece en otros lenguajes de programación, pero evita
que tenga que manejar errores que involucran caracteres no ASCII más adelante
en su ciclo de vida de desarrollo.</p>
<p>La buena noticia es que la biblioteca estándar ofrece mucha funcionalidad
construida a partir de los tipos <code>String</code> y <code>&amp;str</code> para ayudar a manejar estas
situaciones complejas correctamente. Asegúrese de consultar la documentación
para obtener métodos útiles como <code>contains</code> para buscar en un string y
<code>replace</code> para sustituir partes de un string por otro string.</p>
<p>Pasemos a algo un poco menos complejo: ¡Hash Maps!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenar-claves-con-valores-asociados-en-hashmaps"><a class="header" href="#almacenar-claves-con-valores-asociados-en-hashmaps">Almacenar Claves con Valores Asociados en HashMaps</a></h2>
<p>La última de nuestras colecciones comunes es el <em>hash map</em>. El tipo <code>HashMap&lt;K, V&gt;</code> almacena un mapeo de claves de tipo <code>K</code> a valores de tipo <code>V</code> usando una
<em>función hash</em>, que determina cómo coloca estas claves y valores en la memoria.
Muchos lenguajes de programación admiten este tipo de estructura de datos, pero
a menudo usan un nombre diferente, como <em>hash</em>, <em>map</em>, <em>object</em>, <em>hash table</em>,
<em>diccionario</em> o <em>arreglos asociativos</em>, solo para nombrar algunos.</p>
<p>Los hash maps son útiles cuando desea buscar datos no usando un índice, como
puede hacerlo con vectores, sino usando una clave que puede ser de cualquier
tipo. Por ejemplo, en un juego, podría realizar un seguimiento de la puntuación
de cada equipo en un hash map en el que cada clave es el nombre de un equipo y
los valores son la puntuación de cada equipo. Dado un nombre de equipo, puede
recuperar su puntuación.</p>
<p>Repasaremos la API básica de los hash maps en esta sección, pero muchas más
cosas buenas se esconden en las funciones definidas en <code>HashMap&lt;K, V&gt;</code> por la
biblioteca estándar. Como siempre, consulte la documentación de la biblioteca
estándar para obtener más información.</p>
<h3 id="creando-un-nuevo-hashmap"><a class="header" href="#creando-un-nuevo-hashmap">Creando un nuevo HashMap</a></h3>
<p>Una forma de crear un hash map vacío es usar <code>new</code> y agregar elementos con
<code>insert</code>. En el Listado 8-20, estamos realizando un seguimiento de las
puntuaciones de dos equipos cuyos nombres son <em>Blue</em> y <em>Yellow</em>. El equipo
Blue comienza con 10 puntos y el equipo Yellow comienza con 50.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-20: Creando un nuevo hash map e insertando
algunas claves y valores</span></p>
<p>Ten en cuenta que es importante importar primero el módulo <code>HashMap</code> de la
biblioteca estándar de colecciones. De nuestras tres colecciones comunes,
ésta es la menos utilizada, por lo que no se incluye automáticamente en las
características del <em>prelude</em>. Además, los hash maps tienen menos soporte por
parte de la biblioteca estándar; por ejemplo, no hay una macro incorporada para
construirlos.</p>
<p>Al igual que los vectores, los hash maps almacenan sus datos en el <em>heap</em>. Este
<code>HashMap</code> tiene claves de tipo <code>String</code> y valores de tipo <code>i32</code>. Al igual que los
vectores, los hash maps son homogéneos: todas las claves deben tener el mismo
tipo entre sí y todos los valores deben tener el mismo tipo.</p>
<h3 id="accediendo-a-los-valores-en-un-hashmap"><a class="header" href="#accediendo-a-los-valores-en-un-hashmap">Accediendo a los valores en un HashMap</a></h3>
<p>Podemos obtener un valor de un hash map proporcionando su clave al método <code>get</code>
como se muestra en el listado 8-21.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-21: Acceso al puntaje para el equipo Blue
almacenado en el hash map</span></p>
<p>Aquí, <code>score</code> tendrá el valor que está asociado con el equipo Blue, y el
resultado será <code>10</code>. El método <code>get</code> devuelve un <code>Option&lt;&amp;V&gt;</code>; si no hay un
valor para ese clave en el hash map, <code>get</code> devolverá <code>None</code>. Este programa
maneja un <code>Option</code> llamando a <code>copied</code> para obtener un <code>Option&lt;i32&gt;</code> en lugar
de un <code>Option&lt;&amp;i32&gt;</code>, luego <code>unwrap_or</code> para establecer <code>score</code> en cero si
<code>scores</code> no tiene una entrada para la clave.</p>
<p>Podemos iterar sobre cada par clave-valor en un hash map de manera similar a
como lo hacemos con vectores, usando un ciclo <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{key}: {value}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>Este código imprimirá cada par en un orden arbitrario:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="hashmaps-y-ownership"><a class="header" href="#hashmaps-y-ownership">HashMaps y Ownership</a></h3>
<p>Para los tipos que implementan el trait <code>Copy</code>, como <code>i32</code>, los valores se
copian en el hash map. Para valores de propiedad como <code>String</code>, los valores se
moverán y el hash map será el propietario de esos valores, como se demuestra
en el listado 8-22.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;Blue&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-22: Mostrando que claves y valores son propiedad
del hash map una vez que se insertan</span></p>
<p>No podemos usar <code>field_name</code> y <code>field_value</code> después de que se hayan movido al
hash map con la llamada a <code>insert</code>.</p>
<p>Si insertamos referencias a valores en el hash map, los valores no se moverán
al hash map. Los valores a los que apuntan las referencias deben ser válidos
al menos mientras el hash map sea válido. Hablaremos más sobre estos problemas
en la sección <a href="ch10-03-lifetime-syntax.html#validando-referencias-con-lifetimes">“Validando referencias con Lifetimes”</a><!-- ignore --> en el
Capítulo 10.</p>
<h3 id="actualizando-un-hashmap"><a class="header" href="#actualizando-un-hashmap">Actualizando un HashMap</a></h3>
<p>Aunque la cantidad de pares clave/valor es creciente, cada clave única solo puede
tener un valor asociado con ella a la vez (pero no viceversa: por ejemplo, el
equipo Blue y el equipo Yellow podrían tener el valor <code>10</code> almacenados en el hash
map <code>scores</code>).</p>
<p>Cuando queremos cambiar los datos en un hash map, tenemos que decidir cómo
manejar el caso en el que una clave ya tiene un valor asignado. Podrías
reemplazar el valor antiguo por el nuevo valor, ignorando completamente el
valor antiguo. Podrías mantener el valor antiguo e ignorar el nuevo valor,
agregando el nuevo valor solo si la clave <em>no</em> tiene ya un valor. O podrías
combinar el valor antiguo y el nuevo valor. ¡Veamos cómo hacer cada una de
estas!</p>
<h4 id="reemplazando-un-valor"><a class="header" href="#reemplazando-un-valor">Reemplazando un valor</a></h4>
<p>Si insertamos una clave y un valor en un hash map y luego insertamos esa misma
clave con un valor diferente, el valor asociado con esa clave se reemplazará.
Aunque el código en el listado 8-23 llama a <code>insert</code> dos veces, el hash map
solo contendrá un par clave-valor porque estamos insertando el valor para la clave
del equipo Blue dos veces.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);

    println!(&quot;{scores:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-23: Reemplazando un valor almacenado con una
clave en particular</span></p>
<p>Este código imprimirá <code>{&quot;Blue&quot;: 25}</code>. El valor original de <code>10</code> ha sido
sobrescrito.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="insertando-una-clave-y-un-valor-solo-si-una-clave-no-está-presente"><a class="header" href="#insertando-una-clave-y-un-valor-solo-si-una-clave-no-está-presente">Insertando una clave y un valor solo si una clave no está presente</a></h4>
<p>Es común verificar si una clave en particular ya existe en el hash map con un
valor y luego realizar las siguientes acciones: si la clave existe en el hash
map, el valor existente debe permanecer tal como está; si la clave no existe,
insertarla junto con su valor.</p>
<p>Los hash maps tienen una API especial para esto llamada <code>entry</code> que toma la clave
que desea verificar como parámetro. El valor de retorno del método <code>entry</code> es
un enum llamado <code>Entry</code> que representa un valor que puede o no existir. Digamos
que queremos verificar si la clave para el equipo Yellow tiene un valor
asociado. Si no lo tiene, queremos insertar el valor <code>50</code>, y lo mismo para el
equipo Blue. Usando la API <code>entry</code>, el código se ve como el listado 8-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{scores:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-24: Usando el método <code>entry</code> para insertar solo
si la clave aún no tiene un valor</span></p>
<p>El método <code>or_insert</code> en <code>Entry</code> está definido para devolver una referencia
mutable al valor correspondiente a la clave <code>Entry</code> si esa clave existe, y si no,
inserta el parámetro como el nuevo valor para esta clave y devuelve una
referencia mutable al nuevo valor. Esta técnica es mucho más limpia que
escribir la lógica nosotros mismos y, además, juega mejor con el borrow
checker.</p>
<p>Ejecutar el código en el listado 8-24 imprimirá <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>.
La primera llamada a <code>entry</code> insertará la clave para el equipo Yellow con el
valor 50 porque el equipo Yellow no tiene un valor todavía. La segunda llamada
a <code>entry</code> no cambiará el hash map porque el equipo Blue ya tiene el valor <code>10</code>.</p>
<h4 id="actualizando-un-valor-basado-en-el-valor-anterior"><a class="header" href="#actualizando-un-valor-basado-en-el-valor-anterior">Actualizando un valor basado en el valor anterior</a></h4>
<p>Otro caso común para los hash maps es buscar un valor para una clave y luego
actualizar ese valor en función del valor anterior. Por ejemplo, el listado 8-25
muestra un código que cuenta cuántas veces aparece cada palabra en algún texto.
Usamos un hash map con las palabras como claves y aumentamos el valor para
mantener un recuento de cuántas veces hemos visto esa palabra. Si es la primera
vez que vemos una palabra, primero insertaremos el valor <code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = &quot;hello world wonderful world&quot;;

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!(&quot;{map:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-25: Contando ocurrencias de palabras usando un
hash map que almacena palabras y cuenta</span></p>
<p>Este código imprimirá <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. Es posible
que veas los mismos pares clave-valor en un orden diferente: recuerda la sección
<a href="ch08-03-hash-maps.html#accediendo-a-los-valores-en-un-hashmap">“Accediendo a valores en un hash map”</a><!-- ignore --> que iterar sobre
un hash map ocurre en un orden arbitrario.</p>
<p>El método <code>split_whitespace</code> devuelve un iterator sobre sub-slices, separados
por espacios en blanco, del valor en <code>text</code>. El método <code>or_insert</code> devuelve una
referencia mutable (<code>&amp;mut V</code>) al valor para la clave especificada. Aquí,
almacenamos esa referencia mutable en la variable <code>count</code>, por lo que para
asignar a ese valor, primero debemos desreferenciar <code>count</code> usando el asterisco
(<code>*</code>). La referencia mutable sale del ámbito al final del ciclo <code>for</code>, por lo
que todos estos cambios son seguros y permitidos por las reglas del borrowing.</p>
<h3 id="funciones-de-hashing"><a class="header" href="#funciones-de-hashing">Funciones de Hashing</a></h3>
<p>Por defecto, <code>HashMap</code> usa una función de hashing llamada <em>SipHash</em> que puede
proporcionar resistencia a ataques de Denegación de Servicio (DoS) que
involucran tablas hash<sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore -->. Este no es el algoritmo de
hashing más rápido disponible, pero el compromiso por una mejor seguridad que
viene con la caída en el rendimiento vale la pena. Si perfilas tu código y
encuentras que la función de hash predeterminada es demasiado lenta para tus
propósitos, puedes cambiar a otra función especificando un hasher diferente. Un
<em>hasher</em> es un tipo que implementa el trait <code>BuildHasher</code>. Hablaremos sobre
traits y cómo implementarlos en el <a href="ch10-02-traits.html">Capítulo 10</a>. No necesariamente tienes que
implementar tu propio hasher desde cero;
<a href="https://crates.io/">crates.io</a><!-- ignore -->
tiene bibliotecas compartidas por otros usuarios de Rust que proporcionan
hashes que implementan muchos algoritmos de hashing comunes.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="resumen-7"><a class="header" href="#resumen-7">Resumen</a></h2>
<p>Los vectores, los strings y los hash maps proporcionan una funcionalidad
importante que necesitarás cuando quieras almacenar, acceder y modificar datos.
Aquí hay algunos ejercicios que ahora deberías estar equipado para resolver:</p>
<ol>
<li>Dada una lista de enteros, usa un vector y devuelve la mediana (cuando se
ordena, el valor en la posición media) y la moda (el valor que ocurre con más
frecuencia; un hash map será útil aquí) de la lista.</li>
<li>Convierte strings a pig latin. La primera consonante de cada palabra se
mueve al final de la palabra y se agrega &quot;<em>ay</em>&quot;, por lo que &quot;<em>primero</em>&quot; se
convierte en &quot;<em>rimepay</em>&quot;. Sin embargo, si la palabra comienza con una vocal,
simplemente agregue &quot;hay&quot; al final de la palabra (&quot;<em>manzanaay</em>&quot;). ¡Ten en
cuenta las reglas de UTF-8!</li>
<li>Usando un hash map y vectores, cree un texto de interfaz para permitir que un
usuario agregue nombres de empleados a un departamento en una empresa. Por
ejemplo, &quot;Agregar Sally a Ingeniería&quot; o &quot;Agregar Amir a Ventas&quot;. Luego,
permita que el usuario recupere una lista de todas las personas en un
departamento o todas las personas en la empresa por departamento, ordenadas
alfabéticamente.</li>
</ol>
<p>La documentación de la biblioteca estándar describe métodos que los vectores,
strings y hash maps tienen que ser útiles para estos ejercicios.</p>
<p>Nos estamos adentrando en programas más complejos en los que las operaciones
pueden fallar, por lo que es un momento perfecto para discutir el manejo de
errores. ¡Haremos eso a continuación!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manejo-de-errores"><a class="header" href="#manejo-de-errores">Manejo de Errores</a></h1>
<p>Los errores son un hecho de la vida en el software, por lo que Rust tiene una
serie de características para manejar situaciones en las que algo sale mal. En
muchos casos, Rust te obliga a reconocer la posibilidad de un error y tomar
alguna acción antes de que tu código se compile. ¡Este requisito hace que su
programa sea más robusto al garantizar que descubrirá errores y los manejará
adecuadamente antes de implementar su código en producción!</p>
<p>Rust agrupa los errores en dos categorías principales: errores <em>recuperables</em> e
<em>irrecuperables</em>. Para un error recuperable, como un error de <em>archivo no
encontrado</em>, lo más probable es que solo queramos informar el problema al
usuario y volver a intentar la operación. Los errores irreversibles siempre son
síntomas de errores, como intentar acceder a una ubicación más allá del final
de un arreglo, por lo que queremos detener inmediatamente el programa.</p>
<p>La mayoría de los lenguajes no distinguen entre estos dos tipos de errores y los
manejan de la misma manera, utilizando mecanismos como excepciones. Rust no
tiene excepciones. En cambio, tiene el tipo <code>Result&lt;T, E&gt;</code> para errores
recuperables y el macro <code>panic!</code> que detiene la ejecución cuando el programa
encuentra un error irrecuperable. Este capítulo cubre primero la llamada a
<code>panic!</code> y luego habla sobre la devolución de valores <code>Result&lt;T, E&gt;</code>.
Además, exploraremos consideraciones al decidir si intentar recuperarse de un
error o detener la ejecución.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="errores-irrecuperables-con-panic"><a class="header" href="#errores-irrecuperables-con-panic">Errores irrecuperables con <code>panic!</code></a></h2>
<p>A veces, sucede algo malo en su código y no hay nada que pueda hacer al
respecto. En estos casos, Rust tiene la macro <code>panic!</code>. Hay dos formas de causar
un panic en la práctica: tomando una acción que hace que nuestro código entre en
pánico (como acceder a un arreglo más allá del final) o llamando explícitamente
a la macro <code>panic!</code>. En ambos casos, causamos un pánico en nuestro programa. De
forma predeterminada, estos pánicos imprimirán un mensaje de error, se desharán,
limpiarán la pila y se cerrarán. A través de una variable de entorno, también
puede hacer que Rust muestre la pila de llamadas cuando ocurre un pánico para
facilitar el seguimiento de la fuente del panic.</p>
<blockquote>
<h3 id="deshacer-la-pila-o-abortar-en-respuesta-a-un-pánico"><a class="header" href="#deshacer-la-pila-o-abortar-en-respuesta-a-un-pánico">Deshacer la pila o abortar en respuesta a un pánico</a></h3>
<p>Por defecto, cuando ocurre un panic, el programa comienza a <em>deshacerse</em>, lo
que significa que Rust retrocede por la pila y limpia los datos de cada
función que encuentra. Sin embargo, este retroceso y limpieza es mucho
trabajo. Rust, por lo tanto, le permite elegir la alternativa de <em>abortar</em>
inmediatamente, lo que termina el programa sin limpiar.</p>
<p>La memoria que el programa estaba usando deberá ser limpiada por el sistema
operativo. Si en su proyecto necesita hacer que el binario resultante sea lo
más pequeño posible, puede cambiar de deshacer el programa a abortarlo al
producir un pánico agregando <code>panic = 'abort'</code> a las secciones <code>[profile]</code>
apropiadas en su archivo <em>Cargo.toml</em>. Por ejemplo, si desea abortar en caso
de pánico en el modo de lanzamiento, agregue esto:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Intentemos llamar un <code>panic!</code> en un programa simple:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}</code></pre></pre>
<p>Cuando ejecutes el programa, verás algo como esto:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>La llamada a <code>panic!</code> causa el mensaje de error contenido en las dos últimas
líneas. La primera línea muestra nuestro mensaje de panic y el lugar en nuestro
código fuente donde ocurrió el panic: <em>src/main.rs:2:5</em> indica que es la segunda
línea, quinto carácter de nuestro archivo <em>src/main.rs</em>.</p>
<p>En este caso, la línea indicada es parte de nuestro código, y si vamos a esa
línea, vemos la llamada a la macro <code>panic!</code>. En otros casos, la llamada a
<code>panic!</code> podría estar en el código que nuestro código llama, y el nombre de
archivo y el número de línea informados por el mensaje de error serán el código
de otra persona donde se llama a la macro <code>panic!</code>, no la línea de nuestro
código que finalmente condujo a la llamada a <code>panic!</code>. Podemos usar el backtrace
de las funciones de las que provino la llamada a <code>panic!</code> para determinar la
parte de nuestro código que está causando el problema. Discutiremos el backtrace
en más detalle a continuación.</p>
<h3 id="usando-el-backtrace-de-panic"><a class="header" href="#usando-el-backtrace-de-panic">Usando el backtrace de <code>panic!</code></a></h3>
<p>Veamos otro ejemplo de cómo es cuando una llamada a <code>panic!</code> proviene de una
biblioteca debido a un error en nuestro código en lugar de que nuestro código
llame directamente a la macro. El listado 9-1 tiene algún código que intenta
acceder a un índice en un vector más allá del rango de índices válidos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
<p><span class="caption">Listado 9-1: Intentando acceder a un elemento más allá del
fin de un vector, que provocará una llamada a <code>panic!</code></span></p>
<p>Aquí, estamos intentando acceder al elemento 100 de nuestro vector (que está en
el índice 99 porque el indexado comienza en cero), pero el vector solo tiene 3
elementos. En esta situación, Rust entrará en pánico. Usar <code>[]</code> se supone que
devuelve un elemento, pero si pasa un índice no válido, no hay ningún elemento
que Rust podría devolver aquí que sea correcto.</p>
<p>En C, intentar leer más allá del final de una estructura de datos es un
undefined. Podría obtener lo que está en la ubicación de memoria que
correspondería a ese elemento en la estructura de datos, aunque la memoria no
pertenece a esa estructura. Esto se llama <em>buffer overread</em> y puede provocar
vulnerabilidades de seguridad si un atacante puede manipular el índice de tal
manera que lea datos que no debería estar permitido que se almacenen después de
la estructura de datos.</p>
<p>Para proteger su programa de este tipo de vulnerabilidad, si intenta leer un
elemento en un índice que no existe, Rust detendrá la ejecución y se negará a
continuar. Intentémoslo y veamos:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Este error apunta a la línea 4 de nuestro <code>main.rs</code> donde intentamos acceder al
índice 99. La siguiente línea de nota nos dice que podemos establecer la
variable de entorno <code>RUST_BACKTRACE</code> para obtener el backtrace de exactamente lo
que sucedió para causar el error. El <em>Backtrace</em> es una lista de todas las
funciones que se han llamado para llegar a este punto. El backtrace en Rust
funciona como lo hacen en otros lenguajes: la clave para leer el backtrace es
comenzar desde la parte superior y leer hasta que vea archivos que escribió. Ese
es el lugar donde se originó el problema. Las líneas por encima de ese punto son
el código que su código ha llamado; las líneas a continuación son el código que
llamó a su código. Estas líneas antes y después pueden incluir código de Rust
core, código de biblioteca estándar o crates que estés usando. Intentemos
obtener el backtrace estableciendo la variable de entorno <code>RUST_BACKTRACE</code> a
cualquier valor excepto 0. El listado 9-2 muestra una salida similar a la que
verás.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ export RUST_BACKTRACE=1; cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/std/src/panicking.rs:645:5
   1: core::panicking::panic_fmt
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/panicking.rs:72:14
   2: core::panicking::panic_bounds_check
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/panicking.rs:208:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/slice/index.rs:255:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/alloc/src/vec/mod.rs:2770:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Listado 9-2: El backtrace generado por una llamada a
<code>panic!</code> se muestra cuando la variable de entorno <code>RUST_BACKTRACE</code> está
configurada</span></p>
<p>¡Eso es mucho resultado! La salida exacta que vea puede ser diferente según su
sistema operativo y la versión de Rust. Para obtener el backtrace con esta
información, deben estar habilitados los símbolos de depuración. Los símbolos de
depuración están habilitados de forma predeterminada cuando se usa <code>cargo build</code>
o <code>cargo run</code> sin el indicador <code>--release</code>, como tenemos aquí.</p>
<p>En la salida en el listado 9-2, la línea 6 del backtrace apunta a la línea en
nuestro proyecto que está causando el problema: la línea 4 de <code>src/main.rs</code>. Si
no queremos que nuestro programa entre en pánico, debemos comenzar nuestra
investigación en la ubicación señalada por la primera línea que menciona un
archivo que escribimos. En la listado 9-1, donde escribimos deliberadamente un
código que entraría en pánico, la forma de solucionar el pánico es no solicitar
un elemento más allá del rango de los índices del vector. Cuando su código entra
en pánico en el futuro, deberá averiguar qué acción está tomando el código con
qué valores para causar el pánico y qué debería hacer el código en su lugar.</p>
<p>¡Volveremos a <code>panic!</code> y cuándo deberíamos y no deberíamos usar <code>panic!</code> para
manejar las condiciones de error en la sección <a href="ch09-03-to-panic-or-not-to-panic.html#panic-o-no-panic">“To <code>panic!</code> or Not to
<code>panic!</code>”</a><!-- ignore --> más adelante en este
capítulo. A continuación, veremos cómo recuperarnos de un error usando <code>Result</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="errores-recuperables-con-result"><a class="header" href="#errores-recuperables-con-result">Errores recuperables con <code>Result</code></a></h2>
<p>La mayoría de los errores no son lo suficientemente graves como para requerir
que el programa se detenga por completo. A veces, cuando una función falla, es
por una razón que puede interpretar y responder fácilmente. Por ejemplo, si
intenta abrir un archivo y esa operación falla porque el archivo no existe,
es posible que desee crear el archivo en lugar de terminar el proceso.</p>
<p>Recordemos el capítulo
<a href="ch02-00-guessing-game-tutorial.html#manejando-el-posible-fallo-con-result">“Manejo de fallas potenciales con <code>Result</code>”</a><!--ignore -->
en el Capítulo 2 que el enum <code>Result</code> se define como tener dos variantes,
<code>Ok</code> y <code>Err</code>, de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code> y <code>E</code> son parámetros de tipo genérico: hablaremos de los genéricos con más
detalle en el Capítulo 10. Lo que necesita saber ahora es que <code>T</code> representa el
tipo del valor que será devuelto en un caso de éxito dentro de la variante <code>Ok</code>,
y <code>E</code> representa el tipo del error que será devuelto en un caso de fallo dentro
de la variante <code>Err</code>. Debido a que <code>Result</code> tiene estos parámetros de tipo
genérico, podemos usar el tipo <code>Result</code> y las funciones definidas en él en
muchas situaciones diferentes donde el valor de éxito y el valor de error que
queremos devolver pueden diferir.</p>
<p>Llamemos a una función que devuelve un valor <code>Result</code> porque la función podría
fallar. En el listado 9-3 intentamos abrir un archivo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 9-3: Abriendo un archivo</span></p>
<p>El tipo de retorno de <code>File::open</code> es un <code>Result&lt;T, E&gt;</code>. El parámetro genérico
<code>T</code> ha sido llenado por la implementación de <code>File::open</code> con el tipo del valor
de éxito, <code>std::fs::File</code>, que es un manejador de archivo. El tipo de <code>E</code>
utilizado en el valor de error es <code>std::io::Error</code>. Este tipo de retorno
significa que la llamada a <code>File::open</code> podría tener éxito y devolver un
manejador de archivo del que podemos leer o escribir. La llamada a la función
también podría fallar: por ejemplo, el archivo podría no existir, o podríamos
no tener permiso para acceder al archivo. La función <code>File::open</code> necesita tener
una forma de decirnos si tuvo éxito o falló y al mismo tiempo darnos el
manejador de archivo o la información de error. Esta información es exactamente
lo que transmite el enum <code>Result</code>.</p>
<p>En el caso en que <code>File::open</code> tenga éxito, el valor en la variable
<code>greeting_file_result</code> será una instancia de <code>Ok</code> que contiene un manejador de
archivo. En el caso en que falla, el valor en <code>greeting_file_result</code> será una
instancia de <code>Err</code> que contiene más información sobre el tipo de error que
ocurrió.</p>
<p>Necesitamos agregar al código en el listado 9-3 para tomar diferentes acciones
dependiendo del valor que <code>File::open</code> devuelve. El listado 9-4 muestra una
forma de manejar él <code>Result</code> usando una herramienta básica, la expresión
<code>match</code> que discutimos en el Capítulo 6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {error:?}&quot;),
    };
}</code></pre></pre>
<p><span class="caption">Listado 9-4: Usando una expresión <code>match</code> para manejar las
variantes <code>Result</code> que podrían devolverse</span></p>
<p>Ten en cuenta que, al igual que el enum <code>Option</code>, el enum <code>Result</code> y sus
variantes se han traído al ámbito por el <a href="ch02-00-guessing-game-tutorial.html#prelude-meaning">prelude</a>, por lo que no necesitamos
especificar <code>Result::</code> antes de las variantes <code>Ok</code> y <code>Err</code> en las opciones de
<code>match</code>.</p>
<p>Cuando el result es <code>Ok</code>, este código devolverá el valor interno <code>file</code> fuera
de la variante <code>Ok</code>, y luego asignaremos ese valor de manejador de archivo a la
variable <code>greeting_file</code>. Después del <code>match</code>, podemos usar el manejador de
archivo para leer o escribir.</p>
<p>La otra opción en el <code>match</code> es <code>Err</code>, que significa que el <code>File::open</code> ha
fallado y el valor interno <code>err</code> de la variante <code>Err</code> contendrá información
sobre cómo o por qué falló <code>File::open</code>. En este caso, llamamos a la función
<code>panic!</code> y pasamos el valor <code>err</code> al <code>panic!</code>. Esto causa que nuestro programa
se bloquee y muestre el mensaje de error que <code>panic!</code> proporciona. Si ejecutamos
este código, obtendremos el siguiente mensaje de error:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Como de costumbre, esta salida nos dice exactamente qué ha salido mal.</p>
<h3 id="haciendo-coincidir-diferentes-errores"><a class="header" href="#haciendo-coincidir-diferentes-errores">Haciendo coincidir diferentes errores</a></h3>
<p>El código en el listado 9-4 será <code>panic!</code> no importa por qué <code>File::open</code> falló.
Sin embargo, queremos tomar diferentes acciones para diferentes razones de
falla: si <code>File::open</code> falló porque el archivo no existe, queremos crear el
archivo y devolver el manejador del nuevo archivo. Si <code>File::open</code> falló por
cualquier otra razón, por ejemplo, porque no teníamos permiso para abrir el
archivo, todavía queremos que el código dispare el <code>panic!</code> de la misma manera que lo hizo
en el listado 9-4. Para esto agregamos una expresión <code>match</code> interna, que se
muestra en el listado 9-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {e:?}&quot;),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {other_error:?}&quot;);
            }
        },
    };
}</code></pre>
<p><span class="caption">Listado 9-5: Manejando diferentes tipos de errores de
diferentes formas</span></p>
<p>El tipo de valor que <code>File::open</code> devuelve dentro de la variante <code>Err</code> es
<code>io::Error</code>, que es una estructura proporcionada por la biblioteca estándar.
Esta estructura tiene un método <code>kind</code> que podemos llamar para obtener un valor
<code>io::ErrorKind</code>. El enum <code>io::ErrorKind</code> es proporcionado por la biblioteca
estándar y tiene variantes que representan los diferentes tipos de errores que
podrían resultar de una operación <code>io</code>. La variante que queremos usar es
<code>ErrorKind::NotFound</code>, que indica que el archivo que estamos tratando de abrir
aún no existe. Así que hacemos coincidir en <code>greeting_file_result</code>, pero
también tenemos una coincidencia interna en <code>error.kind()</code>.</p>
<p>La condición que queremos verificar en la coincidencia interna es si el valor
devuelto por <code>error.kind()</code> es la variante <code>NotFound</code> del enum <code>ErrorKind</code>. Si
es así, intentamos crear el archivo con <code>File::create</code>. Sin embargo, debido a
que <code>File::create</code> también podría fallar, necesitamos una segunda opción en la
expresión <code>match</code> interna. Cuando no se puede crear el archivo, se imprime un
mensaje de error diferente. La segunda opción del <code>match</code> externo permanece
igual, por lo que el programa se bloquea en cualquier error además del error de
archivo faltante.</p>
<blockquote>
<h3 id="alternativas-a-usar-match-con-resultt-e"><a class="header" href="#alternativas-a-usar-match-con-resultt-e">Alternativas a usar <code>match</code> con <code>Result&lt;T, E&gt;</code></a></h3>
<p>¡Eso es mucho <code>match</code>! La expresión <code>match</code> es útil, pero también es bastante
verbosa. En el Capítulo 13 aprenderás sobre los closures, que se usan con
muchos de los métodos definidos en <code>Result&lt;T, E&gt;</code>. Estos métodos pueden ser
más concisos que usar <code>match</code> al manejar valores <code>Result&lt;T, E&gt;</code> en tu código.</p>
<p>Por ejemplo, aquí hay otra forma de escribir la misma lógica que se muestra en
el listado 9-5, esta vez usando closures y el método <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {error:?}&quot;);
            })
        } else {
            panic!(&quot;Problem opening the file: {error:?}&quot;);
        }
    });
}</code></pre>
<p>Aunque este código tiene el mismo comportamiento que el listado 9-5, no
contiene ninguna expresión <code>match</code> y es más fácil de leer. Vuelve a este
ejemplo después de leer el Capítulo 13, y busca el método <code>unwrap_or_else</code> en
la documentación de la biblioteca estándar. Muchos más de estos métodos pueden
limpiar enormes expresiones <code>match</code> anidadas cuando se trata de errores.</p>
</blockquote>
<h3 id="atajos-para-panic-en-caso-de-error-unwrap-y-expect"><a class="header" href="#atajos-para-panic-en-caso-de-error-unwrap-y-expect">Atajos para <code>panic</code> en caso de error: <code>unwrap</code> y <code>expect</code></a></h3>
<p>Usando <code>match</code> funciona bastante bien, pero puede ser un poco verboso y no
siempre comunica bien la intención. El tipo <code>Result&lt;T, E&gt;</code> tiene muchos métodos
auxiliares definidos en él para hacer varias tareas más específicas. El método
<code>unwrap</code> es un método de atajo implementado exactamente como la expresión
<code>match</code> que escribimos en el listado 9-4. Si el valor <code>Result</code> es la variante
<code>Ok</code>, <code>unwrap</code> devolverá el valor dentro de <code>Ok</code>. Si el <code>Result</code> es la variante
<code>Err</code>, <code>unwrap</code> llamará a la macro <code>panic!</code> por nosotros. Aquí hay un ejemplo de
<code>unwrap</code> en acción:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap();
}</code></pre></pre>
<p>Si ejecutamos este código sin un archivo <em>hello.txt</em>, veremos un mensaje de
error de la llamada <code>panic!</code> que el método <code>unwrap</code> hace:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre>
<p>Del mismo modo, el método <code>expect</code> nos permite elegir el mensaje de error de
<code>panic!</code>. Usando <code>expect</code> en lugar de <code>unwrap</code> y proporcionando buenos mensajes
de error puede transmitir tu intención y facilitar el seguimiento de la fuente
de un pánico. La sintaxis de <code>expect</code> se ve así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)
        .expect(&quot;hello.txt should be included in this project&quot;);
}</code></pre></pre>
<p>Nosotros usamos <code>expect</code> de la misma manera que <code>unwrap</code>: para devolver el
manejo de archivo o llamar a la macro <code>panic!</code>. El mensaje de error utilizado
por <code>expect</code> en su llamada a <code>panic!</code> será el parámetro que pasamos a <code>expect</code>,
en lugar del mensaje predeterminado de <code>panic!</code> que usa <code>unwrap</code>. Así es como
se ve:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre>
<p>En producción, la mayoría de los Rustaceans eligen <code>expect</code> en lugar de
<code>unwrap</code> y dan más contexto sobre por qué se espera que la operación siempre
tenga éxito. De esa manera, si tus suposiciones se demuestran incorrectas,
tienes más información para usar en la depuración.</p>
<h3 id="propagación-de-errores"><a class="header" href="#propagación-de-errores">Propagación de errores</a></h3>
<p>Cuando escribes una función cuyo cuerpo puede generar un error, en lugar de
manejar el error dentro de la función, puedes devolver el error al código que
llamó la función. Esto se conoce como <em>propagación</em> del error y le da más
control al código que llama, donde puede haber más información o lógica que
dicte cómo se debe manejar el error que la que tienes disponible en el contexto
de tu código.</p>
<p>Por ejemplo, El listado 9-6 muestra una función que lee un nombre de usuario de
un archivo. Si el archivo no existe o no se puede leer, esta función devolverá
esos errores al código que llamó a la función.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hello.txt&quot;);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-6: Una función que devuelve errores al código
llamado usando <code>match</code></span></p>
<p>Esta función se puede escribir de una manera mucho más corta, pero vamos a
empezar por hacer mucho de ella manualmente para explorar el manejo de errores;
al final, mostraremos la forma más corta. Veamos primero el tipo de retorno de
la función: <code>Result&lt;String, io::Error&gt;</code>. Esto significa que la función está
devolviendo un valor del tipo <code>Result&lt;T, E&gt;</code> donde el parámetro genérico <code>T</code> se
ha rellenado con el tipo concreto <code>String</code>, y el tipo genérico <code>E</code> se ha
rellenado con el tipo concreto <code>io::Error</code>.</p>
<p>Si esta función tiene éxito sin ningún problema, el código que llama a esta
función recibirá un valor <code>Ok</code> que contiene una <code>String</code> - el nombre de usuario
que esta función leyó del archivo. Si esta función encuentra algún problema, el
código que llama recibirá un valor <code>Err</code> que contiene una instancia de
<code>io::Error</code> que contiene más información sobre cuáles fueron los problemas.
Elegimos <code>io::Error</code> como el tipo de retorno de esta función porque eso sucede
que es el tipo del valor de error devuelto de ambas operaciones que estamos
llamando en el cuerpo de esta función que podrían fallar: la función
<code>File::open</code> y el método <code>read_to_string</code>.</p>
<p>El cuerpo de la función comienza llamando a la función <code>File::open</code>. Entonces
manejamos el valor <code>Result</code> con una expresión <code>match</code> similar a la del Listado
9-4. Si <code>File::open</code> tiene éxito, el archivo manejador en el patrón de variable
<code>file</code> se convierte en el valor en la variable de patrón mutable <code>username_file</code>
y la función continúa. En el caso de <code>Err</code>, en lugar de llamar a <code>panic!</code>,
usamos la palabra clave <code>return</code> para devolver temprano la función por
completo y pasar el valor de error de <code>File::open</code>, ahora en la variable de
patrón <code>e</code>, de vuelta al código que llama a esta función como el valor de error
de esta función.</p>
<p>Entonces, si tenemos un manejador de archivo en <code>username_file</code>, la función
crea un nuevo <code>String</code> en la variable <code>username</code> y llama al método
<code>read_to_string</code> en el manejador de archivo en <code>username_file</code> para leer el
contenido del archivo en <code>username</code>. El método <code>read_to_string</code> también
devuelve un <code>Result</code> porque podría fallar, incluso si <code>File::open</code> tuvo éxito.
Así que necesitamos otro <code>match</code> para manejar ese <code>Result</code>: si <code>read_to_string</code>
tiene éxito, entonces nuestra función ha tenido éxito, y devolvemos el nombre de
usuario del archivo que ahora está en <code>username</code> envuelto en un <code>Ok</code>. Si
<code>read_to_string</code> falla, devolvemos el valor de error de la misma manera que
devolvimos el valor de error en el <code>match</code> que manejó el valor de retorno de
<code>File::open</code>. Sin embargo, no necesitamos decir explícitamente <code>return</code>, porque
esta es la última expresión de la función.</p>
<p>El código que llama a este código se encargará de obtener un valor <code>Ok</code> que
contiene un nombre de usuario o un valor <code>Err</code> que contiene un <code>io::Error</code>. Es
responsabilidad del código que llama decidir qué hacer con esos valores. Si el
código que llama obtiene un valor <code>Err</code>, podría llamar a <code>panic!</code> y bloquear el
programa, usar un nombre de usuario predeterminado o buscar el nombre de
usuario en algún lugar que no sea un archivo, por ejemplo. No tenemos
suficiente información sobre lo que el código que llama realmente está tratando
de hacer, por lo que propagamos toda la información de éxito o error hacia
arriba para que la maneje apropiadamente.</p>
<p>Este patrón de propagación de errores es tan común en Rust que Rust proporciona
el operador de interrogación <code>?</code> para hacer esto más fácil.</p>
<h4 id="un-atajo-para-propagar-errores-el-operador-"><a class="header" href="#un-atajo-para-propagar-errores-el-operador-">Un atajo para propagar errores: el operador <code>?</code></a></h4>
<p>El listado 9-7 muestra una implementación de <code>read_username_from_file</code> que tiene
la misma funcionalidad que en el Listado 9-6, pero esta implementación utiliza
el operador <code>?</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-7: Una función que devuelve errores al código
llamado usando el operador <code>?</code></span></p>
<p>El <code>?</code> colocado después de un valor <code>Result</code> se define para funcionar de casi
la misma manera que las expresiones <code>match</code> que definimos para manejar los
valores <code>Result</code> en el listado 9-6. Si el valor de <code>Result</code> es un <code>Ok</code>, el
valor dentro del <code>Ok</code> se devolverá de esta expresión, y el programa continuará.
Si el valor es un <code>Err</code>, él <code>Err</code> se devolverá de toda la función como si
hubiéramos usado la palabra clave <code>return</code> para que el valor de error se
propague al código que llama.</p>
<p>Hay una diferencia entre lo que hace la expresión <code>match</code> del listado 9-6 y lo
que hace el operador <code>?</code>: los valores de error que tienen el operador <code>?</code>
llamado en ellos pasan a través de la función <code>from</code>, definida en el trait
<code>From</code> en la biblioteca estándar, que se usa para convertir valores de un tipo
a otro. Cuando el operador <code>?</code> llama a la función <code>from</code>, el tipo de error
recibido se convierte en el tipo de error definido en el tipo de retorno de la
función actual. Esto es útil cuando una función devuelve un tipo de error para
representar todas las formas en que una función podría fallar, incluso si las
partes podrían fallar por muchas razones diferentes.</p>
<p>Por ejemplo, podríamos cambiar la función <code>read_username_from_file</code> en el
listado 9-7 para devolver un tipo de error personalizado llamado <code>OurError</code> que
definimos. Si también definimos <code>impl From&lt;io::Error&gt; for OurError</code> para
construir una instancia de <code>OurError</code> a partir de un <code>io::Error</code>, entonces el
operador <code>?</code> llama en el cuerpo de <code>read_username_from_file</code> llamará a <code>from</code>
y convertirá los tipos de error sin necesidad de agregar más código a la
función.</p>
<p>En el contexto del listado 9-7, el <code>?</code> al final de la llamada a <code>File::open</code>
devolverá el valor dentro de un <code>Ok</code> a la variable <code>username_file</code>. Si ocurre
un error, el <code>?</code> operador devolverá temprano toda la función y dará cualquier
valor <code>Err</code> al código que llama. Lo mismo se aplica al <code>?</code> al final de la
llamada a <code>read_to_string</code>.</p>
<p>El operador <code>?</code> elimina mucho código repetitivo y realiza esta función de
implementación más simple. Incluso podríamos acortar aún más este código
encadenando llamadas de método inmediatamente después del <code>?</code>, como se muestra
en el Listado 9-8.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-8: Método de encadenamiento
llamado después del operador <code>?</code></span></p>
<p>Hemos movido la creación del nuevo <code>String</code> en <code>username</code> al principio de la
función; esa parte no ha cambiado. En lugar de crear una variable
<code>username_file</code>, hemos encadenado la llamada a <code>read_to_string</code> directamente
sobre el resultado de <code>File::open(&quot;hello.txt&quot;)?</code>. Todavía tenemos un <code>?</code> al
final de la llamada a <code>read_to_string</code>, y todavía devolvemos un valor <code>Ok</code>
que contiene <code>username</code> cuando tanto <code>File::open</code> como <code>read_to_string</code>
tienen éxito en lugar de devolver errores. La funcionalidad es nuevamente la
misma que en el listado 9-6 y el listado 9-7; esta es solo una forma diferente
y más ergonómica de escribirla.</p>
<p>El listado 9-9 muestra una forma de hacer esto aún más conciso usando
<code>fs::read_to_string</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-9: Usando <code>fs::read_to_string</code> en lugar de
abrir y luego leer el archivo</span></p>
<p>Leer un archivo en un <code>String</code> es una operación bastante común, por lo que la
biblioteca estándar proporciona la conveniente función <code>fs::read_to_string</code>
que abre el archivo, crea un nuevo <code>String</code>, lee el contenido del archivo,
coloca el contenido en ese <code>String</code> y lo devuelve. Por supuesto, usar
<code>fs::read_to_string</code> no nos da la oportunidad de explicar todo el manejo de
errores, por lo que lo hicimos de la manera más larga primero.</p>
<h4 id="donde-se-puede-usar-el-operador-"><a class="header" href="#donde-se-puede-usar-el-operador-">Donde se puede usar el operador <code>?</code></a></h4>
<p>El operador <code>?</code> solo puede usarse en funciones cuyo tipo de retorno sea
compatible con el valor que se usa con el operador <code>?</code>. Porque el operador <code>?</code>
está definido para realizar una devolución temprana de un valor de la función,
de la misma manera que la expresión <code>match</code> que definimos en el listado 9-6.
En el listado 9-6, el <code>match</code> estaba usando un valor <code>Result</code>, y el brazo de
devolución temprana devolvió un valor <code>Err(e)</code>. El tipo de retorno de la
función debe ser un <code>Result</code> para que sea compatible con este <code>return</code>.</p>
<p>En el listado 9-10, veamos el error que obtendremos si usamos el operador <code>?</code>
en una función <code>main</code> con un tipo de retorno incompatible con el tipo de valor
que usamos <code>?</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;
}</code></pre>
<p><span class="caption">Listado 9-10: Intentando usar el <code>?</code> en la función <code>main</code>
que devuelve <code>()</code> no se compilará</span></p>
<p>Este código abre un archivo, que puede fallar. El operador <code>?</code> sigue el valor
<code>Result</code> devuelto por <code>File::open</code>, pero esta función <code>main</code> tiene el tipo de
retorno de <code>()</code>, no <code>Result</code>. Cuando compilamos este código, obtenemos el
siguiente mensaje de error:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open(&quot;hello.txt&quot;)?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin &quot;error-handling&quot;) due to 1 previous error
</code></pre>
<p>Este error señala que solo podemos usar el operador <code>?</code> en una función que
devuelve <code>Result</code> o <code>Option</code> o en cualquier otro tipo que implemente
<code>FromResidual</code>.</p>
<p>Para corregir el error, tienes dos opciones. Una opción es cambiar el tipo de
retorno de tu función para que sea compatible con el valor que estás usando el
operador <code>?</code> mientras no tengas restricciones que lo impidan. La otra técnica
es usar un <code>match</code> o uno de los métodos <code>Result&lt;T, E&gt;</code> para manejar el
<code>Result&lt;T, E&gt;</code> de la manera que sea apropiada.</p>
<p>El mensaje de error también menciona que el operador <code>?</code> también se puede usar
con valores <code>Option&lt;T&gt;</code>. Al igual que con el uso de <code>?</code> en <code>Result</code>, solo
puedes usar <code>?</code> en <code>Option</code> en una función que devuelve <code>Option</code>. El
comportamiento del operador <code>?</code> cuando se llama en un <code>Option&lt;T&gt;</code> es similar a
su comportamiento cuando se llama en un <code>Result&lt;T, E&gt;</code>: si el valor es <code>None</code>,
el <code>None</code> se devolverá temprano desde la función en ese punto. Si el valor es
<code>Some</code>, el valor dentro de <code>Some</code> es el valor resultante de la expresión y la
función continúa. El listado 9-11 tiene un ejemplo de una función que encuentra
el último carácter de la primera línea en el texto dado:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hello, world\nHow are you today?&quot;),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-11: Using the <code>?</code> operator on an <code>Option&lt;T&gt;</code>
value</span></p>
<p>Esta función devuelve <code>Option&lt;char&gt;</code> porque es posible que haya un carácter
allí, pero también es posible que no lo haya. Este código toma el argumento de
string slice <code>text</code> y llama al método <code>lines</code> en él, que devuelve un
iterador sobre las líneas en el string. Debido a que esta función quiere
examinar la primera línea, llama a <code>next</code> en el iterador para obtener el primer
valor del iterador. Si <code>text</code> es un string vacío, esta llamada a <code>next</code>
devolverá <code>None</code>, en cuyo caso usamos <code>?</code> para detener y devolver <code>None</code> desde
<code>last_char_of_first_line</code>. Si <code>text</code> no es un string vacío, <code>next</code> devolverá
un valor <code>Some</code> que contiene un string slice de la primera línea en <code>text</code>.</p>
<p>El <code>?</code> extrae el string slice, y podemos llamar a <code>chars</code> en ese string slice
para obtener un iterador de sus caracteres. Estamos interesados en el último
carácter en esta primera línea, por lo que llamamos a <code>last</code> para devolver el
último elemento en el iterador. Esto es un <code>Option</code> porque es posible que la
primera línea sea el string vacío, por ejemplo, si <code>text</code> comienza con una
línea en blanco pero tiene caracteres en otras líneas, como en <code>&quot;\nhi&quot;</code>. Sin
embargo, si hay un último carácter en la primera línea, se devolverá en la
variante <code>Some</code>. El operador <code>?</code> en el medio nos da una forma concisa de
expresar esta lógica, lo que nos permite implementar la función en una línea.
Si no pudiéramos usar el operador <code>?</code> en <code>Option</code>, tendríamos que implementar
esta lógica usando más llamadas de método o una expresión <code>match</code>.</p>
<p>Ten en cuenta que puedes usar el operador <code>?</code> en una función que devuelve
<code>Result</code> y puedes usar el operador <code>?</code> en una función que devuelve <code>Option</code>,
pero no puedes mezclar y combinar. El operador <code>?</code> no convertirá
automáticamente un <code>Result</code> en un <code>Option</code> o viceversa; en esos casos, puedes
usar métodos como el método <code>ok</code> en <code>Result</code> o el método <code>ok_or</code> en <code>Option</code>
para hacer la conversión explícitamente.</p>
<p>Hasta ahora, todas las funciones <code>main</code> que hemos usado devuelven <code>()</code>. La
función <code>main</code> es especial porque es el punto de entrada y salida de los
programas ejecutables, y hay restricciones sobre cuál puede ser su tipo de
retorno para que los programas se comporten como se espera.</p>
<p>Por suerte, <code>main</code> también puede devolver un <code>Result&lt;(), E&gt;</code>. El Listado 9-12
tiene el código del listado 9-10, pero hemos cambiado el tipo de retorno de
<code>main</code> para que sea <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> y hemos agregado un valor de
retorno <code>Ok(())</code> al final. Este código ahora se compilará:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}</code></pre>
<p><span class="caption">Listado∂ 9-12: Cambiando <code>main</code> devuelve <code>Result&lt;(), E&gt;</code>
permitiendo el uso del operador <code>?</code> en valores <code>Result</code></span></p>
<p>El <code>Box&lt;dyn Error&gt;</code> tipo es un <em>trait object</em>, que hablaremos en la sección
<a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">“Usando Trait Objects que permiten valores de diferentes
tipos”</a><!-- ignore --> en el Capítulo 17. Por ahora, puedes leer
<code>Box&lt;dyn Error&gt;</code> para significar “cualquier tipo de error”. Usar <code>?</code> en un
valor <code>Result</code> en una función <code>main</code> con el tipo de error <code>Box&lt;dyn Error&gt;</code> está
permitido, porque permite que cualquier valor <code>Err</code> se devuelva temprano. A
pesar de que el cuerpo de esta función <code>main</code> solo devolverá errores de tipo
<code>std::io::Error</code>, al especificar <code>Box&lt;dyn Error&gt;</code>, esta firma seguirá siendo
correcta incluso si se agrega más código que devuelva otros errores al cuerpo
de <code>main</code>.</p>
<p>Cuando una función <code>main</code> devuelve un <code>Result</code>, el ejecutable puede
salir con un valor de <code>0</code> si <code>main</code> devuelve <code>Ok(())</code> y saldrá con un valor
distinto de <code>0</code> si <code>main</code> devuelve un <code>Err</code>. Los ejecutables escritos en C
devuelven enteros cuando salen: los programas que salen con éxito devuelven el
entero <code>0</code>, y los programas que devuelven un error devuelven algún entero
distinto de <code>0</code>. Rust también devuelve enteros de ejecutables para ser
compatibles con esta convención.</p>
<p>La función <code>main</code> puede devolver cualquier tipo que implemente el trait
<a href="https://doc.rust-lang.org/std/process/trait.Termination.html"><code>std::process::Termination</code></a><!-- ignore -->, que incluye una
función <code>report</code> que devuelve un <code>ExitCode</code>. Consulta la documentación de la
biblioteca estándar para obtener más información sobre la implementación del
trait <code>Termination</code> para tus propios tipos.</p>
<p>Ahora que hemos discutido los detalles de llamar a <code>panic!</code> o devolver
<code>Result</code>, volvamos al tema de cómo decidir cuál es apropiado usar en qué casos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic-o-no-panic"><a class="header" href="#panic-o-no-panic"><code>panic!</code> o no <code>panic!</code></a></h2>
<p>Entonces, ¿cómo decides cuándo debes llamar a <code>panic!</code> y cuándo debes devolver
<code>Result</code>? Cuando el código entra en panic, no hay forma de recuperarse. Podrías
llamar a <code>panic!</code> para cualquier situación de error, ya sea que haya una forma
posible de recuperarse o no, pero entonces estás tomando la decisión de que una
situación es irreparable en nombre del código que llama. Cuando eliges devolver
un valor <code>Result</code>, le das al código que llama opciones. El código que llama
podría elegir intentar recuperarse de una manera que sea apropiada para su
situación, o podría decidir que un valor <code>Err</code> en este caso es irreparable, por
lo que puede llamar a <code>panic!</code> y convertir su error recuperable en uno
irreparable. Por lo tanto, devolver <code>Result</code> es una buena opción predeterminada
cuando estás definiendo una función que podría fallar.</p>
<p>En situaciones como ejemplos, código de prototipo y pruebas, es más apropiado
escribir código que entre en panic en lugar de devolver un <code>Result</code>. Veamos
por qué, luego discutiremos situaciones en las que el compilador no puede
darse cuenta de que la falla es imposible, pero tú como humano puedes. El
capítulo concluirá con algunas pautas generales sobre cómo decidir si entrar en
panic en el código de la biblioteca.</p>
<h3 id="ejemplos-código-de-prototipo-y-test"><a class="header" href="#ejemplos-código-de-prototipo-y-test">Ejemplos, código de prototipo y test</a></h3>
<p>Cuando estás escribiendo un ejemplo para ilustrar algún concepto, también
incluir código de manejo de errores robusto puede hacer que el ejemplo sea
menos claro. En los ejemplos, se entiende que una llamada a un método como
<code>unwrap</code> que podría entrar en panic se entiende como un marcador de posición
para la forma en que desea que su aplicación maneje los errores, que puede
diferir según lo que el resto de su código está haciendo.</p>
<p>De manera similar, los métodos <code>unwrap</code> y <code>expect</code> son muy útiles cuando se
prototipa, antes de que estés listo para decidir cómo manejar los errores.
Dejan marcadores claros en tu código para cuando estés listo para hacer que tu
programa sea más robusto.</p>
<p>Si una llamada a un método falla en una prueba, querrás que toda la prueba
falle, incluso si ese método no es la funcionalidad en prueba. Debido a que
<code>panic!</code> es la forma en que una prueba se marca como fallida, llamar a
<code>unwrap</code> o <code>expect</code> es exactamente lo que debería suceder.</p>
<h3 id="casos-en-los-que-tienes-mas-informacion-que-el-compilador"><a class="header" href="#casos-en-los-que-tienes-mas-informacion-que-el-compilador">Casos en los que tienes mas informacion que el compilador</a></h3>
<p>También sería apropiado llamar a <code>unwrap</code> o <code>expect</code> cuando tienes alguna otra
lógica que garantiza que el <code>Result</code> tendrá un valor <code>Ok</code>, pero la lógica no
es algo que el compilador entiende. Aún tendrás un valor <code>Result</code> que debes
manejar: la operación que estás llamando aún tiene la posibilidad de fallar en
general, incluso si es lógicamente imposible en tu situación particular. Si
puedes asegurar inspeccionando manualmente el código que nunca tendrás una
variante <code>Err</code>, es perfectamente aceptable llamar a <code>unwrap</code>, e incluso mejor
documentar la razón por la que crees que nunca tendrás una variante <code>Err</code> en el
texto de <code>expect</code>. Aquí hay un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;
        .parse()
        .expect(&quot;Hardcoded IP address should be valid&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Aquí estamos creando una instancia <code>IpAddr</code> analizando una cadena codificada.
Podemos ver que <code>127.0.0.1</code> es una dirección IP válida, por lo que es aceptable
usar <code>expect</code> aquí. Sin embargo, tener una cadena válida codificada no cambia
el tipo de retorno del método <code>parse</code>: aún obtenemos un valor <code>Result</code>, y el
compilador aún nos hará manejar el <code>Result</code> como si la variante <code>Err</code> fuera una
posibilidad porque el compilador no es lo suficientemente inteligente como
para ver que esta cadena es siempre una dirección IP válida. Si la cadena de
dirección IP proviniera de un usuario en lugar de estar codificada en el
programa y, por lo tanto, <em>tuviera</em> una posibilidad de falla, definitivamente
querríamos manejar el <code>Result</code> de una manera más robusta en su lugar. Mencionar
la suposición de que esta dirección IP está codificada nos indicará que
cambiemos <code>expect</code> a un mejor código de manejo de errores si en el futuro
necesitamos obtener la dirección IP de otra fuente.</p>
<h3 id="pautas-para-el-manejo-de-errores"><a class="header" href="#pautas-para-el-manejo-de-errores">Pautas para el manejo de errores</a></h3>
<p>Es aconsejable que tu código entre en panic cuando sea posible que tu código
termine en un estado incorrecto. En este contexto, un <em>estado incorrecto</em> es
cuando se ha roto alguna suposición, garantía, contrato o invariante, como
cuando se pasan valores no válidos, valores contradictorios o valores
faltantes a tu código, más uno o más de los siguientes:</p>
<ul>
<li>El mal estado es algo inesperado, a diferencia de algo que probablemente
suceda ocasionalmente, como un usuario que ingresa datos en el formato
incorrecto.</li>
<li>Tu código después de este punto debe confiar en no estar en este mal estado,
en lugar de verificar el problema en cada paso.</li>
<li>No hay una buena manera de codificar esta información en los tipos que
usas. Trabajaremos a través de un ejemplo de lo que queremos decir en la
sección <a href="ch17-03-oo-design-patterns.html#codificando-estados-y-comportamiento-como-tipos">“Codificación de estados y comportamientos como tipos”</a><!-- ignore --> del Capítulo 17.
</li>
</ul>
<p>Si alguien llama a tu código y pasa valores que no tienen sentido, es mejor
devolver un error si puedes para que el usuario de la biblioteca pueda decidir
qué hacer en ese caso. Sin embargo, en los casos en que continuar podría ser
inseguro o dañino, la mejor opción podría ser llamar a <code>panic!</code> y alertar a la
persona que usa tu biblioteca sobre el error en su código para que puedan
solucionarlo durante el desarrollo. De manera similar, <code>panic!</code> a menudo es
apropiado si estás llamando a un código externo que está fuera de tu control y
devuelve un estado no válido que no tienes forma de solucionar.</p>
<p>Sin embargo, cuando se espera que falle, es más apropiado devolver un <code>Result</code>
que hacer una llamada a <code>panic!</code>. Los ejemplos incluyen un analizador que
recibe datos con formato incorrecto o una solicitud HTTP que devuelve un estado
que indica que has alcanzado un límite de velocidad. En estos casos, devolver
un <code>Result</code> indica que el fallo es una posibilidad esperada que el código
llamado decidida cómo manejarlo.</p>
<p>Cuando tu código realiza una operación que podría poner a un usuario en riesgo
si se llama con valores no válidos, tu código debe verificar primero que los
valores sean válidos y entrar en panic si los valores no son válidos. Esto es
principalmente por razones de seguridad: intentar operar con datos no válidos
puede exponer tu código a vulnerabilidades. Esta es la razón principal por la
que la biblioteca estándar llamará a <code>panic!</code> si intentas un acceso a memoria
fuera de los límites: intentar acceder a la memoria que no pertenece a la
estructura de datos actual es un problema de seguridad común. Las funciones
suelen tener <em>contratos</em>: su comportamiento solo está garantizado si las
entradas cumplen con requisitos particulares. Entrar en panic cuando se viola
el contrato tiene sentido porque una violación del contrato siempre indica un
error del lado del llamador y no es un tipo de error que deseas que el código
llamado tenga que manejar explícitamente. De hecho, no hay una manera
razonable para que el código de llamada se recupere; los programadores que
llaman deben corregir el código. Los contratos para una función, especialmente
cuando una violación causará un panic, deben explicarse en la documentación
de la API de la función.</p>
<p>Sin embargo, tener muchas comprobaciones de errores en todas tus funciones
sería verboso y molesto. Afortunadamente, puedes usar el sistema de tipos de
Rust (y, por lo tanto, la comprobación de tipos realizada por el compilador)
para hacer muchas de las comprobaciones por ti. Si tu función tiene un tipo
particular como parámetro, puedes proceder con la lógica de tu código sabiendo
que el compilador ya se ha asegurado de que tengas un valor válido. Por
ejemplo, si tienes un tipo en lugar de un <code>Option</code>, tu programa espera tener
<em>algo</em> en lugar de <em>nada</em>. Tu código entonces no tiene que manejar dos casos
para las variantes <code>Some</code> y <code>None</code>: solo tendrá un caso para tener
definitivamente un valor. El código que intenta pasar nada a tu función ni
siquiera se compilará, por lo que tu función no tiene que verificar ese caso
en tiempo de ejecución. Otro ejemplo es usar un tipo de entero sin signo como
<code>u32</code>, que garantiza que el parámetro nunca sea negativo.</p>
<h3 id="creacion-de-tipos-personalizados-para-validacion"><a class="header" href="#creacion-de-tipos-personalizados-para-validacion">Creacion de tipos personalizados para validacion</a></h3>
<p>Tomemos la idea de usar el sistema de tipos de Rust para garantizar que
tengamos un valor válido un paso más allá y veamos cómo crear un tipo
personalizado para validación. Recuerda el juego de adivinanzas en el Capítulo
2 en el que nuestro código le pidió al usuario que adivinara un número entre 1
y 100. Nunca validamos que la suposición del usuario estuviera entre esos
números antes de verificarla con nuestro número secreto; solo validamos que la
suposición fuera positiva. En este caso, las consecuencias no fueron muy
graves: nuestra salida de “Demasiado alto” o “Demasiado bajo” seguiría siendo
correcta. Pero sería una mejora útil guiar al usuario hacia suposiciones
válidas y tener un comportamiento diferente cuando un usuario adivina un
número que está fuera del rango en comparación con cuando un usuario escribe,
por ejemplo, letras en su lugar.</p>
<p>Una forma de hacer esto sería analizar la suposición como un <code>i32</code> en lugar de
solo un <code>u32</code> para permitir números potencialmente negativos, y luego agregar
una verificación de que el número esté en el rango, de esta manera:</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;The secret number will be between 1 and 100.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
<p>La expresión <code>if</code> verifica si nuestro valor está fuera del rango, le dice al
usuario sobre el problema y llama a <code>continue</code> para iniciar la siguiente
iteración del ciclo y pedir otra suposición. Después de la expresión <code>if</code>,
podemos continuar con las comparaciones entre <code>guess</code> y el número secreto
sabiendo que <code>guess</code> está entre 1 y 100.</p>
<p>Sin embargo, esta no es una solución ideal: si fuera absolutamente crítico que
el programa solo operara en valores entre 1 y 100, y tuviera muchas funciones
con este requisito, tener una verificación como esa en cada función sería
tedioso (y podría afectar el rendimiento).</p>
<p>En su lugar, podemos crear un nuevo tipo y poner las verificaciones en una
función para crear una instancia del tipo en lugar de repetir las
verificaciones en cada función. De esa manera, es seguro que las funciones
utilicen el nuevo tipo en sus firmas y utilicen los valores que reciben con
confianza. El Listado 9-13 muestra una forma de definir un tipo <code>Guess</code> que
solo creará una instancia de <code>Guess</code> si la función <code>new</code> recibe un valor entre
1 y 100.</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {value}.&quot;);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-13: Un tipo <code>Guess</code> que solo continuará con
valores entre 1 y 100</span></p>
<p>Primero, definimos un struct llamado <code>Guess</code> que tiene un campo llamado <code>value</code>
que contiene un <code>i32</code>. Aquí es donde se almacenará el número.</p>
<p>Luego implementamos una función asociada llamada <code>new</code> en <code>Guess</code> que crea
instancias de valores <code>Guess</code>. La función <code>new</code> está definida para tener un
parámetro llamado <code>value</code> de tipo <code>i32</code> y para devolver un <code>Guess</code>. El código
en el cuerpo de la función <code>new</code> prueba <code>value</code> para asegurarse de que esté
entre 1 y 100. Si <code>value</code> no pasa esta prueba, hacemos una llamada <code>panic!</code>,
que alertará al programador que está escribiendo el código de llamada que
tiene un error que debe corregir, porque crear un <code>Guess</code> con un <code>value</code> fuera
de este rango violaría el contrato en el que <code>Guess::new</code> se basa. Las
condiciones en las que <code>Guess::new</code> podría entrar en pánico deben discutirse
en la documentación de la API de cara al público; cubriremos las convenciones
de documentación que indican la posibilidad de un <code>panic!</code> en la documentación
de la API que creas en el Capítulo 14. Si <code>value</code> pasa la prueba, creamos un
nuevo <code>Guess</code> con su campo <code>value</code> establecido en el <code>value</code> y devolvemos el
<code>Guess</code>.</p>
<p>A continuación, implementamos un método llamado <code>value</code> que toma prestado
<code>self</code>, no tiene otros parámetros y devuelve un <code>i32</code>. Este tipo de método se
llama a veces <em>getter</em>, porque su propósito es obtener algunos datos de sus
campos y devolverlos. Este método público es necesario porque el campo <code>value</code>
del struct <code>Guess</code> es privado. Es importante que el campo <code>value</code> sea privado
para que el código que usa el struct <code>Guess</code> no pueda establecer <code>value</code>
directamente: el código fuera del módulo <em>debe</em> usar la función <code>Guess::new</code>
para crear una instancia de <code>Guess</code>, lo que garantiza que no hay forma de que
un <code>Guess</code> tenga un <code>value</code> que no haya sido verificado por las condiciones en
la función <code>Guess::new</code>.</p>
<p>Una función que tiene un parámetro o devuelve solo números entre 1 y 100 podría
entonces declarar en su firma que toma o devuelve un <code>Guess</code> en lugar de un
<code>i32</code> y no necesitaría hacer ninguna verificación adicional en su cuerpo.</p>
<h2 id="resumen-8"><a class="header" href="#resumen-8">Resumen</a></h2>
<p>Las características de manejo de errores de Rust están diseñadas para ayudarte
a escribir un código más robusto. La macro <code>panic!</code> indica que tu programa
está en un estado que no puede manejar y te permite indicarle al proceso que
se detenga en lugar de intentar continuar con valores no válidos o incorrectos.
El enum <code>Result</code> usa el sistema de tipos de Rust para indicar que las
operaciones pueden fallar de una manera que tu código podría recuperar. Puedes
usar <code>Result</code> para decirle al código que llama a tu código que necesita manejar
el éxito o el error de manera potencial. Usar <code>panic!</code> y <code>Result</code> en las
situaciones apropiadas hará que tu código sea más confiable ante los problemas
inevitables.</p>
<p>Ahora que has visto formas útiles en que la biblioteca estándar usa generics
con los enums <code>Option</code> y <code>Result</code>, hablaremos sobre cómo funcionan los
generics y cómo puedes usarlos en tu código.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-genéricos-traits-y-lifetimes"><a class="header" href="#tipos-genéricos-traits-y-lifetimes">Tipos Genéricos, Traits y Lifetimes</a></h1>
<p>Cada lenguaje de programación tiene herramientas para manejar eficazmente la
duplicación de conceptos. En Rust, una de esas herramientas son los <em>genéricos</em>:
sustitutos abstractos de tipos concretos u otras propiedades. Podemos expresar
el comportamiento de los genéricos o cómo se relacionan con otros genéricos sin
saber qué estará en su lugar cuando se compile y ejecute el código.</p>
<p>Las funciones pueden tomar parámetros de algún tipo genérico, en lugar de un
tipo concreto como <code>i32</code> o <code>String</code>, de la misma manera que una función toma
parámetros con valores desconocidos para ejecutar el mismo código en múltiples
valores concretos. De hecho, ya hemos usado genéricos en el Capítulo 6 con
<code>Option&lt;T&gt;</code>, Capítulo 8 con <code>Vec&lt;T&gt;</code> y <code>HashMap&lt;K, V&gt;</code>, y Capítulo 9 con
<code>Result&lt;T, E&gt;</code>. ¡En este capítulo, explorará cómo definir sus propios tipos,
funciones y métodos con genéricos!</p>
<p>Primero, revisaremos cómo extraer una función para reducir la duplicación de
código. Luego usaremos la misma técnica para hacer una función genérico a
partir de dos funciones que difieren solo en los tipos de sus parámetros.
También explicaremos cómo usar tipos genéricos en definiciones de structs y
enums.</p>
<p>Entonces aprenderás cómo usar <em>traits</em> para definir el comportamiento de una
manera genérica. Puedes combinar traits con tipos genéricos para restringir un
tipo genérico para que acepte solo aquellos tipos que tienen un comportamiento
particular, en lugar de cualquier tipo.</p>
<p>Finalmente, discutiremos <em>lifetimes</em>: una variedad de genéricos que le dan al
compilador información sobre cómo se relacionan las referencias entre sí.
Lifetimes nos permiten darle al compilador suficiente información sobre los
valores prestados para que pueda garantizar que las referencias serán válidas
en más situaciones de las que podría sin nuestra ayuda.</p>
<h2 id="eliminando-la-duplicación-extrayendo-una-función"><a class="header" href="#eliminando-la-duplicación-extrayendo-una-función">Eliminando la duplicación extrayendo una función</a></h2>
<p>Los genéricos nos permiten reemplazar tipos específicos con un marcador de
posición que representa múltiples tipos para eliminar la duplicación de código.
Antes de sumergirnos en la sintaxis de los genéricos, veamos primero cómo
eliminar la duplicación de código de una manera que no involucre tipos
genéricos extrayendo una función que reemplace valores específicos con un
marcador de posición que represente múltiples valores. ¡Luego aplicaremos la
misma técnica para extraer una función genérica! Al observar cómo reconocer el
código duplicado que puede usar en una función, comenzará a reconocer el
código duplicado que puede usar en los genéricos.</p>
<p>Comenzamos con un corto programa en el listado 10-1 que encuentra el número
más grande en una lista.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {largest}&quot;);
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre></pre>
<p><span class="caption">Listado 10-1: Encontrando el mayor número en una lista de
números</span></p>
<p>Almacenamos una lista de enteros en la variable <code>number_list</code> y colocamos una
referencia al primer número de la lista en una variable llamada <code>largest</code>.
Luego iteramos a través de todos los números de la lista, y si el número
actual es mayor que el número almacenado en <code>largest</code>, reemplazamos la
referencia en esa variable. Sin embargo, si el número actual es menor o igual
al número más grande visto hasta ahora, la variable no cambia, y el código
pasa al siguiente número de la lista. Después de considerar todos los números
de la lista, <code>largest</code> debería hacer referencia al número más grande, que en
este caso es 100.</p>
<p>Ahora se nos ha encargado encontrar el número más grande en dos listas de
números. Para hacerlo, podemos duplicar el código en el listado 10-1 y usar la
misma lógica en dos lugares diferentes en el programa, como se muestra en el
listado 10-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {largest}&quot;);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {largest}&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 10-2: Código para encontrar el mayor número en
<em>dos</em> listas de números</span></p>
<p>Aunque este código funciona, duplicar el código es tedioso y propenso a errores.
También tenemos que recordar actualizar el código en varios lugares cuando
queremos cambiarlo.</p>
<p>Para eliminar esta duplicación, crearemos una abstracción definiendo una
función que opera en cualquier lista de enteros que se pase en un parámetro.
Esta solución hace que nuestro código sea más claro y nos permite expresar el
concepto de encontrar el número más grande en una lista de forma abstracta.</p>
<p>En el listado 10-3, extraemos el código que encuentra el mayor número en una
función llamada <code>largest</code>. Luego llamamos a la función para encontrar el mayor
número en las dos listas del listado 10-2. También podríamos usar la función
en cualquier otra lista de valores <code>i32</code> que podríamos tener en el futuro.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {result}&quot;);
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {result}&quot;);
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre></pre>
<p><span class="caption">Listado 10-3: Código abstracto para encontrar el número
mayor en dos listas</span></p>
<p>La función <code>largest</code> tiene un parámetro llamado <code>list</code>, que representa cualquier
slice de valores <code>ì32</code> que podríamos pasar a la función. Como resultado, cuando
llamamos a la función, el código se ejecuta en los valores específicos que
pasamos.</p>
<p>En resumen, estos son los pasos que tomamos para cambiar el código del listado
10-2 al listado 10-3:</p>
<ol>
<li>Identificar código duplicado.</li>
<li>Extraer el código duplicado en el cuerpo de la función y especificar las
entradas y salidas de ese código en la firma de la función.</li>
<li>Actualizar las dos instancias de código duplicado para llamar a la función
en su lugar.</li>
</ol>
<p>A continuación, usaremos estos mismos pasos con los genéricos para reducir la
duplicación de código. De la misma manera que el cuerpo de la función puede
operar en una <code>list</code> abstracta en lugar de valores específicos, los genéricos
permiten que el código opere en tipos abstractos.</p>
<p>Por ejemplo, digamos que teníamos dos funciones: una que encuentra el mayor
elemento en un slices de valores <code>i32</code> y otra que encuentra el mayor elemento
en un slice de valores <code>char</code>. ¿Cómo eliminaríamos esa duplicación?
¡Averigüémoslo!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-de-datos-genéricos"><a class="header" href="#tipos-de-datos-genéricos">Tipos de Datos Genéricos</a></h2>
<p>Utilizamos genéricos para crear definiciones para elementos como firmas de
funciones o structs, que luego podemos usar con muchos tipos de datos
concretos diferentes. Primero veamos cómo definir funciones, structs,
enums y métodos usando genéricos. Luego discutiremos cómo los genéricos
afectan el rendimiento del código.</p>
<h3 id="definiciones-in-function"><a class="header" href="#definiciones-in-function">Definiciones in function</a></h3>
<p>Al definir una función que usa genéricos, colocamos los genéricos en la firma de
la función donde normalmente especificaríamos los tipos de datos de los
parámetros y el valor de retorno. Hacerlo hace que nuestro código sea más
flexible y brinda más funcionalidad a los llamadores de nuestra función al
tiempo que evita la duplicación de código.</p>
<p>Continuando con nuestra función <code>largest</code>, el listado 10-4 muestra dos
funciones que encuentran el valor más grande en un slice. Luego
combinaremos estos en una sola función que usa genéricos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {result}&quot;);
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {result}&quot;);
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
<p><span class="caption">Listado 10-4: Dos funciones que difieren solo en sus
nombres y los tipos en sus firmas</span></p>
<p>La función <code>largest_i32</code> es la que extrajimos en el listado 10-3 que encuentra
el <code>i32</code> más grande en un slice. La función <code>largest_char</code> encuentra el
<code>char</code> más grande en un slice. Los cuerpos de las funciones tienen el mismo
código, así que eliminemos la duplicación introduciendo un parámetro de tipo
generic en una sola función.</p>
<p>Para parametrizar los tipos en una nueva función única, necesitamos nombrar el
parámetro de tipo, tal como lo hacemos para los parámetros de valor de una
función. Pero usaremos <code>T</code> porque, por convención, los nombres de los
parámetros de tipo en Rust son cortos, a menudo solo una letra, y la
convención de nomenclatura de tipo de Rust es UpperCamelCase. Abreviatura de
&quot;tipo&quot;, <code>T</code> es la opción predeterminada de la mayoría de los programadores de
Rust.</p>
<p>Cuando usamos un parámetro en el cuerpo de la función, tenemos que declarar el
nombre del parámetro en la firma para que el compilador sepa qué significa ese
nombre. De manera similar, cuando usamos un nombre de parámetro de tipo en la
firma de una función, tenemos que declarar el nombre del parámetro de tipo
antes de usarlo. Para definir la función genérico <code>largest</code>, coloque las
declaraciones de nombre de tipo dentro de corchetes angulares, <code>&lt;&gt;</code>, entre el
nombre de la función y la lista de parámetros, así:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>Leemos esta definición como: la función <code>largest</code> es genérico sobre algún tipo
<code>T</code>. Esta función tiene un parámetro llamado <code>list</code>, que es un slice de valores
de tipo <code>T</code>. La función <code>largest</code> devolverá una referencia a un valor del mismo
tipo <code>T</code>.</p>
<p>El listado 10-5 muestra la definición de la función <code>largest</code> combinada usando
el tipo de datos genérico en su firma. La lista también muestra cómo podemos
llamar a la función con un slice de valores <code>i32</code> o valores <code>char</code>. Tenga en
cuenta que este código aún no se compilará, pero lo arreglaremos más adelante
en este capítulo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {result}&quot;);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {result}&quot;);
}</code></pre>
<p><span class="caption">Listing 10-5: La función <code>largest</code> está usando parámetros
de tipo genérico; esto aún no se compila</span></p>
<p>Si compilamos este código ahora, obtendremos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>El texto de ayuda menciona <code>std::cmp::PartialOrd</code>, que es un <em>trait</em>, y vamos a
hablar de traits en la siguiente sección. Por ahora, sepa que este error
indica que el cuerpo de <code>largest</code> no funcionará para todos los tipos posibles
que podría ser <code>T</code>. Debido a que queremos comparar valores de tipo <code>T</code> en el
cuerpo, solo podemos usar tipos cuyos valores se pueden ordenar. Para habilitar
las comparaciones, la biblioteca estándar tiene el trait <code>std::cmp::PartialOrd</code>
que puede implementar en tipos (consulte el Apéndice C para obtener más
información sobre este trait). Siguiendo la sugerencia del texto de ayuda,
restringimos los tipos válidos para <code>T</code> solo a aquellos que implementan
<code>PartialOrd</code> y este ejemplo se compilará, porque la biblioteca estándar
implementa <code>PartialOrd</code> tanto en <code>i32</code> como en <code>char</code>.</p>
<h3 id="definiciones-in-struct"><a class="header" href="#definiciones-in-struct">Definiciones In Struct</a></h3>
<p>También podemos definir structs para usar tipos genéricos en uno o más campos
usando la sintaxis <code>&lt;&gt;</code>. El listado 10-6 define un struct <code>Point&lt;T&gt;</code> para
contener valores <code>x</code> e <code>y</code> de cualquier tipo <code>T</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Listing 10-6: Un struct <code>Point&lt;T&gt;</code> que contiene valores
<code>x</code> and <code>y</code> de tipo <code>T</code></span></p>
<p>La sintaxis para usar genéricos en las definiciones de structs es similar a la
que se usa en las definiciones de funciones. Primero, declaramos el nombre del
parámetro de tipo dentro de corchetes angulares, justo después del nombre del
struct. Luego, usamos el tipo genérico en la definición del struct donde
especificaríamos tipos de datos concretos.</p>
<p>Ten en cuenta que porque hemos usado un solo tipo genérico para definir
<code>Point&lt;T&gt;</code>, esta definición dice que el struct <code>Point&lt;T&gt;</code> es genérico sobre algún
tipo <code>T</code>, y los campos <code>x</code> e <code>y</code> son <em>ambos</em> ese mismo tipo, sea cual sea ese
tipo. Si creamos una instancia de un <code>Point&lt;T&gt;</code> que tenga valores de diferentes
tipos, como en el listado 10-7, nuestro código no se compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
<p><span class="caption">Listing 10-7: Los campos <code>x</code> e <code>y</code> deben ser del mismo
tipo porque ambos tienen el mismo tipo de dato genérico <code>T</code>.</span></p>
<p>En este ejemplo, cuando asignamos el valor entero 5 a <code>x</code>, le decimos al
compilador que el tipo genérico <code>T</code> será un entero para esta instancia de
<code>Point&lt;T&gt;</code>. Luego, cuando especificamos 4.0 para <code>y</code>, que hemos definido para
tener el mismo tipo que <code>x</code>, obtendremos un error de tipo incompatible como
este:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>Para definir un struct <code>Point</code> donde <code>x</code> e <code>y</code> son ambos genéricos pero podrían
tener diferentes tipos, podemos usar múltiples parámetros de tipo genérico. Por
ejemplo, en el listado 10-8, cambiamos la definición de <code>Point</code> para que sea
generic sobre los tipos <code>T</code> y <code>U</code> donde <code>x</code> es de tipo <code>T</code> y <code>y</code> es de tipo
<code>U</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Listado 10-8: Un <code>Point&lt;T, U&gt;</code> genérico sobre dos tipos
para que <code>x</code> e <code>y</code> puedan ser valores de tipos diferentes</span></p>
<p>¡Ahora todas las instancias de <code>Point</code> que se muestran se permiten! Puede usar
tantos parámetros de tipo genérico en una definición como desee, pero usar más
de unos pocos hace que su código sea difícil de leer. Si encuentra que necesita
muchos tipos genérico en su código, podría indicar que su código necesita
reestructurarse en piezas más pequeñas.</p>
<h3 id="definiciones-in-enum"><a class="header" href="#definiciones-in-enum">Definiciones In Enum</a></h3>
<p>Como hicimos con structs, podemos definir enums para contener tipos genérico en
sus variantes. Echemos otro vistazo al enum <code>Option&lt;T&gt;</code> que la biblioteca
estándar proporciona, que usamos en el Capítulo 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>Esta definición debería tener más sentido para ti ahora. Como puede ver, el
enum <code>Option&lt;T&gt;</code> es genérico sobre el tipo <code>T</code> y tiene dos variantes: <code>Some</code>,
que contiene un valor de tipo <code>T</code>, y <code>None</code>, que no contiene ningún valor.
Al usar el enum <code>Option&lt;T&gt;</code>, podemos expresar el concepto abstracto de un valor
opcional, y porque <code>Option&lt;T&gt;</code> es genérico, podemos usar esta abstracción sin
importar el tipo del valor opcional.</p>
<p>Los enums también pueden usar múltiples tipos genérico. La definición del enum
<code>Result</code> que usamos en el Capítulo 9 es un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>El enum <code>Result</code> es un genérico en dos tipos, <code>T</code> y <code>E</code>. Tiene dos variantes:
<code>Ok</code>, que contiene un valor de tipo <code>T</code>, y <code>Err</code>, que contiene un valor de tipo
<code>E</code>. Esta definición es apropiada porque el significado de <code>Result</code> es que uno
de estos dos tipos, <code>T</code> o <code>E</code>, será el tipo del valor que se devuelve cuando se
produce un error o cuando se tiene éxito (devolviendo un valor de tipo <code>T</code>) o
falla (devolviendo un valor de tipo <code>E</code>). De hecho, esta es la definición que
usamos para abrir un archivo en el listado 9-3, donde <code>T</code> se llenó con el tipo
<code>std::fs::File</code> cuando el archivo se abrió con éxito y <code>E</code> se llenó con el tipo
<code>std::io::Error</code> cuando hubo problemas para abrir el archivo.</p>
<p>Cuando reconoces situaciones en tu código con múltiples definiciones de struct
o enum que difieren solo en los tipos de los valores que contienen, puedes
evitar la duplicación usando tipos genérico en su lugar.</p>
<h3 id="definiciones-in-method"><a class="header" href="#definiciones-in-method">Definiciones In Method</a></h3>
<p>Podemos implementar métodos en structs y enums y usar tipos genérico en sus
definiciones también. El listado 10-9 muestra el struct <code>Point&lt;T&gt;</code> que
definimos en el listado 10-6 con un método llamado <code>x</code> implementado en él.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}</code></pre></pre>
<p><span class="caption">Listado 10-9: Implementando un método llamado <code>x</code> en el
struct <code>Point&lt;T&gt;</code> que devolverá una referencia al campo <code>x</code> de tipo <code>T</code></span></p>
<p>Aquí, hemos definido un método llamado <code>x</code> en <code>Point&lt;T&gt;</code> que devuelve una
referencia a la data en el campo <code>x</code>.</p>
<p>Ten en cuenta que tenemos que declarar <code>T</code> justo después de <code>impl</code> para que
podamos usar <code>T</code> para especificar que estamos implementando métodos en el tipo
<code>Point&lt;T&gt;</code>. Al declarar <code>T</code> como un tipo genérico después de <code>impl</code>, Rust puede
identificar que el tipo en los corchetes angulares en <code>Point</code> es un tipo
generic en lugar de un tipo concreto. Podríamos haber elegido un nombre
diferente para este parámetro genérico que el parámetro genérico declarado en la
definición del struct, pero usar el mismo nombre es convencional. Los métodos
escritos dentro de un <code>impl</code> que declara el tipo genérico se definirán en
cualquier instancia del tipo, sin importar qué tipo concreto termine
sustituyendo al tipo genérico.</p>
<p>También podemos especificar restricciones en los tipos genérico al definir
métodos en el tipo. Por ejemplo, podríamos implementar métodos solo en
instancias de <code>Point&lt;T&gt;</code> con un tipo <code>f32</code> concreto en lugar de en instancias
de <code>Point&lt;T&gt;</code> con cualquier tipo genérico. En el listado 10-10 usamos el tipo
concreto <code>f32</code>, lo que significa que no declaramos ningún tipo después de
<code>impl</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 10-10: Un bloque <code>impl</code> que solo aplica a un
struct con un tipo concreto particular para el parámetro del tipo genérico
<code>T</code></span></p>
<p>Este código significa que el tipo <code>Point&lt;f32&gt;</code> tendrá un método
<code>distance_from_origin</code> definido en él, y otros tipos de <code>Point&lt;T&gt;</code> que no sean
de tipo <code>f32</code> no tendrán este método definido. El método mide qué tan lejos
está nuestro punto del punto en las coordenadas (0.0, 0.0) y usa operaciones
matemáticas que solo están disponibles para tipos de punto flotante.</p>
<p>Los parámetros de tipo genérico en una definición de struct no siempre son los
mismos que los que usas en las firmas de métodos de ese mismo struct. El
listado 10-11 usa los tipos genérico <code>X1</code> e <code>Y1</code> para el struct <code>Point</code> y <code>X2</code>
<code>Y2</code> para la firma del método <code>mixup</code> para hacer el ejemplo más claro. El
método crea una nueva instancia de <code>Point</code> con el valor <code>x</code> del <code>self</code> <code>Point</code>
(de tipo <code>X1</code>) y el valor <code>y</code> del <code>Point</code> pasado (de tipo <code>Y2</code>).</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}</code></pre></pre>
<p><span class="caption">Listado 10-11: Un método que usa diferentes tipos genérico
de la definición de su struct</span></p>
<p>En <code>main</code>, hemos definido un <code>Point</code> que tiene un <code>i32</code> para <code>x</code> (con valor <code>5</code>)
y un <code>f64</code> para <code>y</code> (con valor <code>10.4</code>). La variable <code>p2</code> es un <code>Point</code> struct
que tiene un string slice para <code>x</code> (con valor <code>&quot;Hello&quot;</code>) y un <code>char</code> para <code>y</code>
(con valor <code>c</code>). Llamar a <code>mixup</code> en <code>p1</code> con el argumento <code>p2</code> nos da <code>p3</code>,
que tendrá un <code>i32</code> para <code>x</code>, porque <code>x</code> vino de <code>p1</code>. La variable <code>p3</code> tendrá
un <code>char</code> para <code>y</code>, porque <code>y</code> vino de <code>p2</code>. La llamada al macro <code>println!</code>
imprimirá <code>p3.x = 5, p3.y = c</code>.</p>
<p>El propósito de este ejemplo es demostrar una situación en la que algunos
parámetros genérico se declaran con <code>impl</code> y otros se declaran con la definición
del método. Aquí, los parámetros genérico <code>X1</code> e <code>Y1</code> se declaran después de
<code>impl</code> porque van con la definición del struct. Los parámetros genérico <code>X2</code> e
<code>Y2</code> se declaran después de <code>fn mixup</code>, porque solo son relevantes para el
método.</p>
<h3 id="rendimiento-de-codigo-usando-genericos"><a class="header" href="#rendimiento-de-codigo-usando-genericos">Rendimiento de codigo usando genericos</a></h3>
<p>Quizás te estés preguntando si hay un costo de rendimiento al usar parámetros
de tipo genérico. La buena noticia es que usar tipos genérico no hará que tu
programa se ejecute más lento de lo que lo haría con tipos concretos.</p>
<p>Rust logra esto realizando <em>monomorfización</em> del código usando genéricos en
tiempo de compilación. <em>Monomorfización</em> es el proceso de convertir código
genérico en código específico llenando los tipos concretos que se usan cuando
se compila. En este proceso, el compilador hace lo contrario de los pasos que
usamos para crear la función genérica en el listado 10-5: el compilador mira
todos los lugares donde se llama el código genérico y genera código para los
tipos concretos con los que se llama el código genérico.</p>
<p>Veamos como funciona esto usando el enum genérico de la biblioteca estándar
<code>Option&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>Cuando Rust compila este código, realiza monomorfización. Durante ese
proceso, el compilador lee los valores que se han usado en las instancias de
<code>Option&lt;T&gt;</code> e identifica dos tipos de <code>Option&lt;T&gt;</code>: uno es <code>i32</code> y el otro es
<code>f64</code>. Como tal, expande la definición genérica de <code>Option&lt;T&gt;</code> en dos
definiciones especializadas a <code>i32</code> y <code>f64</code>, reemplazando así la definición
genérica con las específicas.</p>
<p>La versión monomorfizada del código se ve similar al siguiente (el compilador
usa nombres diferentes a los que estamos usando aquí para ilustración):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
<p>El genérico <code>Option&lt;T&gt;</code> se reemplaza con las definiciones específicas creadas por
el compilador. Debido a que Rust compila código genérico en código que
especifica el tipo en cada instancia, no pagamos ningún costo de rendimiento
por usar genéricos. Cuando el código se ejecuta, se comporta de la misma manera
que si hubiéramos duplicado cada definición a mano. El proceso de
monomorfización hace que los genéricos de Rust sean extremadamente eficientes
en tiempo de ejecución.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="traits-definiendo-comportamiento-compartido"><a class="header" href="#traits-definiendo-comportamiento-compartido">Traits: Definiendo Comportamiento Compartido</a></h2>
<p>Un <em>trait</em> define funcionalidad que un tipo particular tiene y puede compartir
con otros tipos. Podemos usar traits para definir comportamiento compartido de
una manera abstracta. Podemos usar <em>trait bounds</em> para especificar que un tipo
genérico puede ser cualquier tipo que tenga cierto comportamiento.</p>
<blockquote>
<p>Nota: Los traits son similares a una característica a menudo llamada
<em>interfaces</em> en otros lenguajes, aunque con algunas diferencias.
En español también se les conoce como <em>rasgos</em> pero en el libro intentaremos
mantener la palabra clave sin traducir, no obstante creamos esta
<a href="https://github.com/RustLangES/rust-book-es/discussions/29">encuesta</a> para futuras
revisiones.</p>
</blockquote>
<h3 id="definiendo-un-trait"><a class="header" href="#definiendo-un-trait">Definiendo un Trait</a></h3>
<p>El comportamiento de un tipo consiste en los métodos que podemos llamar en ese
tipo. Diferentes tipos comparten el mismo comportamiento si podemos llamar los
mismos métodos en todos esos tipos. Las definiciones de traits son una manera
de agrupar firmas de métodos para definir un conjunto de comportamientos
necesarios para lograr algún propósito.</p>
<p>Por ejemplo, digamos que tenemos múltiples structs que contienen varios tipos y
cantidades de texto: un struct <code>NewsArticle</code> que contiene una historia de
noticias archivada en una ubicación particular y un <code>Tweet</code> que puede tener
como máximo 280 caracteres junto con metadatos que indican si es un nuevo
tweet, un retweet, o una respuesta a otro tweet.</p>
<p>Queremos hacer una biblioteca de agregación de medios llamada <code>aggregator</code> que
puede mostrar resúmenes de datos que podrían estar almacenados en una
instancia de <code>NewsArticle</code> o <code>Tweet</code>. Para hacer esto, necesitamos un resumen
de cada tipo, y solicitaremos ese resumen llamando un método <code>summarize</code> en
una instancia. El listado 10-12 muestra la definición de un trait <code>Summary</code>
público que expresa este comportamiento.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
<p><span class="caption">Listado 10-12: Un trait <code>Summary</code> que consiste en el
comportamiento proporcionado por un método <code>summarize</code></span></p>
<p>Aquí, declaramos un trait usando la palabra clave <code>trait</code> y luego el nombre
del trait, que en este caso es <code>Summary</code>. También hemos declarado el trait
como <code>pub</code> para que los crates que dependen de este crate puedan hacer uso de
este trait también, como veremos en algunos ejemplos. Dentro de las llaves
curvas, declaramos las firmas de los métodos que describen los comportamientos
de los tipos que implementan este trait, que en este caso es <code>fn summarize (&amp;self) -&gt; String</code>.</p>
<p>Después de la firma del método, en lugar de proporcionar una implementación
dentro de llaves curvas, usamos un punto y coma. Cada tipo que implementa este
trait debe proporcionar su propio comportamiento personalizado para el cuerpo
del método. El compilador hará cumplir que cualquier tipo que tenga el trait
<code>Summary</code> tendrá el método <code>summarize</code> definido con esta firma exactamente.</p>
<p>Un trait puede tener múltiples métodos en su cuerpo: las firmas de los métodos
se enumeran una por línea y cada línea termina en un punto y coma.</p>
<h3 id="implementando-un-trait-en-un-tipo"><a class="header" href="#implementando-un-trait-en-un-tipo">Implementando un Trait en un Tipo</a></h3>
<p>Ahora que hemos definido el trait <code>Summary</code>, podemos implementarlo en los
tipos en nuestro agregador de medios. El listado 10-13 muestra una
implementación del trait <code>Summary</code> en el struct <code>NewsArticle</code> que usa el
encabezado, el autor y la ubicación para crear el valor de retorno de
<code>summarize</code>. Para el struct <code>Tweet</code>, definimos <code>summarize</code> como el nombre de
usuario seguido del texto completo del tweet, asumiendo que el contenido del
tweet ya está limitado a 280 caracteres.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}</code></pre>
<p><span class="caption">Listado 10-13: Implementación del trait <code>Summary</code> en los
tipos <code>NewsArticle</code> y <code>Tweet</code></span></p>
<p>Implementar un trait en un tipo es similar a implementar métodos regulares.
La diferencia es que después de <code>impl</code>, ponemos el nombre del trait que
queremos implementar, luego usamos la palabra clave <code>for</code>, y luego
especificamos el nombre del tipo que queremos implementar el trait. Dentro del
bloque <code>impl</code>, ponemos las firmas de los métodos que la definición del trait ha
definido. En lugar de agregar un punto y coma después de cada firma, usamos
llaves y llenamos el cuerpo del método con el comportamiento específico que
queremos que los métodos del trait tengan para el tipo en particular.</p>
<p>Ahora que la biblioteca ha implementado el trait <code>Summary</code> en <code>NewsArticle</code> y
<code>Tweet</code>, los usuarios de la biblioteca pueden llamar a los métodos de trait
en las instancias de <code>NewsArticle</code> y <code>Tweet</code> en la misma forma en que llamamos
a los métodos regulares. La única diferencia es que el usuario debe traer el
trait al scope, así como los tipos. Aquí hay un ejemplo de cómo un crate
binario podría usar nuestra biblioteca de <code>aggregator</code>:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}</code></pre>
<p>Este código imprime <code>New article available! horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Otros crates que dependen de nuestro crate <code>aggregator</code> pueden usar el trait
<code>Summary</code> en el ámbito para implementar <code>Summary</code> en sus propios tipos. Una
restricción a tener en cuenta es que podemos implementar un trait en un tipo
solo si al menos uno de los trait o el tipo es local a nuestro crate. Por
ejemplo, podemos implementar traits de la biblioteca estándar como <code>Display</code>
en un tipo personalizado como <code>Tweet</code> como parte de nuestra funcionalidad de
crate <code>aggregator</code>, porque el tipo <code>Tweet</code> es local a nuestro crate
<code>aggregator</code>. También podemos implementar <code>Summary</code> en <code>Vec&lt;T&gt;</code> en nuestro
crate <code>aggregator</code>, porque el trait <code>Summary</code> es local a nuestro crate
<code>aggregator</code>.</p>
<p>Pero no podemos implementar traits externos en tipos externos. Por ejemplo,
digamos que queremos implementar <code>Display</code> en <code>Vec&lt;T&gt;</code> como parte de nuestra
funcionalidad de crate <code>aggregator</code>. Esto no es posible porque tanto <code>Display</code>
como <code>Vec&lt;T&gt;</code> están definidos en la biblioteca estándar y no son locales a
nuestro crate <code>aggregator</code>. La restricción de implementar un trait en un tipo
solo si uno de ellos es local a nuestro crate es parte de una propiedad
llamada <em>coherencia</em>, y más específicamente la <em>regla huérfana</em>, así llamada
porque el tipo padre no está presente. Esta regla asegura que el código de
otras personas no pueda romper su código y viceversa. Sin la regla, dos crates
podrían implementar el mismo trait para el mismo tipo, y Rust no sabría qué
implementación usar.</p>
<h3 id="implementaciones-predeterminadas"><a class="header" href="#implementaciones-predeterminadas">Implementaciones predeterminadas</a></h3>
<p>A veces es útil tener un comportamiento predeterminado para algunos o todos
los métodos en un trait en lugar de requerir implementaciones para todos los
métodos en cada tipo. Luego, a medida que implementamos el trait en un tipo
particular, podemos mantener o anular el comportamiento predeterminado para
cada método.</p>
<p>En el listado 10-14, especificamos un string predeterminado para el método
<code>summarize</code> del trait <code>Summary</code> en lugar de solo definir la firma del método,
como hicimos en el listado 10-12.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 10-14: Definición de un trait <code>Summary</code> con un
valor predeterminado implementado del método <code>summarize</code></span></p>
<p>Para usar una implementación predeterminada para resumir instancias de
<code>NewsArticle</code>, especificamos un bloque <code>impl</code> vacío con <code>impl Summary for NewsArticle {}</code>.</p>
<p>Aunque ya no estamos definiendo el método <code>summarize</code> en <code>NewsArticle</code>
directamente, hemos proporcionado una implementación predeterminada y
especificado que <code>NewsArticle</code> implementa el trait <code>Summary</code>. Como resultado,
todavía podemos llamar al método <code>summarize</code> en una instancia de <code>NewsArticle</code>,
como esto:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}</span></code></pre>
<p>Este código imprime <code>New article available! (Read more...)</code>.</p>
<p>Crear una implementación predeterminada no requiere que cambiemos nada sobre
la implementación de <code>Summary</code> en <code>Tweet</code> en el listado 10-13. La razón es que
la sintaxis para anular una implementación predeterminada es la misma que la
sintaxis para implementar un método de trait que no tiene una implementación
predeterminada.</p>
<p>Las implementaciones predeterminadas pueden llamar otros métodos en el mismo
trait, incluso si esos métodos no tienen una implementación predeterminada.
De esta manera, un trait puede proporcionar una gran cantidad de
funcionalidad útil y solo requiere que los implementadores especifiquen una
pequeña parte de ella. Por ejemplo, podríamos definir el trait <code>Summary</code> para
tener un método <code>summarize_author</code> cuya implementación es requerida, y luego
definir un método <code>summarize</code> que tenga una implementación predeterminada que
llame al método <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Para usar esta version de <code>Summary</code>, solo necesitamos definir <code>summarize_author</code>
cuando implementamos el trait en un tipo:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}</code></pre>
<p>Después de definir <code>summarize_author</code>, podemos llamar a <code>summarize</code> en
instancias de la estructura <code>Tweet</code>, y la implementación predeterminada de
<code>summarize</code> llamará a la definición de <code>summarize_author</code> que hemos
proporcionado. Debido a que hemos implementado <code>summarize_author</code>, el trait
<code>Summary</code> nos ha dado el comportamiento del método <code>summarize</code> sin requerirnos
escribir más código.</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}</span></code></pre>
<p>Este código imprime <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Ten en cuenta que no es posible llamar a la implementación predeterminada desde
una implementación primordial de ese mismo método.</p>
<h3 id="traits-como-parametros"><a class="header" href="#traits-como-parametros">Traits como parametros</a></h3>
<p>Ahora que sabes cómo definir y implementar traits, podemos explorar cómo usar
traits para definir funciones que aceptan muchos tipos diferentes. Usaremos el
trait <code>Summary</code> que implementamos en los tipos <code>NewsArticle</code> y <code>Tweet</code> en el
listado 10-13 para definir una función <code>notify</code> que llama al método <code>summarize</code>
en su parámetro <code>item</code>, que es de algún tipo que implementa el trait <code>Summary</code>.
Para hacer esto, usamos la sintaxis <code>impl Trait</code>, como esto:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}</code></pre>
<p>En lugar de un tipo concreto para el parámetro <code>item</code>, especificamos el
parámetro <code>impl</code> y el nombre del trait. Cualquier tipo que implemente el trait
<code>Summary</code> puede ser pasado al parámetro <code>item</code> en la función <code>notify</code>. El
código que llama a la función <code>notify</code> con cualquier otro tipo, como un <code>String</code>
o un <code>i32</code>, no compilará porque esos tipos no implementan <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="sintaxis-de-trait-bound"><a class="header" href="#sintaxis-de-trait-bound">Sintaxis de trait bound</a></h4>
<p>La sintaxis <code>impl Trait</code> funciona para casos sencillos, pero en realidad es
azúcar sintáctico para una forma más larga conocida como <em>trait bound</em>; se ve
así:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}</code></pre>
<p>Esta forma más larga es equivalente al ejemplo en la sección anterior pero más
detallado. Colocamos los límites de los traits con la declaración del parámetro
generic después de dos puntos y dentro de corchetes angulares.</p>
<p>La sintaxis <code>impl Trait</code> es conveniente y hace que el código sea más conciso en
casos simples, mientras que la sintaxis de trait bound más completa puede
expresar más complejidad en otros casos. Por ejemplo, podemos tener dos
parámetros que implementan <code>Summary</code>. Hacerlo con la sintaxis <code>impl Trait</code> se
ve así:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Usando <code>impl Trait</code> es apropiado si queremos que esta función permita que
<code>item1</code> y <code>item2</code> tengan tipos diferentes (siempre que ambos tipos implementen
<code>Summary</code>). Sin embargo, si queremos forzar que ambos parámetros tengan el
mismo tipo, debemos usar un trait bound, como esto:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>El tipo generic <code>T</code> especificado como el tipo de los parámetros <code>item1</code> e
<code>item2</code> restringe la función de tal manera que el tipo concreto del valor
pasado como argumento para <code>item1</code> e <code>item2</code> debe ser el mismo.</p>
<h4 id="especificando-múltiples-trait-bounds-con-la-sintaxis-"><a class="header" href="#especificando-múltiples-trait-bounds-con-la-sintaxis-">Especificando múltiples trait bounds con la sintaxis <code>+</code></a></h4>
<p>También podemos especificar más de un trait bound. Digamos que queremos que
<code>notify</code> use la representación de cadena de un tipo que implementa <code>Summary</code>
en el cuerpo de la función. Para hacer esto, necesitamos que el parámetro
<code>item</code> implemente tanto <code>Display</code> como <code>Summary</code>. Podemos hacerlo usando la
sintaxis <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>La sintaxis <code>+</code> también es válida con los trait bounds en tipos generics:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>Con los dos trait bounds especificados, el cuerpo de <code>notify</code> puede llamar a
<code>summarize</code> y usar <code>{}</code> para formatear <code>item</code>.</p>
<h4 id="trait-bounds-más-claros-con-cláusulas-where"><a class="header" href="#trait-bounds-más-claros-con-cláusulas-where">Trait bounds más claros con cláusulas <code>where</code></a></h4>
<p>Usar demasiados trait bounds tiene sus inconvenientes. Cada generic tiene sus
propios trait bounds, por lo que las funciones con múltiples parámetros de tipo
generic pueden contener mucha información de trait bound entre el nombre de la
función y su lista de parámetros, lo que hace que la firma de la función sea
difícil de leer. Por esta razón, Rust tiene una sintaxis alternativa para
especificar los trait bounds dentro de una cláusula <code>where</code> después de la
firma de la función. Así que en lugar de escribir esto:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>podemos usar una cláusula <code>where</code>, como esta:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>La firma de esta función está menos desordenada: el nombre de la función, la
lista de parámetros y el tipo de retorno están muy juntos, similar a una función
sin muchos trait bounds.</p>
<h3 id="devolviendo-tipos-que-implementan-traits"><a class="header" href="#devolviendo-tipos-que-implementan-traits">Devolviendo tipos que implementan traits</a></h3>
<p>También podemos usar la sintaxis <code>impl Trait</code> en el tipo de retorno de una
función para devolver un valor de algún tipo que implementa un trait, como se
muestra aquí:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}</code></pre>
<p>Al usar <code>impl Summary</code> para el tipo de retorno, especificamos que la función
<code>returns_summarizable</code> devuelve algún tipo que implementa el trait <code>Summary</code>
sin nombrar el tipo concreto. En este caso, <code>returns_summarizable</code> devuelve un
<code>Tweet</code>, pero el código que llama a esta función no necesita saber eso.</p>
<p>La capacidad de especificar un tipo que es una implementación de un trait
especialmente útil en el contexto de los closures y los iteradores, que
cubriremos en el Capítulo 13. Los closures y los iteradores crean tipos que
solo el compilador conoce o tipos que son muy largos de especificar. La sintaxis
<code>impl Trait</code> te permite especificar de manera concisa que una función devuelve
algún tipo que implementa el trait <code>Iterator</code> sin necesidad de escribir un tipo
muy largo.</p>
<p>Sin embargo, no puedes usar <code>impl Trait</code> si la función devuelve más de un tipo.
Por ejemplo, este código que devuelve un <code>NewsArticle</code> o un <code>Tweet</code> con el tipo
de retorno especificado como <code>impl Summary</code> no compilaría:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p>Volviendo un <code>NewsArticle</code> o un <code>Tweet</code> no está permitido debido a las
restricciones en torno a cómo se implementa la sintaxis <code>impl Trait</code> en el
compilador. Cubriremos cómo escribir una función con este comportamiento en la
sección <a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">“Usando objetos trait que permiten valores de diferentes
tipos”</a><!--
ignore --> del Capítulo 17.</p>
<h3 id="usando-trait-bounds-para-implementar-métodos-condicionalmente"><a class="header" href="#usando-trait-bounds-para-implementar-métodos-condicionalmente">Usando trait bounds para implementar métodos condicionalmente</a></h3>
<p>Al usar un trait bound con un bloque <code>impl</code> que usa parámetros de tipo generic,
podemos implementar métodos condicionalmente para tipos que implementan los
traits especificados. Por ejemplo, el tipo <code>Pair&lt;T&gt;</code> en el listado 10-15 siempre
implementa la función <code>new</code> para devolver una nueva instancia de <code>Pair&lt;T&gt;</code>
(recuerda de la sección <a href="ch05-03-method-syntax.html#definiendo-metodos">“Definiendo métodos”</a><!-- ignore --> del
Capítulo 5 que <code>Self</code> es un alias de tipo para el tipo del bloque <code>impl</code>, que en
este caso es <code>Pair&lt;T&gt;</code>). Pero en el siguiente bloque <code>impl</code>, <code>Pair&lt;T&gt;</code> solo
implementa el método <code>cmp_display</code> si su tipo interno <code>T</code> implementa el trait
<code>PartialOrd</code> que permite la comparación <em>y</em> el trait <code>Display</code> que permite la
impresión.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}</code></pre>
<p><span class="caption">Listado 10-15: Implementación condicional de métodos en un
tipo generic dependiendo de los trait bounds</span></p>
<p>También podemos implementar condicionalmente un trait para cualquier tipo que
implemente otro trait. Implementaciones de un trait en cualquier tipo que
satisfaga los trait bounds se llaman <em>implementaciones blanket</em> y se usan
extensivamente en la biblioteca estándar de Rust. Por ejemplo, la biblioteca
estándar implementa el trait <code>ToString</code> en cualquier tipo que implemente el
trait <code>Display</code>. El bloque <code>impl</code> en la biblioteca estándar se ve similar a este
código:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>Debido a que la biblioteca estándar tiene esta implementación, podemos llamar al
método <code>to_string</code> definido por el trait <code>ToString</code> en cualquier tipo que
implemente el trait <code>Display</code>. Por ejemplo, podemos convertir enteros en sus
valores <code>String</code> correspondientes de esta manera porque los enteros implementan
<code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Las implementaciones generales aparecen en la documentación del trait en la
sección “Implementors”.</p>
<p>Traits y trait bounds nos permiten usar genéricos para reducir la duplicación de
código, pero también para especificar a el compilador que queremos que un tipo
generic tenga un comportamiento particular. El compilador puede usar la
información de los trait bounds para verificar que todos los tipos concretos que
usamos con nuestro código proporcionan el comportamiento correcto. En lenguajes
de tipado dinámico, obtendríamos un error en tiempo de ejecución si llamamos a
un método en un tipo que no define el método. Pero Rust mueve estos errores al
tiempo de compilación, por lo que estamos obligados a corregir los problemas
antes de que nuestro código pueda ejecutarse. Además, no tenemos que escribir
código que verifique el comportamiento en tiempo de ejecución porque ya hemos
verificado en tiempo de compilación. Hacerlo mejora el rendimiento sin tener que
renunciar a la flexibilidad de los generics.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="validando-referencias-con-lifetimes"><a class="header" href="#validando-referencias-con-lifetimes">Validando Referencias con Lifetimes</a></h2>
<p>Los <em>lifetimes</em> son otro tipo de genéricos que ya hemos estado usando. En lugar
de asegurarnos de que un tipo tenga el comportamiento que queremos, los
lifetimes aseguran que las referencias sean válidas el tiempo que las
necesitemos.</p>
<p>Un detalle que no discutimos en la sección <a href="ch04-02-references-and-borrowing.html#referencias-y-prestamos">“Referencias y
Borrowing&quot;</a><!-- ignore --> en el Capítulo 4 es que
cada referencia en Rust tiene un <em>lifetime</em>, que es el scope para el que esa
referencia es válida. La mayoría de las veces, los lifetimes son implícitos e
inferidos, al igual que la mayoría de las veces, los tipos se infieren.
Solo debemos anotar los tipos cuando son posibles varios tipos. De manera
similar, debemos anotar los lifetimes cuando los lifetimes de las referencias
podrían estar relacionados de algunas maneras diferentes. Rust nos obliga a
anotar las relaciones usando parámetros genéricos de lifetime para garantizar
que las referencias reales utilizadas en tiempo de ejecución sean
definitivamente válidas.</p>
<p>Anotar lifetimes no es ni siquiera un concepto que la mayoría de los otros
lenguajes de programación tengan, por lo que esto se sentirá poco familiar.
Aunque no cubriremos los lifetimes en su totalidad en este capítulo,
discutiremos las formas comunes en que podría encontrar la sintaxis de los
lifetimes para que pueda familiarizarse con el concepto.</p>
<h3 id="previniendo-referencias-colgantes-con-lifetimes"><a class="header" href="#previniendo-referencias-colgantes-con-lifetimes">Previniendo Referencias Colgantes con Lifetimes</a></h3>
<p>El objetivo principal de los lifetimes es prevenir <em>referencias colgantes</em>,
que hacen que un programa haga referencia a datos que no son los que se
pretende referenciar. Considere el programa en el listado 10-16, que tiene un
scope externo y un scope interno.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {r}&quot;);
}</code></pre>
<p><span class="caption">Listado 10-16: Un intento de usar una referencia cuyo
valor ha quedado fuera del scope</span></p>
<blockquote>
<p>Nota: Los ejemplos en los Listados 10-16, 10-17 y 10-23 declaran variables
sin darles un valor inicial, por lo que el nombre de la variable existe en el
scope externo. A primera vista, esto podría parecer estar en conflicto con el
hecho de que Rust no tiene valores nulos. Sin embargo, si intentamos usar una
variable antes de darle un valor, obtendremos un error en tiempo de
compilación, lo que muestra que Rust de hecho no permite valores nulos.</p>
</blockquote>
<p>El scope externo declara una variable llamada <code>r</code> sin valor inicial, y el scope
interno declara una variable llamada <code>x</code> con el valor inicial de 5. Dentro del
scope interno, intentamos establecer el valor de <code>r</code> como una referencia a <code>x</code>.
Luego, el scope interno termina, e intentamos imprimir el valor en <code>r</code>. Este
código no se compilará porque el valor al que se refiere <code>r</code> ha quedado fuera
del scope antes de que intentemos usarlo. Aquí está el mensaje de error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!(&quot;r: {r}&quot;);
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>La variable <code>x</code> no “vive lo suficiente”. La razón es que <code>x</code> estará fuera del
scope cuando el scope interno termine en la línea 7. Pero <code>r</code> todavía es
válido para el scope externo; porque su scope es más grande, decimos que
“vive más tiempo”. Si Rust permitiera que este código funcionara, <code>r</code> estaría
referenciando memoria que se desasignó cuando <code>x</code> quedó fuera del scope, y
cualquier cosa que intentemos hacer con <code>r</code> no funcionaría correctamente. ¿Cómo
determina Rust que este código es inválido? Utiliza el <em>borrow checker</em>.</p>
<h3 id="el-borrow-checker"><a class="header" href="#el-borrow-checker">El Borrow Checker</a></h3>
<p>El compilador de Rust tiene un <em>borrow checker</em> que compara scopes para
determinar si todos los <em>borrows</em> son válidos. El listado 10-17 muestra el
mismo código que el listado 10-16, pero con anotaciones que muestran los
lifetimes de las variables.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {r}&quot;);   //          |
}                         // ---------+</code></pre>
<p><span class="caption">Listado 10-17: Anotaciones de los lifetimes de <code>r</code> y
<code>x</code>, denominados <code>'a</code> y <code>'b</code>, respectivamente</span></p>
<p>Aquí, hemos anotado el lifetime de <code>r</code> con <code>'a</code> y el lifetime de <code>x</code> con <code>'b</code>.
Como puede ver, el bloque interno <code>'b</code> es mucho más pequeño que el bloque
externo <code>'a</code>. En tiempo de compilación, Rust compara el tamaño de los dos
lifetimes y ve que <code>r</code> tiene un lifetime de <code>'a</code> pero que se refiere a la
memoria con un lifetime de <code>'b</code>. El programa es rechazado porque <code>'b</code> es más
corto que <code>'a</code>: el sujeto de la referencia no vive tanto como la referencia.</p>
<p>El listado 10-18 corrige el código para que no tenga una referencia pendiente y
se compile sin errores.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {r}&quot;);   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<p><span class="caption">Listado 10-18: Una referencia válida porque los datos
tienen un lifetime más largo que la referencia</span></p>
<p>Aquí, <code>x</code> tiene el lifetime <code>'b</code> que en este caso es más grande que <code>'a</code>. Esto
significa que <code>r</code> puede hacer referencia a <code>x</code> porque Rust sabe que la
referencia en <code>r</code> siempre será válida mientras <code>x</code> sea válida.</p>
<p>Ahora que sabemos dónde están los lifetimes de las referencias y cómo Rust
analiza los lifetimes para garantizar que las referencias siempre sean válidas,
exploraremos los lifetimes genéricos de los parámetros y valores de retorno en
el contexto de las funciones.</p>
<h3 id="generic-lifetimes-en-funciones"><a class="header" href="#generic-lifetimes-en-funciones">Generic Lifetimes en Funciones</a></h3>
<p>Escribiremos una función que devuelva el más largo de dos <em>string slices</em>.
Esta función tomará dos <em>string slices</em> y devolverá un solo <em>string slice</em>.
Después de haber implementado la función <code>longest</code>, el código en el listado
10-19 debería imprimir <code>The longest string is abcd</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {result}&quot;);
}</code></pre>
<p><span class="caption">Listado 10-19: Una función <code>main</code> que llama a la
función <code>longest</code> para encontrar el más largo de dos string slices</span></p>
<p>Ten en cuenta que queremos que la función tome <em>string slices</em>, que son
referencias, en lugar de <em>strings</em>, porque no queremos que la función <code>longest</code>
tome posesión de sus parámetros. Consulta la sección <a href="ch04-03-slices.html#string-slices-as-parameters">“String Slices as
Parameters”</a><!-- ignore --> en el Capítulo 4 para
obtener más información sobre por qué los parámetros que usamos en el listado
10-19 son los que queremos.</p>
<p>Si intentamos implementar la función <code>longest</code> como se muestra en el listado
10-20, no se compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
<p><span class="caption">Listado 10-20: Una implementación de la función <code>longest</code>
que devuelve el más largo de dos string slices pero aún no compila</span></p>
<p>En su lugar, obtenemos el siguiente error que habla sobre lifetimes:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

error: lifetime may not live long enough
  --&gt; src/main.rs:11:9
   |
9  | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |               - let's call the lifetime of this reference `'1`
10 |     if x.len() &gt; y.len() {
11 |         x
   |         ^ returning this value requires that `'1` must outlive `'static`

error: lifetime may not live long enough
  --&gt; src/main.rs:13:9
   |
9  | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |                        - let's call the lifetime of this reference `'2`
...
13 |         y
   |         ^ returning this value requires that `'2` must outlive `'static`

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 3 previous errors
</code></pre>
<p>El texto de ayuda revela que el tipo de retorno necesita un parámetro de
lifetime generic en él porque Rust no puede decir si la referencia que se
devuelve se refiere a <code>x</code> o <code>y</code>. De hecho, nosotros tampoco lo sabemos, porque
el bloque <code>if</code> en el cuerpo de esta función devuelve una referencia a <code>x</code> y el
bloque <code>else</code> devuelve una referencia a <code>y</code>!</p>
<p>Cuando estamos definiendo esta función, no sabemos los valores concretos que
se pasarán a esta función, por lo que no sabemos si se ejecutará el caso <code>if</code> o
el caso <code>else</code>. Tampoco conocemos los lifetimes concretos de las referencias
que se pasarán, por lo que no podemos mirar los scopes como lo hicimos en los
Listados 10-17 y 10-18 para determinar si la referencia que devolvemos siempre
será válida. El <em>borrow checker</em> tampoco puede determinar esto, porque no sabe
cómo se relacionan los lifetimes de <code>x</code> e <code>y</code> con el lifetime del valor de
retorno. Para corregir este error, agregaremos parámetros de lifetime generics
que definan la relación entre las referencias para que el <em>borrow checker</em>
pueda realizar su análisis.</p>
<h3 id="sintaxis-de-las-anotaciones-de-los-lifetimes"><a class="header" href="#sintaxis-de-las-anotaciones-de-los-lifetimes">Sintaxis de las anotaciones de los lifetimes</a></h3>
<p>Las anotaciones de los lifetimes no cambian cuánto tiempo viven las
referencias. En cambio, describen las relaciones de los lifetimes de múltiples
referencias entre sí sin afectar los lifetimes. Al igual que las funciones
pueden aceptar cualquier tipo cuando la firma especifica un parámetro de tipo
genérico, las funciones pueden aceptar referencias con cualquier lifetime
especificando un parámetro de lifetime generic.</p>
<p>Las anotaciones de los lifetimes tienen una sintaxis ligeramente inusual: los
nombres de los parámetros de los lifetimes deben comenzar con un apóstrofe (<code>'</code>)
y generalmente son todos en minúsculas y muy cortos, como los tipos generics.
La mayoría de la gente usa el nombre <code>'a</code> para la primera anotación de
lifetime. Colocamos las anotaciones de los parámetros de los lifetimes después
del <code>&amp;</code> de una referencia, usando un espacio para separar la anotación del tipo
de referencia.</p>
<p>Estos son algunos ejemplos: una referencia a un <code>i32</code> sin un parámetro de
lifetime, una referencia a un <code>i32</code> que tiene un parámetro de lifetime llamado
<code>'a</code>, y una referencia mutable a un <code>i32</code> que también tiene el lifetime <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>Una anotación de lifetime en si misma no tiene mucho significado, porque las
anotaciones están destinadas a decirle a Rust cómo los parámetros de lifetime
generics de múltiples referencias se relacionan entre sí. Examinemos cómo las
anotaciones de los lifetimes se relacionan entre sí en el contexto de la
función <code>longest</code>.</p>
<h3 id="anotaciones-de-los-lifetimes-en-las-firmas-de-las-funciones"><a class="header" href="#anotaciones-de-los-lifetimes-en-las-firmas-de-las-funciones">Anotaciones de los Lifetimes en las Firmas de las Funciones</a></h3>
<p>Para usar anotaciones de los lifetimes en las firmas de las funciones, primero
necesitamos declarar los parámetros de los lifetimes generic dentro de los
corchetes angulares entre el nombre de la función y la lista de parámetros,
como lo hicimos con los parámetros de tipo generic.</p>
<p>Queremos que la firma exprese la siguiente restricción: la referencia devuelta
será válida siempre que ambos parámetros sean válidos. Esta es la relación
entre los lifetimes de los parámetros y el valor de retorno. Nombraremos al
lifetime <code>'a</code> y luego lo agregaremos a cada referencia, como se muestra en el
listado 10-21.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Listado 10-21: La definición de la función <code>longest</code>
que especifica que todas las referencias en la firma deben tener el mismo
lifetime <code>'a</code></span></p>
<p>Este código debe compilar y producir el resultado que queremos cuando lo
usamos con la función <code>main</code> en el listado 10-19.</p>
<p>La firma de la función ahora le dice a Rust que durante el lifetime <code>'a</code>, la
función toma dos parámetros, ambos los cuales son string slices que viven al
menos tanto como el lifetime <code>'a</code>. La firma de la función también le dice a
Rust que el string slice devuelto también vivirá al menos tanto como el
lifetime <code>'a</code>. En la práctica, significa que el lifetime de la referencia
devuelta por la función <code>longest</code> es el mismo que el más pequeño de los
lifetimes de los valores a los que se refieren los argumentos de la función.
Estas relaciones son lo que queremos que Rust use al analizar este código.</p>
<p>Recuerda, cuando especificamos los parámetros de los lifetimes en la firma de
esta función, no estamos cambiando los lifetimes de ninguna de las referencias
que se pasan en o se devuelven. En cambio, estamos especificando que el
<em>borrow checker</em> debería rechazar cualquier valor que no cumpla con estas
restricciones. Ten en cuenta que la función <code>longest</code> no necesita saber
exactamente cuánto tiempo vivirán <code>x</code> e <code>y</code>, solo que algún scope puede
sustituirse por <code>'a</code> que satisfará esta firma.</p>
<p>Cuando anotamos lifetimes en funciones, las anotaciones van en la firma de la
función, no en el cuerpo de la función. Las anotaciones de los lifetimes se
convierten en parte del contrato de la función, al igual que los tipos en la
firma. Tener las firmas de las funciones que contienen el contrato de los
lifetimes significa que el análisis que hace el compilador de Rust puede ser
más simple. Si hay un problema con la forma en que se anotó una función o la
forma en que se llama, los errores del compilador pueden apuntar a la parte de
nuestro código y las restricciones con más precisión. Si, en cambio, el
compilador de Rust hiciera más inferencias sobre lo que pretendíamos que
fueran las relaciones de los lifetimes, el compilador solo podría señalar el
uso de nuestro código muchas etapas después de la causa del problema.</p>
<p>Cuando pasamos referencias concretas a <code>longest</code>, se sustituye un lifetime
concreto por <code>'a</code>. Este lifetime concreto corresponde a la parte del scope de <code>x</code>
que se superpone con el scope de y. En otras palabras, el lifetime
genérico <code>'a</code> adquirirá el lifetime concreto que sea menor entre los lifetimes de
<code>x</code> e <code>y</code>. Debido a que hemos anotado la referencia devuelta con el mismo parámetro
de lifetime <code>'a</code>, la referencia devuelta también será válida por la duración del
lifetime más corta entre <code>x</code> e <code>y</code>.</p>
<p>Veamos cómo las anotaciones de los lifetimes restringen la función <code>longest</code>
pasando referencias que tienen diferentes lifetimes concretos. El listado
10-22 es un ejemplo sencillo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {result}&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 10-22: Usando la función <code>longest</code> con referencias
a valores <code>String</code> que tienen diferentes lifetimes concretos</span></p>
<p>En este ejemplo, <code>string1</code> es válida hasta el final del scope externo, <code>string2</code>
es válida hasta el final del scope interno, y <code>result</code> referencia algo que es
válido hasta el final del scope interno. Ejecuta este código, y verás que el
<em>borrow checker</em> lo aprueba; se compilará e imprimirá <code>The longest string is long string is long</code>.</p>
<p>A continuación, intentemos un ejemplo que muestre que el lifetime de la
referencia en <code>result</code> debe ser el más pequeño de los dos argumentos.
Moveremos la declaración de la variable <code>result</code> fuera del scope interno, pero
dejaremos la asignación del valor a <code>result</code> dentro del scope interno. Luego
moveremos la llamada a <code>println!</code> que usa <code>result</code> fuera del scope interno,
después de que el scope interno haya terminado. El código del listado 10-23 no
compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {result}&quot;);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 10-23: Intentando utilizar <code>result</code> después de que
<code>string2</code> haya quedado fuera del scope</span></p>
<p>Cuando intentamos compilar este código, obtenemos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from(&quot;xyz&quot;);
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {result}&quot;);
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>El error muestra que para que <code>result</code> sea válido para la instrucción
<code>println!</code>, <code>string2</code> tendría que ser válido hasta el final del scope externo.
Rust sabe esto porque anotamos los lifetimes de los parámetros de la función y
los valores de retorno usando el mismo parámetro de lifetime <code>'a</code>.</p>
<p>Como humanos, podemos mirar este código y ver que <code>string1</code> es más larga que
<code>string2</code> y por lo tanto <code>result</code> contendrá una referencia a <code>string1</code>. Debido a
que <code>string1</code> aún no ha quedado fuera del scope, una referencia a <code>string1</code>
todavía será válida para la instrucción <code>println!</code>. Sin embargo, el compilador
no puede ver que la referencia sea válida en este caso. Le hemos dicho a Rust
que el lifetime de la referencia devuelta por la función <code>longest</code> es el mismo
que el más pequeño de los lifetimes de las referencias pasadas. Por lo tanto,
el <em>borrow checker</em> rechaza el código del listado 10-23 como posiblemente
conteniendo una referencia no válida.</p>
<p>Intenta diseñar más experimentos que varíen los valores y los lifetimes de las
referencias que se pasan a la función <code>longest</code> y cómo se usa la referencia
devuelta. Haz hipótesis sobre si tus experimentos pasarán el <em>borrow checker</em>
antes de compilar; luego comprueba si tienes razón!</p>
<h3 id="pensando-en-términos-de-lifetimes"><a class="header" href="#pensando-en-términos-de-lifetimes">Pensando en términos de lifetimes</a></h3>
<p>La forma en que necesitas especificar los parámetros de los lifetimes depende
de lo que tu función esté haciendo. Por ejemplo, si cambiamos la implementación
de la función <code>longest</code> para que siempre devuelva el primer parámetro en lugar
de la referencia a la cadena más larga, no necesitaríamos especificar un
lifetime en el parámetro <code>y</code>. El siguiente código compilará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
<p>Hemos especificado un parámetro de lifetime <code>'a</code> para el parámetro <code>x</code> y el tipo
de retorno, pero no para el parámetro <code>y</code> porque el lifetime de <code>y</code> no tiene
ninguna relación con el lifetime de <code>x</code> o el valor de retorno.</p>
<p>Cuando se devuelve una referencia desde una función, el parámetro del lifetime
para el tipo de retorno debe coincidir con el parámetro del lifetime de uno de
los parámetros. Si la referencia devuelta no se refiere a uno de los parámetros,
debe referirse a un valor creado dentro de esa función. Sin embargo, esto sería
una referencia colgante porque el valor quedará fuera del scope al final de la
función. Considera esta implementación intentada de la función <code>longest</code> que no
se compilará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}</code></pre>
<p>Aquí, aunque hemos especificado un parámetro de lifetime <code>'a</code> para el tipo de
retorno, esta implementación no se compilará porque el lifetime del valor
retornado no está relacionado en absoluto con el lifetime de los parámetros.
Este es el mensaje de error que obtenemos:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>El problema es que <code>result</code> sale del scope y se limpia al final de la función
<code>longest</code>. También estamos tratando de devolver una referencia a <code>result</code> desde
la función. No hay forma de especificar parámetros de lifetime que cambien la
referencia colgante, y Rust no nos permitirá crear una referencia colgante. En
este caso, la mejor solución sería devolver un tipo de dato propiedad en lugar
de una referencia para que la función que llama sea responsable de limpiar el
valor.</p>
<p>En última instancia, la sintaxis de lifetime se trata de conectar las duraciones
de vida de varios parámetros y valores de retorno de funciones. Una vez que se
conectan, Rust tiene suficiente información para permitir operaciones seguras en
memoria y prohibir operaciones que puedan crear punteros colgantes o que de otro
modo violen la seguridad de la memoria.</p>
<h3 id="anotaciones-de-lifetime-en-definiciones-de-struct"><a class="header" href="#anotaciones-de-lifetime-en-definiciones-de-struct">Anotaciones de lifetime en definiciones de struct</a></h3>
<p>Hasta ahora, los structs que hemos definido contienen tipos de ownership.
Podemos definir structs que contengan referencias, pero en ese caso necesitamos
agregar una anotación de lifetime en cada referencia en la definición del
struct. El listado 10-24 tiene un struct llamado <code>ImportantExcerpt</code> que contiene
una string slice.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<p><span class="caption">Listado 10-24: Un struct que contiene una referencia,
lo que requiere una annotation de lifetime</span></p>
<p>Este struct tiene el campo <code>part</code> que contiene un string slice, que es una
referencia. Como con los tipos de datos generics, declaramos el nombre del
parámetro de lifetime genérico dentro de corchetes angulares después del nombre
del struct para que podamos usar el parámetro de lifetime en el cuerpo de la
definición del struct. Esta anotación significa que una instancia de
<code>ImportantExcerpt</code> no puede sobrevivir más allá de la referencia que contiene
en su campo <code>part</code>.</p>
<p>La función <code>main</code> aquí crea una instancia del struct <code>ImportantExcerpt</code> que
contiene una referencia a la primera oración de la variable <code>novel</code>. La data en
<code>novel</code> existe antes de que se cree la instancia de <code>ImportantExcerpt</code>. Además,
<code>novel</code> no sale del scope hasta después de que la instancia de <code>ImportantExcerpt</code>
sale del scope, por lo que la referencia en la instancia de <code>ImportantExcerpt</code>
es válida.</p>
<h3 id="omisión-de-lifetime"><a class="header" href="#omisión-de-lifetime">Omisión de lifetime</a></h3>
<p>Has aprendido que cada referencia tiene un lifetime y que debes especificar
parámetros de lifetime para las funciones o structs que usan referencias. Sin
embargo, en el Capítulo 4, tuvimos una función en el listado 4-9, que se muestra
nuevamente en el listado 10-25, que se compiló sin anotaciones de lifetime.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 10-25: Una función que definimos en el listado 4-9
que compiló sin anotaciones de lifetime, a pesar de que el parámetro y el tipo
de retorno son referencias</span></p>
<p>La razón por la que esta función se compila sin anotaciones de lifetime es
histórica: en las primeras versiones (pre-1.0) de Rust, este código no se
compilaría porque cada referencia necesitaba un lifetime explícito. En ese
momento, la firma de la función se habría escrito así:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Después de escribir mucho código en Rust, el equipo de Rust descubrió que los
programadores de Rust estaban ingresando las mismas anotaciones de lifetime una
y otra vez en situaciones particulares. Estas situaciones eran predecibles y
seguían algunos patrones deterministas. Los desarrolladores programaron estos
patrones en el código del compilador para que el borrow checker pudiera inferir
los lifetimes en estas situaciones y no necesitara anotaciones explícitas.</p>
<p>Este fragmento de la historia de Rust es relevante porque es posible que
aparezcan patrones más deterministas y se agreguen al compilador. En el futuro,
se pueden requerir aún menos anotaciones de lifetime.</p>
<p>Los patrones programados en el análisis de referencias de Rust se llaman <em>reglas
de omisión de lifetime</em>. Estas no son reglas que los programadores deben<br />
seguir; son un conjunto de casos particulares que el compilador considerará, y
si su código se ajusta a estos casos, no es necesario que escriba los lifetimes
explícitamente.</p>
<p>Las reglas de omisión no proporcionan inferencia completa. Si Rust aplica
determinísticamente las reglas pero todavía hay ambigüedad sobre qué lifetimes
tienen las referencias, el compilador no adivinará qué lifetime deberían tener
las referencias restantes. En lugar de adivinar, el compilador le dará un error
que puede resolver agregando las anotaciones de lifetime.</p>
<p>Los lifetime en los parámetros de una función o método se llaman lifetime de
entrada y los lifetime en los valores de retorno se llaman <em>output lifetimes</em>.</p>
<p>El compilador usa tres reglas para determinar los lifetime de las referencias
cuando no hay anotaciones explícitas. La primera regla se aplica a los lifetime
de entrada, y la segunda y tercera regla se aplican a los <em>output lifetimes</em>. Si
el compilador llega al final de las tres reglas y aún hay referencias para las
que no puede determinar los lifetime, el compilador mostrará un error. Estas
reglas se aplican tanto a las definiciones de <code>fn</code> como a los bloques <code>impl</code>.</p>
<p>La primera regla es que el compilador asigna un parámetro de lifetime a cada
parámetro que sea una referencia. En otras palabras, una función con un
parámetro obtiene un parámetro de lifetime: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; una
función con dos parámetros obtiene dos parámetros de lifetime separados: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; y así sucesivamente.</p>
<p>La segunda regla es que, si hay un parámetro de input de lifetime, ese lifetime
se asigna a todos los parámetros de output de lifetime:<code>fn foo&lt;'a&gt;(x: &amp;'a i32)  -&gt; &amp;'a i32</code>.</p>
<p>La tercera regla es que si hay múltiples parámetros de input de lifetime, pero
uno de ellos es <code>&amp;self</code> o <code>&amp;mut self</code> porque este es un método, el lifetime de
<code>self</code> se asigna a todos los parámetros de output de lifetime. Esto hace que los
métodos sean mucho más agradables de leer y escribir porque se necesitan menos
símbolos.</p>
<p>Imaginemos que somos el compilador. Aplicaremos estas reglas para descubrir los
lifetime de las referencias en la firma de la función <code>first_word</code> en el
listado 10-25. La firma comienza sin ningún lifetime asociado con las
referencias:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Luego el compilador aplica la primera regla, que especifica que cada parámetro
tiene su propio lifetime. Como de costumbre, llamaremos a este lifetime <code>'a</code>,
por lo que ahora la firma es la siguiente:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>La segunda regla aplica porque hay exactamente un parámetro de input con
lifetime. Este segundo conjunto establece que el lifetime del único parámetro de
input se asigna a todos los parámetros de output, por lo que la firma de la
función se convierte en la siguiente:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Ahora todas las referencias en esta firma de función tienen lifetime, y el
compilador puede continuar su análisis sin necesidad de que el programador
anote los lifetime en esta firma de función.</p>
<p>Veamos otro ejemplo, esta vez usando la función <code>longest</code> que no tenía
parámetros de lifetime cuando comenzamos a trabajar con ella en el listado
10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Aplicamos la primera regla: cada parámetro obtiene su propio lifetime. Esta vez
tenemos dos parámetros en lugar de uno, por lo que tenemos dos lifetimes:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Podemos ver que la segunda regla no se aplica porque hay más de un input
lifetime. La tercera regla tampoco se aplica porque <code>longest</code> es una función
en lugar de un método, por lo que no hay un parámetro de <code>self</code>. Después de
trabajar a través de las tres reglas, todavía no hemos descubierto cuál es el
lifetime de retorno. Es por eso que obtuvimos un error al intentar compilar el
código en el listado 10-20: el compilador trabajó a través de las reglas de
omisión de lifetime, pero aún no pudo descubrir todos los lifetime de las
referencias en la firma.</p>
<p>Dado que la tercera regla solo se aplica realmente en las firmas de los métodos,
veremos los lifetime en ese contexto a continuación para ver por qué la tercera
regla significa que no tenemos que anotar los lifetime en las firmas de los
métodos con mucha frecuencia.</p>
<h3 id="anotaciones-de-lifetime-en-las-definiciones-de-métodos"><a class="header" href="#anotaciones-de-lifetime-en-las-definiciones-de-métodos">Anotaciones de lifetime en las definiciones de métodos</a></h3>
<p>Cuando implementamos métodos en un struct con lifetimes, usamos la misma
sintaxis que la de los parámetros de tipo generic que se muestra en el listado
10-11. Donde declaramos y usamos los parámetros de lifetime depende de si están
relacionados con los campos del struct o con los parámetros y valores de retorno
del método.</p>
<p>Los nombres de lifetime para los campos de una estructura siempre deben declararse
después de la palabra clave <code>impl</code> y luego usarse después del nombre del struct,
porque esos lifetime son parte del tipo del struct.</p>
<p>En las firmas de los métodos dentro del bloque <code>impl</code>, las referencias pueden
estar vinculadas a los lifetime de los campos del struct, o pueden ser
independientes. Además, las reglas de omisión de lifetime a menudo hacen que no
sean necesarias las anotaciones de lifetime en las firmas de los métodos. Veamos
algunos ejemplos usando el struct llamado <code>ImportantExcerpt</code> que definimos en el
listado 10-24.</p>
<p>En primer lugar, usaremos un método llamado <code>level</code> cuyo parámetro es una
referencia a <code>self</code>, y cuyo valor de retorno es un <code>i32</code>, que no es una
referencia a nada:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Attention please: {announcement}&quot;);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>La declaración del parámetro de lifetime después de <code>impl</code> y su uso después del
nombre del struct son requeridos, pero no estamos obligados a anotar el lifetime
de la referencia a <code>self</code> porque se aplica la primera regla de omisión.</p>
<p>Aquí hay un ejemplo donde la tercera regla de omisión de lifetime se aplica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {announcement}&quot;);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Hay dos input lifetimes, por lo que Rust aplica la primera regla de omisión de
lifetime y les da a <code>&amp;self</code> y <code>announcement</code> sus propios lifetimes. Luego,
debido a que uno de los parámetros es <code>&amp;self</code>, el tipo de retorno obtiene el
lifetime de <code>&amp;self</code>, y todos los lifetimes han sido contabilizados.</p>
<h3 id="el-lifetime-static"><a class="header" href="#el-lifetime-static">El lifetime static</a></h3>
<p>Un lifetime especial que necesitamos discutir es <code>'static</code>, que denota que
la referencia afectada puede vivir durante toda la duración del programa. Todos
los string literals tienen el lifetime <code>'static</code>, que podemos anotar de la
siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}</span></code></pre></pre>
<p>El texto de este string se almacena directamente en el programa binario, que
siempre está disponible. Por lo tanto, la duración de todos los string literals
es <code>'static</code>.</p>
<p>Es posible que veas sugerencias para usar el lifetime <code>'static</code> en mensajes de
error. Pero antes de especificar <code>'static</code> como el lifetime para una referencia,
piensa si la referencia que tienes realmente vive durante toda la duración de tu
programa o no, y si quieres que lo haga. La mayoría de las veces, un mensaje de
error que sugiere el lifetime <code>'static</code> resulta de intentar crear una referencia
colgante o una falta de coincidencia de los lifetimes disponibles. En tales
casos, la solución es corregir esos problemas, no especificar el lifetime
<code>'static</code>.</p>
<h2 id="parámetros-de-tipo-generic-trait-bounds-y-lifetimes-juntos"><a class="header" href="#parámetros-de-tipo-generic-trait-bounds-y-lifetimes-juntos">Parámetros de tipo generic, trait bounds y lifetimes juntos</a></h2>
<p>¡Veamos brevemente la sintaxis de especificar parámetros de tipo generic, trait
bounds y lifetimes todo en una función!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Today is someone's birthday!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Announcement! {ann}&quot;);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>Esta es la función <code>longest</code> del listado 10-21 que devuelve el string más largo
de dos string slices. Pero ahora tiene un parámetro adicional llamado <code>ann</code> del
tipo generic <code>T</code>, que puede llenarse con cualquier tipo que implemente el trait
<code>Display</code> como se especifica en la cláusula <code>where</code>. Este parámetro adicional
se imprimirá con <code>{}</code>, por lo que es necesario el trait bound <code>Display</code>. Debido
a que los lifetimes son un tipo de generic, las declaraciones del parámetro de
lifetime <code>'a</code> y el parámetro de tipo generic <code>T</code> van en la misma lista dentro
de los corchetes angulares después del nombre de la función.</p>
<h2 id="resumen-9"><a class="header" href="#resumen-9">Resumen</a></h2>
<p>¡Hemos cubierto mucho en este capítulo! Ahora que conoces los parámetros de
tipo generic, los traits y los trait bounds, y los parámetros de lifetime
generic, estás listo para escribir código sin repetición que funcione en muchas
situaciones diferentes. Los parámetros de tipo generic te permiten aplicar el
código a diferentes tipos. Los traits y los trait bounds garantizan que, aunque
los tipos son generic, tendrán el comportamiento que el código necesita.
Aprendiste cómo usar las anotaciones de lifetime para garantizar que este código
flexible no tendrá referencias colgantes. ¡Y todo este análisis ocurre en tiempo
de compilación, lo que no afecta el rendimiento en tiempo de ejecución!</p>
<p>Aunque no lo creas, hay mucho más que aprender sobre los temas que discutimos en
este capítulo: el Capítulo 17 discute los trait objects, que son otra forma de
usar traits. También hay escenarios más complejos que involucran anotaciones de
lifetime que solo necesitarás en escenarios muy avanzados; para esos, debes leer
la <a href="https://doc.rust-lang.org/reference/index.html">Referencia de Rust</a>. Pero a continuación, aprenderás cómo
escribir pruebas en Rust para que puedas asegurarte de que tu código funcione
como debería.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escribiendo-tests-automatizados"><a class="header" href="#escribiendo-tests-automatizados">Escribiendo Tests automatizados</a></h1>
<p>En su ensayo de 1972 &quot;El programador humilde&quot;, Edsger W. Dijkstra dijo que
&quot;Los tests de programas pueden ser una forma muy efectiva de mostrar la
presencia de errores, pero es inútil para mostrar su ausencia&quot;. Eso no significa
que no debamos intentar probar tanto como podamos!</p>
<p>La corrección en nuestros programas es el grado en que nuestro código hace lo
que pretendemos que haga. Rust está diseñado con un alto grado de preocupación
por la corrección de los programas, pero la corrección es compleja y no es
fácil de probar. El sistema de tipos de Rust soporta una gran parte de esta
carga, pero el sistema de tipos no puede atrapar todo. Como tal, Rust incluye
soporte para escribir tests de software automatizados.</p>
<p>Digamos que escribimos una función <code>add_two</code> que suma 2 a cualquier número que
se le pase. La firma de esta función acepta un entero como parámetro y devuelve
un entero como resultado. Cuando implementamos y compilamos esa función, Rust
hace toda la comprobación de tipos y de préstamos que has aprendido hasta ahora
para asegurarse de que, por ejemplo, no estamos pasando un valor <code>String</code> o una
referencia no válida a esta función. Pero Rust <em>no puede</em> comprobar que esta
función haga precisamente lo que pretendemos, que es devolver el parámetro más
2 en lugar de, por ejemplo, el parámetro más 10 o el parámetro menos 50! Ahí es
donde entran los tests.</p>
<p>Podemos escribir tests que afirmen, por ejemplo, que cuando pasamos <code>3</code> a la
función <code>add_two</code>, el valor devuelto es <code>5</code>. Podemos ejecutar estos tests
siempre que hagamos cambios en nuestro código para asegurarnos de que cualquier
comportamiento correcto existente no haya cambiado.</p>
<p>El Testing es una habilidad compleja: aunque no podemos cubrir todos los
detalles sobre cómo escribir buenos tests en un capítulo, discutiremos los
mecanismos de las instalaciones de testing de Rust. Hablaremos sobre las
anotaciones y macros disponibles para ti cuando escribas tus tests, el
comportamiento predeterminado y las opciones proporcionadas para ejecutar tus
tests, y cómo organizar los tests en tests unitarios y tests de integración.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="como-escribir-tests"><a class="header" href="#como-escribir-tests">Como escribir tests</a></h2>
<p>Los tests son funciones en Rust que verifican que el código no-test funciona de
la manera esperada. Los cuerpos de las funciones de test típicamente realizan
estas tres acciones:</p>
<ol>
<li>Configurar cualquier dato o estado necesario.</li>
<li>Ejecutar el código que se quiere testear.</li>
<li>Verificar que los resultados son los esperados.</li>
</ol>
<p>Veamos las características que Rust provee específicamente para escribir tests
que incluyen el atributo <code>test</code>, algunas macros, y el atributo <code>should_panic</code>.</p>
<h3 id="la-anatomia-de-una-funcion-de-test"><a class="header" href="#la-anatomia-de-una-funcion-de-test">La anatomia de una funcion de test</a></h3>
<p>En su forma más simple, un test en Rust es una función que está anotada con el
atributo <code>test</code>. Los atributos son metadatos sobre piezas de código Rust; un
ejemplo es el atributo <code>derive</code> que usamos con structs en el Capítulo 5. Para
cambiar una función en una función de test, agrega <code>#[test]</code> en la línea antes
de <code>fn</code>. Cuando ejecutas tus tests con el comando <code>cargo test</code>, Rust construye
un binario que corre las funciones anotadas y reporta si cada función de test
pasa o falla.</p>
<p>Cuando creamos un nuevo proyecto de librería con Cargo, se genera
automáticamente un módulo de test con una función de test. Este módulo te da
una plantilla para escribir tus tests para que no tengas que buscar la
estructura y sintaxis exacta cada vez que comiences un nuevo proyecto. ¡Puedes
agregar tantas funciones de test adicionales y tantos módulos de test como
quieras!</p>
<p>Exploraremos algunos aspectos de cómo funcionan los tests experimentando con la
plantilla de test antes de testear cualquier código. Luego escribiremos algunos
tests del mundo real que llaman a algún código que hemos escrito y verifican
que su comportamiento es correcto.</p>
<p>Creemos un nuevo proyecto de librería llamado <code>adder</code> que sume dos números:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>El contenido del archivo <code>src/lib.rs</code> en tu librería <code>adder</code> debería verse como
el Listado 11-1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p><span class="caption">Listing 11-1: El módulo test y la función generada
automáticamente por <code>cargo new</code></span></p>
<p>Por ahora, ignoremos las dos primeras líneas y nos enfoquemos solamente en la 
función <code>it_works()</code>.
Nota la anotación <code>#[test]</code>: este atributo indica que esta es una función de
test, así que el test runner sabe que tratar esta función como un test. También
podríamos tener funciones no-test en el módulo <code>tests</code> para ayudar a configurar
escenarios comunes o realizar operaciones comunes, así que siempre necesitamos
indicar qué funciones son tests.</p>
<p>El cuerpo de la función de test llama a la macro <code>assert_eq!</code>, que verifica que
dos valores sean iguales. Si los valores no son iguales, <code>assert_eq!</code> falla y
el test falla. Si son iguales, no pasa nada y el test pasa.</p>
<p>El comando <code>cargo test</code> ejecuta todos los tests en tu proyecto de librería, Como
puedes ver en el Listado 11-2.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><span class="caption">Listing 11-2: El resultado de ejecutar el test generado
automáticamente</span></p>
<p>Cargo compila y ejecuta el test. Vemos la línea <code>running 1 test</code>. La siguiente
línea muestra el nombre de la función de test generada, llamada <code>it_works</code>, y
que el resultado de ejecutar ese test es <code>ok</code>. El resumen general <code>test result: ok.</code> significa que todos los tests pasaron, y la porción que lee <code>1 passed; 0 failed</code> totaliza el número de tests que pasaron o fallaron.</p>
<p>Es posible marcar un test como ignorado para que no se ejecute en una
particular instancia; cubriremos eso en la sección <a href="ch11-02-running-tests.html#ignorando-algunos-tests-a-menos-que-se-soliciten-especificamente">“Ignorando algunos tests a
menos que sean específicamente requeridos”</a><!-- ignore --> más tarde
en este capítulo. Porque no hemos hecho eso aquí, el resumen muestra <code>0 ignored</code>. También podemos pasar un argumento al comando <code>cargo test</code> para
ejecutar solo tests cuyo nombre coincida con un string; esto se llama
<em>filtrado</em> y lo cubriremos en la sección <a href="ch11-02-running-tests.html#ejecutando-un-subset-de-tests-por-nombre">“Ejecutando un subconjunto de tests
por nombre”</a><!-- ignore -->. Tampoco hemos filtrado los tests que se
ejecutan, así que el final del resumen muestra <code>0 filtered out</code>.</p>
<p>La estadística <code>0 measured</code> es para tests de benchmark que miden performance.
Los tests de benchmark, al momento de escribir esto, solo están disponibles en
Rust nightly. Ver <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">la documentación sobre tests de benchmark</a> para
aprender más.</p>
<p>La siguiente parte del output de test, comenzando con <code>Doc-tests adder</code>, es
para los resultados de cualquier test de documentación. No tenemos tests de
documentación aún, pero Rust puede compilar cualquier ejemplo de código que
aparezca en nuestra documentación de API. ¡Esta característica ayuda a mantener
tus docs y tu código en sincronía! Discutiremos cómo escribir tests de
documentación en la sección <a href="ch14-02-publishing-to-crates-io.html#comentarios-de-documentacion-como-tests">“Documentación como tests”</a><!--
ignore --> del Capítulo 14. Por ahora, ignoraremos el output <code>Doc-tests</code>.</p>
<p>Comenzaremos a personalizar el test para nuestras propias necesidades. Primero
cambiaremos el nombre de la función <code>it_works</code> a un nombre diferente, como
<code>exploration</code>, así:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Entonces ejecutamos <code>cargo test</code> de nuevo. El output ahora muestra <code>exploration</code>
en lugar de <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Ahora agregaremos otro test, ¡pero esta vez haremos un test que falle! Los
tests fallan cuando algo en la función de test hace panic. Cada test se ejecuta
en un nuevo thread, y cuando el thread principal ve que un thread de test ha
muerto, el test se marca como fallido. En el Capítulo 9, hablamos sobre cómo la
forma más simple de hacer panic es llamar a la macro <code>panic!</code>. Ingresa el nuevo
test como una función llamada <code>another</code>, así que tu archivo <em>src/lib.rs</em> se ve
como el Listado 11-3.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
    
    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}</code></pre>
<p><span class="caption">Listing 11-3: Agregando un segundo test que fallará porque
llamamos a la macro <code>panic!</code></span></p>
<p>Volvemos a ejecutar los tests usando <code>cargo test</code>. El output debería verse como
el Listado 11-4, que muestra que nuestro test <code>exploration</code> pasó y <code>another</code>
falló.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p><span class="caption">Listing 11-4: Resultados del test cuando un test pasa y el
otro falla</span></p>
<p>En lugar de <code>ok</code>, la línea <code>test tests::another</code> muestra <code>FAILED</code>. Dos nuevas
secciones aparecen entre los resultados individuales y el resumen: la primera
muestra la razón detallada de cada falla de test. En este caso, obtenemos los
detalles de que <code>another</code> falló porque <code>panicked at 'Make this test fail'</code> en la
línea 10 del archivo <em>src/lib.rs</em>. La siguiente sección lista solo los nombres
de todos los tests que fallaron, lo cual es útil cuando hay muchos tests y
mucho output detallado de tests fallidos. Podemos usar el nombre de un test
fallido para ejecutar solo ese test y depurarlo más fácilmente; hablaremos más
sobre formas de ejecutar tests en la sección <a href="ch11-02-running-tests.html#controlando-como-los-tests-son-ejecutados">“Controlando cómo se ejecutan los
tests”</a><!-- ignore -->.</p>
<p>La línea de resumen se muestra al final: en general, nuestro resultado de test
es <code>FAILED</code>. Tenemos un test que pasó y uno que falló.</p>
<p>Ahora que has visto cómo se ven los resultados de tests en diferentes
escenarios, veamos algunas macros que son útiles en tests que no sean <code>panic!</code>.</p>
<h3 id="comprobando-resultados-con-la-macro-assert"><a class="header" href="#comprobando-resultados-con-la-macro-assert">Comprobando resultados con la macro <code>assert!</code></a></h3>
<p>La macro <code>assert!</code>, proporcionada por la biblioteca estándar, es útil cuando
quieres asegurarte de que alguna condición en un test se evalúe como <code>true</code>. Le
damos a la macro <code>assert!</code> un argumento que se evalúa a un booleano. Si el valor
es <code>true</code>, no pasa nada y el test pasa. Si el valor es <code>false</code>, la macro
<code>assert!</code> llama a <code>panic!</code> para hacer que el test falle. Usar la macro <code>assert!</code>
nos ayuda a verificar que nuestro código esté funcionando de la forma que
queremos.</p>
<p>En el capítulo 5, en el Listado 5-15, usamos un struct <code>Rectangle</code> y un método
<code>can_hold</code>, que se repiten aquí en el Listado 11-5. Pondremos este código en el
archivo <em>src/lib.rs</em>, luego escribiremos algunos tests para él usando la macro
<code>assert!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<p><span class="caption">Listing 11-5: Usando el struct <code>Rectangle</code> y su método
<code>can_hold</code> del Capítulo 5</span></p>
<p>El método <code>can_hold</code> devuelve un valor booleano, lo que significa que es un caso
de uso perfecto para la macro <code>assert!</code>. En el Listado 11-6, escribimos un test
que ejercita el método <code>can_hold</code> creando una instancia de <code>Rectangle</code> que tiene
un ancho de 8 y una altura de 7 y afirmando que puede contener otra instancia
de <code>Rectangle</code> que tiene un ancho de 5 y una altura de 1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<p><span class="caption">Listing 11-6: Un test para <code>can_hold</code> que verifica si un
rectángulo más grande puede contener un rectángulo más pequeño</span></p>
<p>Observa que hemos agregado una nueva línea dentro del módulo <code>tests</code>: <code>use super::*;</code>. El módulo <code>tests</code> es un módulo regular que sigue las reglas de
visibilidad habituales que cubrimos en el Capítulo 7 en la sección
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths para referirse a un item en el árbol de
módulos”</a><!-- ignore -->.
Como el módulo <code>tests</code> es un módulo interno, necesitamos traer el código bajo
test en el módulo externo al alcance del módulo interno. Usamos un asterisco aquí
para que cualquier cosa que definamos en el módulo externo esté disponible para
este módulo <code>tests</code>.</p>
<p>Hemos llamado a nuestro test <code>larger_can_hold_smaller</code>, y hemos creado dos
instancias de <code>Rectangle</code> que necesitamos. Luego llamamos a la macro <code>assert!</code>
y le pasamos el resultado de llamar a <code>larger.can_hold(&amp;smaller)</code>. Esta
expresión debería devolver <code>true</code>, por lo que nuestro test debería pasar.
¡Veámoslo!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>¡Pasó! Ahora agreguemos otro test, esta vez afirmando que un rectángulo más
pequeño no puede contener un rectángulo más grande:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Porque el resultado correcto de la función <code>can_hold</code> en este caso es <code>false</code>,
necesitamos negar ese resultado antes de pasarlo a la macro <code>assert!</code>. Como
resultado, nuestro test pasará si <code>can_hold</code> devuelve <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>¡Dos tests que pasan! Ahora veamos qué sucede con nuestros resultados de test
cuando introducimos un bug en nuestro código. Cambiaremos la implementación del
método <code>can_hold</code> reemplazando el signo mayor que con un signo menor que cuando
compara los anchos:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ejecutar los tests ahora produce lo siguiente:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>¡Nuestros tests atraparon el bug! Debido a que <code>larger.width</code> es 8 y
<code>smaller.width</code> es 5, la comparación de los anchos en <code>can_hold</code> ahora devuelve
<code>false</code>: 8 no es menor que 5.</p>
<h3 id="testeando-la-igualdad-con-las-macros-assert_eq-y-assert_ne"><a class="header" href="#testeando-la-igualdad-con-las-macros-assert_eq-y-assert_ne">Testeando la igualdad con las macros <code>assert_eq!</code> y <code>assert_ne!</code></a></h3>
<p>Una manera común de verificar la funcionalidad es probar la igualdad entre el
resultado del código bajo test y el valor que esperamos que el código devuelva.
Podrías hacer esto usando la macro <code>assert!</code> y pasándole una expresión usando
el operador <code>==</code>. Sin embargo, este es un test tan común que la biblioteca
estándar provee un par de macros —<code>assert_eq!</code> y <code>assert_ne!</code>— para realizar
este test de manera más conveniente. Estas macros comparan dos argumentos por
igualdad o desigualdad, respectivamente. También imprimirán los dos valores si
la aserción falla, lo que hace más fácil ver <em>por qué</em> falló el test;
conversamente, la macro <code>assert!</code> solo indica que obtuvo un valor <code>false</code> para
la expresión <code>==</code>, sin imprimir los valores que llevaron al valor <code>false</code>.</p>
<p>En el Listado 11-7, escribimos una función llamada <code>add_two</code> que suma <code>2</code> a su
parámetro, luego testeamos esta función usando la macro <code>assert_eq!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}</code></pre>
<p><span class="caption">Listing 11-7: Testeando la función <code>add_two</code> usando la
macro <code>assert_eq!</code></span></p>
<p>¡Veamos que pasa!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Hemos pasado <code>4</code> como argumento a <code>assert_eq!</code>, que es igual al resultado de
llamar a <code>add_two(2)</code>. La línea para este test es <code>test tests::it_adds_two ... ok</code>, y el texto <code>ok</code> indica que nuestro test pasó!</p>
<p>Vamos a introducir un error en nuestro código para ver cómo se ve <code>assert_eq!</code>
cuando falla. Cambiaremos la implementación de la función <code>add_two</code> para que
en su lugar añada <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ejecutemos los tests nuevamente:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:11:9:
assertion `left == right` failed
  left: 4
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>¡Nuestro test atrapó el bug! El test <code>it_adds_two</code> falló, y el mensaje nos dice
que la aserción que falló fue <code> assertion `left == right` failed</code> y
cuáles son los valores de <code>left</code> y <code>right</code>. Este mensaje nos ayuda a comenzar a
debuggear: el argumento <code>left</code> fue <code>4</code> pero el argumento <code>right</code>, donde
llamamos a <code>add_two(2)</code>, fue <code>5</code>. Puedes imaginar que esto sería especialmente
útil cuando tenemos muchos tests en marcha.</p>
<p>Cabe señalar que en algunos lenguajes y frameworks de test, los parámetros de
las funciones de aserción de igualdad se llaman <code>expected</code> y <code>actual</code>, y el
orden en que especificamos los argumentos importa. Sin embargo, en Rust, se
llaman <code>left</code> y <code>right</code>, y el orden en que especificamos el valor que esperamos
y el valor que el código produce no importa. Podríamos escribir la aserción en
este test como <code>assert_eq!(add_two(2), 4)</code>, lo que resultaría en el mismo
mensaje de error que muestra <code>assertion failed: `(left == right)`</code>.</p>
<p>La macro <code>assert_ne!</code> pasará si los dos valores que le proporcionamos no son
iguales. Esta macro es más útil en casos en los que no estamos seguros de cuál
será el valor, pero sabemos que el valor definitivamente <em>no debería</em> ser. Por
ejemplo, si estamos testeando una función que está garantizada de cambiar su
entrada de alguna manera, pero la forma en que la entrada cambia depende del
día de la semana en que ejecutamos nuestros tests, lo mejor sería afirmar que
el output de la función no es igual al input.</p>
<p>En la base, las macros <code>assert_eq!</code> y <code>assert_ne!</code> usan los operadores <code>==</code> y
<code>!=</code>, respectivamente. Cuando las aserciones fallan, estas macros imprimen sus
argumentos usando el formato de debug, lo que significa que los valores que se
comparan deben implementar los traits <code>PartialEq</code> y <code>Debug</code>. Todos los tipos
primitivos y la mayoría de los tipos de la biblioteca estándar implementan
estos traits. Para las estructuras y enumeraciones que definas, deberás
implementar <code>PartialEq</code> para afirmar la igualdad de esos tipos. También
necesitarás implementar <code>Debug</code> para imprimir los valores cuando la aserción
falla. Debido a que ambos traits son derivables, como se mencionó en el
Listado 5-12 en el Capítulo 5, esto suele ser tan sencillo como agregar la
anotación <code>#[derive(PartialEq, Debug)]</code> a la definición de tu estructura o
enumeración. Consulta el Apéndice C,
<a href="appendix-03-derivable-traits.html">“Traits derivables,”</a><!-- ignore -->
para obtener más detalles sobre estos y otros traits derivables.</p>
<h3 id="agregando-mensajes-de-fallo-personalizados"><a class="header" href="#agregando-mensajes-de-fallo-personalizados">Agregando mensajes de fallo personalizados</a></h3>
<p>También puedes agregar un mensaje personalizado a ser impreso con el mensaje de
fallo como argumentos opcionales a las macros <code>assert!</code>, <code>assert_eq!</code> y
<code>assert_ne!</code>. Cualquier argumento especificado después de los argumentos
requeridos se pasa a la macro <code>format!</code> (discutida en el Capítulo 8 en la
sección <a href="ch08-02-strings.html#concatenacion-con-el-operador--o-la-macro-format">“Concatenación con el operador <code>+</code> o la macro
<code>format!</code>”</a><!-- ignore
-->), por lo que puedes pasar una format string que contenga marcadores de
posición <code>{}</code> y valores para ir en esos marcadores de posición. Los mensajes
personalizados son útiles para documentar lo que significa una aserción; cuando
un test falla, tendrás una mejor idea de cuál es el problema con el código.</p>
<p>Por ejemplo, supongamos que tenemos una función que saluda a las personas por
nombre y queremos probar que el nombre que pasamos a la función aparece en el
output:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {name}!&quot;)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}</code></pre>
<p>Las especificaciones para este programa aún no se han acordado, y estamos
bastante seguros de que el texto <code>Hello</code> al comienzo del saludo cambiará.
Decidimos que no queremos tener que actualizar el test cuando cambien los
requisitos, por lo que en lugar de verificar la igualdad exacta con el valor
devuelto de la función <code>greeting</code>, solo afirmaremos que el output contiene el
texto del parámetro de entrada.</p>
<p>Ahora introduciremos un bug en este código cambiando <code>greeting</code> para excluir el
<code>name</code> y veremos cómo se ve el fallo de test predeterminado:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ejecutando este test produce lo siguiente:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains(&quot;Carol&quot;)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>El resultado indica simplemente que la aserción falló y en qué línea se
encuentra. Un mensaje de fallo más útil imprimiría el valor de la función
<code>greeting</code>. Agreguemos un mensaje de fallo personalizado compuesto por un
format string con un marcador de posición reemplazado por el valor real que
obtuvimos de la función <code>greeting</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hello!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Greeting did not contain name, value was `{}`&quot;,
            result
        );
    }
<span class="boring">}</span></code></pre>
<p>Ahora, cuando ejecutemos el test, obtendremos un mensaje de error más
informativo:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Podemos ver el valor que realmente obtuvimos en el output del test, lo que
nos ayudaría a debuggear lo que sucedió en lugar de lo que esperábamos que
sucediera.</p>
<h3 id="comprobando-panics-con-should_panic"><a class="header" href="#comprobando-panics-con-should_panic">Comprobando panics con <code>should_panic</code></a></h3>
<p>Además de verificar los valores de retorno, es importante verificar que nuestro
código maneje las condiciones de error como esperamos. Por ejemplo, considera
el tipo <code>Guess</code> que creamos en el Listado 9-13 del Capítulo 9. Otro código que
usa <code>Guess</code> depende de la garantía de que las instancias de <code>Guess</code> contendrán
solo valores entre 1 y 100. Podemos escribir un test que asegure que al
intentar crear una instancia de <code>Guess</code> con un valor fuera de ese rango, se
produzca un panic.</p>
<p>Lo hacemos agregando el atributo <code>should_panic</code> a nuestra función de test. El
test pasa si el código dentro de la función hace un panic; el test falla si el
código dentro de la función no hace un panic.</p>
<p>El Listado 11-8 muestra un test que verifica que las condiciones de error de
<code>Guess::new</code> sucedan cuando esperamos que sucedan.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {value}.&quot;);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Listing 11-8: Testeando que una condición causará un
<code>panic!</code></span></p>
<p>Colocamos el atributo <code>#[should_panic]</code> después del atributo <code>#[test]</code> y antes
de la función de test a la que se aplica. Veamos el resultado cuando pase este
test:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>¡Se ve bien! Ahora introduzcamos un bug en nuestro código eliminando la
condición de que la función <code>new</code> hará un panic si el valor es mayor que 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be between 1 and 100, got {value}.&quot;);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Cuando ejecutemos el test del Listado 11-8, veremos que fallará:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>No obtenemos un mensaje muy útil en este caso, pero cuando miramos la función
de test, vemos que está anotada con <code>#[should_panic]</code>. El fallo que obtuvimos
significa que el código en la función de test no causó un panic.</p>
<p>Los tests que usan <code>should_panic</code> pueden ser imprecisos. Un test <code>should_panic</code>
pasaría incluso si el test hace un panic por una razón diferente a la que
esperábamos. Para hacer que los tests <code>should_panic</code> sean más precisos,
podemos agregar un parámetro opcional <code>expected</code> al atributo <code>should_panic</code>.
El test harness se asegurará de que el mensaje de error contenga el texto
proporcionado. Por ejemplo, considera el código modificado para <code>Guess</code> en el
Listado 11-9 donde la función <code>new</code> hace un panic con mensajes diferentes
dependiendo de si el valor es demasiado pequeño o demasiado grande.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {value}.&quot;
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {value}.&quot;
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Listing 11-9: Testeando un <code>panic!</code> con un mensaje panic
que contiene un substring específico</span></p>
<p>Este test fallará porque el valor que pusimos en el parámetro <code>expected</code> del
atributo <code>should_panic</code> es un substring del mensaje que genera la función
<code>Guess::new</code>. Podríamos haber especificado todo el mensaje de excepción que
esperamos, que en este caso sería <code>Guess value must be less than or equal to 100, got 200.</code>. Lo que elijas especificar depende de cuánto del mensaje de
excepción es único o dinámico y de cuán preciso quieras que sea tu test. En
este caso, un substring del mensaje de excepción es suficiente para asegurar
que el código en la función de test ejecuta el caso <code>else if value &gt; 100</code>.</p>
<p>Para ver que sucede cuando un test <code>should_panic</code> con un mensaje <code>expected</code>
falla, introduzcamos un bug en nuestro código al intercambiar los cuerpos de
los bloques <code>if value &lt; 1</code> y <code>else if value &gt; 100</code>:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {value}.&quot;
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {value}.&quot;
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Esta vez, cuando ejecutemos el test <code>should_panic</code>, fallará:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>El mensaje de error indica que el test falló con un error como esperábamos, pero
el mensaje de panic no incluyó el string esperado <code>less than or equal to 100</code>. El mensaje de panic que obtuvimos en este caso fue
<code>Guess value must be greater than or equal to 1, got 200.</code>. ¡Ahora podemos
empezar a descubrir dónde está nuestro bug!</p>
<h3 id="usando-resultt-e-en-tests"><a class="header" href="#usando-resultt-e-en-tests">Usando <code>Result&lt;T, E&gt;</code> en Tests</a></h3>
<p>Hasta ahora, todos nuestros tests entran en panic cuando fallan. ¡También podemos
escribir tests que usen <code>Result&lt;T, E&gt;</code>! Aquí está el test del Listado 11-1,
reescrito para usar <code>Result&lt;T, E&gt;</code> y devolver un <code>Err</code> en lugar de hacer un
panic:</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}</code></pre>
<p>La función <code>it_works</code> ahora tiene el tipo de retorno <code>Result&lt;(), String&gt;</code>. En
el cuerpo de la función, en lugar de llamar al macro <code>assert_eq!</code>, devolvemos
<code>Ok(())</code> cuando el test pasa y un <code>Err</code> con un <code>String</code> dentro cuando el test
falla.</p>
<p>Escribir tests que devuelvan un <code>Result&lt;T, E&gt;</code> te permite usar el operador
<code>?</code> en el cuerpo de los tests, lo que puede ser una forma conveniente de
escribir tests que fallarán si cualquier operación dentro de ellos devuelve
una variante <code>Err</code>.</p>
<p>No puedes utilizar la anotación <code>#[should_panic]</code> en tests que usen <code>Result&lt;T, E&gt;</code>. Para asegurar que una operación devuelve una variante <code>Err</code>, <em>no</em> uses el
operador <code>?</code> en el valor <code>Result&lt;T, E&gt;</code>. En su lugar, usa
<code>assert!(value.is_err())</code>.</p>
<p>Ahora que conoces varias formas de escribir tests, veamos qué sucede cuando
ejecutamos nuestros tests y exploremos las diferentes opciones que podemos usar
con <code>cargo test</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="controlando-como-los-tests-son-ejecutados"><a class="header" href="#controlando-como-los-tests-son-ejecutados">Controlando como los tests son ejecutados</a></h2>
<p>Al igual que <code>cargo run</code> compila tu código y luego ejecuta el binario
resultante, <code>cargo test</code> compila tu código en modo de test y ejecuta el binario
resultante. El comportamiento por defecto del binario producido por <code>cargo test</code>
es ejecutar todos los tests en paralelo y capturar la salida generada durante la
ejecución de los tests, previniendo que la salida sea mostrada y haciendo más
fácil leer la salida relacionada con los resultados de los tests. Sin embargo,
puedes especificar opciones de línea de comandos para cambiar este
comportamiento por defecto.</p>
<p>Algunas opciones de línea de comandos van a <code>cargo test</code>, y otras van al binario
de test resultante. Para separar estos dos tipos de argumentos, debes listar los
argumentos que van a <code>cargo test</code> seguidos del separador <code>--</code> y luego los que
van al binario de test. Ejecutar <code>cargo test --help</code> muestra las opciones que
puedes usar con <code>cargo test</code>, y ejecutar <code>cargo test -- --help</code> muestra las
opciones que puedes usar después del separador.</p>
<h3 id="ejecutando-tests-en-paralelo-o-consecutivamente"><a class="header" href="#ejecutando-tests-en-paralelo-o-consecutivamente">Ejecutando tests en paralelo o consecutivamente</a></h3>
<p>Cuando ejecutas múltiples tests, por defecto estos se ejecutan en paralelo
usando hilos, lo que significa que terminan de ejecutarse más rápido y obtienes
feedback más rápido. Debido a que los tests se ejecutan al mismo tiempo, debes
asegurarte que tus tests no dependan entre sí o de cualquier estado compartido,
incluyendo un entorno compartido, como el directorio de trabajo actual o las
variables de entorno.</p>
<p>Por ejemplo, digamos que cada uno de tus tests ejecuta código que crea un
archivo en disco llamado <em>test-output.txt</em> y escribe algunos datos en ese
archivo. Luego cada test lee los datos en ese archivo y aserta que el archivo
contiene un valor particular, el cual es diferente en cada test. Debido a que
los tests se ejecutan al mismo tiempo, un test podría sobreescribir el archivo
en el tiempo entre que otro test escribe y lee el archivo. El segundo test
fallará, no porque el código sea incorrecto, sino porque los tests han
interferido entre sí mientras se ejecutaban en paralelo. Una solución es
asegurarte que cada test escriba en un archivo diferente; otra solución es
ejecutar los tests uno a la vez.</p>
<p>Si no deseas ejecutar los tests en paralelo o si deseas tener un control más
fino sobre el número de hilos usados, puedes enviar la bandera <code>--test-threads</code>
y el número de hilos que deseas usar al binario de test. Echa un vistazo al
siguiente ejemplo:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Establecemos el número de hilos de test a <code>1</code>, indicando al programa que no use
ningún paralelismo. Ejecutar los tests usando un hilo tomará más tiempo que
ejecutarlos en paralelo, pero los tests no interferirán entre sí si comparten
estado.</p>
<h3 id="mostrando-el-output-de-las-funciones"><a class="header" href="#mostrando-el-output-de-las-funciones">Mostrando el Output de las funciones</a></h3>
<p>Por defecto, si un test pasa, la librería de tests de Rust captura cualquier
cosa impresa en la salida estándar. Por ejemplo, si llamamos a <code>println!</code> en un
test y el test pasa, no veremos la salida de <code>println!</code> en la terminal; solo
veremos la línea que indica que el test pasó. Si un test falla, veremos lo que
sea que se haya impreso en la salida estándar junto con el resto del mensaje de
falla.</p>
<p>Como ejemplo, el Listado 11-10 tiene una función tonta que imprime el valor de
su parámetro y retorna 10, así como un test que pasa y un test que falla.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {a}&quot;);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}</code></pre>
<p><span class="caption">Listing 11-10: Tests para una función que llama a
<code>println!</code></span></p>
<p>Cuando ejecutamos estos tests con <code>cargo test</code>, vemos el siguiente output:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 5
 right: 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Nota que en ninguna parte de este output vemos <code>I got the value 4</code>, que es lo
que se imprime cuando el test que pasa se ejecuta. Ese output ha sido capturado.
El output del test que falla, <code>I got the value 8</code>, aparece en la sección del
resumen de tests, que también muestra la causa de la falla del test.</p>
<p>Si queremos ver los valores impresos por los tests que pasan también, podemos
decirle a Rust que muestre el output de los tests exitosos con <code>--show-output</code>.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Cuando ejecutamos los tests en el Listado 11-10 nuevamente con el flag
<code>--show-output</code>, vemos el siguiente output:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 5
 right: 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="ejecutando-un-subset-de-tests-por-nombre"><a class="header" href="#ejecutando-un-subset-de-tests-por-nombre">Ejecutando un Subset de tests por nombre</a></h3>
<p>A veces, ejecutar un conjunto completo de tests puede tomar mucho tiempo. Si
estás trabajando en código en un área particular, podrías querer ejecutar solo
los tests que pertenecen a ese código. Puedes elegir qué tests ejecutar
pasándole a <code>cargo test</code> el nombre o nombres del test(s) que quieres ejecutar
como argumento.</p>
<p>Para demostrar cómo ejecutar un subset de tests, primero crearemos tres tests
para nuestra función <code>add_two</code>, como se muestra en el Listado 11-11, y
elegiremos cuáles ejecutar.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}</code></pre>
<p><span class="caption">Listing 11-11: Tres tests con tres nombres
diferentes</span></p>
<p>Si ejecutamos los tests sin pasar ningún argumento, como vimos anteriormente,
todos los tests se ejecutarán en paralelo:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="ejecutando-un-solo-test"><a class="header" href="#ejecutando-un-solo-test">Ejecutando un solo test</a></h4>
<p>Podemos pasar el nombre de cualquier función de test a <code>cargo test</code> para
ejecutar solo ese test:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Solo se ejecutó el test con el nombre <code>one_hundred</code>; los otros dos tests no
coincidieron con ese nombre. El output de los tests nos indica que tenemos más
tests que no se ejecutaron al mostrar <code>2 filtered out</code> al final.</p>
<p>No podemos especificar los nombres de varios tests de esta manera; solo se usará
el primer valor dado a <code>cargo test</code>. Pero hay una manera de ejecutar varios
tests.</p>
<h4 id="filtrando-para-ejecutar-múltiples-tests"><a class="header" href="#filtrando-para-ejecutar-múltiples-tests">Filtrando para ejecutar múltiples tests</a></h4>
<p>Podemos especificar parte de un nombre de test y cualquier test cuyo nombre
coincida con ese valor se ejecutará. Por ejemplo, como dos de nuestros tests
tienen <code>add</code> en el nombre, podemos ejecutar esos dos ejecutando <code>cargo test add</code>:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>Este comando ejecutó todos los test con <code>add</code> en el nombre y filtró el test
con el nombre <code>one_hundred</code>. También nota que el módulo en el que aparece un
test se convierte en parte del nombre del test, por lo que podemos ejecutar
todos los tests en un módulo filtrando por el nombre del módulo.</p>
<h3 id="ignorando-algunos-tests-a-menos-que-se-soliciten-especificamente"><a class="header" href="#ignorando-algunos-tests-a-menos-que-se-soliciten-especificamente">Ignorando algunos tests a menos que se soliciten especificamente</a></h3>
<p>A veces, algunos tests específicos pueden ser muy lentos para ejecutarse, por lo
que puede que quieras excluirlos en la mayoría de las ejecuciones de
<code>cargo test</code>. En lugar de listar como argumentos todos los tests que quieres
ejecutar, puedes anotar los tests que consumen mucho tiempo usando el atributo
<code>ignore</code> para excluirlos, como se muestra aquí:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}</code></pre>
<p>Después de <code>#[test]</code> agregamos la línea <code>#[ignore]</code> al test que queremos
excluir. Ahora cuando ejecutamos nuestros tests, <code>it_works</code> se ejecuta, pero
<code>expensive_test</code> no:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Esta función <code>expensive_test</code> está listada como <code>ignored</code>. Si queremos ejecutar
solo los tests ignorados, podemos usar <code>cargo test -- -- ignored</code>:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Controlando que tests se ejecutan, puedes asegurarte de que los resultados de
<code>cargo test</code> serán rápidos. Cuando estés en un punto en el que tenga sentido
verificar los resultados de los tests ignorados y tengas tiempo para esperar
los resultados, puedes ejecutar <code>cargo test -- --ignored</code> en su lugar. Si
quieres ejecutar todos los tests, ignorados o no, puedes ejecutar <code>cargo test -- --include-ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="organización-de-los-tests"><a class="header" href="#organización-de-los-tests">Organización de los Tests</a></h2>
<p>Como se mencionó al comienzo del capítulo, el testing es una disciplina, y
diferentes personas usan diferentes terminologías y organización. La comunidad
de Rust piensa en los tests en términos de dos categorías principales: tests de
unidad e integración. Los <em>tests de unidad</em> son pequeños y más enfocados,
probando un módulo a la vez en aislamiento, y pueden probar interfaces privadas.
Los <em>tests de integración</em> son completamente externos a tu biblioteca y usan tu
código de la misma manera que cualquier otro código externo, usando solo la
interfaz pública y potencialmente ejercitando múltiples módulos por test.</p>
<p>Escribir ambos tipos de tests es importante para asegurar que las piezas de tu
biblioteca están haciendo lo que esperas, separada y conjuntamente.</p>
<h3 id="tests-unitarios"><a class="header" href="#tests-unitarios">Tests Unitarios</a></h3>
<p>El propósito de los tests unitarios es probar cada unidad de código en
aislamiento del resto del código para rápidamente identificar donde el código
está y no está funcionando como se espera. Pondrás los tests unitarios en el
directorio <em>src</em> en cada archivo con el código que están testeando. La
convención es crear un módulo llamado <code>tests</code> en cada archivo para contener las
funciones de test y anotar el módulo con <code>cfg(test)</code>.</p>
<h4 id="el-módulo-de-tests-y-cfgtest"><a class="header" href="#el-módulo-de-tests-y-cfgtest">El módulo de tests y <code>#[cfg(test)]</code></a></h4>
<p>La anotación <code>#[cfg(test)]</code> en el módulo de tests le dice a Rust que compile y
ejecute el código de test solo cuando ejecutas <code>cargo test</code>, no cuando ejecutas
<code>cargo build</code>. Esto ahorra tiempo de compilación cuando solo quieres compilar
la biblioteca y ahorra espacio en el resultado compilado porque los tests no
están incluidos. Verás que porque los tests de integración van en un directorio
diferente, no necesitan la anotación <code>#[cfg(test)]</code>. Sin embargo, porque los
tests unitarios van en los mismos archivos que el código, usarás <code>#[cfg(test)]</code>
para especificar que no deberían ser incluidos en el resultado compilado.</p>
<p>Recuerda que cuando generamos el nuevo proyecto <code>adder</code> en la primera sección
de este capítulo, Cargo generó este código para nosotros:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Este código es el módulo de tests generado automáticamente. El atributo <code>cfg</code>
significa <em>configuración</em> y le dice a Rust que el siguiente item debería ser
incluido solo si una cierta opción de configuración está presente. En este
caso, la opción de configuración es <code>test</code>, la cual es provista por Rust para
compilar y ejecutar tests. Al usar el atributo <code>cfg</code>, Cargo compila nuestro
código de test solo si activamente ejecutamos los tests con <code>cargo test</code>. Esto
incluye cualquier función auxiliar que pueda estar dentro de este módulo, en
adición a las funciones anotadas con <code>#[test]</code>.</p>
<h4 id="testeando-funciones-privadas"><a class="header" href="#testeando-funciones-privadas">Testeando Funciones Privadas</a></h4>
<p>Hay debate dentro de la comunidad de testing sobre si las funciones privadas
deberían ser testeables directamente, y otros lenguajes hacen difícil o
imposible testear funciones privadas. Independientemente de la ideología de
testing a la que te adhieras, las reglas de privacidad de Rust te permiten
testear funciones privadas. Considera el código en el Listado 11-12 con la
función privada <code>internal_adder</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}</code></pre>
<p><span class="caption">Listing 11-12: Testeando una función privada</span></p>
<p>Nota que la función <code>internal_adder</code> no está marcada como <code>pub</code>. Los tests son
solo código Rust, y el módulo <code>tests</code> es solo otro módulo. Como discutimos en
la sección <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!--
ignore -->, items en módulos hijos pueden usar los items en sus ancestros. En
este test, traemos todos los items del padre del módulo <code>tests</code> al alcance con
<code>use super::*</code>, y entonces el test puede llamar a <code>internal_adder</code>. Si no
piensas que las funciones privadas deberían ser testeables, no hay nada en Rust
que te obligue a hacerlo.</p>
<h3 id="tests-de-integración"><a class="header" href="#tests-de-integración">Tests de Integración</a></h3>
<p>En Rust, los tests de integración son completamente externos a tu biblioteca.
Usan tu biblioteca de la misma manera que cualquier otro código externo, lo
cual significa que solo pueden llamar a funciones que son parte de la API
pública. Su propósito es probar si muchas partes de tu biblioteca funcionan
correctamente juntas. Unidades de código que funcionan correctamente por su
cuenta podrían tener problemas cuando se integran, así que la cobertura de
tests del código integrado es importante también. Para crear tests de
integración, primero necesitas un directorio <em>tests</em>.</p>
<h4 id="el-directorio-tests"><a class="header" href="#el-directorio-tests">El directorio <em>tests</em></a></h4>
<p>Se crea un directorio llamado tests en el nivel superior del directorio de
nuestro proyecto, al lado de <em>src</em>. Cargo sabe buscar archivos de test de
integración en este directorio. Podemos crear tantos archivos de test como
queramos en este directorio, y Cargo compilará cada archivo como un crate
individual.</p>
<p>Creemos un test de integración. Con el código en el Listado 11-12 aún en el
archivo <em>src/lib.rs</em>, crea un directorio <em>tests</em> y crea un nuevo archivo
llamado <em>tests/integration_test.rs</em>. Tu estructura de directorios debería
verse así:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>Introducimos el código en el Listado 11-13 en el archivo
<em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}</code></pre>
<p><span class="caption">Listing 11-13: Un test de integración de una función en el
crate <code>adder</code></span></p>
<p>Cada archivo en el directorio <em>tests</em> es un crate separado, así que necesitamos
importar nuestra biblioteca en el scope de cada crate de test. Por esa razón,
agregamos <code>use adder::add_two</code> al inicio del código, lo cual no necesitamos en 
los tests unitarios.</p>
<p>No es necesario anotar ningún código en <em>tests/integration_test.rs</em> con
<code>#[cfg(test)]</code>. Cargo trata al directorio <code>tests</code> de manera especial y compila
los archivos en este directorio solo cuando ejecutamos <code>cargo test</code>. Ejecuta
<code>cargo test</code> ahora:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Las tres secciones de output incluyen los tests unitarios, el test de
integración y los tests de documentación. Nota que si algún test en una
sección falla, las siguientes secciones no serán ejecutadas. Por ejemplo, si
falla un test unitario, no habrá ningún output para los tests de integración y
de documentación porque esos tests solo serán ejecutados si todos los tests
unitarios pasan.</p>
<p>La primera sección es para los tests unitarios es la misma que hemos visto:
una línea para cada test unitario (uno llamado <code>internal</code> que agregamos en el
Listado 11-12) y luego una línea de resumen para los tests unitarios.</p>
<p>Los tests de integración comienzan con la línea
<code>Running tests/integration_test.rs</code>. Luego, hay una línea para cada función
de test en ese test de integración y una línea de resumen para los tests de
integración justo antes de que comience la sección <code>Doc-tests adder</code>.</p>
<p>Cada archivo de test de integración tiene su propia sección, así que si
agregamos más archivos en el directorio <em>tests</em>, habrá más secciones de tests
de integración.</p>
<p>Todavía podemos ejecutar una función de test de integración en particular
especificando el nombre de la función de test como argumento de <code>cargo test</code>.
Para ejecutar todos los tests en un archivo de test de integración en
particular, usa el argumento <code>--test</code> de <code>cargo test</code> seguido del nombre del
archivo:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Este comando ejecuta solo los tests en el archivo <em>tests/integration_test.rs</em>.</p>
<h4 id="submódulos-en-tests-de-integración"><a class="header" href="#submódulos-en-tests-de-integración">Submódulos en Tests de Integración</a></h4>
<p>En la medida en que se agregan más tests de integración, es posible que
quieras crear más archivos en el directorio tests para ayudar a organizarlas;
por ejemplo, puedes agrupar las funciones de test por la funcionalidad que
están probando. Como se mencionó anteriormente, cada archivo en el directorio
<em>tests</em> es compilado como un crate separado, lo cual es útil para crear
scopes separados para imitar más de cerca la manera en que los usuarios finales
usarán tu crate. Sin embargo, esto significa que los archivos en el directorio
<em>tests</em> no comparten el mismo comportamiento que los archivos en <em>src</em>, como
aprendiste en el Capítulo 7 sobre cómo separar el código en módulos y archivos.</p>
<p>La diferencia en el comportamiento de los archivos en <em>src</em> y <em>tests</em> es más
notable cuando tienes un conjunto de funciones de ayuda para usar en múltiples
archivos de test de integración y tratas de seguir los pasos en la sección</p>
<!--ignore[“Separando Módulos en Diferentes 
Archivos”][separating-modules-into-files]--> del Capítulo 7 para extraerlas
<p>en un módulo común. Por ejemplo, si creamos <em>tests/common.rs</em> y colocamos una
función llamada <code>setup</code> en él, podemos agregar algo de código a <code>setup</code> que
queremos llamar desde múltiples funciones de test en múltiples archivos de
test:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}</code></pre>
<p>Cuando volvemos a ejecutar los tests, veremos una sección en el output de los
tests para el archivo <em>common.rs</em>, aunque este archivo no contiene ninguna
función de test ni hemos llamada a la función <code>setup</code> desde ningún lado:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Tener <code>common</code> apareciendo en los resultados de los tests con <code>running 0 tests</code>
mostrado para él no es lo que queríamos. Solo queríamos compartir algo de código
con los otros archivos de test de integración.</p>
<p>Para evitar que <code>common</code> aparezca en el output de los tests, en lugar de crear
<em>tests/common.rs</em>, crearemos <em>tests/common/mod.rs</em>. El directorio del proyecto
ahora se ve así:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>Esta es la convención de nomenclatura anterior que Rust también entiende y que
mencionamos en la sección <a href="ch07-05-separating-modules-into-different-files.html#rutas-alternativas-de-archivos">“Rutas de Archivos Alternativas”</a> del
Capítulo 7. Nombrar el archivo de esta manera le dice a Rust que no trate al
módulo <code>common</code> como un archivo de test de integración. Cuando movemos el código
de la función <code>setup</code> a <em>tests/common/mod.rs</em> y borramos el archivo
<em>tests/common.rs</em>, la sección en el output de los tests ya no aparecerá. Los
archivos en subdirectorios del directorio <em>tests</em> no son compilados como crates
separados ni tienen secciones en el output de los tests.</p>
<p>Después de haber creado <em>tests/common/mod.rs</em>, podemos usarlo desde cualquier
archivo de test de integración como un módulo. Aquí hay un ejemplo de llamar a
la función <code>setup</code> desde el test <code>it_adds_two</code> en <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}</code></pre>
<p>Nota que la declaración <code>mod common;</code> es la misma que la declaración de módulo
que demostramos en el Listado 7-21. Luego, en la función de test, podemos llamar
a la función <code>common::setup()</code>.</p>
<h4 id="tests-de-integración-para-crates-binarios"><a class="header" href="#tests-de-integración-para-crates-binarios">Tests de Integración para Crates Binarios</a></h4>
<p>Si nuestro proyecto es un crate binario que solo contiene un archivo
<em>src/main.rs</em> y no tiene un archivo <em>src/lib.rs</em>, no podemos crear tests de
integración en el directorio <em>tests</em> y traer funciones definidas en el archivo
<em>src/main.rs</em> al scope con una declaración <code>use</code>. Solo los crates de librería
exponen funciones que otros crates pueden usar; los crates binarios están
destinados a ser ejecutados por sí mismos.</p>
<p>Esta es una de las razones por las que los proyectos Rust que proveen un binario
tienen un archivo <em>src/main.rs</em> que llama a la lógica que vive en el archivo
<em>src/lib.rs</em>. Usando esa estructura, los tests de integración <em>pueden</em> probar el
crate de la librería con <code>use</code> para hacer que la funcionalidad importante esté
disponible. Si la funcionalidad importante funciona, la pequeña cantidad de
código en el archivo <em>src/main.rs</em> también funcionará, y ese pequeño código no
necesita ser testeado.</p>
<h2 id="resumen-10"><a class="header" href="#resumen-10">Resumen</a></h2>
<p>Las características de testing de Rust proveen una manera de especificar cómo el
código debería funcionar para asegurarse de que continúe funcionando como
esperas, incluso mientras haces cambios. Los tests unitarios ejercitan
diferentes partes de una librería por separado y pueden testear detalles de
implementación privados. Los tests de integración chequean que muchas partes de
la librería funcionen juntas correctamente, y usan la API pública de la
librería para testear el código de la misma manera que el código externo lo
usará. Aunque el sistema de tipos y las reglas de ownership de Rust ayudan a
prevenir algunos tipos de bugs, los tests son todavía importantes para reducir
bugs de lógica que tienen que ver con cómo se espera que tu código se comporte.</p>
<p>¡Combinemos el conocimiento que aprendiste en este capítulo y en capítulos
anteriores para trabajar en un proyecto!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="un-proyecto-de-io-construyendo-un-programa-de-línea-de-comandos"><a class="header" href="#un-proyecto-de-io-construyendo-un-programa-de-línea-de-comandos">Un proyecto de I/O: Construyendo un programa de línea de comandos</a></h1>
<p>Este capítulo es un resumen de las muchas habilidades que has aprendido hasta
ahora y una exploración de algunas características más de la biblioteca estándar.
Construiremos una herramienta de línea de comandos que interactúa con la entrada
y salida de archivos y de línea de comandos para practicar algunos de los
conceptos de Rust que ahora tienes bajo el cinturón.</p>
<p>La velocidad, la seguridad, la salida binaria única y el soporte multiplataforma
de Rust hacen que sea un lenguaje ideal para crear herramientas de línea de
comandos, así que para nuestro proyecto, haremos nuestra propia versión de la
herramienta de búsqueda clásica de la línea de comandos <code>grep</code> (<strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). En el caso de uso más
simple, <code>grep</code> busca un archivo especificado para una cadena especificada.
Para ello, <code>grep</code> toma como argumentos una ruta de archivo y una cadena. Luego
lee el archivo, encuentra las líneas en ese archivo que contienen el argumento
de cadena y las imprime.</p>
<p>En el camino, mostraremos cómo hacer que nuestra herramienta de línea de comandos
use las características del terminal que muchas otras herramientas de línea de
comandos usan. Leeremos el valor de una variable de entorno para permitir que el
usuario configure el comportamiento de nuestra herramienta. También imprimiremos
mensajes de error a la consola de error estándar (<code>stderr</code>) en lugar de la
salida estándar (<code>stdout</code>), para que, por ejemplo, el usuario pueda redirigir
la salida exitosa a un archivo y seguir viendo los mensajes de error en la
pantalla.</p>
<p>Andrew Gallant, miembro de la comunidad de Rust, ya ha creado una versión
completamente funcional y muy rápida de <code>grep</code>, llamada <code>ripgrep</code>. En
comparación, nuestra versión será bastante simple, pero este capítulo te dará
algunos de los conocimientos básicos que necesitas para entender un proyecto
del mundo real como <code>ripgrep</code>.</p>
<p>Nuestro proyecto <code>grep</code> combinará una serie de conceptos que has aprendido
hasta ahora:</p>
<ul>
<li>Organizar código (usando lo que aprendiste sobre módulos en
<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Capítulo 7</a><!-- ignore -->)</li>
<li>Uso de vectores y strings (colecciones, <a href="ch08-00-common-collections.html">Capítulo 8</a><!-- ignore -->)</li>
<li>Manejo de errores (<a href="ch09-00-error-handling.html">Capítulo 9</a><!-- ignore -->)</li>
<li>Uso de traits y lifetimes cuando corresponda (<a href="ch10-00-generics.html">Capítulo 10</a><!-- ignore
  -->)</li>
<li>Escribiendo tests (<a href="ch11-00-testing.html">Capítulo 11</a><!-- ignore -->)</li>
</ul>
<p>También presentaremos brevemente los closures, iterators, y trait objects, que
los capítulos <a href="ch13-00-functional-features.html">13</a><!-- ignore --> y <a href="ch17-00-oop.html">17</a><!-- ignore --> cubrirán en
detalle.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="aceptando-argumentos-de-línea-de-comandos"><a class="header" href="#aceptando-argumentos-de-línea-de-comandos">Aceptando argumentos de línea de comandos</a></h2>
<p>Vamos a crear un nuevo proyecto con, como siempre, <code>cargo new</code>. Llamaremos a
nuestro proyecto <code>minigrep</code> para distinguirlo de la herramienta <code>grep</code> que
puede que ya tengas en tu sistema.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>La primera tarea es hacer que <code>minigrep</code> acepte sus dos argumentos de línea de
comandos: la ruta del archivo y una cadena para buscar. Es decir, queremos
poder ejecutar nuestro programa con <code>cargo run</code>, dos guiones para indicar que
los siguientes argumentos son para nuestro programa en lugar de para <code>cargo</code>,
una cadena para buscar y una ruta a un archivo para buscar, así:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>En este momento, el programa generado por <code>cargo new</code> no puede procesar los
argumentos que le damos. Algunas bibliotecas existentes en
<a href="https://crates.io/">crates.io</a> pueden ayudar a escribir un programa que
acepte argumentos de línea de comandos, pero como estás aprendiendo este
concepto, implementemos esta capacidad nosotros mismos.</p>
<h3 id="leyendo-los-valores-de-los-argumentos"><a class="header" href="#leyendo-los-valores-de-los-argumentos">Leyendo los valores de los argumentos</a></h3>
<p>Para permitir que <code>minigrep</code> lea los valores de los argumentos de línea de
comandos que le pasamos, necesitaremos la función <code>std::env::args</code> proporcionada
en la biblioteca estándar de Rust. Esta función devuelve un iterador de los
argumentos de línea de comandos pasados a <code>minigrep</code>. Cubriremos los iteradores
completamente en <a href="ch13-00-functional-features.html">el capítulo 13</a><!-- ignore -->. Por ahora, solo
necesitas saber dos detalles sobre los iteradores: los iteradores producen una
serie de valores, y podemos llamar al método <code>collect</code> en un iterador para
convertirlo en una colección, como un vector, que contiene todos los elementos
que el iterador produce.</p>
<p>El código en el Listado 12-1 permite que tu programa <code>minigrep</code> lea cualquier
argumento de línea de comandos que se le pase y luego recoja los valores en un
vector.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<p><span class="caption">Listing 12-1: Recopilando los argumentos de línea de
comandos en un vector e imprimiéndolos</span></p>
<p>Primero, traemos el módulo <code>std::env</code> al alcance con una declaración <code>use</code> para
que podamos usar su función <code>args</code>. Ten en cuenta que la función
<code>std::env::args</code> está anidada en dos niveles de módulos. Como discutimos en
<a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creando-rutas-de-use-idiomaticas">el capítulo 7</a><!-- ignore -->, en los casos en que la
función deseada está anidada en más de un módulo, hemos elegido traer el módulo
padre al alcance en lugar de la función. Al hacerlo, podemos usar fácilmente
otras funciones de <code>std::env</code>. También es menos ambiguo que agregar
<code>use std::env::args</code> y luego llamar a la función con solo <code>args</code>, porque
<code>args</code> podría confundirse fácilmente con una función definida en el módulo
actual.</p>
<blockquote>
<h3 id="la-función-args-y-unicode-inválido"><a class="header" href="#la-función-args-y-unicode-inválido">La función <code>args</code> y Unicode inválido</a></h3>
<p>Ten en cuenta que <code>std::env::args</code> lanzará un pánico si algún argumento
contiene Unicode inválido. Si tu programa necesita aceptar argumentos que
contengan Unicode inválido, usa <code>std::env::args_os</code> en su lugar. Esa función
devuelve un iterator que produce valores <code>OsString</code> en lugar de valores
<code>String</code>. Hemos elegido usar <code>std::env::args</code> aquí por simplicidad, porque
los valores <code>OsString</code> difieren según la plataforma y son más complejos de
trabajar que los valores <code>String</code>.</p>
</blockquote>
<p>En la primera línea de <code>main</code>, llamamos a <code>env::args</code> y usamos inmediatamente
<code>collect</code> para convertir el iterator en un vector que contiene todos los valores
producidos por el iterator. Podemos usar la función <code>collect</code> para crear muchos
tipos de colecciones, por lo que anotamos explícitamente el tipo de <code>args</code> para
especificar que queremos un vector de strings. Aunque rara vez necesitamos
anotar tipos en Rust, <code>collect</code> es una función que a menudo necesitas anotar
porque Rust no puede inferir el tipo de colección que deseas.</p>
<p>Finalmente, imprimimos el vector usando la macro debug. Intentemos ejecutar el
código primero sin argumentos y luego con dos argumentos:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    &quot;target/debug/minigrep&quot;,
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    &quot;target/debug/minigrep&quot;,
    &quot;needle&quot;,
    &quot;haystack&quot;,
]
</code></pre>
<p>EL primer valor en el vector es <code>&quot;target/debug/minigrep&quot;</code>, que es el nombre de
nuestro binario. Esto coincide con el comportamiento de la lista de argumentos
en C, lo que permite que los programas usen el nombre por el que fueron
invocados en su ejecución. A menudo es conveniente tener acceso al nombre del
programa en caso de que desees imprimirlo en mensajes o cambiar el
comportamiento del programa según el alias de la línea de comandos que se usó
para invocar el programa. Pero para los propósitos de este capítulo, lo
ignoraremos y solo guardaremos los dos argumentos que necesitamos.</p>
<h3 id="guardando-los-valores-de-los-argumentos-en-variables"><a class="header" href="#guardando-los-valores-de-los-argumentos-en-variables">Guardando los valores de los argumentos en variables</a></h3>
<p>El programa actualmente puede acceder a los valores especificados como
argumentos de línea de comandos. Ahora necesitamos guardar los valores de los
dos argumentos en variables para que podamos usar los valores en el resto del
programa. Hacemos eso en el Listado 12-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!(&quot;Searching for {query}&quot;);
    println!(&quot;In file {file_path}&quot;);
}</code></pre>
<p><span class="caption">Listing 12-2: Creando variables para contener el argumento
de consulta y la ruta de archivo</span></p>
<p>Como vimos cuando imprimimos en el vector, el nombre del programa ocupa el
primer valor del vector en <code>args[0]</code>, por lo que estamos comenzando a leer los
argumentos en el índice <code>1</code>. El primer argumento <code>minigrep</code> que toma es la
cadena que estamos buscando, por lo que ponemos una referencia al primer
argumento en la variable <code>query</code>. El segundo argumento será la ruta del archivo,
por lo que ponemos una referencia al segundo argumento en la variable
<code>file_path</code>.</p>
<p>Temporalmente, imprimimos los valores de estas variables para demostrar que el
código está funcionando como pretendemos. Ejecutemos el programa nuevamente con
los argumentos <code>test</code> y <code>sample.txt</code>:</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>¡Genial, el programa está funcionando! Los valores de los argumentos que
necesitamos se están guardando en las variables correctas. Más adelante
agregaremos un manejo de errores para tratar ciertas situaciones erróneas
potenciales, como cuando el usuario no proporciona argumentos; por ahora,
ignoraremos esa situación y trabajaremos en agregar capacidades de lectura de
archivos en su lugar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="leyendo-un-archivo"><a class="header" href="#leyendo-un-archivo">Leyendo un archivo</a></h2>
<p>Ahora agregaremos funcionalidad para leer el archivo especificado en el 
argumento <code>file_path</code>. Primero, necesitamos un archivo de muestra para probarlo:
¡usaremos un archivo con una pequeña cantidad de texto en varias líneas con 
algunas palabras repetidas! ¡El Listado 12-3 tiene un poema de Emily Dickinson 
que funcionará bien! Cree un archivo llamado <em>poem.txt</em> en el nivel raíz de su
proyecto e ingrese el poema &quot;¡Soy nadie! ¿Quién eres tú?&quot;</p>
<p><span class="filename">Filename: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listing 12-3: Un poema de Emily Dickinson sirve como
buen caso de test</span></p>
<p>Con el texto en su lugar, edite <em>src/main.rs</em> y agregue código para leer el
archivo, como se muestra en el Listado 12-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {query}&quot;);
</span>    println!(&quot;In file {file_path}&quot;);

    let contents = fs::read_to_string(file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    println!(&quot;With text:\n{contents}&quot;);
}</code></pre>
<p><span class="caption">Listing 12-4: Leyendo el contenido del archivo 
especificado por el segundo argumento</span></p>
<p>Primero, importamos la parte relevante de la biblioteca estándar con una
sentencia <code>use</code>: necesitamos <code>std::fs</code> para manejar archivos.</p>
<p>En <code>main</code>, la nueva sentencia <code>fs::read_to_string</code> toma el <code>file_path</code>, abre
ese archivo y devuelve un <code>std::io::Result&lt;String&gt;</code> del contenido del archivo.</p>
<p>Luego, nuevamente agregamos una declaración <code>println!</code> temporal que imprime el
valor de <code>contents</code> después de que se lee el archivo, para que podamos verificar
que el programa está funcionando hasta ahora.</p>
<p>Ejecutemos este código con cualquier string como primer argumento de la línea de
comandos (porque aún no hemos implementado la parte de búsqueda) y el archivo
<em>poem.txt</em> como segundo argumento:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>¡Genial! El código leyó el archivo y luego imprimió el contenido del archivo.
Pero el código tiene algunas fallas. En este momento, la función <code>main</code> tiene
múltiples responsabilidades: en general, las funciones son más claras y más
fáciles de mantener si cada función es responsable de una sola idea. El otro
problema es que no estamos manejando los errores tan bien como podríamos. El
programa todavía es pequeño, por lo que estas fallas no son un gran problema,
pero a medida que el programa crece, será más difícil corregirlos de manera
limpia. Es una buena práctica comenzar a refactorizar desde el principio al
desarrollar un programa, porque es mucho más fácil refactorizar cantidades
menores de código. Haremos eso a continuación.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refactorizando-para-mejorar-la-modularidad-y-el-manejo-de-errores"><a class="header" href="#refactorizando-para-mejorar-la-modularidad-y-el-manejo-de-errores">Refactorizando para mejorar la modularidad y el manejo de errores</a></h2>
<p>Para mejorar nuestro programa, solucionaremos cuatro problemas que tienen que
ver con la estructura del programa y cómo maneja los errores potenciales. En
primer lugar, nuestra función <code>main</code> ahora realiza dos tareas: analiza los
argumentos y lee los archivos. A medida que nuestro programa crece, el número
de tareas separadas que maneja la función <code>main</code> aumentará. A medida que una
función adquiere responsabilidades, se vuelve más difícil de razonar, más
difícil de probar y más difícil de cambiar sin romper una de sus partes. Es
mejor separar la funcionalidad para que cada función sea responsable de una
tarea.</p>
<p>Este problema también está relacionado con el segundo problema: aunque <code>query</code>
y <code>file_path</code> son variables de configuración para nuestro programa, variables
como <code>contents</code> se utilizan para realizar la lógica del programa. Cuanto más
largo sea <code>main</code>, más variables necesitaremos para traer al alcance; Cuantas
más variables tengamos en el alcance, más difícil será realizar un seguimiento
del propósito de cada una. Es mejor agrupar las variables de configuración en
una estructura para que su propósito quede claro.</p>
<p>El tercer problema es que hemos usado <code>expect</code> para imprimir un mensaje de
error cuando falla la lectura del archivo, pero el mensaje de error solo
imprime <code>Should have been able to read the file</code>. La lectura de un archivo
puede fallar de varias maneras: por ejemplo, el archivo podría faltar, o
podríamos no tener permiso para abrirlo. En este momento, independientemente
de la situación, imprimiríamos el mismo mensaje de error para todo, ¡lo que no
le daría al usuario ninguna información!</p>
<p>Cuarto, usamos <code>expect</code> repetidamente para manejar un error, y si el
usuario ejecuta nuestro programa sin especificar suficientes argumentos,
obtendrán un error de <code>índice fuera de límites</code> de Rust que no explica
claramente el problema. Sería mejor si todo el código de manejo de errores
estuviera en un solo lugar para que los futuros mantenedores tuvieran un solo
lugar para consultar el código si la lógica de manejo de errores necesitaba
cambiar. Tener todo el código de manejo de errores en un solo lugar también
asegurará que estamos imprimiendo mensajes que serán significativos para
nuestros usuarios finales.</p>
<p>Abordemos estos cuatro problemas refactorizando nuestro proyecto.</p>
<h3 id="separacion-de-preocupaciones-para-proyectos-binarios"><a class="header" href="#separacion-de-preocupaciones-para-proyectos-binarios">Separacion de preocupaciones para proyectos binarios</a></h3>
<p>El problema organizativo de asignar la responsabilidad de múltiples tareas a la
función <code>main</code> es común a muchos proyectos binarios. Como resultado, la
comunidad de Rust ha desarrollado pautas para dividir las preocupaciones
separadas de un programa binario cuando <code>main</code> comienza a crecer. Este proceso
tiene los siguientes pasos:</p>
<ul>
<li>Divide tu programa en un <em>main.rs</em> y un <em>lib.rs</em> y mueve la lógica de tu
programa a <em>lib.rs</em>.</li>
<li>Mientras la lógica de análisis de línea de comandos sea pequeña, puede
permanecer en <em>main.rs</em>.</li>
<li>Cuando la lógica de análisis de línea de comandos comience a complicarse,
extráela de <em>main.rs</em> y muévala a <em>lib.rs</em>.</li>
</ul>
<p>Las responsabilidades que quedan en la función <code>main</code> después de este proceso
deberían limitarse a lo siguiente:</p>
<ul>
<li>Llamar a la lógica de análisis de línea de comandos con los valores de
argumento</li>
<li>Configuración de cualquier otra configuración</li>
<li>Llamando a una función <code>run</code> en <em>lib.rs</em></li>
<li>Manejo del error si <code>run</code> devuelve un error</li>
</ul>
<p>Este patrón se trata de separar las preocupaciones: <em>main.rs</em> maneja la
ejecución del programa, y <em>lib.rs</em> maneja toda la lógica de la tarea en
cuestión. Debido a que no puede probar la función <code>main</code> directamente, esta
estructura le permite probar toda la lógica de su programa moviéndola a
funciones en <em>lib.rs</em>. El código que permanece en <em>main.rs</em> será lo
suficientemente pequeño como para verificar su corrección leyéndolo. Rehagamos
nuestro programa siguiendo este proceso.</p>
<h4 id="extracción-del-parser-de-argumentos"><a class="header" href="#extracción-del-parser-de-argumentos">Extracción del parser de argumentos</a></h4>
<p>Extraeremos la funcionalidad para analizar los argumentos en una función que
<code>main</code> llamará para prepararse para mover la lógica de análisis de línea de
comandos a <em>src/lib.rs</em>. La lista 12-5 muestra el nuevo inicio de <code>main</code> que
llama a una nueva función <code>parse_config</code>, que definiremos en <em>src/main.rs</em> por
el momento.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {query}&quot;);
</span><span class="boring">    println!(&quot;In file {file_path}&quot;);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<p><span class="caption">Listing 12-5: Extrayendo una función <code>parse_config</code> de
<code>main</code></span></p>
<p>En este cambio, aún estamos recopilando los argumentos de la línea de comandos
en un vector, pero en lugar de asignar el valor del argumento en el índice 1 a
la variable <code>query</code> y el valor del argumento en el índice 2 a la variable
<code>file_path</code> dentro de la función <code>main</code>, pasamos todo el vector a la función
<code>parse_config</code>. La función <code>parse_config</code> luego tiene la lógica que determina
qué argumento va en qué variable y pasa los valores de vuelta a <code>main</code>. Todavía
creamos las variables <code>query</code> y <code>file_path</code> en <code>main</code>, pero <code>main</code> ya no tiene
la responsabilidad de determinar cómo se corresponden los argumentos de la
línea de comandos y las variables.</p>
<p>Esta reorganización puede parecer excesiva para nuestro pequeño programa, pero
estamos refactorizando en pequeños pasos incrementales. Después de hacer este
cambio, ejecute el programa nuevamente para verificar que el análisis de
argumentos aún funcione. Es bueno verificar su progreso con frecuencia, para
ayudar a identificar la causa de los problemas cuando ocurren.</p>
<h4 id="agrupación-de-valores-de-configuración"><a class="header" href="#agrupación-de-valores-de-configuración">Agrupación de valores de configuración</a></h4>
<p>Podemos dar otro pequeño paso para mejorar aún más la función <code>parse_config</code>.
En este momento, estamos devolviendo una tupla, pero luego rompemos esa tupla
en partes individuales nuevamente. Esto es una señal de que tal vez no
tenemos la abstracción correcta todavía.</p>
<p>Otro indicador que muestra que hay margen de mejora es la parte <code>config</code> de
<code>parse_config</code>, que implica que los dos valores que devolvemos están
relacionados y ambos son parte de un valor de configuración. Actualmente, no
estamos transmitiendo este significado en el struct de los datos que no sea
agrupar los dos valores en una tupla; en su lugar, pondremos los dos valores en
un struct y daremos a cada uno de los campos del struct un nombre significativo.
Hacerlo hará que sea más fácil para los futuros mantenedores de este código
comprender cómo se relacionan los diferentes valores entre sí y cuál es su
propósito.</p>
<p>Listing 12-6 muestra las mejoras a la función <code>parse_config</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<p><span class="caption">Listing 12-6: Refactorizando <code>parse_config</code> para que
devuelva una instancia de un struct <code>Config</code></span></p>
<p>Hemos agregado un struct llamado <code>Config</code> definido para tener campos llamados
<code>query</code> y <code>file_path</code>. La firma de <code>parse_config</code> ahora índica que devuelve un
valor <code>Config</code>. En el cuerpo de <code>parse_config</code>, donde solíamos devolver
rebanadas de cadena que hacen referencia a valores <code>String</code> en <code>args</code>, ahora
definimos <code>Config</code> para contener valores <code>String</code> de propiedad. La variable
<code>args</code> en <code>main</code> es el propietario de los valores de argumento y solo permite
que la función <code>parse_config</code> los pida prestados, lo que significa que
violaríamos las reglas de préstamo de Rust si <code>Config</code> intentara tomar
posesión de los valores en <code>args</code>.</p>
<p>Hay varias formas de administrar los datos de <code>String</code>; la más fácil, aunque
algo ineficiente, es llamar al método <code>clone</code> en los valores. Esto hará una
copia completa de los datos para que la instancia de <code>Config</code> posea, lo que
toma más tiempo y memoria que almacenar una referencia a los datos de string.
Sin embargo, clonar los datos también hace que nuestro código sea muy
sencillo porque no tenemos que administrar los lifetimes de las referencias; en
estas circunstancias, renunciar a un poco de rendimiento para ganar simplicidad
es un intercambio válido.</p>
<blockquote>
<h3 id="los-intercambios-de-usar-clone"><a class="header" href="#los-intercambios-de-usar-clone">Los intercambios de usar <code>clone</code></a></h3>
<p>Hay una tendencia entre muchos Rustaceans a evitar usar <code>clone</code> para
solucionar problemas de propiedad debido a su costo de tiempo de ejecución.
En <a href="ch13-00-functional-features.html">el capítulo 13</a><!-- ignore -->, aprenderá a usar métodos más
eficientes en este tipo de situaciones. Pero por ahora, está bien copiar
algunas cadenas para seguir progresando porque solo harás estas copias una
vez y tu ruta de archivo y cadena de consulta son muy pequeñas. Es mejor
tener un programa que funcione un poco ineficiente que intentar
hiperoptimizar el código en tu primer paso. A medida que adquieras más
experiencia con Rust, será más fácil comenzar con la solución más eficiente,
, pero por ahora, es perfectamente aceptable llamar a <code>clone</code>.</p>
</blockquote>
<p>Hemos actualizado <code>main</code> para que coloque la instancia de <code>Config</code> devuelta por
<code>parse_config</code> en una variable llamada <code>config</code>, y hemos actualizado el código
que anteriormente usaba las variables separadas <code>query</code> y <code>file_path</code> para que
ahora use los campos en el struct <code>Config</code> en su lugar.</p>
<p>Ahora nuestro código transmite más claramente que <code>query</code> y <code>file_path</code> están
relacionados y que su propósito es configurar cómo funcionará el programa.
Cualquier código que use estos valores sabe que debe buscarlos en la instancia
<code>config</code> en los campos nombrados por su propósito.</p>
<h4 id="creando-un-constructor-para-config"><a class="header" href="#creando-un-constructor-para-config">Creando un constructor para <code>Config</code></a></h4>
<p>Hasta ahora, hemos extraído la lógica responsable de analizar los argumentos de
la línea de comandos de <code>main</code> y la hemos colocado en la función <code>parse_config</code>.
Hacerlo nos ayudó a ver que los valores <code>query</code> y <code>file_path</code> estaban
relacionados y que esa relación debería transmitirse en nuestro código. Luego
agregamos un struct <code>Config</code> para nombrar el propósito relacionado de <code>query</code>
y <code>file_path</code> y poder devolver los nombres de los valores como nombres de campo
de struct desde la función <code>parse_config</code>.</p>
<p>Así que ahora el propósito de la función <code>parse_config</code> es crear una instancia
de <code>Config</code>, podemos cambiar <code>parse_config</code> de una función normal a una función
llama <code>new</code> que es asociada con <code>Config</code>. que esté asociada con el struct
<code>Config</code>. Haciendo este cambio, el código será más idiomático. Podemos crear
instancias de tipos en la biblioteca estándar, como <code>String</code>, llamando a
<code>String::new</code>. De manera similar, al cambiar <code>parse_config</code> a una función
asociada con <code>Config</code>, podremos crear instancias de <code>Config</code> llamando a
<code>Config::new</code>. El listado 12-7 muestra los cambios que debemos hacer.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<p><span class="caption">Listing 12-7: Cambiando <code>parse_config</code> a
<code>Config::new</code></span></p>
<p>Hemos actualizado <code>main</code> donde estábamos llamando a <code>parse_config</code> para que en
su lugar llame a <code>Config::new</code>. Hemos cambiado el nombre de <code>parse_config</code> a
<code>new</code> y lo hemos movido dentro de un bloque <code>impl</code>, que asocia la función <code>new</code>
con <code>Config</code>. Intenta compilar este código nuevamente para asegurarte de que
funciona.</p>
<h3 id="arreglando-el-manejo-de-errores"><a class="header" href="#arreglando-el-manejo-de-errores">Arreglando el manejo de errores</a></h3>
<p>Ahora trabajaremos en la corrección de nuestro manejo de errores. Recuerda que
intentar acceder a los valores en el vector <code>args</code> en el índice 1 o el índice
2 hará que el programa entre en pánico si el vector contiene menos de tres
elementos. Intenta ejecutar el programa sin ningún argumento; se verá así:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>La línea <code>index out of bounds: the len is 1 but the index is 1</code> es un mensaje
de error destinado a los programadores. No ayudará a nuestros usuarios finales
a comprender lo que deben hacer en su lugar. Arreglemos eso ahora.</p>
<h4 id="mejorando-el-mensaje-de-error"><a class="header" href="#mejorando-el-mensaje-de-error">Mejorando el mensaje de error</a></h4>
<p>En el Listado 12-8, agregamos una verificación en la función <code>new</code> que
verificará que el slice sea lo suficientemente largo antes de acceder al índice
1 y 2. Si el slice no es lo suficientemente largo, el programa entra en pánico
y muestra un mensaje de error mejor.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;not enough arguments&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-8: Agregando una verificación para el número de
argumentos</span></p>
<p>Este código es similar a <a href="ch09-03-to-panic-or-not-to-panic.html#creacion-de-tipos-personalizados-para-validacion">la función <code>Guess::new</code> que escribimos en el Listado
9-13</a><!-- ignore -->, donde llamamos a <code>panic!</code> cuando el
argumento <code>value</code> estaba fuera del rango de valores válidos. En lugar de
verificar un rango de valores aquí, estamos verificando que la longitud de
<code>args</code> sea al menos 3 y el resto de la función puede operar bajo la suposición
de que esta condición se ha cumplido. Si <code>args</code> tiene menos de tres elementos,
esta condición será verdadera y llamaremos a la macro <code>panic!</code> para finalizar
el programa inmediatamente.</p>
<p>Con estas pocas líneas de código adicionales en <code>new</code>, ejecutemos el programa
sin ningún argumento nuevamente para ver cómo se ve el error ahora:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Este output es mejor: ahora tenemos un mensaje de error razonable. Sin embargo,
también tenemos información superflua que no queremos dar a nuestros usuarios.
Quizás usar la técnica que usamos en el Listado 9-13 no es la mejor para usar
aquí: una llamada a <code>panic!</code> es más apropiada para un problema de programación
que para un problema de uso,
<a href="ch09-03-to-panic-or-not-to-panic.html#pautas-para-el-manejo-de-errores">como se discutió en el Capítulo 9</a><!-- ignore -->.
En su lugar, usaremos la otra técnica que aprendiste en el Capítulo 9:
<a href="ch09-02-recoverable-errors-with-result.html">devolver un <code>Result</code></a><!-- ignore --> que indique el éxito o un
error.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="devolver-un-result-en-lugar-de-llamar-a-panic"><a class="header" href="#devolver-un-result-en-lugar-de-llamar-a-panic">Devolver un <code>Result</code> en lugar de llamar a <code>panic!</code></a></h4>
<p>En su lugar, podemos devolver un <code>Result</code> que contendrá una instancia de
<code>Config</code> en el caso de éxito y describirá el problema en el caso de error.
También cambiaremos el nombre de la función de <code>new</code> a <code>build</code> porque muchos
programadores esperan que las funciones <code>new</code> nunca fallen. Cuando
<code>Config::build</code> se comunique con <code>main</code>, podemos usar el tipo <code>Result</code> para
señalar que hubo un problema. Luego podemos cambiar <code>main</code> para convertir una
variante <code>Err</code> en un error más práctico para nuestros usuarios sin el texto
circundante sobre <code>thread 'main'</code> y <code>RUST_BACKTRACE</code> que una llamada a <code>panic!</code>
provoca.</p>
<p>El Listado 12-9 muestra los cambios que debemos hacer en el valor de retorno de
la función que ahora llamamos <code>Config::build</code> y el cuerpo de la función
necesario para devolver un <code>Result</code>. Ten en cuenta que esto no se compilará
hasta que actualicemos <code>main</code> también, lo cual haremos en el siguiente
listado.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<p><span class="caption">Listing 12-9: Devolviendo un <code>Result</code> desde
<code>Config::build</code></span></p>
<p>Nuestra función <code>build</code> devuelve un <code>Result</code> con una instancia de <code>Config</code> en
el caso de éxito y una referencia a un string en el caso de error. Nuestros
valores de error siempre serán string literals que tengan el lifetime <code>'static</code>.</p>
<p>Hemos hecho dos cambios en el cuerpo de la función: en lugar de llamar a
<code>panic!</code> cuando el usuario no pasa suficientes argumentos, ahora devolvemos un
valor <code>Err</code>, y hemos envuelto el valor de retorno <code>Config</code> en un <code>Ok</code>. Estos
cambios hacen que la función se ajuste a su nueva firma de tipo.</p>
<p>Devolviendo un valor <code>Err</code> desde <code>Config::build</code> permite que la función
<code>main</code> maneje el <code>Result</code> devuelto por la función <code>build</code> y salga del proceso
de manera más limpia en el caso de error.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="llamando-a-configbuild-y-manejando-errores"><a class="header" href="#llamando-a-configbuild-y-manejando-errores">Llamando a <code>Config::build</code> y manejando errores</a></h4>
<p>Para manejar el caso de error e imprimir un mensaje amigable para el usuario,
necesitamos actualizar <code>main</code> para manejar el <code>Result</code> que devuelve
<code>Config::build</code>, como se muestra en el Listado 12-10. También tomaremos la
responsabilidad de salir de la herramienta de línea de comandos con un código
de error distinto de cero de <code>panic!</code> e implementarlo a mano. Un estado de
salida distinto de cero es una convención para señalar al proceso que llamó a
nuestro programa que el programa salió con un estado de error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-10: Saliendo con un código de error si falla la
construcción de una <code>Config</code></span></p>
<p>En este listado, hemos usado un método que aún no hemos cubierto en detalle:
<code>unwrap_or_else</code>, que está definido en <code>Result&lt;T, E&gt;</code> por la biblioteca
estándar. Usar <code>unwrap_or_else</code> nos permite definir un manejo de errores
personalizado que no sea <code>panic!</code>. Si el <code>Result</code> es un valor <code>Ok</code>, el
comportamiento de este método es similar a <code>unwrap</code>: devuelve el valor interno
que <code>Ok</code> está envolviendo. Sin embargo, si el valor es un valor <code>Err</code>, este
método llama al código en el <em>closure</em>, que es una función anónima que
definimos y pasamos como argumento a <code>unwrap_or_else</code>. Cubriremos los closures
con más detalle en el <a href="ch13-00-functional-features.html">Capítulo 13</a><!-- ignore -->. Por ahora, solo
necesitas saber que <code>unwrap_or_else</code> pasará el valor interno del <code>Err</code>, que en
este caso es el string estático <code>&quot;not enough arguments&quot;</code> que agregamos en el
Listado 12-9, a nuestro closure en el argumento <code>err</code> que aparece entre las
barras verticales <code>|</code>. El código en el closure imprime el valor de <code>err</code> cuando
se ejecuta.</p>
<p>Hemos agregado una nueva línea <code>use</code> para traer <code>process</code> de la biblioteca
estándar al alcance. El código en el closure que se ejecutará en el caso de
error es solo de dos líneas: imprimimos el valor de <code>err</code> y luego llamamos a
<code>process::exit</code>. La función <code>process::exit</code> detendrá el programa
inmediatamente y devolverá el número que se pasó como código de estado de
salida. Esto es similar al manejo basado en <code>panic!</code> que usamos en el Listado
12-8, pero ya no obtenemos todo el output extra. ¡Probémoslo!</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>¡Genial! Este output es mucho más amigable para nuestros usuarios.</p>
<h3 id="extrayendo-la-lógica-de-main"><a class="header" href="#extrayendo-la-lógica-de-main">Extrayendo la lógica de <code>main</code></a></h3>
<p>Ahora que hemos terminado de refactorizar el análisis de configuración, pasemos
a la lógica del programa. Como dijimos en <a href="ch12-03-improving-error-handling-and-modularity.html#separacion-de-preocupaciones-para-proyectos-binarios">“Separación de preocupaciones para
proyectos
binarios”</a><!-- ignore -->
, extraeremos una función llamada <code>run</code> que contendrá toda la lógica actualmente
en la función <code>main</code> que no está involucrada con la configuración o el manejo
de errores. Cuando terminemos, <code>main</code> será conciso y fácil de verificar por
inspección, y podremos escribir pruebas para toda la otra lógica.</p>
<p>El Listado 12-11 muestra la función <code>run</code> extraída. Por ahora, solo estamos
haciendo la pequeña mejora incremental de extraer la función. Todavía estamos
definiendo la función en <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    println!(&quot;With text:\n{contents}&quot;);
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-11: Extracting a <code>run</code> function containing the
rest of the program logic</span></p>
<p>La función <code>run</code> ahora contiene toda la lógica restante de <code>main</code>, comenzando
desde la lectura del archivo. La función <code>run</code> toma la instancia de <code>Config</code>
como argumento.</p>
<h4 id="devolviendo-errores-desde-la-función-run"><a class="header" href="#devolviendo-errores-desde-la-función-run">Devolviendo errores desde la función <code>run</code></a></h4>
<p>Con la lógica del programa restante separada en la función <code>run</code>, podemos
mejorar el manejo de errores, como hicimos con <code>Config::build</code> en el Listado
12-9. En lugar de permitir que el programa entre en pánico llamando a
<code>expect</code>, la función <code>run</code> devolverá un <code>Result&lt;T, E&gt;</code> cuando algo salga mal.
Esto nos permitirá consolidar aún más la lógica que rodea el manejo de errores
en <code>main</code> de una manera amigable para el usuario. El Listado 12-12 muestra los
cambios que debemos hacer en la firma y el cuerpo de <code>run</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!(&quot;With text:\n{contents}&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-12: Cambiando la función <code>run</code> para devolver
<code>Result</code></span></p>
<p>Hemos realizado tres cambios significativos aquí. Primero, cambiamos el tipo de
retorno de la función <code>run</code> a <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. Esta función
anteriormente devolvía el tipo unitario, <code>()</code>, y lo mantenemos como el valor
devuelto en el caso <code>Ok</code>.</p>
<p>Para el tipo de error, usamos el <em>trait object</em> <code>Box&lt;dyn Error&gt;</code> (y hemos
traído <code>std::error::Error</code> al alcance con una declaración <code>use</code> en la parte
superior). Cubriremos los <em>trait objects</em> en el <a href="ch17-00-oop.html">Capítulo 17</a><!-- ignore
-->. Por ahora, solo sepa que <code>Box&lt;dyn Error&gt;</code> significa que la función
devolverá un tipo que implementa el trait <code>Error</code>, pero no tenemos que
especificar qué tipo particular será el valor de retorno. Esto nos da
flexibilidad para devolver valores de error que pueden ser de diferentes tipos
en diferentes casos de error. La palabra clave <code>dyn</code> es corta para “dynamic”.</p>
<p>Segundo, hemos eliminado la llamada a <code>expect</code> en favor del operador <code>?</code>, como
hablamos en el <a href="ch09-02-recoverable-errors-with-result.html#un-atajo-para-propagar-errores-el-operador-">Capítulo 9</a><!-- ignore -->. En lugar de
<code>panic!</code> en un error, <code>?</code> devolverá el valor de error de la función actual para
que el llamador lo maneje.</p>
<p>Tercero, la función <code>run</code> ahora devuelve un valor <code>Ok</code> en caso de éxito. Hemos
declarado con éxito la función <code>run</code> como <code>()</code> en la firma, lo que significa
que necesitamos envolver el valor unitario en el valor <code>Ok</code>. Esta sintaxis
<code>Ok(())</code> puede parecer un poco extraña al principio, pero usar <code>()</code> de esta
manera es la forma idiomática de indicar que estamos llamando a <code>run</code> solo por
sus efectos secundarios; no devuelve un valor que necesitamos.</p>
<p>Cuando ejecutamos el código, se compila, pero no muestra nada:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust nos dice que nuestro código ignoró el valor <code>Result</code> y el valor <code>Result</code>
podría indicar que ocurrió un error. Pero no estamos comprobando si hubo un
error o no, ¡y el compilador nos recuerda que probablemente quisimos tener algo
de código de manejo de errores aquí! Corrijamos ese problema ahora.</p>
<h4 id="manejando-errores-devueltos-por-run-en-main"><a class="header" href="#manejando-errores-devueltos-por-run-en-main">Manejando errores devueltos por <code>run</code> en <code>main</code></a></h4>
<p>Comprobaremos los errores y los manejaremos usando una técnica similar a la que
usamos con <code>Config::build</code> en el Listado 12-10, pero con una ligera diferencia:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {e}&quot;);
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Usamos <code>if let</code> en lugar de <code>unwrap_or_else</code> para verificar si <code>run</code> devuelve un
valor <code>Err</code> y llamar a <code>process::exit(1)</code> si lo hace. La función <code>run</code> no
devuelve un valor que queremos <code>unwrap</code> de la misma manera que <code>Config::build</code>
devuelve la instancia de <code>Config</code>. Debido a que <code>run</code> devuelve <code>()</code> en el caso
de éxito, solo nos importa detectar un error, por lo que no necesitamos que
<code>unwrap_or_else</code> devuelva el valor desempaquetado, que solo sería <code>()</code>.</p>
<p>Los cuerpos de las funciones <code>if let</code> y <code>unwrap_or_else</code> son los mismos en
ambos casos: imprimimos el error y salimos.</p>
<h3 id="dividiendo-el-código-en-un-crate-de-biblioteca"><a class="header" href="#dividiendo-el-código-en-un-crate-de-biblioteca">Dividiendo el código en un crate de biblioteca</a></h3>
<p>Nuestro proyecto <code>minigrep</code> se ve bien hasta ahora. Ahora dividiremos el archivo
<em>src/main.rs</em> y pondremos parte del código en el archivo <em>src/lib.rs</em>. De esa
manera podemos probar el código y tener un archivo <em>src/main.rs</em> con menos
responsabilidades.</p>
<p>Vamos a mover todo el código que no sea la función <code>main</code> de <em>src/main.rs</em> a
<em>src/lib.rs</em>:</p>
<ul>
<li>La función <code>run</code></li>
<li>Las declaraciones <code>use</code> relevantes</li>
<li>La definición de <code>Config</code></li>
<li>La función <code>Config::build</code></li>
</ul>
<p>El contenido de <em>src/main.rs</em> debería tener la firma que se muestra en el
Listado 12-13 (omitimos los cuerpos de las funciones por brevedad). Ten en
cuenta que esto no se compilará hasta que modifiquemos <em>src/main.rs</em> en el
Listado 12-14.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Listing 12-13: Moviendo <code>Config</code> y <code>run</code> a
<em>src/lib.rs</em></span></p>
<p>Hemos hecho uso de la palabra clave <code>pub</code>: en <code>Config</code>, en sus campos y en su
método <code>build</code>, y en la función <code>run</code>. ¡Ahora tenemos un crate de biblioteca que
tiene una API pública que podemos probar!.</p>
<p>Ahora necesitamos traer el código que movimos a <em>src/lib.rs</em> al scope del crate
binario en <em>src/main.rs</em>, como se muestra en el Listado 12-14.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!(&quot;Application error: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<p><span class="caption">Listing 12-14: Usando el crate biblioteca <code>minigrep</code> en
<em>src/main.rs</em></span></p>
<p>Agregamos una línea <code>use minigrep::Config</code> para traer el tipo <code>Config</code> desde el
crate de biblioteca al scope del crate binario, y agregamos el prefijo
<code>minigrep::</code> a la llamada a <code>run</code>. Ahora toda la funcionalidad debería estar
conectada y debería funcionar. Ejecuta el programa con <code>cargo run</code> y asegúrate
de que todo funcione correctamente.</p>
<p>¡Uf! Eso fue mucho trabajo, pero nos hemos preparado para el éxito en el
futuro. Ahora es mucho más fácil manejar errores, y hemos hecho que el código
sea más modular. Casi todo nuestro trabajo se hará en <em>src/lib.rs</em> a partir de
ahora.</p>
<p>¡Aprovechemos esta nueva modularidad haciendo algo que habría sido difícil con
el código antiguo, pero es fácil con el nuevo código: escribiremos algunas
pruebas!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="desarrollando-la-funcionalidad-de-la-biblioteca-con-tdd"><a class="header" href="#desarrollando-la-funcionalidad-de-la-biblioteca-con-tdd">Desarrollando la funcionalidad de la biblioteca con T.D.D.</a></h2>
<p>Ahora que hemos extraído la lógica en <em>src/lib.rs</em> y dejado la recolección de
argumentos y el manejo de errores en <em>src/main.rs</em>, es mucho más fácil escribir
pruebas para la funcionalidad principal de nuestro código. Podemos llamar a las
funciones directamente con varios argumentos y verificar los valores de
retorno sin tener que llamar a nuestro binario desde la línea de comandos.</p>
<p>En esta sección, agregaremos la lógica de búsqueda al programa <code>minigrep</code>
utilizando el proceso de desarrollo impulsado por pruebas (TDD) con los
siguientes pasos:</p>
<ol>
<li>Escriba un test que falle y ejecútala para asegurarse de que falla por la
razón que espera.</li>
<li>Escribe o modifica solo el código suficiente para que el nuevo test pase.</li>
<li>Refactoriza el código que acabas de agregar o cambiar y asegúrate de que los
tests sigan pasando.</li>
<li>¡Repite desde el paso 1!</li>
</ol>
<p>Aunque es solo una de las muchas formas de escribir software, TDD puede ayudar
a impulsar el diseño del código. Escribir la prueba antes de escribir el código
que hace que la prueba pase ayuda a mantener una alta cobertura de prueba
durante todo el proceso.</p>
<p>Vamos a probar la implementación de la funcionalidad que realmente buscará el
string de consulta en el contenido del archivo y producirá una lista de líneas
que coincidan con la consulta. Agregaremos esta funcionalidad en una función
llamada <code>search</code>.</p>
<h3 id="escribiendo-un-test-fallido"><a class="header" href="#escribiendo-un-test-fallido">Escribiendo un test fallido</a></h3>
<p>Debido a que ya no los necesitamos, eliminemos las declaraciones <code>println!</code> de
<em>src/lib.rs</em> y <em>src/main.rs</em> que usamos para verificar el comportamiento del
programa. Luego, en <em>src/lib.rs</em>, agregue un módulo <code>tests</code> con una función de
prueba, como lo hicimos en <a href="ch11-01-writing-tests.html#la-anatomia-de-una-funcion-de-test">Capítulo 11</a><!-- ignore -->. La
función de prueba especifica el comportamiento que queremos que tenga la
función <code>search</code>: tomará una consulta y el texto a buscar, y devolverá solo las
líneas del texto que contengan la consulta. El listado 12-15 muestra esta
prueba, que aún no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }
}</code></pre>
<p><span class="caption">Listing 12-15: Creando un test fallido para la función
<code>search</code> que deseamos tener</span></p>
<p>Este test busca el string <code>&quot;duct&quot;</code>. El texto que estamos buscando son tres
líneas, solo una de las cuales contiene <code>&quot;duct&quot;</code> (Tenga en cuenta que la barra
invertida después de la comilla doble de apertura le dice a Rust que no ponga
un carácter de nueva línea al comienzo del contenido de esta cadena literal).
Afirmamos que el valor devuelto de la función <code>search</code> contiene solo la línea
que esperamos.</p>
<p>Aún no podemos ejecutar este test y verlo fallar porque el test ni siquiera se
compila: ¡la función <code>search</code> aún no existe! De acuerdo con los principios de
TDD, agregaremos solo el código suficiente para que la prueba se compile y se
ejecute agregando una definición de la función <code>search</code> que siempre devuelve
un vector vacío, como se muestra en el listado 12-16. Luego, la prueba debería
compilar y fallar porque un vector vacío no coincide con un vector que
contiene la línea <code>&quot;safe, fast, productive.&quot;</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-16: Definiendo solo lo necesario de la función
<code>search</code> para que nuestro test compile</span></p>
<p>Observa que necesitamos definir un lifetime explícito <code>'a</code> en la firma de
<code>search</code> y usar ese lifetime con el argumento <code>contents</code> y el valor de retorno.
Recuerde en <a href="ch10-03-lifetime-syntax.html">Capítulo 10</a><!-- ignore --> que los parámetros de
lifetime especifican qué lifetime de argumento está conectado al lifetime del
valor de retorno. En este caso, indicamos que el vector devuelto debe contener
string slices que hagan referencia a slices del argumento <code>contents</code> (en lugar
del argumento <code>query</code>).</p>
<p>En otras palabras, le decimos a Rust que los datos devueltos por la función
<code>search</code> vivirán tanto tiempo como los datos pasados a la función <code>search</code> en
el argumento <code>contents</code>. ¡Esto es importante! Los datos a los que hace
referencia un slice deben ser válidos para que la referencia sea válida; si el
compilador asume que estamos haciendo string slices de <code>query</code> en lugar de
<code>contents</code>, hará sus comprobaciones de seguridad incorrectamente.</p>
<p>Si olvidamos las anotaciones de lifetime y tratamos de compilar esta función,
obtendremos este error:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust no puede saber qué argumento de los dos necesitamos, por lo que debemos
decirle explícitamente. Debido a que <code>contents</code> es el argumento que contiene
todo nuestro texto y queremos devolver las partes de ese texto que coincidan,
sabemos que <code>contents</code> es el argumento que debe estar conectado al valor de
retorno usando la sintaxis de lifetime.</p>
<p>Otros lenguajes de programación no requieren que conectes argumentos a valores
de retorno en la firma, pero esta práctica será más fácil con el tiempo. Quizás
quiera comparar este ejemplo con la sección <a href="ch10-03-lifetime-syntax.html#validando-referencias-con-lifetimes">&quot;Validando referencias con
lifetimes&quot;</a><!-- ignore --> en el
Capítulo 10.</p>
<p>Ahora ejecutemos el test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'tests::one_result' panicked at src/lib.rs:44:9:
assertion `left == right` failed
  left: [&quot;safe, fast, productive.&quot;]
 right: []
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>¡Genial, el test falla, exactamente como esperábamos! ¡Vamos a hacer que el
test pase!</p>
<h3 id="escribiendo-código-para-pasar-el-test"><a class="header" href="#escribiendo-código-para-pasar-el-test">Escribiendo código para pasar el test</a></h3>
<p>Actualmente, nuestro test falla porque siempre devolvemos un vector vacío. Para
solucionar eso e implementar <code>search</code>, nuestro programa debe seguir estos
pasos:</p>
<ul>
<li>Iterar a través de cada línea del contenido.</li>
<li>Compruebe si la línea contiene nuestro string de consulta.</li>
<li>Si es así, agréguelo a la lista de valores que estamos devolviendo.</li>
<li>Si no lo hace, no haga nada.</li>
<li>Devuelve la lista de resultados que coinciden.</li>
</ul>
<p>Trabajaremos en cada paso, comenzando por iterar a través de las líneas.</p>
<h4 id="iterando-a-través-de-las-líneas-con-el-método-lines"><a class="header" href="#iterando-a-través-de-las-líneas-con-el-método-lines">Iterando a través de las líneas con el método <code>lines</code></a></h4>
<p>Rust tiene un método útil para manejar la iteración línea por línea de strings,
convenientemente llamado <code>lines</code>, que funciona como se muestra en el listado
12-17. Tenga en cuenta que esto aún no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-17: Iterando a través de cada línea en
<code>contents</code></span></p>
<p>El método <code>lines</code> devuelve un iterador. Hablaremos sobre los iteradores en
profundidad en <a href="ch13-02-iterators.html">Capítulo 13</a><!-- ignore -->, pero recuerde que
vio esta forma de usar un iterador en <a href="ch03-05-control-flow.html#bucle-a-traves-de-una-coleccion-con-for">Listado 3-5</a><!-- ignore -->,
donde usamos un bucle <code>for</code> con un iterador para ejecutar algún código en cada
elemento de una colección.</p>
<h4 id="buscando-cada-línea-para-la-consulta"><a class="header" href="#buscando-cada-línea-para-la-consulta">Buscando cada línea para la consulta</a></h4>
<p>A continuación, necesitamos verificar si la línea contiene el string de
consulta. Afortunadamente, los strings tienen un método útil llamado <code>contains</code>
que hace esto por nosotros. Agregue una llamada al método <code>contains</code> en la
función <code>search</code>, como se muestra en el listado 12-18. Tenga en cuenta que esto
aún no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-18: Agregando funcionalidad para verificar si
la línea contiene el string en <code>query</code></span></p>
<p>En este punto, estamos construyendo funcionalidad. Para que compile, debemos
devolver un valor del cuerpo como indicamos en la firma de la función.</p>
<h4 id="almacenando-líneas-coincidentes"><a class="header" href="#almacenando-líneas-coincidentes">Almacenando líneas coincidentes</a></h4>
<p>Para terminar esta función, necesitamos una forma de almacenar las líneas
coincidentes que queremos devolver. Para eso, podemos hacer un vector mutable
antes del bucle <code>for</code> y llamar al método <code>push</code> para almacenar una <code>line</code> en el
vector. Después del bucle <code>for</code>, devolvemos el vector, como se muestra en el
listado 12-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-19: Almacenando las líneas que coinciden para
poder devolverlas</span></p>
<p>Ahora la función <code>search</code> debería devolver solo las líneas que contienen
<code>query</code>, y nuestro test debería pasar. Ejecutemos el test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Nuestro test pasó, así que sabemos que funciona. ¡Genial!</p>
<p>En este punto, podríamos considerar oportunidades para refactorizar la
implementación de la función <code>search</code> mientras mantenemos las pruebas para
mantener la misma funcionalidad. El código en la función <code>search</code> no es tan
malo, pero no aprovecha algunas características útiles de los iteradores.
Volveremos a este ejemplo en <a href="ch13-02-iterators.html">Capítulo 13</a><!-- ignore -->, donde
exploraremos los iteradores en detalle y veremos cómo mejorarlo.</p>
<h4 id="usando-la-función-search-en-la-función-run"><a class="header" href="#usando-la-función-search-en-la-función-run">Usando la función <code>search</code> en la función <code>run</code></a></h4>
<p>Ahora que la función <code>search</code> funciona y está probada, necesitamos llamar a
<code>search</code> desde nuestra función <code>run</code>. Necesitamos pasar el valor de
<code>config.query</code> y el <code>contents</code> que <code>run</code> lee del archivo a la función <code>search</code>.
Luego, <code>run</code> imprimirá cada línea devuelta por <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Todavía estamos usando un bucle <code>for</code> para devolver cada línea de <code>search</code> e
imprimirla.</p>
<p>Ahora todo el programa debería funcionar. Probémoslo con una palabra que
debería devolver exactamente una línea del poema de Emily Dickinson, &quot;frog&quot;:</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>¡Funciona! Ahora intentemos que coincida con varias líneas, como &quot;body&quot;:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Y finalmente, asegurémonos de que no obtengamos ninguna línea cuando buscamos
una palabra que no está en el poema, como &quot;monomorphization&quot;:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>¡Excelente! Hemos construido nuestra propia versión de una herramienta clásica
y hemos aprendido mucho sobre cómo estructurar aplicaciones. También hemos
aprendido un poco sobre input y output de archivos, lifetimes, testing y
análisis de líneas de comandos.</p>
<p>Para completar nuestro proyecto, demostraremos brevemente cómo trabajar con
variables de entorno y cómo imprimir en el error estándar, ambas son útiles
cuando se escriben programas de línea de comandos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trabajando-con-variables-de-entorno"><a class="header" href="#trabajando-con-variables-de-entorno">Trabajando con Variables de Entorno</a></h2>
<p>Mejoraremos <code>minigrep</code> agregando una característica extra: una opción para
búsqueda insensible a mayúsculas y minúsculas que el usuario puede activar
mediante una variable de entorno. Podríamos hacer esta característica una opción
de línea de comandos y requerir que los usuarios la ingresen cada vez que la
quieran aplicar, pero en lugar de eso, al hacerla una variable de entorno,
permitimos a nuestros usuarios establecer la variable de entorno una vez y
tener todas sus búsquedas insensibles a mayúsculas y minúsculas en esa sesión de
terminal.</p>
<h3 id="escribiendo-un-test-fallido-para-la-función-search-insensible-a-mayúsculas-y-minúsculas"><a class="header" href="#escribiendo-un-test-fallido-para-la-función-search-insensible-a-mayúsculas-y-minúsculas">Escribiendo un Test Fallido para la Función <code>search</code> Insensible a Mayúsculas y Minúsculas</a></h3>
<p>Primero agregaremos una nueva función <code>search_case_insensitive</code> que será
llamada cuando la variable de entorno tenga un valor. Continuaremos siguiendo el
proceso TDD, así que el primer paso es nuevamente escribir un test fallido.
Agregaremos un nuevo test para la nueva función <code>search_case_insensitive</code> y
renombraremos nuestro viejo test de <code>one_result</code> a <code>case_sensitive</code> para
clarificar las diferencias entre los dos tests, como se muestra en el Listado
12-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<p><span class="caption">Listing 12-20: Agregando un nuevo test fallido para la
función insensible a mayúsculas y minúsculas que estamos a punto de 
agregar</span></p>
<p>Ten en cuenta que hemos editado el <code>contents</code> del viejo test también. Hemos
agregado una nueva línea con el texto <code>&quot;Duct tape.&quot;</code> usando una D mayúscula que
no debería coincidir con la consulta <code>&quot;duct&quot;</code> cuando estamos buscando de manera
sensible a mayúsculas y minúsculas. Cambiar el viejo test de esta manera ayuda
a asegurar que no rompamos accidentalmente la funcionalidad de búsqueda
sensible a mayúsculas y minúsculas que ya hemos implementado. Este test debería
pasar ahora y debería continuar pasando mientras trabajamos en la búsqueda
insensible a mayúsculas y minúsculas.</p>
<p>El nuevo test para la búsqueda insensible a mayúsculas y minúsculas usa <code>&quot;rUsT&quot;</code>
como su consulta. En la función <code>search_case_insensitive</code> que estamos a punto
de agregar, la consulta <code>&quot;rUsT&quot;</code> debería coincidir con la línea que contiene
<code>&quot;Rust:&quot;</code> con una R mayúscula y coincidir con la línea <code>&quot;Trust me.&quot;</code> aunque
ambas tienen diferente capitalización que la consulta. Este es nuestro test
fallido, y fallará al compilar porque aún no hemos definido la función
<code>search_case_insensitive</code>. Siéntete libre de agregar una implementación
esqueleto que siempre devuelva un vector vacío, similar a la forma en que lo
hicimos para la función <code>search</code> en el Listado 12-16 para ver el test compilar
y fallar.</p>
<h3 id="implementando-la-función-search_case_insensitive"><a class="header" href="#implementando-la-función-search_case_insensitive">Implementando la Función <code>search_case_insensitive</code></a></h3>
<p>La función <code>search_case_insensitive</code>, como se muestra en el Listado 12-21,
será casi la misma que la función <code>search</code>. La única diferencia es que
convertiremos a minúsculas la <code>query</code> y cada <code>line</code> para que no importe la
mayúscula o minúscula de los argumentos de entrada, serán la misma mayúscula o
minúscula cuando verifiquemos si la línea contiene la consulta.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-21: Definiendo la función 
<code>search_case_insensitive</code> para convertir a minúsculas tanto la consulta como la
línea antes de compararlas</span></p>
<p>Primero, convertimos el string <code>query</code> a minúsculas y lo almacenamos en una
variable sombreada con el mismo nombre. Llamar a <code>to_lowercase</code> en la consulta
es necesario para que no importe si la consulta del usuario es <code>&quot;rust&quot;</code>,
<code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code> o <code>&quot;rUsT&quot;</code>, trataremos la consulta como si fuera <code>&quot;rust&quot;</code> y
y seremos insensibles a la mayúscula o minúscula. Mientras que <code>to_lowercase</code>
manejará Unicode básico, no será 100% preciso. Si estuviéramos escribiendo una
aplicación real, querríamos hacer un poco más de trabajo aquí, pero esta
sección trata sobre variables de entorno, no Unicode, así que lo dejaremos así
aquí.</p>
<p>Nota que <code>query</code> ahora es un <code>String</code> en lugar de un string slice, porque
llamar a <code>to_lowercase</code> crea nuevos datos en lugar de referenciar datos
existentes. Digamos que la consulta es <code>&quot;rUsT&quot;</code>, como un ejemplo: ese string 
slice no contiene una <code>u</code> o <code>t</code> en minúscula para que podamos usar, así que
tenemos que asignar un nuevo <code>String</code> que contenga <code>&quot;rust&quot;</code>. Cuando pasamos
<code>query</code> como un argumento al método <code>contains</code> ahora, necesitamos agregar un
ampersand porque la firma de <code>contains</code> está definida para tomar un string 
slice.</p>
<p>A continuación, agregamos una llamada a <code>to_lowercase</code> en cada <code>line</code> para
convertir a minúsculas todos los caracteres. Ahora que hemos convertido <code>line</code>
y <code>query</code> a minúsculas, encontraremos coincidencias sin importar la mayúscula
o minúscula de la consulta.</p>
<p>Veamos si esta implementación pasa los tests:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>¡Genial! Pasaron. Ahora, llamemos a la nueva función <code>search_case_insensitive</code>
desde la función <code>run</code>. Primero, agregaremos una opción de configuración a la
estructura <code>Config</code> para cambiar entre la búsqueda sensible a mayúsculas y
minúsculas y la búsqueda insensible a mayúsculas y minúsculas. Agregar este
campo causará errores del compilador porque aún no estamos inicializando este
campo en ningún lugar:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Hemos agregado el campo <code>ignore_case</code> que contiene un booleano. A continuación,
necesitamos la función <code>run</code> para verificar el valor del campo <code>ignore_case</code> y
usar eso para decidir si llamar a la función <code>search</code> o la función
<code>search_case_insensitive</code>, como se muestra en el Listado 12-22. Esto aún no se
compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-22: Llamando a <code>search</code> o
<code>search_case_insensitive</code> en función del valor de <code>config.ignore_case</code></span></p>
<p>Finalmente, necesitamos verificar la variable de entorno. Las funciones para
trabajar con variables de entorno están en el módulo <code>env</code> en la biblioteca
estándar, así que traemos ese módulo al alcance en la parte superior de
<em>src/lib.rs</em>. Luego usaremos la función <code>var</code> del módulo <code>env</code> para verificar
si se ha establecido algún valor para una variable de entorno llamada
<code>IGNORE_CASE</code>, como se muestra en el Listado 12-23.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --snip--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-23: Comprobando si existe algún valor en una 
variable de entorno llamada <code>IGNORE_CASE</code></span></p>
<p>Aquí, creamos una nueva variable <code>ignore_case</code>. Para establecer su valor,
llamamos a la función <code>env::var</code> y le pasamos el nombre de la variable de
entorno <code>IGNORE_CASE</code>. La función <code>env::var</code> devuelve un <code>Result</code> que será la
variante <code>Ok</code> exitosa que contiene el valor de la variable de entorno si la
variable de entorno está configurada con algún valor. Devolverá la variante
<code>Err</code> si la variable de entorno no está configurada.</p>
<p>Usaremos el método <code>is_ok</code> en el <code>Result</code> para verificar si la variable de
entorno está configurada, lo que significa que el programa debería hacer una
búsqueda insensible a mayúsculas. Si la variable de entorno <code>IGNORE_CASE</code> no
está configurada en nada, <code>is_ok</code> devolverá <code>false</code> y el programa realizará
una búsqueda sensible a mayúsculas. No nos importa el <em>valor</em> de la variable
de entorno, solo si está configurada o no, así que estamos verificando
<code>is_ok</code> en lugar de usar <code>unwrap</code>, <code>expect</code> o cualquiera de los otros métodos
que hemos visto en <code>Result</code>.</p>
<p>Hemos pasado el valor en la variable <code>ignore_case</code> a la instancia <code>Config</code> para
que la función <code>run</code> pueda leer ese valor y decidir si llamar a la función
<code>search_case_insensitive</code> o <code>search</code>, como implementamos en el Listado 12-22.</p>
<p>¡Probémoslo! Primero, ejecutemos el programa sin la variable de entorno
establecida y con la consulta <code>to</code>, que debería coincidir con cualquier línea
que contenga la palabra &quot;to&quot; en minúsculas:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>¡Parece que aún funciona! Ahora, ejecutemos el programa con <code>IGNORE_CASE</code>
establecido en <code>1</code> pero con la misma consulta <code>to</code>.</p>
<pre><code class="language-console">$ export IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Si estás usando PowerShell, deberás establecer la variable de entorno y
ejecutar el programa como comandos separados:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Esto hará que <code>IGNORE_CASE</code> persista durante el resto de la sesión de tu
shell. Puede desestablecerse con el comando <code>Remove-Item</code>:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Deberíamos obtener líneas que contengan &quot;to&quot; que podrían tener letras
mayúsculas:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excelente, ¡también obtuvimos líneas que contienen &quot;To&quot;! Nuestro programa
<code>minigrep</code> ahora puede hacer búsquedas insensibles a mayúsculas y minúsculas
controladas por una variable de entorno. Ahora sabes cómo administrar las
opciones establecidas mediante argumentos de línea de comandos o variables de
entorno.</p>
<p>Algunos programas permiten argumentos <em>y</em> variables de entorno para la misma
configuración. En esos casos, los programas deciden que uno u otro tiene
precedencia. Para otro ejercicio por tu cuenta, intenta controlar la
sensibilidad a mayúsculas y minúsculas a través de un argumento de línea de
comandos o una variable de entorno. Decide si el argumento de línea de comandos
o la variable de entorno deben tener prioridad si el programa se ejecuta con
uno configurado para ser sensible a mayúsculas y minúsculas y otro configurado
para ignorar mayúsculas y minúsculas.</p>
<p>El módulo <code>std::env</code> contiene muchas más funciones útiles para trabajar con
variables de entorno: consulta su documentación para ver qué está disponible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="escribiendo-mensajes-de-error-estándar-en-lugar-del-output-estándar"><a class="header" href="#escribiendo-mensajes-de-error-estándar-en-lugar-del-output-estándar">Escribiendo mensajes de error estándar en lugar del output estándar</a></h2>
<p>En este momento, estamos escribiendo toda nuestro output en la terminal usando
la macro <code>println!</code>. En la mayoría de las terminales, hay dos tipos de output:
<em>output estándar</em> (<code>stdout</code>) para información general y <em>error estándar</em>
(<code>stderr</code>) para mensajes de error. Esta distinción permite a los usuarios
elegir dirigir el output exitoso de un programa a un archivo pero aun así
imprimir mensajes de error en la pantalla.</p>
<p>La macro <code>println!</code> solo es capaz de imprimir en el output estándar, así que
tenemos que usar algo más para imprimir en el error estándar.</p>
<h3 id="revisando-donde-se-escriben-los-errores"><a class="header" href="#revisando-donde-se-escriben-los-errores">Revisando donde se escriben los errores</a></h3>
<p>Primero, observemos como el contenido impreso por <code>minigrep</code> está siendo
escrito en el output estándar, incluyendo cualquier mensaje de error que
queramos escribir en el error estándar. Haremos eso redirigiendo el output
estándar a un archivo mientras causamos un error intencionalmente. No
redirigiremos el error estándar, así que cualquier contenido enviado al error
estándar continuará mostrándose en la pantalla.</p>
<p>Los programas de línea de comandos se espera que envíen mensajes de error al
error estándar así que podemos ver los mensajes de error en la pantalla incluso
si redirigimos el output estándar a un archivo. Nuestro programa no se está
comportando bien: estamos a punto de ver que guarda los mensajes de error en un
archivo en su lugar!</p>
<p>Para demostrar este comportamiento, ejecutaremos el programa con <code>&gt;</code> y la ruta
del archivo, <em>output.txt</em>, al que queremos redirigir el output estándar. No
pasaremos ningún argumento, lo que debería causar un error:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>La sintaxis <code>&gt;</code> le dice a la shell que escriba el contenido del output estándar
en <em>output.txt</em> en lugar de la pantalla. No vimos el mensaje de error que
esperábamos impreso en la pantalla, así que eso significa que debe haber
terminado en el archivo. Esto es lo que contiene <em>output.txt</em>:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Sí, nuestro mensaje de error está siendo impreso en el output estándar. Es mucho
más útil para mensajes de error como este ser impresos en el error estándar así
que solo los datos de una ejecución exitosa terminen en el archivo. Cambiaremos
eso.</p>
<h3 id="imprimiendo-errores-en-el-error-estándar"><a class="header" href="#imprimiendo-errores-en-el-error-estándar">Imprimiendo errores en el error estándar</a></h3>
<p>Usaremos el código en el Listado 12-24 para cambiar como los mensajes de error
son impresos. Debido al refactor que hicimos anteriormente en este capítulo,
todo el código que imprime mensajes de error está en una función, <code>main</code>. La
librería estándar provee la macro <code>eprintln!</code> que imprime en el flujo de error
estándar, así que cambiaremos los dos lugares donde estábamos llamando
<code>println!</code> para imprimir errores usando <code>eprintln!</code> en su lugar.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {e}&quot;);
        process::exit(1);
    }
}</code></pre>
<p><span class="caption">Listing 12-24: Escribiendo mensajes de error en el 
error estándar en lugar del output estándar utilizando <code>eprintln!</code></span></p>
<p>Ahora, ejecutaremos el programa de la misma manera que antes, sin pasar ningún
argumento y redirigiendo el output estándar con <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Ahora podemos ver el mensaje de error en la pantalla y <em>output.txt</em> no contiene
nada, que es el comportamiento que esperamos de los programas de línea de
comandos.</p>
<p>Ejecutemos el programa otra vez con argumentos que no causen un error pero aun
así redirigiendo el output estándar a un archivo, como así:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>No veremos ningún output en la terminal, y <em>output.txt</em> contendrá nuestros
resultados:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Esto demuestra que ahora estamos usando el output estándar para output exitoso
y el error estándar para output de error como es apropiado.</p>
<h2 id="resumen-11"><a class="header" href="#resumen-11">Resumen</a></h2>
<p>En este capítulo repasó algunos de los conceptos principales que has aprendido
hasta ahora y cubrió como realizar operaciones de I/O comunes en Rust. Al usar
argumentos de línea de comandos, archivos, variables de ambiente, y la macro
<code>eprintln!</code> para imprimir errores, ahora estás preparado para escribir
aplicaciones de línea de comandos. Combinado con los conceptos de capítulos
anteriores, tu código estará bien organizado, almacenará datos efectivamente en
las estructuras de datos apropiadas, manejará errores de manera agradable, y
estará bien testeado.</p>
<p>A continuación, exploraremos algunas características de Rust que fueron
influenciadas por lenguajes funcionales: closures e iterators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="características-de-lenguajes-funcionales-iteradores-y-closures"><a class="header" href="#características-de-lenguajes-funcionales-iteradores-y-closures">Características De Lenguajes Funcionales: Iteradores y Closures</a></h1>
<p>El diseño de Rust se ha inspirado en muchos lenguajes y técnicas existentes, 
y una influencia significativa es la <em>programación funcional</em>. La programación 
en un estilo funcional a menudo incluye el uso de funciones como valores 
pasándolas en argumentos, devolviéndolas de otras funciones, asignándolas a 
variables para su ejecución posterior, y así sucesivamente.</p>
<p>En este capítulo, no debatiremos la cuestión de lo que es o no es la
programación funcional, sino que discutiremos algunas características de Rust
que son similares a las características de muchos lenguajes a menudo
denominados funcionales.</p>
<p>Más específicamente, cubriremos:</p>
<ul>
<li><em>Closures</em>, una construcción similar a una función que puede almacenarse en una
variable</li>
<li><em>Iteradores</em>, una forma de procesar una serie de elementos</li>
<li>Cómo usar closures e iterators para mejorar el proyecto I/O en el Capítulo 12</li>
<li>¡El rendimiento de los closures e iteradores (Spoiler alert: son más rápidos
de lo que podrías pensar!)</li>
</ul>
<p>Ya hemos cubierto algunas otras características de Rust, como el <em>pattern
matching</em> y los <em>enums</em>, que también están influenciados por el estilo
funcional. Debido a que dominar los closures e iteradores es una parte
importante de escribir código Rust idiomático y rápido, dedicaremos todo este
capítulo a ellos.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="closures-funciones-anónimas-que-capturan-su-entorno"><a class="header" href="#closures-funciones-anónimas-que-capturan-su-entorno">Closures: Funciones anónimas que capturan su entorno</a></h2>
<p>Los closures de Rust son funciones anónimas que puede guardar en una variable o
pasar como argumentos a otras funciones. Puede crear el closure en un lugar y
luego llamar al closure en otro lugar para evaluarlo en un contexto diferente.
A diferencia de las funciones, los closures pueden capturar valores del scope en
el que se definen. Demostraremos cómo estas características de los closures
permiten la reutilización de código y la personalización del comportamiento.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="capturando-el-entorno-con-closures"><a class="header" href="#capturando-el-entorno-con-closures">Capturando el entorno con Closures</a></h3>
<p>Primero examinaremos cómo podemos usar closures para capturar valores del
entorno en el que están definidos para su uso posterior. Aquí está el escenario:
Cada cierto tiempo, nuestra compañía de camisetas regala una camiseta exclusiva
y de edición limitada a alguien en nuestra lista de correo como promoción. Las
personas en la lista de correo pueden agregar opcionalmente su color favorito a
su perfil. Si la persona elegida para una camiseta gratis tiene su color
favorito establecido, obtienen esa camiseta de color. Si la persona no ha
especificado un color favorito, obtienen el color que la compañía tiene
actualmente en mayor cantidad.</p>
<p>Hay muchas formas de implementar esto. Para este ejemplo, vamos a usar un enum
llamado <code>ShirtColor</code> que tiene las variantes <code>Red</code> y <code>Blue</code> (limitando el
número de colores disponibles para simplificar). Representamos el inventario de
la compañía con un struct <code>Inventory</code> que tiene un campo llamado <code>shirts</code> que
contiene un <code>Vec&lt;ShirtColor&gt;</code> que representa los colores de camisetas
actualmente en stock. El método <code>giveaway</code> definido en <code>Inventory</code> obtiene la
preferencia opcional de color de camiseta del ganador de la camiseta gratis, y
devuelve el color de camiseta que la persona obtendrá. Esta configuración se
muestra en el Listado 13-1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref2, giveaway2
    );
}</code></pre>
<p><span class="caption">Listing 13-1: Situación de giveaway</span></p>
<p>El <code>almacén</code> definido en <code>main</code> tiene dos camisetas azules y una camiseta roja
restante para distribuir para esta promoción de edición limitada. Llamamos al
método <code>giveaway</code> para un usuario con preferencia por una camiseta roja y un
usuario sin ninguna preferencia.</p>
<p>Otra vez, este código podría implementarse de muchas maneras, y aquí, para
centrarnos en los closures, nos hemos adherido a los conceptos que ya has
aprendido, excepto por el cuerpo del método <code>giveaway</code> que usa un closure. En el
método <code>giveaway</code>, obtenemos la preferencia del usuario como un parámetro de
tipo <code>Option&lt;ShirtColor&gt;</code> y llamamos al método <code>unwrap_or_else</code> en
<code>user_preference</code>. El método <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> en <code>Option&lt;T&gt;</code></a></p>
<!-- ignore --> está definido por la biblioteca estándar. Toma un argumento: un
<p>Closure sin ningún argumento que devuelve un valor <code>T</code> (el mismo tipo almacenado
en la variante <code>Some</code> de la <code>Option&lt;T&gt;</code>, en este caso <code>ShirtColor</code>). Si la
<code>Option&lt;T&gt;</code> es la variante <code>Some</code>, <code>unwrap_or_else</code> devuelve el valor de dentro
de <code>Some</code>. Si la <code>Option&lt;T&gt;</code> es la variante <code>None</code>, <code>unwrap_or_else</code> llama al
closure y devuelve el valor devuelto por el closure.</p>
<p>Especificamos el closure <code>|| self.most_stocked()</code> como argumento a
<code>unwrap_or_else</code>. Este es un closure que no toma parámetros en sí mismo (si el
closure tuviera parámetros, aparecerían entre las dos barras verticales). El
cuerpo del closure llama a <code>self.most_stocked()</code>. Estamos definiendo el closure
aquí, y la implementación de <code>unwrap_or_else</code> evaluará el closure más tarde si
se necesita el resultado.</p>
<p>Ejecutar este código imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>Un aspecto interesante aquí es que hemos pasado un closure que llama a
<code>self.most_stocked()</code> en la instancia <code>Inventory</code> actual. La biblioteca estándar
no necesitaba saber nada sobre los tipos <code>Inventory</code> o <code>ShirtColor</code> que
definimos, o la lógica que queremos usar en este escenario. El closure captura
una referencia inmutable a la instancia <code>self</code> <code>Inventory</code> y la pasa con el
código que especificamos al método <code>unwrap_or_else</code>. Las funciones, por otro
lado, no pueden capturar su entorno de esta manera.</p>
<h3 id="inferencia-de-tipo-de-closure-y-anotación"><a class="header" href="#inferencia-de-tipo-de-closure-y-anotación">Inferencia de tipo de Closure y anotación</a></h3>
<p>Existen más diferencias entre funciones y closures. Los closures no suelen
requerir que anotes los tipos de los parámetros o el valor de retorno como lo
hacen las funciones <code>fn</code>. Las anotaciones de tipo son necesarias en las
funciones porque los tipos son parte de una interfaz explícita expuesta a tus
usuarios. Definir esta interfaz rígidamente es importante para garantizar que
todos estén de acuerdo en qué tipos de valores usa y devuelve una función. Los
closures, por otro lado, no se usan en una interfaz expuesta como esta: se
almacenan en variables y se usan sin nombrarlos y exponerlos a los usuarios de
nuestra biblioteca.</p>
<p>Los closures típicamente son cortos y relevantes solo dentro de un contexto
estrecho en lugar de en cualquier escenario arbitrario. Dentro de estos
contextos limitados, el compilador puede inferir los tipos de los parámetros y
el tipo de retorno, similar a cómo puede inferir los tipos de la mayoría de las
variables (hay casos raros en los que el compilador también necesita
anotaciones de tipo de closure).</p>
<p>Como con las variables, podemos agregar anotaciones de tipo opcionales si
queremos aumentar la explicitud y la claridad a costa de ser más verbosos de lo
estrictamente necesario. La anotación de tipos para un closure se vería como la
definición que se muestra en el Listado 13-2. En este ejemplo, estamos
definiendo un closure y almacenándolo en una variable en lugar de definir el
closure en el lugar donde lo pasamos como argumento como lo hicimos en el
Listado 13-1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-2: Agregando anotaciones de tipo opcionales
para los tipos de parámetros y valor de retorno en el closure</span></p>
<p>Con la anotación de tipo agregada, la sintaxis de los closures se parece más a
la sintaxis de las funciones. Aquí definimos una función que agrega 1 a su
parámetro y un closure que tiene el mismo comportamiento, para comparación.
Hemos agregado algunos espacios para alinear las partes relevantes. Esto
ilustra cómo la sintaxis de los closures es similar a la sintaxis de las
funciones, excepto por el uso de tuberías y la cantidad de sintaxis que es
opcional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>La primera línea muestra una definición de función, y la segunda línea muestra
una definición de closure completamente anotada. En la tercera línea, quitamos
las anotaciones de tipo de la definición de closure. En la cuarta línea,
quitamos los corchetes, que son opcionales porque el cuerpo del closure tiene
solo una expresión. Estas son todas definiciones válidas que producirán el mismo
comportamiento cuando se llamen. Las líneas <code>add_one_v3</code> y <code>add_one_v4</code>
requieren que los closures se evalúen para poder compilar porque los tipos se
inferirán a partir de su uso. Esto es similar a <code>let v = Vec::new();</code> que
necesita anotaciones de tipo o valores de algún tipo para insertar en el <code>Vec</code>
para que Rust pueda inferir el tipo.</p>
<p>Para las definiciones de closure, el compilador infiere un tipo concreto para
cada uno de sus parámetros y para su valor de retorno. Por ejemplo, el Listado
13-3 muestra la definición de un closure corto que solo devuelve el valor que
recibe como parámetro. Este closure no es muy útil, excepto para los propósitos
de este ejemplo. Tenga en cuenta que no hemos agregado ninguna anotación de
tipo a la definición. Debido a que no hay anotaciones de tipo, podemos llamar al
closure con cualquier tipo, lo que hemos hecho aquí con <code>String</code> la primera
vez. Si luego intentamos llamar a <code>example_closure</code> con un entero, obtendremos
un error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-3: Intentando llamar a un closure cuyos tipos
se infieren con dos tipos diferentes</span></p>
<p>El compilador nos da este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from(&quot;hello&quot;));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin &quot;closure-example&quot;) due to 1 previous error
</code></pre>
<p>La primera vez que llamamos a <code>example_closure</code> con el valor <code>String</code>, el
compilador infiere el tipo de <code>x</code> y el tipo de retorno del closure como
<code>String</code>. Esos tipos se bloquean en el closure en <code>example_closure</code>, y
obtenemos un error de tipo cuando intentamos usar un tipo diferente con el
mismo closure.</p>
<h3 id="capturando-referencias-o-moviendo-el-ownership"><a class="header" href="#capturando-referencias-o-moviendo-el-ownership">Capturando referencias o moviendo el ownership</a></h3>
<p>Los closures pueden valores desde su entorno de tres maneras, que se mapean
directamente a las tres formas en que una función puede tomar un parámetro:
borrowing inmutable, borrowing mutable y tomando ownership. El closure decidirá
cuál de estos usar en función de lo que haga el cuerpo de la función con los
valores capturados.</p>
<p>En el Listado 13-4, definimos un closure que captura una referencia inmutable al
vector <code>list</code> ya que solo necesita una referencia inmutable para imprimir el
valor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    let only_borrows = || println!(&quot;From closure: {list:?}&quot;);

    println!(&quot;Before calling closure: {list:?}&quot;);
    only_borrows();
    println!(&quot;After calling closure: {list:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-4: Definiendo y llamando a un closure que
captura una referencia inmutable</span></p>
<p>Este ejemplo también ilustra que una variable puede vincularse a una definición
de closure, y luego podemos llamar al closure usando el nombre de la variable y
paréntesis como si el nombre de la variable fuera un nombre de función.</p>
<p>Debido a que podemos tener múltiples referencias inmutables a <code>list</code> al mismo
tiempo, <code>list</code> sigue siendo accesible desde el código antes de la definición del
closure, después de la definición del closure, pero antes de que se llame al
closure, y después de que se llame al closure. Este código se compila, se
ejecuta e imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Luego, en el Listado 13-5, cambiamos el cuerpo del closure para que agregue un
elemento al vector <code>list</code>. El closure ahora captura una referencia mutable:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;After calling closure: {list:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-5: Definiendo y llamando a un closure que
captura una referencia mutable</span></p>
<p>Este código compila, se ejecuta e imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Nota que ya no hay un <code>println!</code> entre la definición y la llamada del closure
<code>borrows_mutably</code>: cuando se define <code>borrows_mutably</code>, captura una referencia
mutable a <code>list</code>. No usamos el closure nuevamente después de llamar al closure,
por lo que el préstamo mutable termina. Entre la definición del closure y la
llamada del closure, no se permite un préstamo inmutable para imprimir porque
no se permiten otros préstamos cuando hay un préstamo mutable. ¡Intente agregar
un <code>println!</code> allí para ver qué mensaje de error obtiene!</p>
<p>Si deseas forzar al closure para que tome ownership de los valores que usa en el
entorno, incluso cuando el cuerpo del closure no los necesite, puedes usar la
palabra clave <code>move</code> antes de la lista de parámetros.</p>
<p>Esta técnica es principalmente útil cuando se pasa un closure a un nuevo hilo
para mover los datos para que sean propiedad del nuevo hilo. Discutiremos los
hilos y por qué querrías usarlos en detalle en el Capítulo 16 cuando hablemos
sobre la concurrencia, pero por ahora, exploremos brevemente cómo generar un
nuevo hilo usando un closure que necesita la palabra clave <code>move</code>. El Listado
13-6 muestra el Listado 13-4 modificado para imprimir el vector en un nuevo
hilo en lugar de en el hilo principal:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    thread::spawn(move || println!(&quot;From thread: {list:?}&quot;))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 13-6: Usando <code>move</code> para forzar que el closure del
thread tome el ownership de <code>list</code></span></p>
<p>Iniciamos un nuevo hilo, dando al hilo un closure para ejecutar como argumento.
El cuerpo del closure imprime la lista. En el Listado 13-4, el closure solo
capturó <code>list</code> usando una referencia inmutable porque esa es la menor cantidad
de acceso a <code>list</code> necesaria para imprimirla. En este ejemplo, aunque el cuerpo
del closure todavía solo necesita una referencia inmutable, debemos especificar
que <code>list</code> debe moverse al closure poniendo la palabra clave <code>move</code> al comienzo
de la definición del closure. El nuevo hilo podría terminar antes de que el
resto del hilo principal termine, o el hilo principal podría terminar primero.
Si el hilo principal mantuviera la propiedad de <code>list</code> pero terminara antes de
que lo hiciera el nuevo hilo y dejara caer <code>list</code>, la referencia inmutable en
el hilo sería inválida. Por lo tanto, el compilador requiere que <code>list</code> se
mueva al closure dado al nuevo hilo para que la referencia sea válida. ¡Intente
eliminar la palabra clave <code>move</code> o usar <code>list</code> en el hilo principal después de
que se defina el closure para ver qué errores del compilador obtiene!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="moviendo-valores-capturados-fuera-de-los-closures-y-los-traits-fn"><a class="header" href="#moviendo-valores-capturados-fuera-de-los-closures-y-los-traits-fn">Moviendo valores capturados fuera de los closures y los traits <code>Fn</code></a></h3>
<p>Una vez que un closure ha capturado una referencia o capturado el ownership de
un valor del entorno donde se define el closure (afectando así lo que, si
cualquier cosa, se mueve <em>dentro</em> del closure), el código en el cuerpo del
closure define lo que sucede con las referencias o valores cuando el closure se
evalúa más tarde (afectando así lo que, si cualquier cosa, se mueve <em>fuera</em> del
closure). El cuerpo de un closure puede hacer cualquiera de las siguientes
acciones: mover un valor capturado fuera del closure, mutar el valor capturado,
ni mover ni mutar el valor, o no capturar nada del entorno para comenzar.</p>
<p>La forma en que un closure captura y maneja los valores del entorno afecta qué
traits implementa el closure, y los traits son cómo las funciones y los
structs pueden especificar qué tipos de closures pueden usar. Los closures
implementarán automáticamente uno, dos o los tres de estos traits <code>Fn</code>, de
manera aditiva, dependiendo de cómo el cuerpo del closure maneje los valores:</p>
<ol>
<li><code>FnOnce</code> se aplica los closures que pueden ser llamados una vez. Todos los
closures implementan al menos este trait, porque todos los closures pueden
ser llamados. Un closure que mueve valores capturados fuera de su cuerpo
solo implementará <code>FnOnce</code> y ninguno de los otros traits <code>Fn</code>, porque solo
puede ser llamado una vez.</li>
<li><code>FnMut</code> se aplica a los closures que no mueven valores capturados fuera de
su cuerpo, pero que podrían mutar los valores capturados. Estos closures
pueden ser llamados más de una vez.</li>
<li><code>Fn</code> se aplica a los closures que no mueven valores capturados fuera de su
cuerpo y que no mutan los valores capturados, así como los closures que no
capturan nada de su entorno. Estos closures pueden ser llamados más de una
vez sin mutar su entorno, lo cual es importante en casos como llamar a un
closure múltiples veces concurrentemente.</li>
</ol>
<p>Veamos la definición del método <code>unwrap_or_else</code> en <code>Option&lt;T&gt;</code> que utilizamos
en el Listado 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Recuerda que <code>T</code> es el tipo generic que representa el tipo del valor en la
variante <code>Some</code> de un <code>Option</code>. Ese tipo <code>T</code> también es el tipo de retorno de
la función <code>unwrap_or_else</code>: el código que llama a <code>unwrap_or_else</code> en un
<code>Option&lt;String&gt;</code>, por ejemplo, obtendrá un <code>String</code>.</p>
<p>Luego, observe que el método <code>unwrap_or_else</code> tiene el parámetro de tipo
generic adicional <code>F</code>. El tipo <code>F</code> es el tipo del parámetro llamado <code>f</code>, que
es el closure que proporcionamos al llamar a <code>unwrap_or_else</code>.</p>
<p>El trait bound especificado en el tipo generic <code>F</code> es <code>FnOnce() -&gt; T</code>, lo que
significa que <code>F</code> debe poder ser llamado una vez para producir un valor del
tipo <code>T</code>. Usar <code>FnOnce</code> en el trait bound expresa la restricción de que
<code>unwrap_or_else</code> solo va a llamar a <code>f</code> como máximo una vez. En el cuerpo de
<code>unwrap_or_else</code>, podemos ver que si el <code>Option</code> es <code>Some</code>, <code>f</code> no se llamará.
Si el <code>Option</code> es <code>None</code>, <code>f</code> se llamará una vez. Debido a que todos los
closures implementan <code>FnOnce</code>, <code>unwrap_or_else</code> acepta todos esos tipos de 
closures y es tan flexible como puede ser.</p>
<blockquote>
<p>Nota: Las funciones también pueden implementar los tres traits <code>Fn</code>, <code>FnMut</code>
y <code>FnOnce</code>. Si lo que queremos hacer no requiere capturar un valor del
entorno, podemos usar el nombre de una función en lugar de un closure donde
necesitamos algo que implemente uno de los traits <code>Fn</code>. Por ejemplo, en un
valor <code>Option&lt;Vec&lt;T&gt;&gt;</code>, podríamos llamar a <code>unwrap_or_else(Vec::new)</code> para
obtener un nuevo vector vacío si el valor es <code>None</code>.</p>
</blockquote>
<p>Ahora veamos el método de la biblioteca estándar <code>sort_by_key</code> definido en
slices, para ver cómo difiere de <code>unwrap_or_else</code> y por qué <code>sort_by_key</code>
utiliza <code>FnMut</code> en lugar de <code>FnOnce</code> para el trait bound. El closure recibe un
argumento en forma de referencia al elemento actual en el slice que se está
considerando, y devuelve un valor de tipo <code>K</code> que se puede ordenar. Esta
función es útil cuando desea ordenar un slice por un atributo particular de
cada elemento. En el Listado 13-7, tenemos una lista de instancias de
<code>Rectangle</code> y usamos <code>sort_by_key</code> para ordenarlas por su atributo <code>width</code>
de menor a mayor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{list:#?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-7: Usando <code>sort_by_key</code> para ordenar
rectángulos por ancho</span></p>
<p>Este código imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>La razón por la que <code>sort_by_key</code> está definido para tomar un closure <code>FnMut</code>
es que llama al closure varias veces: una vez por cada elemento en el slice.
El closure <code>|r| r.width</code> no captura, muta ni mueve nada de su entorno, por lo
que cumple con los requisitos de los trait bound.</p>
<p>En contraste, El Listado 13-8 muestra un ejemplo de un closure que implementa
solo el trait <code>FnOnce</code>, porque mueve un valor fuera del entorno. El
compilador no nos permitirá usar este closure con <code>sort_by_key</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;closure called&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{list:#?}&quot;);
}</code></pre>
<p><span class="caption">Listing 13-8: Intentando usar un closure <code>FnOnce</code> con
<code>sort_by_key</code></span></p>
<p>Esto es un ejemplo artificial y complicado (que no funciona) para tratar de
contar la cantidad de veces que se llama a <code>sort_by_key</code> llama a la closure al 
ordenar <code>list</code>.
Este código intenta hacer este conteo empujando <code>value</code>—un <code>String</code> del
entorno del closure—en el vector <code>sort_operations</code>. El closure captura <code>value</code>
y luego mueve <code>value</code> fuera del closure transfiriendo la propiedad de <code>value</code>
al vector <code>sort_operations</code>. Este closure puede ser llamado una vez; tratar de
llamarlo una segunda vez no funcionaría porque <code>value</code> ya no estaría en el
entorno para ser empujado a <code>sort_operations</code> nuevamente. Por lo tanto, este
closure solo implementa <code>FnOnce</code>. Cuando intentamos compilar este código,
obtenemos este error de que <code>value</code> no se puede mover fuera del closure porque
el closure debe implementar <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from(&quot;closure called&quot;);
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin &quot;rectangles&quot;) due to 1 previous error
</code></pre>
<p>El error señala la línea en el cuerpo del closure que mueve <code>value</code> fuera del
entorno. Para solucionar esto, debemos cambiar el cuerpo del closure para que
no mueva valores fuera del entorno. Para contar la cantidad de veces que se
llama a la closure, mantener un contador en el entorno e incrementar su
valor en el cuerpo del closure es una forma más directa de calcular eso. El
closure en el Listado 13-9 funciona con <code>sort_by_key</code> porque solo está
capturando una referencia mutable al contador <code>num_sort_operations</code> y, por lo
tanto, puede ser llamado más de una vez:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{list:#?}, sorted in {num_sort_operations} operations&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-9: Usando un closure <code>FnMut</code> con <code>sort_by_key</code>
está permitido</span></p>
<p>Los <code>Fn</code> traits son importantes al definir o usar funciones o tipos que
hacen uso de closures. En la siguiente sección, discutiremos los iteradores.
Muchos métodos de iteradores toman argumentos de closure, ¡así que tenga en
cuenta estos detalles de closure a medida que continuamos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="procesando-una-serie-de-elementos-con-iteradores"><a class="header" href="#procesando-una-serie-de-elementos-con-iteradores">Procesando una serie de elementos con Iteradores</a></h2>
<p>El patrón de iterador te permite realizar alguna tarea en una secuencia de
elementos a su vez. Un iterador es responsable de la lógica de iterar sobre
cada elemento y determinar cuándo ha terminado la secuencia. Cuando usas
iterators, no tienes que reimplementar esa lógica tú mismo.</p>
<p>En rust, los iterators son <em>lazy</em>, lo que significa que no tienen efecto hasta
que llamas a métodos que consumen el iterador para usarlo. Por ejemplo, el
código en el Listado 13-10 crea un iterador sobre los elementos del vector <code>v1</code>
llamando al método <code>iter</code> definido en <code>Vec&lt;T&gt;</code>. Este código por sí solo no hace
nada útil.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-10: Creando un iterator</span></p>
<p>El iterador es almacenado en la variable <code>v1_iter</code>. Una vez que hemos creado un
iterator, podemos usarlo de varias maneras. En el Listado 3-5 del Capítulo 3,
iteramos sobre un array usando un bucle <code>for</code> para ejecutar algún código en cada
uno de sus elementos. Bajo el capó, esto crea e implícitamente consume un
iterator, pero pasamos por alto cómo funciona exactamente hasta ahora.</p>
<p>En el ejemplo del Listado 13-11, separamos la creación del iterador del uso del
iterador en el bucle <code>for</code>. Cuando el bucle <code>for</code> es llamado usando el iterator
en <code>v1_iter</code>, cada elemento en el iterador es usado en una iteración del bucle,
lo que imprime cada valor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;Got: {val}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-11: Usando un iterador en un bucle <code>for</code></span></p>
<p>En lenguajes que no tienen iterators provistos por sus bibliotecas estándar,
probablemente escribirías esta misma funcionalidad comenzando una variable en
el índice 0, usando esa variable para indexar en el vector para obtener un
valor, e incrementando el valor de la variable en un bucle hasta que alcanzara
el número total de elementos en el vector.</p>
<p>Los iterators manejan toda esa lógica por ti, reduciendo el código repetitivo
que podrías potencialmente arruinar. Los iterators te dan más flexibilidad para
usar la misma lógica con muchos tipos diferentes de secuencias, no solo
estructuras de datos en las que puedes indexar, como los vectores. Examinemos
cómo los iterators hacen eso.</p>
<h3 id="el-trait-iterator-y-el-método-next"><a class="header" href="#el-trait-iterator-y-el-método-next">El trait <code>Iterator</code> y el método <code>next</code></a></h3>
<p>Todos los iterators implementan un trait llamado <code>Iterator</code> que está definido
en la biblioteca estándar. La definición del trait se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<p>Observa que esta definición usa una nueva sintaxis: <code>type Item</code> y
<code>Self::Item</code>, que definen un <em>associated type</em> con este trait. Hablaremos sobre
los associated types en profundidad en el Capítulo 19. Por ahora, todo lo que
necesitas saber es que este código dice que implementar el trait <code>Iterator</code>
requiere que también definas un tipo <code>Item</code>, y este tipo <code>Item</code> es usado en el
tipo de retorno del método <code>next</code>. En otras palabras, el tipo <code>Item</code> será el
tipo retornado del iterator.</p>
<p>El trait <code>Iterator</code> solo requiere que los implementadores definan un método:
el método <code>next</code>, que retorna un item del iterador a la vez envuelto en <code>Some</code>
y, cuando la iteración ha terminado, retorna <code>None</code>.</p>
<p>Podemos llamar al método <code>next</code> en los iterators directamente; el Listado 13-12
demuestra qué valores son retornados de llamadas repetidas a <code>next</code> en el
iterador creado desde el vector.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-12: Llamando al método <code>next</code> en un
iterator</span></p>
<p>Nota que necesitamos hacer <code>v1_iter</code> mutable: llamar al método <code>next</code> en un
iterador cambia el estado interno que el iterador usa para mantenerse al tanto
de dónde está en la secuencia. En otras palabras, este código <em>consume</em>, o usa,
el iterator. Cada llamada a <code>next</code> consume un item del iterator. No necesitamos
hacer <code>v1_iter</code> mutable cuando usamos un bucle <code>for</code> porque el bucle toma
posesión de <code>v1_iter</code> y lo hace mutable detrás de escena.</p>
<p>También debemos tener en cuenta que los valores que obtenemos de las llamadas a
<code>next</code> son referencias inmutables a los valores en el vector. El método <code>iter</code>
produce un iterador sobre referencias inmutables. Si queremos crear un iterator
que tome posesión de <code>v1</code> y retorne valores poseídos, podemos llamar a
<code>into_iter</code> en lugar de <code>iter</code>. De manera similar, si queremos iterar sobre
referencias mutables, podemos llamar a <code>iter_mut</code> en lugar de <code>iter</code>.</p>
<h3 id="métodos-que-consumen-el-iterator"><a class="header" href="#métodos-que-consumen-el-iterator">Métodos que consumen el iterator</a></h3>
<p>El trait <code>Iterator</code> tiene una variedad de métodos con implementaciones
predeterminadas provistas por la biblioteca estándar; puedes encontrar
información sobre estos métodos en la documentación de la biblioteca estándar
para el trait <code>Iterator</code>. Algunos de estos métodos llaman al método <code>next</code> en su
definición, por lo que se requiere que implementes el método <code>next</code> al
implementar el trait <code>Iterator</code>.</p>
<p>Los métodos que llaman a <code>next</code> se llaman <em>consuming adaptors</em>, porque
consumen el iterador llamando a <code>next</code>. Un ejemplo es el método <code>sum</code>, que
toma posesión del iterador y lo itera a través de los items llamando a <code>next</code>,
así consumiendo el iterator. A medida que itera a través de ellos, agrega cada
item a un total en ejecución y retorna el total cuando la iteración está
completa. El Listado 13-13 tiene una prueba que ilustra el uso del método <code>sum</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-13: Llamando al método <code>sum</code> para obtener el 
total de todos los items en el iterator</span></p>
<p>No se nos permite usar <code>v1_iter</code> después de la llamada a <code>sum</code> porque <code>sum</code>
toma el ownership del iterador en el que lo llamamos.</p>
<h3 id="métodos-que-producen-otros-iterators"><a class="header" href="#métodos-que-producen-otros-iterators">Métodos que producen otros iterators</a></h3>
<p><em>Iterator adaptors</em> son métodos definidos en el trait <code>Iterator</code> que no
consumen el iterator. En cambio, producen diferentes iterators cambiando algún
aspecto del iterador original.</p>
<p>El Listado 13-14 muestra un ejemplo de llamar al método adaptador de iterator
<code>map</code> que toma un closure para llamar en cada item y produce un nuevo iterator.
El método <code>map</code> retorna un nuevo iterador que ejecuta el closure que le
pasamos en cada item y produce los items resultantes. El closure aquí crea un
nuevo iterador en el que cada item del vector será incrementado en 1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-14: Llamando al iterador adaptor <code>map</code> para
crear un nuevo iterator</span></p>
<p>Como siempre, este código producirá un warning:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>El código del Listado 13-14 no hace nada; el closure que hemos especificado
nunca es llamado. El warning nos recuerda por qué: los iterador adaptors son
perezosos, y necesitamos consumir el iterador aquí.</p>
<p>Para solucionar este warning y consumir el iterator, usaremos el método
<code>collect</code>, que usamos en el Capítulo 12 con <code>env::args</code> en el Listado 12-1. Este
método consume el iterador y colecciona los valores resultantes en un tipo de
colección.</p>
<p>En el Listado 13-15, recolectamos los resultados de iterar sobre el iterator
que es retornado de la llamada a <code>map</code> en un vector. Este vector terminará
conteniendo cada item del vector original incrementado en 1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-15: Llamando al método <code>map</code> para crear un 
nuevo iterador y luego llamando al método <code>collect</code> para consumir el nuevo 
iterador y crear un vector</span></p>
<p>Debido a que <code>map</code> toma un closure, podemos especificar cualquier operación que
queramos realizar en cada item. Este es un gran ejemplo de cómo los closures te
permiten personalizar algún comportamiento mientras reutilizas el comportamiento
de iteración que el trait <code>Iterator</code> provee.</p>
<p>Puedes encadenar múltiples llamadas a iterador adaptors para realizar acciones
complejas de una manera legible. Pero debido a que todos los iterators son
perezosos, tienes que llamar a uno de los métodos adaptadores consumidores para
obtener resultados de las llamadas a iterador adaptors.</p>
<h3 id="usando-closures-que-capturan-su-entorno"><a class="header" href="#usando-closures-que-capturan-su-entorno">Usando Closures que Capturan su Entorno</a></h3>
<p>Muchos de los iterador adaptors toman closures como argumentos, y comúnmente los
closures que especificaremos como argumentos a iterador adaptors capturarán su
entorno.</p>
<p>Para este ejemplo, usaremos el método <code>filter</code> definido en el trait <code>Iterator</code>,
que toma un closure que toma un item y retorna un <code>bool</code>. Si el closure retorna
<code>true</code>, el valor será incluido en el iterador producido. Si el closure retorna
<code>false</code>, el valor no será incluido en el iterador producido.</p>
<p>En el Listado 13-16, usamos <code>filter</code> con un closure que captura la variable
<code>shoe_size</code> de su entorno para iterar sobre una colección de instancias de la
estructura <code>Shoe</code>. Retornará solo los zapatos que sean del tamaño especificado.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;sandal&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;sneaker&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;boot&quot;)
                },
            ]
        );
    }
}</code></pre>
<p><span class="caption">Listing 13-16: Usando el método <code>filter</code> con un closure
que captura <code>shoe_size</code></span></p>
<p>La función <code>shoes_in_size</code> toma ownership de un vector de zapatos y un tamaño de
zapato como parámetros. Retorna un vector que contiene solo zapatos del tamaño
especificado.</p>
<p>En el cuerpo de <code>shoes_in_size</code>, llamamos a <code>into_iter</code> para crear un iterator
que tome ownership del vector. Luego llamamos a <code>filter</code> para adaptar ese
iterador en un nuevo iterador que solo contiene elementos para los cuales el
closure retorna <code>true</code>.</p>
<p>El closure captura el parámetro <code>shoe_size</code> del entorno y compara el valor con
el tamaño de cada zapato, manteniendo solo los zapatos del tamaño especificado.
Finalmente, llamando a <code>collect</code> recolectamos los valores retornados por el
iterador adaptado en un vector que es retornado por la función.</p>
<p>El test muestra que cuando llamamos a <code>shoes_in_size</code> con un vector de zapatos
y un tamaño de zapato, obtenemos de vuelta solo los zapatos del tamaño
especificado:</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mejorando-nuestro-proyecto-io"><a class="header" href="#mejorando-nuestro-proyecto-io">Mejorando nuestro proyecto I/O</a></h2>
<p>Con este nuevo conocimiento sobre iteradores, podemos mejorar el proyecto I/O
en el Capítulo 12 usando iteradores para hacer que los lugares en el código
sean más claros y concisos. Veamos cómo los iterators pueden mejorar nuestra
implementación de la función <code>Config::build</code> y la función <code>search</code>.</p>
<h3 id="removiendo-un-clone-usando-un-iterator"><a class="header" href="#removiendo-un-clone-usando-un-iterator">Removiendo un <code>clone</code> usando un iterator</a></h3>
<p>En el Listado 12-6, agregamos código que tomó un slice de valores <code>String</code> y
creó una instancia del struct <code>Config</code> indexando en el slice y clonando
los valores, permitiendo que el struct <code>Config</code> posea esos valores. En el
Listado 13-17, hemos reproducido la implementación de la función <code>Config::build</code>
tal como estaba en el Listado 12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-17: Reproducción de la función <code>Config::build</code>
del Listing 12-23</span></p>
<p>En ese momento, dijimos que no nos preocupáramos por las llamadas ineficientes
a <code>clone</code> porque las eliminaríamos en el futuro. ¡Bueno, ese momento es ahora!</p>
<p>Necesitábamos <code>clone</code> aquí porque tenemos un slice con elementos <code>String</code> en el
parámetro <code>args</code>, pero la función <code>build</code> no posee <code>args</code>. Para retornar la
propiedad de una instancia de <code>Config</code>, tuvimos que clonar los valores de los
campos <code>query</code> y <code>file_path</code> de <code>Config</code> para que la instancia de <code>Config</code>
pueda poseer sus valores.</p>
<p>Con nuestro nuevo conocimiento sobre iteradores, podemos cambiar la función
<code>build</code> para tomar propiedad de un iterator como su argumento en lugar de
tomar prestado un slice. Usaremos la funcionalidad del iterator en lugar del
código que verifica la longitud del slice e indexa en ubicaciones específicas.
Esto aclarará lo que la función <code>Config::build</code> está haciendo porque el
iterator accederá a los valores.</p>
<p>Una vez que <code>Config::build</code> tome ownership del iterator y deje de usar
operaciones de indexación que toman borrowing, podemos mover los valores
<code>String</code> del iterator dentro de <code>Config</code> en lugar de llamar a <code>clone</code> y hacer
una nueva asignación.</p>
<h4 id="usando-el-iterator-retornado-directamente"><a class="header" href="#usando-el-iterator-retornado-directamente">Usando el iterator retornado directamente</a></h4>
<p>Abre tu proyecto I/O en <em>src/main.rs</em>, el cual debería verse así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p>Primero cambiaremos el inicio de la función <code>main</code> que teníamos en el Listado
12-24 al código del Listado 13-18, el cual esta vez usa un iterator. Esto no
compilará hasta que actualicemos <code>Config::build</code> también.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listing 13-18: Pasando el valor de retorno de <code>env::args</code>
a <code>Config::build</code></span></p>
<p>¡La función <code>env::args</code> retorna un iterator! En lugar de recolectar los valores
del iterator en un vector y luego pasar un slice a <code>Config::build</code>, ahora
estamos pasando ownership del iterator retornado por <code>env::args</code> directamente a
<code>Config::build</code>.</p>
<p>Luego, necesitamos actualizar la definición de <code>Config::build</code>. En el archivo
<em>src/lib.rs</em> de tu proyecto I/O, cambiemos la firma de <code>Config::build</code> para que
se vea como el Listado 13-19. Esto aún no compilará porque necesitamos
actualizar el cuerpo de la función.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-19: Actualizando la firma de <code>Config::build</code>
para esperar un iterator</span></p>
<p>La documentación de la biblioteca estándar para la función <code>env::args</code> muestra
que el tipo del iterator que retorna es <code>std::env::Args</code>, y que ese tipo
implementa el trait <code>Iterator</code> y retorna valores <code>String</code>.</p>
<p>Hemos actualizado la firma de la función <code>Config::build</code> para que el parámetro
<code>args</code> tenga un tipo genérico con los trait bounds
<code>impl Iterator&lt;Item = String&gt;</code> en lugar de <code>&amp;[String]</code>. Este uso de la sintaxis
<code>impl Trait</code> que discutimos en la sección <a href="ch10-02-traits.html#traits-como-parametros">“Traits como parámetros”</a></p>
<!-- ignore --> del Capítulo 10 significa que `args` puede ser cualquier tipo
<p>que implemente el trait <code>Iterator</code> y retorne items <code>String</code>.</p>
<p>Debido a que estamos tomando ownership de <code>args</code> y estaremos mutando <code>args</code>
por iterarlo, podemos agregar la palabra clave <code>mut</code> en la especificación del
parámetro <code>args</code> para hacerlo mutable.</p>
<h4 id="usando-los-métodos-del-trait-iterator-en-lugar-de-indexar"><a class="header" href="#usando-los-métodos-del-trait-iterator-en-lugar-de-indexar">Usando los métodos del trait <code>Iterator</code> en lugar de indexar</a></h4>
<p>Luego, necesitamos actualizar el cuerpo de <code>Config::build</code> para usar los
métodos del trait <code>Iterator</code> en lugar de indexar en el slice. En el Listado
13-20 hemos actualizado el código del Listado 12-23 para usar el método <code>next</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file path&quot;),
        };

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-20: Cambiando el cuerpo de <code>Config::build</code> para
usar métodos de iterators</span></p>
<p>Recuerda que el primer valor en el valor de retorno de <code>env::args</code> es el nombre
del programa. Queremos ignorar eso y llegar al siguiente valor, así que
primero llamamos a <code>next</code> y no hacemos nada con el valor de retorno. Segundo,
llamamos a <code>next</code> para obtener el valor que queremos poner en el campo <code>query</code>
de <code>Config</code>. Si <code>next</code> retorna un <code>Some</code>, usamos un <code>match</code> para extraer el
valor. Si retorna <code>None</code>, significa que no se dieron suficientes argumentos y
retornamos temprano con un valor <code>Err</code>. Hacemos lo mismo para el valor
<code>file_path</code>.</p>
<h3 id="haciendo-el-código-más-claro-con-iterator-adaptors"><a class="header" href="#haciendo-el-código-más-claro-con-iterator-adaptors">Haciendo el código más claro con iterator adaptors</a></h3>
<p>También podemos aprovechar los iterators en la función <code>search</code> de nuestro
proyecto I/O, el cual se reproduce aquí en el Listado 13-21 como estaba en el
Listado 12-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-21: La implementación de la función <code>search</code>
del Listing 12-19</span></p>
<p>Podemos escribir este código de una manera más concisa usando los métodos
adaptor del iterator. Hacerlo también nos permite evitar tener un vector
intermedio mutable <code>results</code>. El estilo de programación funcional prefiere
minimizar la cantidad de estado mutable para hacer el código más claro. Remover
el estado mutable podría permitir una mejora futura para hacer que la búsqueda
ocurra en paralelo, porque no tendríamos que manejar el acceso concurrente al
vector <code>results</code>. El Listado 13-22 muestra este cambio:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a query string&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a file path&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-22: Utilizando método iterator adaptor en la
implementación de la función <code>search</code></span></p>
<p>Recuerda que el propósito de la función <code>search</code> es retornar todas las líneas
en <code>contents</code> que contengan <code>query</code>. Similar al ejemplo de <code>filter</code> en el
Listado 13-16, este código usa el adaptador <code>filter</code> para mantener solo las
líneas que retornan <code>true</code> para <code>line.contains(query)</code>. Luego recolectamos las
líneas que coinciden en otro vector con <code>collect</code>. ¡Mucho más simple! Siéntete
libre de hacer el mismo cambio para usar los métodos del iterator en la función
<code>search_case_insensitive</code> también.</p>
<h3 id="escogiendo-entre-loops-o-iterators"><a class="header" href="#escogiendo-entre-loops-o-iterators">Escogiendo entre loops o iterators</a></h3>
<p>La siguiente pregunta lógica es qué estilo deberías escoger en tu propio código
y por qué: la implementación original en el Listado 13-21 o la versión usando
iterators en el Listado 13-22. La mayoría de los programadores Rust prefieren
usar el estilo de iterators. Es un poco más difícil de entender al principio,
pero una vez que obtienes una idea de los varios adaptadores de iterators y lo
que hacen, los iterators pueden ser más fáciles de entender. En lugar de
manipular los varios bits de los loops y construir nuevos vectores, el código
se enfoca en el objetivo de alto nivel del loop. Esto abstrae un poco del
código común para que sea más fácil ver los conceptos que son únicos a este
código, como la condición de filtrado que cada elemento en el iterator debe
pasar.</p>
<p>¿Pero son las dos implementaciones realmente equivalentes? La suposición
intuitiva podría ser que el loop más bajo nivel será más rápido. Hablemos de
performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comparando-performance-bucles-vs-iteradores"><a class="header" href="#comparando-performance-bucles-vs-iteradores">Comparando Performance: Bucles vs. Iteradores</a></h2>
<p>Para determinar si usar loops o iterators, necesitas saber cuál implementación
es más rápida: la versión de la función <code>search</code> con un <code>for</code> loop explícito o
la versión con iterators.</p>
<p>Realizamos un benchmark cargando el contenido completo de <em>The Adventures of
Sherlock Holmes</em> de Sir Arthur Conan Doyle en un <code>String</code> y buscando la palabra
<em>the</em> en el contenido. Aquí están los resultados del benchmark en la versión de
<code>search</code> usando el ciclo <code>for</code> y la versión usando iterators:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>La versión del iterator fue ligeramente más rápida! No explicaremos el código
del benchmark aquí, porque el punto no es probar que las dos versiones son
equivalentes, sino obtener una idea general de cómo estas dos implementaciones
se comparan en términos de performance.</p>
<p>Para un benchmark más completo, deberías verificar usando varios textos de
varios tamaños como el <code>contents</code>, diferentes palabras y palabras de diferentes
longitudes como el <code>query</code>, y todo tipo de otras variaciones. El punto es este:
los iterators, aunque son una abstracción de alto nivel, se compilan a
aproximadamente el mismo código que si hubieras escrito el código de más bajo
nivel tú mismo. Los iterators son una de las <em>abstracciones de costo cero</em> de
Rust, por lo que queremos decir que el uso de la abstracción no impone ningún
costo adicional en tiempo de ejecución. Esto es análogo a cómo Bjarne
Stroustrup, el diseñador e implementador original de C++, define <em>cero costo</em> en
“Foundations of C++” (2012):</p>
<blockquote>
<p>En general, las implementaciones de C++ obedecen el principio de cero costo:
lo que no usas, no pagas. Y además: lo que usas, no podrías codificarlo a
mano mejor.</p>
</blockquote>
<p>Como otro ejemplo, el siguiente código es tomado de un decodificador de audio.
El algoritmo de decodificación usa la operación matemática de predicción lineal
para estimar valores futuros basados en una función lineal de las muestras
anteriores. Este código usa un string de iteradores para hacer algunos cálculos
en tres variables en el scope: un slice <code>buffer</code> de datos, un array de 12
<code>coefficients</code>, y una cantidad por la cual desplazar datos en <code>qlp_shift</code>. Hemos
declarado las variables dentro de este ejemplo, pero no les hemos dado ningún
valor; aunque este código no tiene mucho sentido fuera de su contexto, sigue
siendo un ejemplo conciso y del mundo real de cómo Rust traduce ideas de alto
nivel a código de bajo nivel.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p>Para calcular el valor de <code>prediction</code>, este código itera a través de cada uno
de los 12 valores en <code>coefficients</code> y usa el método <code>zip</code> para emparejar los
valores de los coeficientes con los 12 valores anteriores en <code>buffer</code>. Luego,
para cada par, multiplicamos los valores juntos, sumamos todos los resultados y
desplazamos los bits en la suma <code>qlp_shift</code> bits a la derecha.</p>
<p>Calculaciones en aplicaciones como decodificadores de audio a menudo priorizan
el performance. Aquí, estamos creando un iterator, usando dos adaptadores, y
luego consumiendo el valor. ¿Qué código ensamblador compilaría este código Rust?
Bueno, a partir de este escrito, compila al mismo ensamblador que escribirías a
mano. No hay ningún ciclo correspondiente a la iteración sobre los valores en
<code>coefficients</code>: Rust sabe que hay 12 iteraciones, por lo que “desenrolla” el
ciclo. <em>Desenrollar</em> es una optimización que elimina el overhead del código de
control del ciclo y en su lugar genera código repetitivo para cada iteración del
ciclo.</p>
<p>Todos los coeficientes se almacenan en registros, lo que significa que acceder
a los valores es muy rápido. No hay verificaciones de límites en el acceso al
array en tiempo de ejecución. Todas estas optimizaciones que Rust es capaz de
aplicar hacen que el código resultante sea extremadamente eficiente. Ahora que
sabes esto, ¡puedes usar iterators y closures sin miedo! Hacen que el código
parezca de más alto nivel, pero no imponen una penalización de performance en
tiempo de ejecución por hacerlo.</p>
<h2 id="resumen-12"><a class="header" href="#resumen-12">Resumen</a></h2>
<p>Los closures e iterators son características de Rust inspiradas en ideas de
lenguajes de programación funcionales. Contribuyen a la capacidad de Rust de
expresar claramente ideas de alto nivel a bajo nivel de performance. Las
implementaciones de closures e iterators son tales que el performance en tiempo
de ejecución no se ve afectado. Esto es parte de la meta de Rust de esforzarse
por proveer abstracciones de costo cero.</p>
<p>Ahora que mejoramos la expresividad de nuestro proyecto I/O, veamos algunas
características más de <code>cargo</code> que nos ayudarán a compartir el proyecto con el
mundo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="más-sobre-cargo-y-cratesio"><a class="header" href="#más-sobre-cargo-y-cratesio">Más sobre Cargo y Crates.io</a></h1>
<p>Hasta ahora, sólo hemos usado las características más básicas de Cargo para
construir, ejecutar y probar nuestro código, pero puede hacer mucho más. En este
capítulo, discutiremos algunas de sus otras características más avanzadas para
mostrarle cómo hacer lo siguiente:</p>
<ul>
<li>Personaliza tu compilación a través de perfiles de lanzamiento</li>
<li>Publicar bibliotecas en <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Organizar grandes proyectos con workspaces</li>
<li>Instalar binarios de <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Extender Cargo usando comandos personalizados</li>
</ul>
<p>Cargo puede hacer aún más que la funcionalidad que cubrimos en este capítulo,
así que para una explicación completa de todas sus características, consulte la
<a href="https://doc.rust-lang.org/cargo/">documentación</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="personalizando-compilaciones-con-perfiles-de-lanzamiento"><a class="header" href="#personalizando-compilaciones-con-perfiles-de-lanzamiento">Personalizando compilaciones con perfiles de lanzamiento</a></h2>
<p>En Rust, los <em>release profiles</em> son perfiles predefinidos y personalizables con
diferentes configuraciones que permiten a un programador tener más control sobre
varias opciones para compilar código. Cada perfil se configura de forma
independiente de los demás.</p>
<p>Cargo tiene dos perfiles principales: el perfil <code>dev</code> que Cargo usa cuando
ejecutas <code>cargo build</code> y el perfil <code>release</code> que Cargo usa cuando ejecutas
<code>cargo build --release</code>. El perfil <code>dev</code> está definido con buenos valores
predeterminados para el desarrollo, y el perfil <code>release</code> tiene buenos valores
predeterminados para las compilaciones de lanzamiento.</p>
<p>Estos nombres de perfil pueden ser familiares en la salida de tus compilaciones:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p>El perfil <code>dev</code> y <code>release</code> son estos perfiles diferentes utilizados por el
compilador.</p>
<p>Cargo tiene valores predeterminados para cada uno de los perfiles que se
aplican cuando no has agregado explícitamente ninguna sección <code>[profile.*]</code> en
el archivo <em>Cargo.toml</em> del proyecto. Al agregar secciones <code>[profile.*]</code> para
cualquier perfil que desees personalizar, anularás cualquier subconjunto de los
valores predeterminados. Por ejemplo, aquí están los valores predeterminados
para la configuración <code>opt-level</code> para los perfiles <code>dev</code> y <code>release</code>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>El ajuste <code>opt-level</code> controla la cantidad de optimizaciones que Rust aplicará
a tu código, con un rango de 0 a 3. Aplicar más optimizaciones extiende el
tiempo de compilación, por lo que si estás en desarrollo y compilando tu código
con frecuencia, querrás menos optimizaciones para compilar más rápido, incluso
si el código resultante se ejecuta más lento. El <code>opt-level</code> predeterminado para
<code>dev</code> es, por lo tanto, <code>0</code>. Cuando estés listo para lanzar tu código, es mejor
dedicar más tiempo a compilar. Solo compilarás en modo de lanzamiento una vez,
pero ejecutarás el programa compilado muchas veces, por lo que el modo de
lanzamiento intercambia un tiempo de compilación más largo por un código que se
ejecuta más rápido. Es por eso que el <code>opt-level</code> predeterminado para el perfil
<code>release</code> es <code>3</code>.</p>
<p>Puedes anular un ajuste predeterminado agregando un valor diferente para él en
<em>Cargo.toml</em>. Por ejemplo, si queremos usar el nivel de optimización 1 en el
perfil de desarrollo, podemos agregar estas dos líneas al archivo <em>Cargo.toml</em>
del proyecto:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Este código anula la configuración predeterminada de <code>0</code>. Ahora, cuando
ejecutemos <code>cargo build</code>, Cargo usará los valores predeterminados para el perfil
<code>dev</code> más nuestra personalización de <code>opt-level</code>. Debido a que establecimos
<code>opt-level</code> en <code>1</code>, Cargo aplicará más optimizaciones que el valor 
predeterminado, pero no tantas como en una compilación de lanzamiento.</p>
<p>Para la lista completa de opciones de configuración y valores predeterminados
para cada perfil, consulta la 
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">documentación de Cargo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="publicando-un-crate-a-cratesio"><a class="header" href="#publicando-un-crate-a-cratesio">Publicando un Crate a Crates.io</a></h2>
<p>Hasta ahora, hemos usado paquetes de <a href="https://crates.io/">crates.io</a><!-- ignore
--> como dependencias de nuestro proyecto, pero también puedes compartir tu
código con otras personas publicando tus propios paquetes. El registro de
paquetes en <a href="https://crates.io/">crates.io</a><!-- ignore --> distribuye el código
fuente de tus paquetes, por lo que aloja principalmente código que es de código
abierto.</p>
<p>Rust y Cargo tienen características que hacen que tu paquete publicado sea más
fácil de encontrar y usar. Hablaremos sobre algunas de estas características a
continuación y luego explicaremos cómo publicar un paquete.</p>
<h3 id="haciendo-comentarios-de-documentación-útiles"><a class="header" href="#haciendo-comentarios-de-documentación-útiles">Haciendo comentarios de documentación útiles</a></h3>
<p>Documentar adecuadamente tus paquetes ayudará a otros usuarios a saber cómo y
cuándo usarlos, por lo que vale la pena invertir el tiempo para escribir
documentación. En el Capítulo 3, discutimos cómo comentar el código Rust usando
dos barras diagonales, <code>//</code>. Rust también tiene un tipo particular de comentario
para la documentación, conocido convenientemente como un <em>comentario de
documentación</em>, que generará documentación HTML. El HTML muestra el contenido
de los comentarios de documentación para los elementos de API públicos
destinados a programadores interesados en saber cómo <em>usar</em> tu paquete en
oposición a cómo se <em>implementa</em> tu paquete.</p>
<p>Los comentarios de documentación usan tres barras diagonales, <code>///</code>, en lugar
de dos y admiten la notación Markdown para formatear el texto. Coloca los
comentarios de documentación justo antes del elemento que están documentando.
El Listado 14-1 muestra comentarios de documentación para una función <code>add_one</code>
en un crate llamado <code>my_crate</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p><span class="caption">Listing 14-1: Un comentario de documentación para una
función</span></p>
<p>Aquí, damos una descripción de lo que hace la función <code>add_one</code>, comenzamos una
sección con el encabezado <code>Examples</code> y luego proporcionamos código que
demuestra cómo usar la función <code>add_one</code>. Podemos generar la documentación HTML
de este comentario de documentación ejecutando <code>cargo doc</code>. Este comando ejecuta
la herramienta <code>rustdoc</code> distribuida con Rust y coloca la documentación HTML
generada en el directorio <em>target/doc</em>.</p>
<p>Por conveniencia, ejecutar <code>cargo doc --open</code> generará el HTML para la
documentación de tu crate actual (así como la documentación para todas las
dependencias de tu crate) y abrirá el resultado en un navegador web. Navega
hasta la función <code>add_one</code> y verás cómo se renderiza el texto en los comentarios
de documentación, como se muestra en la Figura 14-1:</p>
<img alt="Documentación HTML renderizada para la función `add_one` de `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Figura 14-1: documentación en HTML para la función
<code>add_one</code></span></p>
<h4 id="secciones-comúnmente-usadas"><a class="header" href="#secciones-comúnmente-usadas">Secciones comúnmente usadas</a></h4>
<p>Hemos usado el encabezado de Markdown <code># Examples</code> en el Listado 14-1 para crear
una sección en el HTML con el título &quot;Examples&quot;. Aquí hay algunas otras
secciones que los autores de crates comúnmente usan en su documentación:</p>
<ul>
<li><strong>Panics</strong>: Los escenarios en los que la función documentada podría
entrar en panic. Los llamadores de la función que no quieren que sus
programas entren en panic deben asegurarse de no llamar a la función en
estas situaciones.</li>
<li><strong>Errores</strong>: Si la función devuelve un <code>Result</code>, describir los tipos de
errores que podrían ocurrir y qué condiciones podrían hacer que esos errores
se devuelvan puede ser útil para los llamadores para que puedan escribir
código para manejar los diferentes tipos de errores de diferentes maneras.</li>
<li><strong>Seguridad</strong>: Si la función es <code>unsafe</code> de llamar (discutimos unsafe en
el Capítulo 19), debería haber una sección que explique por qué la función es
insegura y cubra las invariantes que la función espera que los llamadores
mantengan.</li>
</ul>
<p>La mayoría de los comentarios de documentación no necesitan todas estas
secciones, pero esta es una buena lista de verificación para recordar los
aspectos del código que los usuarios estarán interesados en saber.</p>
<h4 id="comentarios-de-documentacion-como-tests"><a class="header" href="#comentarios-de-documentacion-como-tests">Comentarios de documentacion como Tests</a></h4>
<p>Agregar bloques de código de ejemplo en tus comentarios de documentación puede
ayudar a demostrar cómo usar tu biblioteca, y hacerlo tiene una ventaja
adicional: ¡ejecutar <code>cargo test</code> ejecutará los ejemplos de código en tu
documentación como pruebas! Nada es mejor que la documentación con ejemplos.
Pero nada es peor que los ejemplos que no funcionan porque el código ha cambiado
desde que se escribió la documentación. Si ejecutamos <code>cargo test</code> con la
documentación para la función <code>add_one</code> del Listado 14-1, veremos una sección en
los resultados de la prueba como esta:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>¡Ahora si cambiamos la función o el ejemplo para que el <code>assert_eq!</code> en el
ejemplo entre en pánico y ejecutamos <code>cargo test</code> nuevamente, veremos que los
doc tests capturan que el ejemplo y el código están fuera de sincronización
entre sí!</p>
<h4 id="comentando-items-contenidos"><a class="header" href="#comentando-items-contenidos">Comentando items contenidos</a></h4>
<p>El estilo de comentario de doc <code>//!</code> agrega documentación al item que contiene
los comentarios en lugar de a los items que siguen a los comentarios.
Normalmente, usamos estos comentarios de documentación dentro del archivo raíz
del crate (<em>src/lib.rs</em> por convención) o dentro de un módulo para documentar el
crate o el módulo en su conjunto.</p>
<p>Por ejemplo, para agregar documentación que describe el propósito del crate
<code>my_crate</code> que contiene la función <code>add_one</code>, agregamos comentarios de
documentación que comienzan con <code>//!</code> al principio del archivo <em>src/lib.rs</em>,
como se muestra en el Listado 14-2:</p>
<p><span class="filename">Nombre de archivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 14-2: Documentación para el crate <code>my_crate</code> como
un todo</span></p>
<p>Observa que no hay ningún código después de la última línea que comienza con
<code>//!</code>. Debido a que comenzamos los comentarios con <code>//!</code> en lugar de <code>///</code>,
estamos documentando el item que contiene este comentario en lugar de un item
que sigue a este comentario. En este caso, ese item es el archivo <em>src/lib.rs</em>,
que es el crate root. Estos comentarios describen todo el crate.</p>
<p>Cuando ejecutamos <code>cargo doc --open</code> ahora, veremos la documentación para el
crate <code>my_crate</code> en lugar de la documentación para la función <code>add_one</code>, como
se muestra en la Figura 14-2:</p>
<img alt="Documentación HTML renderizada con un comentario para el crate como un todo" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Figura 14-2: Documentación renderizada para <code>my_crate</code>,
incluido el comentario que describe el crate como un todo</span></p>
<p>Los comentarios de documentación dentro de los items son útiles para describir
crates y módulos en particular. Úsalos para explicar el propósito general del
contenedor para ayudar a tus usuarios a comprender la organización del crate.</p>
<h3 id="exportando-una-api-publica-conveniente-con-pub-use"><a class="header" href="#exportando-una-api-publica-conveniente-con-pub-use">Exportando una API publica conveniente con <code>pub use</code></a></h3>
<p>La estructura de tu API pública es una consideración importante al publicar un
crate. Las personas que usan tu crate están menos familiarizadas con la
estructura que tú y podrían tener dificultades para encontrar las piezas que
desean usar si tu crate tiene una gran jerarquía de módulos.</p>
<p>En el Capítulo 7, cubrimos cómo hacer que los items sean públicos usando la
palabra clave <code>pub</code> y traer items a un scope con la palabra clave <code>use</code>.
Sin embargo, la estructura que tiene sentido para ti mientras desarrollas un
crate puede que no sea muy conveniente para tus usuarios. Es posible que desees
organizar tus structs en una jerarquía que contenga varios niveles, pero luego
las personas que desean usar un tipo que has definido profundamente en la
jerarquía podrían tener problemas para descubrir que ese tipo existe. También
podrían estar molestos por tener que ingresar <code>use</code>
<code>my_crate::some_module::another_module::UsefulType;</code> en lugar de <code>use</code>
<code>my_crate::UsefulType;</code>.</p>
<p>Las buenas noticias son que si la estructura <em>no</em> es conveniente para que otros
la usen desde otra biblioteca, no tienes que reorganizar tu organización
interna: en su lugar, puedes reexportar items para hacer una estructura pública
que sea diferente de tu estructura privada usando <code>pub use</code>. Reexportar toma un
item público en una ubicación y lo hace público en otra ubicación, como si se
definiera en la otra ubicación en su lugar.</p>
<p>Por ejemplo, supongamos que creamos una biblioteca llamada <code>art</code> para modelar
conceptos artísticos. Dentro de esta biblioteca hay dos módulos: un módulo
<code>kinds</code> que contiene dos enums llamados <code>PrimaryColor</code> y <code>SecondaryColor</code> y un
módulo <code>utils</code> que contiene una función llamada <code>mix</code>, como se muestra en el
Listado 14-3:</p>
<p><span class="filename">Nombre de archivo: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
<p><span class="caption">Listado 14-3: Una biblioteca llamada <code>art</code> con items
organizados en los módulos <code>kinds</code> y <code>utils</code></span></p>
<p>La Figura 14-3 muestra cómo se vería la página frontal de la documentación para
este crate generada por <code>cargo doc</code>:</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Figure 14-3: Página principal de la documentación de <code>art</code>
que enumera los módulos <code>kinds</code> y <code>utils</code></span></p>
<p>Nota que los tipos <code>PrimaryColor</code> y <code>SecondaryColor</code> no están listados en la
página principal. Tampoco lo está la función <code>mix</code>. Para verlos, tendríamos que
hacer clic en <code>kinds</code> y <code>utils</code>.</p>
<p>Otro crate que depende de esta biblioteca necesitaría declarar un <code>use</code> que
traigan los items de <code>art</code> al scope, especificando la estructura de módulos
actualmente definida. El Listado 14-4 muestra un ejemplo de un crate que usa
los items <code>PrimaryColor</code> y <code>mix</code> del crate <code>art</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<p><span class="caption">Listado 14-4: Un crate que utiliza los items del crate
<code>art</code> con su estructura interna exportada</span></p>
<p>El autor del código en el Listado 14-4, que usa el crate <code>art</code>, tuvo que
averiguar que <code>PrimaryColor</code> está en el módulo <code>kinds</code> y <code>mix</code> está en el
módulo <code>utils</code>. La estructura de módulos del crate <code>art</code> es más relevante para
los desarrolladores que trabajan en el crate <code>art</code> que para aquellos que lo
usan. La estructura interna no contiene ninguna información útil para alguien
que intenta comprender cómo usar el crate <code>art</code>, sino que causa confusión
porque los desarrolladores que lo usan tienen que averiguar dónde buscar y
deben especificar los nombres de módulo en las declaraciones <code>use</code>.</p>
<p>Para remover la estructura interna de la API pública, podemos modificar el
código del crate <code>art</code> en el Listado 14-3 para agregar declaraciones <code>pub use</code>
para reexportar los items en el nivel superior, como se muestra en el Listado
14-5:</p>
<p><span class="filename">Nombre de archivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listado 14-5: Agregando declaraciones <code>pub use</code> para
re-exportar items</span></p>
<p>La documentación de la API que <code>cargo doc</code> genera para este crate ahora
listará y enlazará los reexports en la página principal, como se muestra en la
Figura 14-4, haciendo que los tipos <code>PrimaryColor</code> y <code>SecondaryColor</code> y la
función <code>mix</code> sean más fáciles de encontrar.</p>
<img alt="Documentación renderizada para el crate `art` con las re-exportaciones en la página principal" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Figura 14-4: La página principal de la documentación para
<code>art</code> que lista las re-exportaciones</span></p>
<p>Los usuarios del crate <code>art</code> aún pueden ver y usar la estructura interna del
Listado 14-3 como se demuestra en el Listado 14-4, o pueden usar la estructura
más conveniente del Listado 14-5, como se muestra en el Listado 14-6:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
<p><span class="caption">Listado 14-6: Un programa que utiliza los items
reexportados del crate <code>art</code></span></p>
<p>En casos donde hay muchos módulos anidados, reexportar los tipos en el nivel
superior con <code>pub use</code> puede hacer una diferencia significativa en la
experiencia de las personas que usan el crate. Otro uso común de <code>pub use</code> es
reexportar definiciones de una dependencia en el crate actual para hacer que
las definiciones de ese crate sean parte de la API pública de su crate.</p>
<p>Crear una estructura de API pública es más un arte que una ciencia, y puedes
iterar para encontrar la API que funcione mejor para tus usuarios. Elegir <code>pub use</code> te da flexibilidad en cómo estructuras tu crate internamente y desacopla
esa estructura interna de lo que presentas a tus usuarios. Mira algo del código
de los crates que has instalado para ver si su estructura interna difiere de su
API pública.</p>
<h3 id="configurando-una-cuenta-de-cratesio"><a class="header" href="#configurando-una-cuenta-de-cratesio">Configurando una cuenta de Crates.io</a></h3>
<p>Antes de que puedas publicar cualquier crate, necesitas crear una cuenta en
<a href="https://crates.io/">crates.io</a><!-- ignore --> y obtener un token de API. Para
hacerlo, visita la página de inicio en
<a href="https://crates.io/">crates.io</a><!-- ignore --> e inicia sesión a través de una
cuenta de GitHub. (La cuenta de GitHub es actualmente un requisito, pero el
sitio podría admitir otras formas de crear una cuenta en el futuro). Una vez
que hayas iniciado sesión, visita la configuración de tu cuenta en
<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> y recupera tu
clave de API. Luego ejecuta el comando <code>cargo login</code> y pega tu clave de la API, 
cuando se solicitad, como se muestra a continuación:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Este comando informará a Cargo de tu token de API y lo almacenará localmente en
<em>~/.cargo/credentials</em>. Ten en cuenta que este token es un <em>secreto</em>: no lo
compartas con nadie. Si lo compartes con alguien por cualquier motivo, debes
revocarlo y generar un nuevo token en
<a href="https://crates.io/">crates.io</a><!-- ignore -->.</p>
<h3 id="agregando-metadata-a-un-nuevo-crate"><a class="header" href="#agregando-metadata-a-un-nuevo-crate">Agregando metadata a un nuevo crate</a></h3>
<p>Supongamos que tienes un crate que deseas publicar. Antes de publicarlo,
necesitarás agregar algunos metadatos en la sección <code>[package]</code> del archivo
<em>Cargo.toml</em> del crate.</p>
<p>Tu crate necesitará un nombre único. Mientras trabajas en un crate localmente,
puedes nombrar un crate como quieras. Sin embargo, los nombres de los crates en
<a href="https://crates.io/">crates.io</a><!-- ignore --> se asignan por orden de llegada.
Una vez que se toma un nombre de crate, nadie más puede publicar un crate con
ese nombre. Antes de intentar publicar un crate, busca el nombre que deseas
usar. Si el nombre ha sido usado, deberás encontrar otro nombre y editar el
campo <code>name</code> en el archivo <em>Cargo.toml</em> bajo la sección <code>[package]</code> para usar
el nuevo nombre para publicar, como se muestra a continuación:</p>
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Incluso si has elegido un nombre único, cuando ejecutes <code>cargo publish</code> para
publicar el crate en este punto, obtendrás una advertencia y luego un error:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>Estos errores se deben a que te faltan algunos datos cruciales: se requiere una
descripción y una licencia para que las personas sepan qué hace tu crate y
bajo qué términos pueden usarlo. En <em>Cargo.toml</em>, agrega una descripción que
sea solo una o dos oraciones, porque aparecerá con tu crate en los resultados
de búsqueda. Para el campo <code>license</code>, debes dar un <em>valor de identificador de
licencia</em>. La <a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data Exchange (SPDX)</a>
enumera los identificadores que puedes usar para este valor. Por ejemplo, para
especificar que has licenciado tu crate usando la Licencia MIT, agrega el
identificador <code>MIT</code>:</p>
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>Si tu deseas especificar una licencia que no aparece en el SPDX, necesitas
colocar el texto de esa licencia en un archivo, incluir el archivo en tu
proyecto y luego usar <code>license-file</code> para especificar el nombre de ese archivo
en lugar de usar la key <code>license</code>.</p>
<p>La orientación sobre qué licencia es apropiada para tu proyecto está fuera del
alcance de este libro. Muchas personas en la comunidad de Rust licencian sus
proyectos de la misma manera que Rust, usando una licencia dual de <code>MIT OR Apache-2.0</code>. Esta práctica demuestra que también puedes especificar múltiples
identificadores de licencia separados por <code>OR</code> para tener múltiples licencias
para tu proyecto.</p>
<p>Con un nombre único, la versión, una descripción y una licencia agregados, el
archivo <em>Cargo.toml</em> para un proyecto que está listo para publicar podría
verse así:</p>
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">La documentación de Cargo</a> describe otros
metadatos que puedes especificar para asegurarte de que otros puedan descubrir
y usar tu crate más fácilmente.</p>
<h3 id="publicando-en-cratesio"><a class="header" href="#publicando-en-cratesio">Publicando en Crates.io</a></h3>
<p>Ahora que has creado una cuenta, guardado tu token de API, elegido un nombre
para tu crate y especificado los metadatos requeridos, ¡estás listo para
publicar! Publicar un crate carga una versión específica en
<a href="https://crates.io/">crates.io</a><!-- ignore --> para que otros la usen.</p>
<p>Ten cuidado, porque una publicación es <em>permanente</em>. La versión nunca se puede
sobrescribir y el código no se puede eliminar. Uno de los principales objetivos
de <a href="https://crates.io/">crates.io</a><!-- ignore --> es actuar como un archivo
permanente de código para que las compilaciones de todos los proyectos que
dependen de crates de <a href="https://crates.io/">crates.io</a><!-- ignore --> sigan
funcionando. Permitir la eliminación de versiones haría imposible cumplir ese
objetivo. Sin embargo, no hay límite en la cantidad de versiones de crate que
puedes publicar.</p>
<p>Ejecuta el comando <code>cargo publish</code> otra vez. Esta vez, debería tener éxito:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>¡Felicidades! Ahora has compartido tu código con la comunidad de Rust y
cualquiera puede agregar tu crate como una dependencia de su proyecto.</p>
<h3 id="publicando-una-nueva-versión-de-un-crate-existente"><a class="header" href="#publicando-una-nueva-versión-de-un-crate-existente">Publicando una Nueva Versión de un Crate Existente</a></h3>
<p>Cuando hayas realizado cambios en tu crate y estés listo para publicar una
nueva versión, cambia el valor <code>version</code> especificado en tu archivo
<em>Cargo.toml</em> y vuelve a publicar. Usa las
<a href="http://semver.org/">reglas de versionado semántico</a> para decidir cuál es el siguiente
número de versión apropiado en función de los tipos de cambios que hayas
realizado. Luego, ejecuta <code>cargo publish</code> para cargar la nueva versión.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="deprecando-versiones-de-cratesio-con-cargo-yank"><a class="header" href="#deprecando-versiones-de-cratesio-con-cargo-yank">Deprecando Versiones de Crates.io con <code>cargo yank</code></a></h3>
<p>Aunque no puedes eliminar versiones anteriores de un crate, puedes evitar que
cualquier proyecto futuro las agregue como una nueva dependencia. Esto es útil
cuando una versión de crate está rota por una razón u otra. En tales
situaciones, Cargo admite <em>yanking</em> una versión de crate.</p>
<p>Hacer un <em>yank</em> a una versión impide que nuevos proyectos dependan de esa
versión, pero permite que todos los proyectos existentes que dependen de ella
continúen. Esencialmente, un <em>yank</em> significa que todos los proyectos con un
<em>Cargo.lock</em> no se romperán y que cualquier <em>Cargo.lock</em> futuro generado no
usará la versión <em>yanked</em>.</p>
<p>Para hacer un <em>yank</em> de una versión de un crate, en el directorio del crate que
has publicado previamente, ejecuta <code>cargo yank</code> y especifica qué versión
deseas <em>yank</em>. Por ejemplo, si hemos publicado un crate llamado
<code>guessing_game</code> versión 1.0.1 y queremos <em>yank</em> la versión, en el directorio
del proyecto para <code>guessing_game</code> ejecutaríamos:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>Al agregar <code>--undo</code> al comando, también puedes deshacer un <em>yank</em> y permitir
que los proyectos vuelvan a depender de una versión:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>Un <em>yank</em> no borra ningún código. No puede, por ejemplo, eliminar secretos
cargados accidentalmente. Si eso sucede, debes restablecer esos secretos
inmediatamente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-workspaces"><a class="header" href="#cargo-workspaces">Cargo Workspaces</a></h2>
<p>En el Capítulo 12, construimos un paquete que incluía un <em>crate</em> binario y un
<em>crate</em> de biblioteca. A medida que su proyecto se desarrolle, es posible que
encuentre que el <em>crate</em> de biblioteca continúa creciendo y que desea dividir
su paquete aún más en múltiples <em>crate</em> de biblioteca. Cargo ofrece una
característica llamada <em>workspaces</em> que puede ayudar a administrar múltiples
paquetes relacionados que se desarrollan en tándem.</p>
<h3 id="creando-un-workspace"><a class="header" href="#creando-un-workspace">Creando un Workspace</a></h3>
<p>Un <em>workspace</em> es un conjunto de paquetes que comparten el mismo <em>Cargo.lock</em> y
el directorio de salida. Hagamos un proyecto usando un <em>workspace</em> - usaremos
código trivial para que podamos concentrarnos en la estructura del
<em>workspace</em>. Hay varias formas de estructurar un <em>workspace</em>, así que solo
mostraremos una forma común. Tendremos un <em>workspace</em> que contiene un binario y
dos bibliotecas. El binario, que proporcionará la funcionalidad principal,
dependerá de las dos bibliotecas. Una biblioteca proporcionará una función
<code>add_one</code>, y una segunda biblioteca una función <code>add_two</code>. Estas tres cajas
serán parte del mismo <em>workspace</em>. Comenzaremos creando un nuevo directorio
para el <em>workspace</em>:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Luego, en el directorio <em>add</em>, crearemos el archivo <em>Cargo.toml</em> que
configurará todo el <em>workspace</em>. Este archivo no tendrá una sección <code>[package]</code>.
En su lugar, comenzará con una sección <code>[workspace]</code> que nos permitirá agregar
miembros al <em>workspace</em> especificando la ruta al paquete con nuestro <em>crate</em>
binario; en este caso, esa ruta es <em>adder</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>A continuación, crearemos el crate binario <code>adder</code> ejecutando <code>cargo new</code> 
dentro del directorio <em>add</em>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>En este punto, podemos construir el <em>workspace</em> ejecutando <code>cargo build</code>. Los
archivos en su directorio <em>add</em> deberían verse así:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>El <em>workspace</em> tiene un directorio <em>target</em> en el nivel superior que contendrá
los artefactos compilados. El paquete <code>adder</code> no tiene su propio directorio
<em>target</em>. Incluso si ejecutáramos <code>cargo build</code> desde dentro del directorio
<em>adder</em>, los artefactos compilados aún terminarían en <em>add/target</em> en lugar de
<em>add/adder/target</em>. Cargo estructura el directorio <em>target</em> en un <em>workspace</em>
de esta manera porque los <em>crate</em> en un <em>workspace</em> están destinados a
dependerse entre sí. Si cada <em>crate</em> tuviera su propio directorio <em>target</em>,
cada <em>crate</em> tendría que volver a compilar cada uno de los otros <em>crate</em> en el
<em>workspace</em> para colocar los artefactos en su propio directorio <em>target</em>. Al
compartir un directorio <em>target</em>, los <em>crate</em> pueden evitar la reconstrucción
innecesaria.</p>
<h3 id="creando-el-segundo-paquete-en-el-workspace"><a class="header" href="#creando-el-segundo-paquete-en-el-workspace">Creando el Segundo Paquete en el Workspace</a></h3>
<p>A continuación crearemos otro paquete miembro en el <em>workspace</em> y lo llamaremos
<code>add_one</code>. Cambie el <em>Cargo.toml</em> de nivel superior para especificar la ruta
<em>add_one</em> en la lista de <code>members</code>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add_one&quot;,
]
</code></pre>
<p>Luego generaremos un nuevo <em>crate</em> de biblioteca llamado <code>add_one</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
</code></pre>
<p>Tu directorio <em>add</em> debería tener estos directorios y archivos:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>En el archivo <em>add_one/lib.rs</em>, agreguemos una función <code>add_one</code>:</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Ahora podemos hacer que el paquete <code>adder</code> con nuestro binario dependa del 
paquete <code>add_one</code> con nuestra biblioteca. Primero, necesitaremos agregar una
dependencia de ruta en <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Filename: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = &quot;../add_one&quot; }
</code></pre>
<p>Cargo no asume que los crates en un <em>workspace</em> dependerán entre sí, por lo que
necesitamos ser explícitos sobre las relaciones de dependencia.</p>
<p>A continuación, usaremos la función <code>add_one</code> (del <em>crate</em> <code>add_one</code>) en el
crate <code>adder</code>. Abra el archivo <em>adder/src/main.rs</em> y agregue una línea <code>use</code>
en la parte superior para traer el nuevo <em>crate</em> de biblioteca <code>add_one</code> al
alcance. Luego cambie la función <code>main</code> para llamar a la función <code>add_one</code>, como
en el Listado 14-7.</p>
<p><span class="filename">Filename: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {num} plus one is {}!&quot;, add_one::add_one(num));
}</code></pre>
<p><span class="caption">Listing 14-7: Usando el crate de biblioteca <code>add_one</code> 
desde el crate <code>adder</code></span></p>
<p>¡Construyamos el workspace ejecutando <code>cargo build</code> en el directorio superior
<em>add</em>!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>Para ejecutar el crate binario desde el directorio <em>add</em>, podemos especificar
qué paquete en el <em>workspace</em> queremos ejecutar con el argumento <code>-p</code> y el
nombre del paquete con <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Esto ejecuta el código en <em>adder/src/main.rs</em>, que depende del crate <code>add_one</code>.</p>
<h4 id="dependiendo-de-un-paquete-externo-en-un-workspace"><a class="header" href="#dependiendo-de-un-paquete-externo-en-un-workspace">Dependiendo de un Paquete Externo en un Workspace</a></h4>
<p>Observa que el workspace tiene solo un archivo <em>Cargo.lock</em> en el nivel
superior, en lugar de tener un <em>Cargo.lock</em> en cada directorio de <em>crate</em>.
Esto asegura que todos los <em>crate</em> estén usando la misma versión de todas las
dependencias. Si agregamos el paquete <code>rand</code> al <em>Cargo.toml</em> de <em>adder</em> y
<em>add_one</em>, Cargo resolverá ambos a una versión de <code>rand</code> y lo registrará en el
único <em>Cargo.lock</em>. Hacer que todos los <em>crate</em> en el <em>workspace</em> usen las
mismas dependencias significa que los <em>crate</em> siempre serán compatibles entre
sí. Agreguemos el <em>crate</em> <code>rand</code> a la sección <code>[dependencies]</code> en el archivo
<em>add_one/Cargo.toml</em> para que podamos usar el <em>crate</em> <code>rand</code> en el <em>crate</em>
<code>add_one</code>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Filename: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>Ahora podemos agregar <code>use rand;</code> al archivo <em>add_one/src/lib.rs</em>, y construir
todo el <em>workspace</em> ejecutando <code>cargo build</code> en el directorio <em>add</em> traerá e
compilará el <em>crate</em> <code>rand</code>. Obtendremos una advertencia porque no nos estamos
refiriendo al <code>rand</code> que trajimos al scope:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>El archivo <em>Cargo.lock</em> de nivel superior ahora contiene información sobre la
dependencia de <code>add_one</code> en <code>rand</code>. Sin embargo, aunque <code>rand</code> se usa en algún
lugar del <em>workspace</em>, no podemos usarlo en otros <em>crate</em> del <em>workspace</em> a
menos que agreguemos <code>rand</code> a sus archivos <em>Cargo.toml</em> también. Por ejemplo,
si agregamos <code>use rand;</code> al archivo <em>adder/src/main.rs</em> para el paquete
<code>adder</code>, obtendremos un error:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>Para solucionar esto, edita el archivo <em>Cargo.toml</em> del paquete <code>adder</code> e
indica que <code>rand</code> es una dependencia para él también. Construir el paquete
<code>adder</code> agregará <code>rand</code> a la lista de dependencias para <code>adder</code> en
<em>Cargo.lock</em>, pero no se descargarán copias adicionales de <code>rand</code>. Cargo se 
asegurara de que cada <em>crate</em> en cada paquete en el <em>workspace</em> que usa el
paquete <code>rand</code> estará usando la misma versión siempre y cuando se especifiquen 
como versiones compatibles de <code>rand</code>, ahorrándonos espacio y asegurando que los 
<em>crate</em> en el <em>workspace</em> serán compatibles entre sí.</p>
<h4 id="agregando-un-test-a-un-workspace"><a class="header" href="#agregando-un-test-a-un-workspace">Agregando un Test a un Workspace</a></h4>
<p>Para otra mejora, agreguemos una prueba de la función <code>add_one::add_one</code> dentro
del <em>crate</em> <code>add_one</code>:</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}</code></pre>
<p>Ahora ejecutamos <code>cargo test</code> en el directorio superior <em>add</em> para ejecutar los 
tests una estructura de workspace como esta ejecutará los tests para todos los
crates en el workspace:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>La primera sección del output muestra que el test <code>it_works</code> en el crate
<code>add_one</code> pasó. La siguiente sección muestra que no se encontraron tests en el
crate <code>adder</code>, y luego la última sección muestra que no se encontraron tests de
documentación en el crate <code>add_one</code>.</p>
<p>También podemos ejecutar tests para un crate en particular en el workspace
desde el directorio superior usando la bandera <code>-p</code> y especificando el nombre
del crate que queremos testear:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Este output muestra que <code>cargo test</code> solo ejecutó los tests para el crate
<code>add_one</code> y no ejecutó los tests del crate <code>adder</code>.</p>
<p>Si tu publicas los crates en el workspace en <a href="https://crates.io/">crates.io</a>,
cada crate en el workspace necesitará ser publicado por separado. Como <code>cargo test</code>, podemos publicar un crate en particular en nuestro workspace usando la
bandera <code>-p</code> y especificando el nombre del crate que queremos publicar.</p>
<p>Para practicar aún más, agrega un crate <code>add_two</code> a este workspace de manera
similar al crate <code>add_one</code>!</p>
<p>Conforme tu proyecto crece, considera usar un workspace: es más fácil de entender
componentes pequeños e individuales que un gran blob de código. Además,
mantener los crates en un workspace puede hacer que la coordinación entre
crates sea más fácil si se cambian a menudo al mismo tiempo.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="instalando-binarios-con-cargo-install"><a class="header" href="#instalando-binarios-con-cargo-install">Instalando Binarios con <code>cargo install</code></a></h2>
<p>El comando <code>cargo install</code> te permite instalar y usar crates binarios localmente.
Esto no está destinado a reemplazar los paquetes del sistema; está destinado a 
ser una forma conveniente para que los desarrolladores de Rust instalen 
herramientas que otros han compartido en <a href="https://crates.io/">crates.io</a><!-- 
ignore -->. Tenga en cuenta que solo puede instalar paquetes que tengan 
objetivos binarios. Un <em>objetivo binario</em> es el programa ejecutable que se crea 
si el crate tiene un archivo <em>src/main.rs</em> u otro archivo especificado como un 
binario, en oposición a un objetivo de biblioteca que no se puede ejecutar por 
sí solo, pero que es adecuado para incluirlo en otros programas. Por lo general, 
las crates tienen información en el archivo <em>README</em> sobre si una crate es una 
biblioteca, tiene un objetivo binario, o ambos.</p>
<p>Todos los binarios instalados con <code>cargo install</code> se almacenan en la carpeta
raíz de instalación de <em>bin</em>. Si instalaste Rust usando <em>rustup.rs</em> y no tienes
configuraciones personalizadas, este directorio será <em>$HOME/.cargo/bin</em>. 
Asegúrese de que el directorio de instalación esté en su <code>$PATH</code> para poder 
ejecutar los programas que ha instalado con <code>cargo install</code>.</p>
<p>Por ejemplo, en el Capítulo 12, mencionamos que hay una implementación de Rust
de la herramienta <code>grep</code> llamada <code>ripgrep</code> para buscar archivos. Para instalar
<code>ripgrep</code>, podemos ejecutar lo siguiente:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>La penúltima línea de la salida muestra la ubicación y el nombre del binario
instalado, que en el caso de <code>ripgrep</code> es <code>rg</code>. Mientras el directorio de
instalación esté en su <code>$PATH</code>, como se mencionó anteriormente, puede ejecutar
<code>rg --help</code> y comenzar a usar una herramienta más rápida y oxidada para buscar
archivos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="extendiendo-cargo-con-comandos-personalizados"><a class="header" href="#extendiendo-cargo-con-comandos-personalizados">Extendiendo Cargo con comandos personalizados</a></h2>
<p>Cargo está diseñado para que puedas extenderlo con nuevos subcomandos sin tener
que modificar Cargo. Si un binario en tu <code>$PATH</code> se llama <code>cargo-something</code>, lo
puedes ejecutar como si fuera un subcomando de Cargo ejecutando <code>cargo something</code>. Los comandos personalizados como este también se enumeran cuando
ejecutas <code>cargo --list</code>. ¡Poder usar <code>cargo install</code> para instalar extensiones y
luego ejecutarlas como las herramientas integradas de Cargo es un beneficio
súper conveniente del diseño de Cargo!</p>
<h2 id="resumen-13"><a class="header" href="#resumen-13">Resumen</a></h2>
<p>Compartir código con Cargo y <a href="https://crates.io/">crates.io</a><!-- ignore --> es
parte de lo que hace que el ecosistema de Rust sea útil para muchas tareas
diferentes. La biblioteca estándar de Rust es pequeña y estable, pero los crates
son fáciles de compartir, usar y mejorar en una línea de tiempo diferente a la
del lenguaje. ¡No seas tímido al compartir código que te sea útil en
<a href="https://crates.io/">crates.io</a><!-- ignore -->; es probable que también sea útil
para otra persona!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<p>Un <em>puntero</em> es un concepto general para una variable que contiene una dirección
en memoria. Esta dirección se refiere, o “apunta a,” algún otro dato. El tipo
más común de puntero en Rust es una referencia, la cual aprendiste en el
Capítulo 4. Las referencias son indicadas por el símbolo <code>&amp;</code> y toman prestado
el valor al que apuntan. No tienen ninguna capacidad especial más allá de
referirse a datos, y no tienen sobrecarga.</p>
<p>Los <em>Smart pointers,</em> por otro lado, son estructuras de datos que actúan como un
puntero, pero también tienen metadatos y capacidades adicionales. El concepto de
smart pointers no es único de Rust: los smart pointers se originaron en C++ y
existen en otros lenguajes también. Rust tiene una variedad de smart pointers
definidos en la biblioteca estándar que proveen funcionalidad más allá de la
proveída por las referencias. Para explorar el concepto general, veremos un
par de ejemplos diferentes de smart pointers, incluyendo un tipo de puntero
<em>reference counting</em>. Este puntero te permite permitir que los datos tengan
múltiples propietarios al mantener un registro del número de propietarios y,
cuando no hay propietarios restantes, limpiar los datos.</p>
<p>Rust, con su concepto de propiedad y préstamo, tiene una diferencia adicional
entre referencias y smart pointers: mientras que las referencias solo toman
prestado los datos, en muchos casos, los smart pointers <em>son dueños</em> de los
datos a los que apuntan.</p>
<p>Aunque no los llamamos así en ese momento, ya hemos encontrado algunos smart
pointers en este libro, incluyendo <code>String</code> y <code>Vec&lt;T&gt;</code> en el Capítulo 8. Ambos
estos tipos cuentan como smart pointers porque poseen algo de memoria y te
permiten manipularla. También tienen metadatos y capacidades o garantías
adicionales. <code>String</code>, por ejemplo, almacena su capacidad como metadato y tiene
la capacidad adicional de asegurar que sus datos siempre serán UTF-8 válidos.</p>
<p>Los smart pointers usualmente son implementados usando structs. A diferencia de
un struct ordinaria, los smart pointers implementan los traits <code>Deref</code> y
<code>Drop</code>. El trait <code>Deref</code> permite que una instancia de la struct smart pointer se
comporte como una referencia, así que puedes escribir tu código para trabajar
con referencias o smart pointers. El trait <code>Drop</code> te permite personalizar el
código que se ejecuta cuando una instancia del smart pointer sale del scope. En
este capítulo, discutiremos ambos traits y demostraremos por qué son
importantes para los smart pointers.</p>
<p>Dado que el patrón de smart pointer es un patrón de diseño general usado
frecuentemente en Rust, este capítulo no cubrirá todos los smart pointers
existentes. Muchas bibliotecas tienen sus propios smart pointers, e incluso
puedes escribir los tuyos. Cubriremos los smart pointers más comunes en la
biblioteca estándar:</p>
<ul>
<li><code>Box&lt;T&gt;</code> para asignar valores en el heap</li>
<li><code>Rc&lt;T&gt;</code>, un tipo de conteo de referencias que permite múltiples ownerships</li>
<li><code>Ref&lt;T&gt;</code> y <code>RefMut&lt;T&gt;</code>, accedidos a través de <code>RefCell&lt;T&gt;</code>, un tipo que
impone las reglas de borrowing en tiempo de ejecución en lugar de tiempo de
compilación</li>
</ul>
<p>Además, cubriremos el patrón <em>interior mutability</em> donde un tipo inmutable
expone una API para mutar un valor interior. También discutiremos <em>reference
cycles</em>: cómo pueden fugar memoria y cómo prevenirlos.</p>
<p>¡Vamos a profundizar en los smart pointers!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-boxt-para-apuntar-a-datos-en-el-heap"><a class="header" href="#usando-boxt-para-apuntar-a-datos-en-el-heap">Usando <code>Box&lt;T&gt;</code> para Apuntar a Datos en el Heap</a></h2>
<p>La forma más sencilla de smart pointer es un <em>box</em>, cuyo tipo se escribe <code>Box&lt;T&gt;</code>.
Los boxes te permiten almacenar datos en el heap en lugar del stack. Lo que
permanece en el stack es el puntero a los datos del heap. Refiérete al Capítulo 4
para revisar la diferencia entre el stack y el heap.</p>
<p>Los boxes no tienen overhead de performance, más allá de almacenar sus datos en
el heap en lugar del stack. Pero tampoco tienen muchas capacidades adicionales.
Los usarás más frecuentemente en estas situaciones:</p>
<ul>
<li>Cuando tienes un tipo cuyo tamaño no puede ser conocido en tiempo de
compilación y quieres usar un valor de ese tipo en un contexto que requiere un
tamaño exacto</li>
<li>Cuando tienes una gran cantidad de datos y quieres transferir el ownership,
pero asegurarte de que los datos no serán copiados cuando hagas eso</li>
<li>Cuando quieres ser dueño de un valor y solo te importa que sea un tipo que
implemente un trait en particular, en lugar de ser de un tipo específico</li>
</ul>
<p>Veremos la primera situación en la sección <a href="ch15-01-box.html#habilitando-tipos-recursivos-con-boxes">“Habilitando Tipos Recursivos con
Boxes”</a><!-- ignore -->. En el segundo
caso, transferir el ownership de una gran cantidad de datos puede tomar mucho
tiempo porque los datos son copiados en el stack. Para mejorar el performance en
esta situación, podemos almacenar la gran cantidad de datos en el heap en un
box. Entonces, solo la pequeña cantidad de datos de puntero es copiada en el
stack, mientras que los datos a los que apunta permanecen en un solo lugar en el
heap. El tercer caso es conocido como un <em>trait object</em>, y el Capítulo 17 dedica
una sección entera, <a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">“Usando Trait Objects que Permiten Valores de Diferentes
Tipos,”</a><!-- ignore --> solo a ese tema. ¡Así que lo que aprendas
aquí lo aplicarás nuevamente en el Capítulo 17!</p>
<h3 id="usando-un-boxt-para-almacenar-datos-en-el-heap"><a class="header" href="#usando-un-boxt-para-almacenar-datos-en-el-heap">Usando un <code>Box&lt;T&gt;</code> para Almacenar Datos en el Heap</a></h3>
<p>Antes de discutir el caso de uso de almacenamiento en el heap para la sintaxis de
<code>Box&lt;T&gt;</code>, cubriremos la sintaxis y cómo interactuar con valores almacenados
dentro de un <code>Box&lt;T&gt;</code>.</p>
<p>El Listado 15-1 muestra cómo usar un box para almacenar un valor <code>i32</code> en el
heap:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {b}&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 15-1: Almacenando un valor <code>i32</code> en el heap usando
un box</span></p>
<p>Declaramos una variable <code>b</code> para tener el valor de un <code>Box</code> que apunta al valor
<code>5</code>, el cual está almacenado en el heap. Este programa imprimirá <code>b = 5</code>; en
este caso, podemos acceder a los datos en el box de forma similar a como lo
haríamos en el stack. Como cualquier valor owned, cuando un box sale del scope,
como <code>b</code>hace al final de <code>main</code>, será desasignado. La desasignación ocurre tanto
para el box (almacenado en el stack) como para los datos a los que apunta
(almacenados en el heap).</p>
<p>Colocar un solo valor en el heap no es muy útil, así que no usarás boxes por sí
solos de esta forma muy seguido. Tener valores como un solo <code>i32</code> en el stack,
donde son almacenados por defecto, es más apropiado en la mayoría de
situaciones. Veamos un caso donde los boxes nos permiten definir tipos que no
podríamos definir si no tuviéramos boxes.</p>
<h3 id="habilitando-tipos-recursivos-con-boxes"><a class="header" href="#habilitando-tipos-recursivos-con-boxes">Habilitando Tipos Recursivos con Boxes</a></h3>
<p>Un valor de <em>tipo recursivo</em> puede tener otro valor del mismo tipo como parte de
sí mismo. Los tipos recursivos plantean un problema porque en tiempo de
compilación Rust necesita saber cuánto espacio ocupa un tipo. Sin embargo, el
anidamiento de valores de tipos recursivos podría teóricamente continuar
infinitamente, así que Rust no puede saber cuánto espacio necesita el valor.
Como los boxes tienen un tamaño conocido, podemos habilitar tipos recursivos
insertando un box en la definición del tipo recursivo.</p>
<p>Como ejemplo de un tipo recursivo, exploremos la <em>cons list</em>. Este es un tipo de
dato comúnmente encontrado en lenguajes de programación funcionales. El tipo de
cons list que definiremos es sencillo excepto por la recursión; por lo tanto,
los conceptos en el ejemplo con el que trabajaremos serán útiles en cualquier
situación más compleja que involucre tipos recursivos.</p>
<h4 id="más-información-acerca-de-la-cons-list"><a class="header" href="#más-información-acerca-de-la-cons-list">Más Información Acerca de la Cons List</a></h4>
<p>Una <em>cons list</em> es una estructura de datos que viene del lenguaje de
programación Lisp y sus dialectos y está compuesta de pares anidados, y es la
versión de Lisp de una lista enlazada. Su nombre viene de la función <code>cons</code>
(abreviatura de “construct function” o “función de construcción”) en Lisp que
construye un nuevo par a partir de sus dos argumentos. Al llamar <code>cons</code> en un
par que consiste en un valor y otro par, podemos construir cons lists hechas de
pares recursivos.</p>
<p>Por ejemplo, aquí tenemos una representación de pseudocódigo de una cons list
que contiene la lista 1, 2, 3 con cada par en paréntesis:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Cada item en una cons list contiene dos elementos: el valor del item actual y el
siguiente item. El último item en la lista contiene solo un valor llamado <code>Nil</code>
sin un siguiente item. Una cons list es producida llamando recursivamente la
función <code>cons</code>. El nombre canónico para denotar el caso base de la recursión es
<code>Nil</code>. Nota que esto no es lo mismo que el concepto de “null” o “nil” en el
Capítulo 6, el cual es un valor inválido o ausente.</p>
<p>La cons list no es un tipo de dato que se use comúnmente en Rust. La mayoría de
las veces cuando tienes una lista de items en Rust, <code>Vec&lt;T&gt;</code> es una mejor
opción. Otros tipos de datos recursivos más complejos <em>son</em> útiles en varias
situaciones, pero al comenzar con la cons list en este capítulo, podemos
explorar cómo los boxes nos permiten definir un tipo de dato recursivo sin mucha
distracción.</p>
<p>El Listado 15-2 contiene una definición de enum para una cons list. Nota que
este código no compilará aún porque el tipo <code>List</code> no tiene un tamaño conocido,
lo cual demostraremos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Listado 15-2: El primer intento de definir un enum para
representar una estructura de datos de lista de cons con valores <code>i32</code></span></p>
<blockquote>
<p>Nota: Estamos implementando una const list que solo contiene valores <code>i32</code> con
el propósito de este ejemplo. Podríamos haberla implementado usando genéricos,
como discutimos en el Capítulo 10, para definir un tipo de cons list que
pueda almacenar valores de cualquier tipo.</p>
</blockquote>
<p>Usando el tipo <code>List</code> para almacenar la lista <code>1, 2, 3</code> se vería como el código
en el Listado 15-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<p><span class="caption">Listado 15-3: Usando el enum <code>List</code> para almacenar la
lista <code>1, 2, 3</code></span></p>
<p>El primer valor <code>Cons</code> contiene <code>1</code> y otro valor <code>List</code>. Este valor <code>List</code> es
otro valor <code>Cons</code> que contiene <code>2</code> y otro valor <code>List</code>. Este valor <code>List</code> es
otro valor <code>Cons</code> que contiene <code>3</code> y un valor <code>List</code>, que es finalmente es
<code>Nil</code>, la variante no recursiva que señala el final de la lista.</p>
<p>Si intentamos compilar el código en el Listado 15-3, obtendremos el error que
se muestra en el Listado 15-4:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin &quot;cons-list&quot;) due to 2 previous errors
</code></pre>
<p><span class="caption">Listado 15-4: El error que obtenemos al intentar definir
un enum recursivo</span></p>
<p>El error muestra que este tipo “tiene un tamaño infinito”. La razón es que
hemos definido <code>List</code> con una variante que es recursiva: contiene otro valor de
sí mismo directamente. Como resultado, Rust no puede averiguar cuánto espacio
necesita para almacenar un valor de <code>List</code>. Veamos por qué obtenemos este error.
Primero, veremos cómo Rust decide cuánto espacio necesita para almacenar un
valor de un tipo no recursivo.</p>
<h4 id="calculando-el-tamaño-de-un-tipo-no-recursivo"><a class="header" href="#calculando-el-tamaño-de-un-tipo-no-recursivo">Calculando el Tamaño de un Tipo No Recursivo</a></h4>
<p>Recuerda el enum <code>Message</code> que definimos en el Listado 6-2 cuando discutimos
definiciones de enum en el Capítulo 6:</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Para determinar cuánto espacio necesita almacenar un valor de tipo <code>Message</code>,
Rust comienza con la variante que necesita la mayor cantidad de espacio. Rust
observa que <code>Message::Quit</code> no necesita ningún espacio, <code>Message::Move</code> necesita
suficiente espacio para almacenar dos valores <code>i32</code> y así sucesivamente. Como
solo una variante será usada, el espacio que un valor de <code>Message</code> necesita es
el espacio que necesitaría la variante más grande.</p>
<p>Compara esto con lo que sucede cuando Rust intenta determinar cuánto espacio
necesita un valor de un tipo recursivo como el enum <code>List</code> en el Listado 15-2.
El compilador comienza mirando la variante <code>Cons</code>, la cual contiene un valor de
tipo <code>i32</code> y un valor de tipo <code>List</code>. Por lo tanto, <code>Cons</code> necesita una cantidad
de espacio igual al tamaño de un <code>i32</code> más el tamaño de un <code>List</code>. Para
averiguar cuánto espacio necesita el tipo <code>List</code>, el compilador mira las
variantes, comenzando con la variante <code>Cons</code>. La variante <code>Cons</code> contiene un
valor de tipo <code>i32</code> y un valor de tipo <code>List</code>, y este proceso continúa
infinitamente, como se muestra en la Figura 15-1.</p>
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figura 15-1: Un <code>List</code> infinito consistente en variantes
<code>Cons</code> infinitas</span></p>
<h4 id="usando-boxt-para-obtener-un-tipo-recursivo-con-un-tamaño-conocido"><a class="header" href="#usando-boxt-para-obtener-un-tipo-recursivo-con-un-tamaño-conocido">Usando <code>Box&lt;T&gt;</code> para Obtener un Tipo Recursivo con un Tamaño Conocido</a></h4>
<p>Debido a que Rust no puede determinar cuánto espacio necesita asignar para tipos
definidos recursivamente, el compilador muestra un error con una sugerencia
util:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>En esta sugerencia, “indirección” significa que en lugar de almacenar un valor
directamente, deberíamos cambiar la estructura de datos para almacenar el valor
indirectamente almacenando un puntero al valor en su lugar.</p>
<p>Debido a que <code>Box&lt;T&gt;</code> es un tipo de puntero, Rust siempre sabe cuánto espacio
necesita un <code>Box&lt;T&gt;</code>: el tamaño de un puntero no cambia en función de la
cantidad de datos que está almacenando. Esto significa que podemos poner un
<code>Box&lt;T&gt;</code> dentro de la variante <code>Cons</code> en lugar de otro valor <code>List</code> directamente.
El <code>Box&lt;T&gt;</code> apuntará al siguiente valor <code>List</code> que estará en el heap en lugar de
dentro de la variante <code>Cons</code>. Conceptualmente, todavía tenemos una lista,
creada con listas que contienen otras listas, pero esta implementación ahora es
más como colocar los elementos uno al lado del otro en lugar de dentro de uno
del otro.</p>
<p>Podemos cambiar la definición del enum <code>List</code> en el Listado 15-2 y el uso de
<code>List</code> en el Listado 15-3 al código del Listado 15-5, el cual compilará:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<p><span class="caption">Listado 15-5: Definición de <code>List</code> que utiliza <code>Box&lt;T&gt;</code>
para tener un tamaño conocido</span></p>
<p>La variante <code>Cons</code> necesita el tamaño de un <code>i32</code> más el espacio para almacenar
los datos del puntero. La variante <code>Nil</code> no almacena ningún valor, por lo que
necesita menos espacio que la variante <code>Cons</code>. Ahora sabemos que cualquier
valor de <code>List</code> ocupará el tamaño de un <code>i32</code> más el tamaño de los datos del
puntero de un Box. Al usar un Box, hemos roto la cadena infinita y recursiva,
por lo que el compilador puede averiguar el tamaño que necesita para almacenar
un valor de <code>List</code>. La Figura 15-2 muestra cómo se ve la variante <code>Cons</code> ahora.</p>
<img alt="Una lista Cons finita" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Figura 15-2: Una <code>List</code> que no tiene un tamaño infinito
porque <code>Cons</code> contiene una <code>Box</code></span></p>
<p>Los Boxes proporcionan indirección y asignación de heap; no tienen ninguna otra
capacidad especial, como veremos con los otros tipos de smart pointers.
Tampoco tienen la sobrecarga de rendimiento que estas capacidades especiales
incurran, por lo que pueden ser útiles en casos como la lista cons donde la
indirección es la única característica que necesitamos. También veremos más
casos de uso para los boxes en el Capítulo 17.</p>
<p>El tipo <code>Box&lt;T&gt;</code> es un tipo de puntero inteligente porque implementa el trait
<code>Deref</code>, que permite que los valores de <code>Box&lt;T&gt;</code> se traten como referencias
normales. Cuando un <code>Box&lt;T&gt;</code> sale del scope, los datos en el heap que apunta se
limpian también porque implementa el trait <code>Drop</code>. Estos dos traits serán aún
más importantes para la funcionalidad proporcionada por los otros tipos de
smart pointers que discutiremos en el resto de este capítulo. Exploraremos estos
dos traits en más detalle.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tratando-los-smart-pointers-como-referencias-regulares-con-el-trait-deref"><a class="header" href="#tratando-los-smart-pointers-como-referencias-regulares-con-el-trait-deref">Tratando los Smart Pointers como Referencias Regulares con el Trait <code>Deref</code></a></h2>
<p>Implementar el trait <code>Deref</code> te permite personalizar el comportamiento del
<em>operador de desreferencia</em> <code>*</code> (no confundir con el operador de multiplicación
o el operador de glob). Al implementar <code>Deref</code> de tal manera que un smart
pointer pueda ser tratado como una referencia regular, puedes escribir código
que opere en referencias y usar ese código con smart pointers también.</p>
<p>Primero veamos cómo funciona el operador de desreferencia con referencias
regulares. Luego intentaremos definir un tipo personalizado que se comporte
como <code>Box&lt;T&gt;</code>, y veremos por qué el operador de desreferencia no funciona como
una referencia en nuestro tipo recién definido. Exploraremos cómo implementar
el trait <code>Deref</code> hace posible que los smart pointers trabajen de manera similar
a las referencias. Luego veremos la característica de <em>deref coercion</em> de Rust
y cómo nos permite trabajar con referencias o smart pointers.</p>
<blockquote>
<p>Nota: Hay una gran diferencia entre el tipo <code>MyBox&lt;T&gt;</code> que estamos a punto de
construir y el tipo <code>Box&lt;T&gt;</code> real: nuestra versión no almacenará sus datos en
el heap. Nos estamos enfocando en este ejemplo en <code>Deref</code>, por lo que dónde
se almacenan los datos es menos importante que el comportamiento similar al
de un puntero.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="siguiendo-el-puntero-al-valor"><a class="header" href="#siguiendo-el-puntero-al-valor">Siguiendo el puntero al valor</a></h3>
<p>Una referencia regular es un tipo de puntero, y una forma de pensar en un
puntero es como una flecha a un valor almacenado en otro lugar. En el Listado
15-6, creamos una referencia a un valor <code>i32</code> y luego usamos el operador de
desreferencia para seguir la referencia al valor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Listing 15-6: Utilizando el operador de dereferencia
para seguir una referencia a un valor <code>i32</code></span></p>
<p>La variable <code>x</code> contiene un valor <code>i32</code> de <code>5</code>. Establecemos <code>y</code> igual a una
referencia a <code>x</code>. Podemos afirmar que <code>x</code> es igual a <code>5</code>. Sin embargo, si
queremos hacer una afirmación sobre el valor en <code>y</code>, tenemos que usar <code>*y</code> para
seguir la referencia al valor al que apunta (de ahí <em>desreferencia</em>) para que
el compilador pueda comparar el valor real. Una vez que desreferenciamos <code>y</code>,
tenemos acceso al valor entero al que apunta <code>y</code> que podemos comparar con <code>5</code>.</p>
<p>Si intentamos escribir <code>assert_eq!(5, y);</code> en su lugar, obtendríamos este error
de compilación:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin &quot;deref-example&quot;) due to 1 previous error
</code></pre>
<p>Comparar un número y una referencia a un número no está permitido porque son
tipos diferentes. Debemos usar el operador de desreferencia para seguir la
referencia al valor al que apunta.</p>
<h3 id="usando-boxt-como-una-referencia"><a class="header" href="#usando-boxt-como-una-referencia">Usando <code>Box&lt;T&gt;</code> como una referencia</a></h3>
<p>Podemos reescribir el código del Listado 15-6 para usar un <code>Box&lt;T&gt;</code> en lugar de
una referencia; el operador de desreferencia usado en el <code>Box&lt;T&gt;</code> en el Listado
15-7 funciona de la misma manera que el operador de desreferencia usado en la
referencia en el Listado 15-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Listing 15-7: Utilizando el operador de dereferencia
en un <code>Box&lt;i32&gt;</code></span></p>
<p>La principal diferencia entre el Listado 15-7 y el Listado 15-6 es que aquí
definimos <code>y</code> como una instancia de <code>Box&lt;T&gt;</code> apuntando a una copia del valor de
<code>x</code> en lugar de ser una referencia que apunta al valor de <code>x</code>. En la última
afirmación, podemos usar el operador de desreferencia para seguir el puntero del
<code>Box&lt;T&gt;</code> de la misma manera que lo hicimos cuando <code>y</code> era una referencia. A
continuación, exploraremos que es lo especial de <code>Box&lt;T&gt;</code> que nos permite el
uso del operador de desreferencia al definir nuestro propio tipo.</p>
<h3 id="definiendo-nuestro-propio-smart-pointer"><a class="header" href="#definiendo-nuestro-propio-smart-pointer">Definiendo nuestro propio Smart Pointer</a></h3>
<p>Construyamos un smart pointer similar al tipo <code>Box&lt;T&gt;</code> proporcionado por la
biblioteca estándar para experimentar cómo los smart pointers se comportan de
manera diferente a las referencias por defecto. Luego veremos cómo agregar la
capacidad de usar el operador de desreferencia.</p>
<p>El tipo <code>Box&lt;T&gt;</code> es finalmente definido como una tupla struct con un elemento,
por lo que el Listado 15-8 define un tipo <code>MyBox&lt;T&gt;</code> de la misma manera.
También definiremos una función <code>new</code> para que coincida con la función <code>new</code>
definida en <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 15-8: Definiendo un tipo <code>MyBox&lt;T&gt;</code></span></p>
<p>Definimos un struct llamado <code>MyBox</code> y declaramos un parámetro generic <code>T</code>,
porque queremos que nuestro tipo contenga valores de cualquier tipo. El tipo
<code>MyBox</code> es una tupla struct con un elemento de tipo <code>T</code>. La función <code>MyBox::new</code>
toma un parámetro de tipo <code>T</code> y devuelve una instancia de <code>MyBox</code> que contiene
el valor pasado.</p>
<p>Vamos a intentar añadir la función <code>main</code> del Listado 15-7 al Listado 15-8 y
cambiarla para usar el tipo <code>MyBox&lt;T&gt;</code> que hemos definido en lugar de <code>Box&lt;T&gt;</code>.
El código en el Listado 15-9 no se compilará porque Rust no sabe cómo
desreferenciar <code>MyBox</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
<p><span class="caption">Listing 15-9: Intentando usar <code>MyBox&lt;T&gt;</code> de la misma
manera en que usamos referencias y <code>Box&lt;T&gt;</code></span></p>
<p>Aquí está el error de compilación resultante:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin &quot;deref-example&quot;) due to 1 previous error
</code></pre>
<p>Nuestro tipo <code>MyBox&lt;T&gt;</code> no puede ser desreferenciado porque no hemos
implementado esa capacidad en nuestro tipo. Para habilitar la desreferencia con
el operador <code>*</code>, implementamos el trait <code>Deref</code>.</p>
<h3 id="tratando-un-tipo-como-una-referencia-implementando-el-trait-deref"><a class="header" href="#tratando-un-tipo-como-una-referencia-implementando-el-trait-deref">Tratando un tipo como una referencia implementando el trait <code>Deref</code></a></h3>
<p>Como discutimos en la sección del Capítulo 10
<a href="ch10-02-traits.html#implementando-un-trait-en-un-tipo">“Implementando un Trait en un Tipo”</a><!-- ignore--> , para
implementar un trait, necesitamos proporcionar implementaciones para los métodos
requeridos del trait. El trait <code>Deref</code>, proporcionado por la biblioteca
estándar, requiere que implementemos un método llamado <code>deref</code> que tome <code>self</code>
y devuelva una referencia al dato interno. El Listado 15-10 contiene una
implementación de <code>Deref</code> para agregar a la definición de <code>MyBox</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 15-10: Implementando <code>Deref</code> en <code>MyBox&lt;T&gt;</code></span></p>
<p>La sintaxis <code>type Target = T;</code> define un tipo asociado que será utilizado por el
trait <code>Deref</code>. Los tipos asociados son una forma ligeramente diferente de
declarar un parámetro genérico, pero no necesitas preocuparte por ellos por
ahora; los cubriremos con más detalle en el Capítulo 19.</p>
<p>Rellenamos el cuerpo del método <code>deref</code> con <code>&amp;self.0</code> para que <code>deref</code> devuelva
una referencia al valor al que queremos acceder con el operador <code>*</code>. Recordemos
de la sección <a href="ch05-01-defining-structs.html#usando-structs-de-tuplas-sin-campos-nombrados-para-crear-diferentes-tipos">“Usando Tuplas Structs sin Campos Nombrados para Crear Diferentes
Tipos”</a><!-- ignore --> del Capítulo 5 que <code>.0</code> accede al primer
valor en una tupla struct. ¡La función <code>main</code> en el Listado 15-9 que llama a <code>*</code>
en el valor <code>MyBox&lt;T&gt;</code> ahora compila, y las afirmaciones pasan!</p>
<p>Sin el trait <code>Deref</code>, el compilador no sabe cómo desreferenciar referencias <code>&amp;</code>.
El método <code>deref</code> le da al compilador la capacidad de tomar un valor de
cualquier tipo que implemente <code>Deref</code> y llamar al método <code>deref</code> para obtener
una referencia <code>&amp;</code> que sabe cómo desreferenciar.</p>
<p>Cuando ingresamos <code>*y</code> en el Listado 15-9, en realidad Rust ejecuta este código:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust sustituye el operador <code>*</code> con una llamada al método <code>deref</code>, y luego
realiza una desreferenciación directa, por lo que no tenemos que pensar si
necesitamos llamar al método <code>deref</code>. Esta característica de Rust nos permite
escribir código que funciona de manera idéntica si tenemos una referencia
regular o un tipo que implementa <code>Deref</code>.</p>
<p>La razón por la cual el método <code>deref</code> devuelve una referencia a un valor, y
por qué la desreferenciación simple fuera de los paréntesis en <code>*(y.deref())</code>
todavía es necesaria, tiene que ver con el sistema de propiedad. Si el método
<code>deref</code> devolviera el valor directamente en lugar de una referencia al valor,
el valor se movería fuera de <code>self</code>. No queremos tomar posesión del valor
interno dentro de <code>MyBox&lt;T&gt;</code> en este caso o en la mayoría de los casos en los
que usamos el operador de desreferencia.</p>
<p>Nota que el operador <code>*</code> es reemplazado con una llamada al método <code>deref</code> y
luego una llamada al operador <code>*</code> solo una vez, cada vez que usamos un <code>*</code> en
nuestro código. Debido a que la sustitución del operador <code>*</code> no se repite
infinitamente, terminamos con datos de tipo <code>i32</code>, que coincide con el <code>5</code> en
<code>assert_eq!</code> en el Listado 15-9.</p>
<h3 id="coerciones-implicitas-de-deref-con-funciones-y-metodos"><a class="header" href="#coerciones-implicitas-de-deref-con-funciones-y-metodos">Coerciones implicitas de Deref con funciones y metodos</a></h3>
<p>La <em>coerción Deref</em> convierte una referencia a un tipo que implementa el trait
<code>Deref</code> en una referencia a otro tipo. Por ejemplo, la coerción Deref puede
convertir <code>&amp;String</code> en <code>&amp;str</code> porque <code>String</code> implementa el trait <code>Deref</code> de
manera que devuelve <code>&amp;str</code>. La coerción Deref es una conveniencia que Rust
realiza en los argumentos de las funciones y métodos, y solo funciona en tipos
que implementan el trait <code>Deref</code>. Sucede automáticamente cuando pasamos una
referencia al valor de un tipo particular como argumento a una función o método
que no coincide con el tipo de parámetro en la definición de la función o
método. Una secuencia de llamadas al método <code>deref</code> convierte el tipo que
proporcionamos en el tipo que necesita el parámetro.</p>
<p>La coerción Deref se agregó a Rust para que los programadores que escriben
llamadas a funciones y métodos no necesiten agregar tantas referencias y
desreferencias explícitas con <code>&amp;</code> y <code>*</code>. La característica de coerción Deref
también nos permite escribir más código que puede funcionar para referencias o
smart pointers.</p>
<p>Para ver la coerción Deref en acción, usemos el tipo <code>MyBox&lt;T&gt;</code> que definimos
en el Listado 15-8 y la implementación de <code>Deref</code> que agregamos en el Listado
15-10. El Listado 15-11 muestra la definición de una función que tiene un
parámetro de tipo string slice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hello, {name}!&quot;);
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 15-11: Una función <code>hello</code> que tiene el parámetro
<code>name</code> de tipo <code>&amp;str</code></span></p>
<p>Llamamos a la función <code>hello</code> con un string slice como un argumento, como
<code>hello(&quot;Rust&quot;);</code> por ejemplo. La coerción Deref hace posible llamar a <code>hello</code>
con una referencia a un valor de tipo <code>MyBox&lt;String&gt;</code>, como se muestra en el
Listado 15-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}</code></pre></pre>
<p><span class="caption">Listing 15-12: Llamando a <code>hello</code> con una referencia a un
valor <code>MyBox&lt;String&gt;</code>, lo cual funciona debido a la coerción deref</span></p>
<p>Aquí estamos llamando a la función <code>hello</code> con el argumento <code>&amp;m</code>, que es una
referencia a un valor <code>MyBox&lt;String&gt;</code>. Debido a que implementamos el trait
<code>Deref</code> en <code>MyBox&lt;T&gt;</code> en el Listado 15-10, Rust puede convertir <code>&amp;MyBox&lt;String&gt;</code>
en <code>&amp;String</code> llamando a <code>deref</code>. La biblioteca estándar proporciona una
implementación de <code>Deref</code> en <code>String</code> que devuelve una cadena de texto, y esto
está en la documentación de la API de <code>Deref</code>. Rust llama a <code>deref</code> nuevamente
para convertir el <code>&amp;String</code> en <code>&amp;str</code>, que coincide con la definición de la
función <code>hello</code>.</p>
<p>Si Rust no implementara la coerción Deref, tendríamos que escribir el código
en el Listado 15-13 en lugar del código en el Listado 15-12 para llamar a
<code>hello</code> con un valor de tipo <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<p><span class="caption">Listing 15-13: El código que tendríamos que escribir si
Rust no tuviera deref coerción</span></p>
<p>El <code>(*m)</code> desreferencia el <code>MyBox&lt;String&gt;</code> en un <code>String</code>. Luego, el <code>&amp;</code> y
<code>[..]</code> toman un string slice del <code>String</code> que es igual a todo el string para
coincidir con la firma de <code>hello</code>. Este código sin coerciones de desreferencia
es más difícil de leer, escribir y entender con todos estos símbolos
involucrados. La coerción Deref permite que Rust maneje estas conversiones
automáticamente.</p>
<p>Cuando el trait <code>Deref</code> está definido para el tipo involucrado, Rust analizará
los tipos y usará <code>Deref::deref</code> tantas veces como sea necesario para obtener
una referencia que coincida con el tipo del parámetro. El número de veces que
<code>Deref::deref</code> necesita ser insertado se resuelve en tiempo de compilación, por
lo que no hay penalización en tiempo de ejecución por aprovechar la coerción
Deref!</p>
<h3 id="cómo-interactúa-la-coerción-deref-con-la-mutabilidad"><a class="header" href="#cómo-interactúa-la-coerción-deref-con-la-mutabilidad">Cómo interactúa la coerción Deref con la mutabilidad</a></h3>
<p>Similar a cómo usas el trait <code>Deref</code> para anular el operador <code>*</code> en
referencias inmutables, puedes usar el trait <code>DerefMut</code> para anular el operador
<code>*</code> en referencias mutables.</p>
<p>Rust realiza la coerción Deref cuando encuentra tipos e implementaciones de
traits en tres casos:</p>
<ul>
<li>De <code>&amp;T</code> a <code>&amp;U</code> cuando <code>T: Deref&lt;Target=U&gt;</code></li>
<li>De <code>&amp;mut T</code> a <code>&amp;mut U</code> cuando <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>De <code>&amp;mut T</code> a <code>&amp;U</code> cuando <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Los dos primeros casos son iguales entre sí, excepto que el segundo implementa
mutabilidad. El primer caso establece que si tienes un <code>&amp;T</code>, y <code>T</code> implementa
<code>Deref</code> a algún tipo <code>U</code>, puedes obtener un <code>&amp;U</code> de forma transparente. El
segundo caso establece que la misma coerción de desreferencia ocurre para
referencias mutables.</p>
<p>El tercer caso es más complicado. Rust también convertirá una referencia mutable
en una inmutable. Pero lo contrario no es posible: una referencia inmutable
nunca se puede convertir en una referencia mutable. Debido a las reglas de
borrowing, si tienes una referencia mutable, esa referencia debe ser la única
referencia a ese dato (de lo contrario, el programa no se compilaría). Convertir
una referencia mutable a una inmutable nunca romperá las reglas de borrowing.
Convertir una referencia inmutable a una mutable requeriría que la referencia
inmutable inicial sea la única referencia inmutable a esos datos, pero las
reglas de borrowing no garantizan eso. Por lo tanto, Rust no puede hacer la
suposición de que convertir una referencia inmutable en una mutable es posible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ejecutando-código-al-limpiar-con-el-trait-drop"><a class="header" href="#ejecutando-código-al-limpiar-con-el-trait-drop">Ejecutando Código al Limpiar con el Trait <code>Drop</code></a></h2>
<p>El segundo trait importante para el patrón de smart pointer es <code>Drop</code>, el cual
permite personalizar qué pasa cuando un valor está a punto de salir del scope.
Puedes proveer una implementación para el trait <code>Drop</code> en cualquier tipo, y ese
código puede ser usado para liberar recursos como archivos o conexiones de
red.</p>
<p>Estamos introduciendo <code>Drop</code> en el contexto de smart pointers porque la
funcionalidad del trait <code>Drop</code> es casi siempre usada cuando se implementa un
smart pointer. Por ejemplo, cuando un <code>Box&lt;T&gt;</code> es dropeado, desasignará el
espacio en el heap al que el box apunta.</p>
<p>En algunos lenguajes, para algunos tipos, el programador debe llamar código
para liberar memoria o recursos cada vez que terminan de usar una instancia de
esos tipos. Ejemplos incluyen manejadores de archivos, sockets, o locks. Si se
olvidan, el sistema podría sobrecargarse y colapsar. En Rust, puedes especificar
que un pedazo particular de código sea ejecutado cada vez que un valor sale del
scope, y el compilador insertará este código automáticamente. Como resultado,
no necesitas ser cuidadoso sobre colocar código de limpieza en todos lados en
un programa que una instancia de un tipo particular está terminada con él—¡aún
no se fugarán recursos!</p>
<p>Puedes especificar el código a ejecutar cuando un valor sale del scope
implementando el trait <code>Drop</code>. El trait <code>Drop</code> requiere que implementes un
método llamado <code>drop</code> que toma una referencia mutable a <code>self</code>. Para ver cuándo
Rust llama a <code>drop</code>, implementemos <code>drop</code> con declaraciones <code>println!</code> por
ahora. </p>
<p>Listing 15-14 muestra una estructura <code>CustomSmartPointer</code> cuya única
funcionalidad personalizada es que imprimirá <code>Dropping CustomSmartPointer!</code>
cuando la instancia sale del scope, para mostrar cuándo Rust ejecuta la
función <code>drop</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;my stuff&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;other stuff&quot;),
    };
    println!(&quot;CustomSmartPointers created.&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 15-14: Un struct <code>CustomSmartPointer</code> que
implementa el trait <code>Drop</code> donde colocaríamos nuestro código de limpieza</span></p>
<p>El trait <code>Drop</code> está incluido en el prelude, así que no necesitamos traerlo al
scope. Implementamos el trait <code>Drop</code> en <code>CustomSmartPointer</code> y proveemos una
implementación para el método <code>drop</code> que llama a <code>println!</code>. El cuerpo de la
función <code>drop</code> es donde colocarías cualquier lógica que quisieras correr cuando
una instancia de tu tipo sale del scope. Estamos imprimiendo un texto aquí para
demostrar visualmente cuándo Rust llamará a <code>drop</code>.</p>
<p>En <code>main</code>, creamos dos instancias de <code>CustomSmartPointer</code> y luego imprimimos
<code>CustomSmartPointers created</code>. Al final de <code>main</code>, nuestras instancias de
<code>CustomSmartPointer</code> saldrán del scope, y Rust llamará al código que colocamos
en el método <code>drop</code>, imprimiendo nuestro mensaje final. Nota que no necesitamos
llamar al método <code>drop</code> explícitamente.</p>
<p>Cuando ejecutemos este programa, veremos el siguiente output:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust automáticamente llamó a <code>drop</code> para nosotros cuando nuestras instancias
salieron del scope, llamando al código que especificamos. Las variables son
dropeadas en el orden inverso a su creación, así que <code>d</code> fue dropeada antes que
<code>c</code>. El propósito de este ejemplo es darte una guía visual de cómo funciona el
método <code>drop</code>; usualmente especificarías el código de limpieza que tu tipo
necesita correr en lugar de un mensaje de impresión.</p>
<h3 id="droppeando-un-valor-temprano-con-stdmemdrop"><a class="header" href="#droppeando-un-valor-temprano-con-stdmemdrop">Droppeando un valor temprano con <code>std::mem::drop</code></a></h3>
<p>Desafortunadamente, no es sencillo deshabilitar la funcionalidad automática de
<code>drop</code>. Deshabilitar <code>drop</code> usualmente no es necesario; el punto entero del
trait <code>Drop</code> es que se encarga automáticamente. Ocasionalmente, sin embargo,
podrías querer limpiar un valor temprano. Un ejemplo es cuando usas smart
pointers que manejan locks: podrías querer forzar el método <code>drop</code> que libera
el lock para que otro código en el mismo scope pueda adquirir el lock. Rust no
te deja llamar al método <code>drop</code> del trait <code>Drop</code> manualmente; en lugar de eso
tienes que llamar a la función <code>std::mem::drop</code> provista por la librería
estándar si quieres forzar a un valor a ser dropeado antes del final de su
scope.</p>
<p>Si intentamos llamar manualmente al método <code>drop</code> del trait <code>Drop</code> modificando 
la función <code>main</code> del Listado 15-14, como se muestra en el Listado 15-15, 
obtendremos un error del compilador:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}</code></pre>
<p><span class="caption">Listing 15-15: Intento de llamar manualmente al método
<code>drop</code> del trait <code>Drop</code> para limpiar de forma anticipada</span></p>
<p>When we try to compile this code, we’ll get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin &quot;drop-example&quot;) due to 1 previous error
</code></pre>
<p>Este mensaje de error indica que no se nos permite llamar a <code>drop</code> 
explícitamente. El mensaje de error usa el término <em>destructor</em>, que es el 
término general de programación para una función que limpia una instancia. 
Un <em>destructor</em> es análogo a un <em>constructor</em>, que crea una instancia. 
La función <code>drop</code> en Rust es un destructor particular.</p>
<p>Rust no nos deja llamar a <code>drop</code> explícitamente porque Rust llamaría
automáticamente a <code>drop</code> en el valor al final de <code>main</code>. Esto causaría un error
de <em>double free</em> porque Rust intentaría limpiar el mismo valor dos veces.</p>
<p>No podemos desactivar la inserción automática de <code>drop</code> cuando un valor sale
del scope, y no podemos llamar explícitamente al método <code>drop</code>. Así que, si
necesitamos forzar a un valor a ser limpiado temprano, usamos la función
<code>std::mem::drop</code>.</p>
<p>La función <code>std::mem::drop</code> es diferente del método <code>drop</code> en el trait <code>Drop</code>.
La llamamos pasando como argumento el valor que queremos forzar a dropear. La
función está en el prelude, así que podemos modificar <code>main</code> en el Listado
15-15 para llamar a la función <code>drop</code>, como se muestra en el Listado 15-16:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 15-16: Llamando a <code>std::mem::drop</code> para eliminar
explícitamente un valor antes de que salga del scope</span></p>
<p>Ejecutar este código imprimirá lo siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>El texto <code>Dropping CustomSmartPointer with data `some data`!</code> es impreso
entre el texto <code>CustomSmartPointer created.</code> y <code>CustomSmartPointer dropped before the end of main.</code>, mostrando que el código del método <code>drop</code> es llamado
para dropear <code>c</code> en ese punto.</p>
<p>Puedes utilizar código especificado en una implementación del trait <code>Drop</code> de
varias maneras para hacer la limpieza conveniente y segura: por ejemplo,
¡podrías usarlo para crear tu propio allocator de memoria! Con el trait <code>Drop</code>
y el sistema de ownership de Rust, no tienes que recordar limpiar porque Rust
lo hace automáticamente.</p>
<p>Tampoco tienes que preocuparte por problemas que surjan de limpiar 
accidentalmente valores que aún están en uso: el sistema de ownership que
asegura que las referencias siempre sean válidas también asegura que <code>drop</code> sea
llamado solo una vez cuando el valor ya no está siendo usado.</p>
<p>Ahora que hemos examinado <code>Box&lt;T&gt;</code> y algunas de las características de los
smart pointers, veamos algunos otros smart pointers definidos en la librería
estándar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-el-smart-pointer-de-conteo-de-referencias"><a class="header" href="#rct-el-smart-pointer-de-conteo-de-referencias"><code>Rc&lt;T&gt;</code>, el Smart Pointer de Conteo de Referencias</a></h2>
<p>En la mayoría de los casos, el ownership es claro: sabes exactamente qué
variable es dueña de un valor dado. Sin embargo, hay casos en los que un solo
valor puede tener múltiples propietarios. Por ejemplo, en estructuras de datos
de gráficos, múltiples aristas pueden apuntar al mismo nodo, y ese nodo es
conceptualmente propiedad de todas las aristas que apuntan a él. Un nodo no
debería ser limpiado a menos que no tenga aristas apuntando a él y, por lo
tanto, no tenga propietarios.</p>
<p>Debes habilitar el ownership múltiple explícitamente usando el tipo de Rust
<code>Rc&lt;T&gt;</code>, el cual es una abreviación para <em>reference counting</em>. El tipo <code>Rc&lt;T&gt;</code>
lleva la cuenta del número de referencias a un valor para determinar si el valor
aún está en uso. Si hay cero referencias a un valor, el valor puede ser limpiado
sin que ninguna referencia se vuelva inválida.</p>
<p>Imagina <code>Rc&lt;T&gt;</code> como una TV en una sala familiar. Cuando una persona entra a
ver TV, la enciende. Otros pueden entrar a la sala y ver la TV. Cuando la última
persona sale de la sala, apaga la TV porque ya no está siendo usada. Si alguien
apaga la TV mientras otros aún la están viendo, ¡habría un alboroto de los
televidentes restantes!</p>
<p>Usamos el tipo <code>Rc&lt;T&gt;</code> cuando queremos asignar algunos datos en el heap para
que múltiples partes de nuestro programa puedan leer y no podemos determinar en
tiempo de compilación cuál parte terminará usando los datos por último. Si
supiéramos cuál parte terminaría de último, podríamos hacer que esa parte sea
dueña de los datos, y las reglas normales de ownership aplicadas en tiempo de
compilación tomarían efecto.</p>
<p>Nota que <code>Rc&lt;T&gt;</code> es solo para uso en escenarios de un solo hilo. Cuando
discutamos concurrencia en el Capítulo 16, cubriremos cómo hacer conteo de
referencias en programas multihilo.</p>
<h3 id="usando-rct-para-compartir-datos"><a class="header" href="#usando-rct-para-compartir-datos">Usando <code>Rc&lt;T&gt;</code> para Compartir Datos</a></h3>
<p>Volvamos a nuestro ejemplo de la lista cons en el Listado 15-5. Recuerda que lo
definimos usando <code>Box&lt;T&gt;</code>. Esta vez, crearemos dos listas que comparten
ownership de una tercera lista. Conceptualmente, esto se ve similar a la Figura
15-3:</p>
<img alt="Dos listas que comparten ownership de una tercera lista" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Figura 15-3: Dos listas, <code>b</code> y <code>c</code>, comparten ownership de
una tercera lista, <code>a</code></span></p>
<p>Crearemos la lista <code>a</code> que contiene 5 y luego 10. Luego haremos dos listas más:
<code>b</code> que comienza con 3 y <code>c</code> que comienza con 4. Ambas listas <code>b</code> y <code>c</code> luego
continuarán a la primera lista <code>a</code> que contiene 5 y 10. En otras palabras,
ambas listas compartirán la primera lista que contiene 5 y 10.</p>
<p>Intentar implementar este escenario usando nuestra definición de <code>List</code> con
<code>Box&lt;T&gt;</code> no funcionará, como se muestra en el Listado 15-17:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<p><span class="caption">Listado 15-17: Demostrando que no se nos permite tener dos
listas que usen <code>Box&lt;T&gt;</code> y traten de compartir ownership de una tercera
lista</span></p>
<p>Cuando intentamos compilar este código, obtenemos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin &quot;cons-list&quot;) due to 1 previous error
</code></pre>
<p>Las variantes <code>Cons</code> poseen los datos que contienen, así que cuando creamos la
lista <code>b</code>, <code>a</code> es movida a <code>b</code> y <code>b</code> posee <code>a</code>. Luego, cuando intentamos usar
<code>a</code> nuevamente cuando creamos <code>c</code>, no se nos permite porque <code>a</code> ha sido movida.</p>
<p>Podríamos cambiar la definición de <code>Cons</code> para que contenga referencias en su
lugar, pero entonces tendríamos que especificar parámetros de lifetime. Al
especificar parámetros de lifetime, estaríamos especificando que cada elemento
en la lista vivirá al menos tanto como la lista entera. Este es el caso para
los elementos y listas en el Listado 15-17, pero no en todos los escenarios.</p>
<p>En su lugar, cambiaremos nuestra definición de <code>List</code> para usar <code>Rc&lt;T&gt;</code> en
lugar de <code>Box&lt;T&gt;</code>, como se muestra en el Listado 15-18. Cada variante <code>Cons</code>
ahora contendrá un valor y un <code>Rc&lt;T&gt;</code> apuntando a una <code>List</code>. Cuando creamos
<code>b</code>, en lugar de tomar ownership de <code>a</code>, clonaremos el <code>Rc&lt;List&gt;</code> que <code>a</code> está
sosteniendo, aumentando así el número de referencias de uno a dos y permitiendo
que <code>a</code> y <code>b</code> compartan ownership de los datos en ese <code>Rc&lt;List&gt;</code>. También
clonaremos <code>a</code> cuando creamos <code>c</code>, aumentando el número de referencias de dos a
tres. Cada vez que llamamos a <code>Rc::clone</code>, el conteo de referencias a los datos
dentro del <code>Rc&lt;List&gt;</code> aumentará, y los datos no serán limpiados a menos que no
haya referencias a él.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<p><span class="caption">Listado 15-18: Una definición de <code>List</code> que utiliza
<code>Rc&lt;T&gt;</code></span></p>
<p>Necesitamos agregar una declaración <code>use</code> para traer <code>Rc&lt;T&gt;</code> al scope porque no
está en el <a href="ch02-00-guessing-game-tutorial.html#prelude-meaning">prelude</a>. En <code>main</code>, creamos la lista que contiene 5 y 10 y la
almacenamos en un nuevo <code>Rc&lt;List&gt;</code> en <code>a</code>. Luego cuando creamos <code>b</code> y <code>c</code>,
llamamos a la función <code>Rc::clone</code> y pasamos una referencia al <code>Rc&lt;List&gt;</code> en <code>a</code>
como argumento.</p>
<p>Podríamos llamar a <code>Rc::clone()</code> directamente con <code>a</code>, como en <code>Rc::clone(&amp;a)</code>.
pero Rust tiene una convención para llamar a <code>Rc::clone</code> en este caso. La
implementación de <code>Rc::clone</code> no hace una copia profunda de todos los datos
como la mayoría de las implementaciones de <code>clone</code> de los tipos hacen. La
llamada a <code>Rc::clone</code> solo incrementa el conteo de referencias, lo cual no
toma mucho tiempo. Copias profundas de datos pueden tomar mucho tiempo. Al usar
<code>Rc::clone</code> para conteo de referencias, podemos distinguir visualmente entre
las copias profundas y los tipos de clones que incrementan el conteo de
referencias. Cuando busquemos problemas de performance en el código, solo
necesitamos considerar las copias profundas y podemos ignorar las llamadas a
<code>Rc::clone</code>.</p>
<h3 id="clonando-un-rct-incrementa-el-conteo-de-referencias"><a class="header" href="#clonando-un-rct-incrementa-el-conteo-de-referencias">Clonando un <code>Rc&lt;T&gt;</code> Incrementa el Conteo de Referencias</a></h3>
<p>Vamos a modificar nuestro ejemplo de trabajo en el Listado 15-18 para que
podamos ver los conteos de referencias cambiando a medida que creamos y
descartamos referencias al <code>Rc&lt;List&gt;</code> en <code>a</code>.</p>
<p>En el Listado 15-19, cambiaremos <code>main</code> para que tenga un scope interno alrededor
de la lista <code>c</code>; luego podemos ver cómo el conteo de referencias cambia cuando
<code>c</code> sale del scope.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}</code></pre></pre>
<p><span class="caption">Listado 15-19: Imprimiendo el conteo de referencias</span></p>
<p>En este punto del programa donde cambia el recuento de referencias, imprimimos
el recuento de referencias utilizando la función <code>Rc::strong_count</code>. Esta
función se llama <code>strong_count</code> en lugar de <code>count</code> porque el tipo <code>Rc&lt;T&gt;</code>
también tiene un <code>weak_count</code>; veremos para qué se usa <code>weak_count</code> en la
sección <a href="ch15-06-reference-cycles.html#previniendo-ciclos-de-referencia-convirtiendo-un-rct-en-un-weakt">“Previniendo Ciclos de Referencias: Convirtiendo un <code>Rc&lt;T&gt;</code> en un
<code>Weak&lt;T&gt;</code>”</a><!-- ignore -->.</p>
<p>Este código imprime lo siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>Podemos ver que el <code>Rc&lt;List&gt;</code> en <code>a</code> tiene un recuento de referencias de 1;
luego, cada vez que llamamos a <code>clone</code> el recuento aumenta en 1. Cuando <code>c</code> sale
del scope, el recuento disminuye en 1. No tenemos que llamar a una función para
disminuir el recuento de referencias como tenemos que llamar a <code>Rc::clone</code> para
aumentar el recuento de referencias: la implementación del trait <code>Drop</code>
disminuye el recuento de referencias automáticamente cuando un valor <code>Rc&lt;T&gt;</code>
sale del scope.</p>
<p>Lo que no podemos ver en este ejemplo es que cuando <code>b</code> y luego <code>a</code> salen del
scope al final de <code>main</code>, el recuento es entonces 0, y el <code>Rc&lt;List&gt;</code> se limpia
completamente. Usando <code>Rc&lt;T&gt;</code> permite que un solo valor tenga múltiples
propietarios, y el recuento asegura que el valor permanezca válido siempre que
cualquiera de los propietarios aún exista.</p>
<p>A través de referencias inmutables, <code>Rc&lt;T&gt;</code> permite que comparta datos entre
múltiples partes de su programa para lectura solamente. Si <code>Rc&lt;T&gt;</code> le permitiera
tener múltiples referencias mutables también, podría violar una de las reglas
de préstamo discutidas en el Capítulo 4: múltiples préstamos mutables al mismo
lugar pueden causar carreras de datos e inconsistencias. ¡Pero poder mutar datos
es muy útil! En la siguiente sección, discutiremos el patrón de mutabilidad
interior y el tipo <code>RefCell&lt;T&gt;</code> que puede usar en conjunto con un <code>Rc&lt;T&gt;</code> para
trabajar con esta restricción de inmutabilidad.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-y-el-patrón-de-mutabilidad-interior"><a class="header" href="#refcellt-y-el-patrón-de-mutabilidad-interior"><code>RefCell&lt;T&gt;</code> y el Patrón de Mutabilidad Interior</a></h2>
<p>La mutabilidad interna es un patrón de diseño en Rust que te permite mutar datos
incluso cuando hay referencias inmutables a esos datos; normalmente, esta acción
está prohibida por las reglas de borrowing. Para mutar datos, el patrón utiliza
código <code>unsafe</code> dentro de una estructura de datos para flexibilizar las reglas
habituales de Rust que rigen la mutabilidad y el borrowing. El código unsafe
indica al compilador que estamos verificando las reglas manualmente en lugar de
confiar en que el compilador las verifique por nosotros; discutiremos el código
unsafe con más detalle en el Capítulo 19.</p>
<p>Podemos utilizar tipos que utilizan el patrón de mutabilidad interna solo cuando
podemos asegurar que las reglas de borrowing se seguirán en tiempo de ejecución,
aunque el compilador no pueda garantizarlo. El código <code>unsafe</code> involucrado se
envuelve entonces en una API segura, y el tipo externo sigue siendo inmutable.</p>
<p>Vamos a explorar este concepto al examinar el tipo <code>RefCell&lt;T&gt;</code> que sigue el
patrón de mutabilidad interna.</p>
<h3 id="cumpliendo-las-reglas-de-borrowing-en-tiempo-de-ejecución-con-refcellt"><a class="header" href="#cumpliendo-las-reglas-de-borrowing-en-tiempo-de-ejecución-con-refcellt">Cumpliendo las reglas de borrowing en tiempo de ejecución con <code>RefCell&lt;T&gt;</code></a></h3>
<p>A diferencia de <code>Rc&lt;T&gt;</code>, el tipo <code>RefCell&lt;T&gt;</code> representa un único ownership
sobre los datos que contiene. Entonces, ¿qué hace que <code>RefCell&lt;T&gt;</code> sea diferente
de un tipo como <code>Box&lt;T&gt;</code>? Recuerda las reglas de borrowing que aprendiste en el
Capítulo 4:</p>
<ul>
<li>En cualquier momento dado, puedes tener <em>o bien</em> una referencia mutable <em>o
bien</em> cualquier número de referencias inmutables.</li>
<li>Las referencias siempre deben ser válidas.</li>
</ul>
<p>Con referencias y <code>Box&lt;T&gt;</code>, las invariantes de las reglas de borrowing se hacen
cumplir en tiempo de compilación. Con <code>RefCell&lt;T&gt;</code>, estas invariantes se hacen
cumplir <em>en tiempo de ejecución</em>. Con referencias, si rompes estas reglas,
obtendrás un error de compilación. Con <code>RefCell&lt;T&gt;</code>, si rompes estas reglas, tu
programa entrará en panic y saldrá.</p>
<p>La ventaja de comprobar las reglas de borrowing en tiempo de compilación es que
los errores se detectarán antes en el proceso de desarrollo, y no hay impacto en
el rendimiento en tiempo de ejecución porque todo el análisis se completa de
antemano. Por estas razones, comprobar las reglas de borrowing en tiempo de
compilación es la mejor opción en la mayoría de los casos, por lo que esta es la
opción predeterminada de Rust.</p>
<p>La ventaja de comprobar las reglas de borrowing en tiempo de ejecución es que
se permiten ciertos escenarios seguros de memoria, donde habrían sido
rechazados por las comprobaciones en tiempo de compilación. El análisis estático,
como el compilador de Rust, es inherentemente conservador. Algunas propiedades
del código son imposibles de detectar analizando el código: el ejemplo más
famoso es el Problema de la Parada, que está fuera del alcance de este libro,
pero es un tema interesante para investigar.</p>
<p>Debido a que algunos análisis son imposibles, si el compilador de Rust no puede
estar seguro de que el código cumple con las reglas de ownership, podría
rechazar un programa correcto; de esta manera, es conservador. Si Rust aceptara
un programa incorrecto, los usuarios no podrían confiar en las garantías que
Rust hace. Sin embargo, si Rust rechaza un programa correcto, el programador se
verá perjudicado, pero no puede ocurrir nada catastrófico. El tipo <code>RefCell&lt;T&gt;</code>
es útil cuando estás seguro de que tu código sigue las reglas de borrowing, pero
el compilador no puede entenderlo y garantizarlo.</p>
<p>Similar a <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> solo se usa en escenarios de un solo hilo y te
dará un error de tiempo de compilación si intentas usarlo en un contexto
multihilo. Hablaremos de cómo obtener la funcionalidad de <code>RefCell&lt;T&gt;</code> en un
programa multihilo en el Capítulo 16.</p>
<p>Aquí tienes un resumen de las razones para elegir <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> o
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> permite múltiples propietarios de los mismos datos; <code>Box&lt;T&gt;</code> y
<code>RefCell&lt;T&gt;</code> tienen un único propietario.</li>
<li><code>Box&lt;T&gt;</code> permite borrowing inmutable o mutable verificado en tiempo de
compilación; <code>Rc&lt;T&gt;</code> permite solo borrowing inmutable verificado en tiempo de
compilación; <code>RefCell&lt;T&gt;</code> permite borrowing inmutable o mutable verificado en
tiempo de ejecución.</li>
<li>Debido a que <code>RefCell&lt;T&gt;</code> permite borrowing mutable verificado en tiempo de
ejecución, puedes mutar el valor dentro de la <code>RefCell&lt;T&gt;</code> incluso cuando la
<code>RefCell&lt;T&gt;</code> es inmutable.</li>
</ul>
<p>Mutar el valor dentro de un valor inmutable es el patrón de <em>mutabilidad
interior</em>. Veamos una situación en la que la mutabilidad interior es útil y
examinemos cómo es posible.</p>
<h3 id="mutabilidad-interior-un-borrow-mutable-a-un-valor-inmutable"><a class="header" href="#mutabilidad-interior-un-borrow-mutable-a-un-valor-inmutable">Mutabilidad Interior: Un Borrow Mutable a un Valor Inmutable</a></h3>
<p>Una consecuencia de las reglas de borrowing es que cuando tienes un valor
inmutable, no puedes pedir prestado una referencia mutable a través de ese
valor. Por ejemplo, este código no compilará:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>Si intentas compilar este código, obtendrás el siguiente error:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin &quot;borrowing&quot;) due to 1 previous error
</code></pre>
<p>Sin embargo, hay situaciones en las que sería útil que un valor se mute a sí
mismo en sus métodos, pero parezca inmutable para otro código. El código fuera
de los métodos del valor no podría mutar el valor. Usar <code>RefCell&lt;T&gt;</code> es una
forma de obtener la capacidad de tener mutabilidad interior, pero <code>RefCell&lt;T&gt;</code>
no evita las reglas de borrowing por completo: el comprobador de préstamos en el
compilador permite esta mutabilidad interior, y las reglas de borrowing se
comprueban en tiempo de ejecución en su lugar. Si violas las reglas, obtendrás
un <code>panic!</code> en lugar de un error del compilador.</p>
<p>Vamos a trabajar a través de un ejemplo práctico donde podemos usar <code>RefCell&lt;T&gt;</code>
para mutar un valor inmutable y ver por qué es útil.</p>
<h4 id="un-caso-de-uso-para-la-mutabilidad-interior-mock-objects"><a class="header" href="#un-caso-de-uso-para-la-mutabilidad-interior-mock-objects">Un Caso de Uso para la Mutabilidad Interior: Mock Objects</a></h4>
<p>A veces durante el testing, un programador usará un tipo en lugar de otro para
observar un comportamiento particular y afirmar que se implementa correctamente.
Este tipo de marcador de posición se llama <em>test double</em>. Piensa en ello en el
sentido de un &quot;doble de riesgo&quot; en la realización de películas, donde una
persona entra y sustituye a un actor para hacer una escena particularmente
difícil. Los test doubles se sustituyen por otros tipos cuando se ejecutan las
pruebas. Los <em>objetos simulados</em> son tipos específicos de test doubles que
registran lo que sucede durante una prueba para que puedas afirmar que se
produjeron las acciones correctas.</p>
<p>Rust no tiene objetos en el mismo sentido que otros lenguajes tienen objetos, y
Rust no tiene funcionalidad de objetos simulados integrada en la biblioteca
estándar como lo hacen otros lenguajes. Sin embargo, definitivamente puedes
crear una struct que sirva para los mismos propósitos que un objeto
simulado.</p>
<p>Aquí está el escenario que vamos a probar: crearemos una biblioteca que realiza
un seguimiento de un valor en relación con un valor máximo, y envía mensajes
en función de la proximidad del valor actual al valor máximo. Esta biblioteca
podría usarse para realizar un seguimiento de la cuota de un usuario para el
número de llamadas a la API que se le permite realizar, por ejemplo.</p>
<p>El objetivo de nuestra biblioteca es proporcionar la funcionalidad de realizar
un seguimiento de qué tan cerca está un valor de su máximo y que mensajes se
deben enviar en qué momentos. Se espera que las aplicaciones que utilicen
nuestra biblioteca proporcionen el mecanismo para enviar los mensajes: la
aplicación podría poner un mensaje en la interfaz de la aplicación, enviar un
correo electrónico, enviar un mensaje de texto o algo más. La biblioteca no
necesita saber ese detalle. Todo lo que necesita es algo que implemente un
trait que proporcionaremos llamado <code>Messenger</code>. El listado 15-20 muestra el
código de la biblioteca:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        }
    }
}</code></pre>
<p><span class="caption">Listing 15-20: Una biblioteca para realizar un seguimiento
de qué tan cerca está un valor a su valor máximo y emitir advertencias
cuando el valor alcanza ciertos niveles.</span></p>
<p>Una parte importante de este código es el trait <code>Messenger</code>, que tiene un método
llamado <code>send</code> que toma una referencia inmutable a <code>self</code> y el texto del
mensaje. Este trait es la interfaz que nuestro objeto simulado necesita
implementar para que el simulado se pueda usar de la misma manera que un objeto
real. La otra parte importante es que queremos probar el comportamiento del
método <code>set_value</code> en el <code>LimitTracker</code>. Podemos cambiar lo que pasamos para el
parámetro <code>value</code>, pero <code>set_value</code> no devuelve nada para que podamos hacer
afirmaciones. Queremos poder decir que si creamos un <code>LimitTracker</code> con algo
que implemente el trait <code>Messenger</code> y un valor particular para <code>max</code>, cuando
pasemos diferentes números para <code>value</code>, se le dice al mensajero que envíe los
mensajes apropiados.</p>
<p>Necesitamos un objeto simulado que, en lugar de enviar un email o un mensaje de
texto cuando llamamos a <code>send</code>, solo haga un seguimiento de los mensajes que se
le dice que envíe. Podemos crear una nueva instancia del objeto simulado,
crear un <code>LimitTracker</code> que use el objeto simulado, llamar al método
<code>set_value</code> en <code>LimitTracker</code> y luego verificar que el objeto simulado tenga los
mensajes que esperamos. El listado 15-21 muestra un intento de implementar un
objeto simulado para hacer precisamente eso, pero el borrow checker
no lo permite:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<p><span class="caption">Listing 15-21: Un intento de implementar un <code>MockMessenger</code>
que no es permitido por el borrow checker</span></p>
<p>Este código de test define un struct <code>MockMessenger</code> que tiene un campo
<code>sent_messages</code> que es una <code>Vec</code> de <code>String</code> valores. Definimos una función
asociada <code>new</code> para que sea conveniente crear nuevos valores <code>MockMessenger</code>
que comiencen con una lista vacía de mensajes. Luego implementamos el trait
<code>Messenger</code> para <code>MockMessenger</code> para que podamos darle un <code>MockMessenger</code> a un
<code>LimitTracker</code>. En la definición del método <code>send</code>, tomamos el mensaje pasado
como parámetro y lo almacenamos en la lista <code>MockMessenger</code> de <code>sent_messages</code>.</p>
<p>En el test, estamos testeando qué sucede cuando el <code>LimitTracker</code> se le dice que
establezca <code>value</code> en algo que es más del 75 por ciento del valor <code>max</code>. En
primer lugar, creamos un nuevo <code>MockMessenger</code>, que comenzará con una lista
vacía de mensajes. Luego creamos un nuevo <code>LimitTracker</code> y le damos una
referencia al nuevo <code>MockMessenger</code> y un valor <code>max</code> de 100. Llamamos al método
<code>set_value</code> en el <code>LimitTracker</code> con un valor de 80, que es más del 75 por
ciento de 100. Luego afirmamos que la lista de mensajes que el <code>MockMessenger</code>
está realizando un seguimiento debería tener ahora un mensaje en ella.</p>
<p>Sin embargo, hay un problema con este test, como se muestra aquí:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference
   |
2  |     fn send(&amp;mut self, msg: &amp;str);
   |             ~~~~~~~~~

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>No podemos modificar <code>sent_messages</code> para realizar un seguimiento de los
mensajes, porque el método <code>send</code> toma una referencia inmutable a <code>self</code>.
Tampoco podemos tomar la sugerencia del texto de error para usar <code>&amp;mut self</code>
en su lugar, porque entonces la firma de <code>send</code> no coincidiría con la firma en
la definición del trait <code>Messenger</code> (siéntase libre de intentarlo y ver qué
mensaje de error obtiene).</p>
<p>Esta es una situación en la que la mutabilidad interior puede ayudar.
Almacenaremos los <code>sent_messages</code> dentro de un <code>RefCell&lt;T&gt;</code>, y luego el método
<code>send</code> podrá modificar <code>sent_messages</code> para almacenar los mensajes que hemos
visto. El listado 15-22 muestra cómo se ve eso:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<p><span class="caption">Listing 15-22: Usando <code>RefCell&lt;T&gt;</code> para mutar un valor
interno mientras el valor externo se considera inmutable.</span></p>
<p>El campo <code>sent_messages</code> ahora es de tipo <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> en lugar de
<code>Vec&lt;String&gt;</code>. En la función <code>new</code>, creamos una nueva instancia de
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> alrededor del vector vacío.</p>
<p>En la implementación del método <code>send</code>, el primer parámetro sigue siendo un
inmutable borrow de <code>self</code>, que coincide con la definición del trait. Llamamos
a <code>borrow_mut</code> en el <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> en <code>self.sent_messages</code> para obtener
una referencia mutable al valor dentro del <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, que es el
vector. Luego podemos llamar a <code>push</code> en la referencia mutable al vector para
hacer un seguimiento de los mensajes enviados durante el test.</p>
<p>La última modificación que debemos hacer está en la afirmación: para ver cuántos
elementos hay en el vector interno, llamamos a <code>borrow</code> en el
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> para obtener una referencia inmutable al vector.</p>
<p>Ahora que has visto cómo usar <code>RefCell&lt;T&gt;</code>, ¡profundicemos en cómo funciona!</p>
<h4 id="haciendo-un-seguimiento-del-borrowing-en-runtime-con-refcellt"><a class="header" href="#haciendo-un-seguimiento-del-borrowing-en-runtime-con-refcellt">Haciendo un seguimiento del borrowing en runtime con <code>RefCell&lt;T&gt;</code></a></h4>
<p>Cuando creamos referencias inmutables y mutables, usamos la sintaxis <code>&amp;</code> y
<code>&amp;mut</code>, respectivamente. Con <code>RefCell&lt;T&gt;</code>, usamos los métodos <code>borrow</code> y
<code>borrow_mut</code>, que son parte de la API segura que pertenece a <code>RefCell&lt;T&gt;</code>. El
método <code>borrow</code> devuelve el tipo de smart pointer <code>Ref&lt;T&gt;</code>, y <code>borrow_mut</code>
devuelve el tipo de smart pointer <code>RefMut&lt;T&gt;</code>. Ambos tipos implementan <code>Deref</code>,
por lo que podemos tratarlos como referencias regulares.</p>
<p><code>RefCell&lt;T&gt;</code> realiza un seguimiento de cuántos smart pointers <code>Ref&lt;T&gt;</code> y
<code>RefMut&lt;T&gt;</code> están actualmente activos. Cada vez que llamamos a <code>borrow</code>, el
<code>RefCell&lt;T&gt;</code> aumenta su recuento de cuántos borrowing inmutables están activos.
Cuando un valor <code>Ref&lt;T&gt;</code> sale del scope, el recuento de borrowing inmutables
disminuye en uno. Al igual que las reglas de borrowing en tiempo de compilación,
<code>RefCell&lt;T&gt;</code> nos permite tener muchos borrowing inmutables o un borrowing
mutable en un momento dado.</p>
<p>Si intentamos romper estas reglas, en lugar de obtener un error del compilador
como lo haríamos con las referencias, la implementación de <code>RefCell&lt;T&gt;</code> se
bloqueará en tiempo de ejecución. El listado 15-23 muestra una modificación de
la implementación de <code>send</code> en el listado 15-22. Estamos tratando
deliberadamente de crear dos borrowing mutables activos para el mismo scope
para ilustrar que <code>RefCell&lt;T&gt;</code> nos impide hacer esto en tiempo de ejecución.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 15-23: Creando dos referencias mutables en el
mismo scope para ver que <code>RefCell&lt;T&gt;</code> lanzará un panic</span></p>
<p>Creamos una variable <code>one_borrow</code> para el smart pointer <code>RefMut&lt;T&gt;</code> devuelto
desde <code>borrow_mut</code>. Luego creamos otro borrowing mutable de la misma manera en
la variable <code>two_borrow</code>. Esto hace dos referencias mutables en el mismo scope,
lo cual no está permitido. Cuando ejecutamos los tests para nuestra librería, el
código en el listado 15-23 se compilará sin errores, pero el test fallará:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Observa que el código entró en panic con el mensaje <code>already borrowed: BorrowMutError</code>. Así es como <code>RefCell&lt;T&gt;</code> maneja las violaciones de las reglas
de borrowing en tiempo de ejecución.</p>
<p>Elegir capturar errores de borrowing en tiempo de ejecución en lugar de en
tiempo de compilación, como lo hemos hecho aquí, significa que potencialmente
encontrarías errores en tu código más tarde en el proceso de desarrollo:
posiblemente no hasta que tu código se implemente en producción. Además, tu
código incurriría en una pequeña penalización de rendimiento en tiempo de
ejecución como resultado de realizar un seguimiento de los borrows en tiempo de
ejecución en lugar de en tiempo de compilación. Sin embargo, usar <code>RefCell&lt;T&gt;</code>
hace posible escribir un objeto simulado que pueda modificarse para realizar un
seguimiento de los mensajes que ha visto mientras lo estás usando en un
contexto donde solo se permiten valores inmutables. Puedes usar <code>RefCell&lt;T&gt;</code>
a pesar de sus compensaciones para obtener más funcionalidad de la que
proporcionan las referencias regulares.</p>
<h3 id="teniendo-múltiples-propietarios-de-datos-mutables-combinando-rct-y-refcellt"><a class="header" href="#teniendo-múltiples-propietarios-de-datos-mutables-combinando-rct-y-refcellt">Teniendo múltiples propietarios de datos mutables combinando <code>Rc&lt;T&gt;</code> y <code>RefCell&lt;T&gt;</code></a></h3>
<p>Una forma común de usar <code>RefCell&lt;T&gt;</code> es en combinación con <code>Rc&lt;T&gt;</code>. Recuerda
que <code>Rc&lt;T&gt;</code> te permite tener múltiples propietarios de algunos datos, pero solo
te da acceso inmutable a esos datos. Si tienes un <code>Rc&lt;T&gt;</code> que contiene un
<code>RefCell&lt;T&gt;</code>, puedes obtener un valor que puede tener múltiples propietarios y
que puedes mutar.</p>
<p>Por ejemplo, recuerda el ejemplo de la lista de cons en el Listado 15-18 donde
usamos <code>Rc&lt;T&gt;</code> para permitir que múltiples listas compartan propiedad de otra
lista. Debido a que <code>Rc&lt;T&gt;</code> contiene solo valores inmutables, no podemos cambiar
ninguno de los valores en la lista una vez que los hemos creado. Agreguemos
<code>RefCell&lt;T&gt;</code> para obtener la capacidad de cambiar los valores en las listas.
El listado 15-24 muestra que al usar un <code>RefCell&lt;T&gt;</code> en la definición de <code>Cons</code>,
podemos modificar el valor almacenado en todas las listas:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {a:?}&quot;);
    println!(&quot;b after = {b:?}&quot;);
    println!(&quot;c after = {c:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 15-24: Usando <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> para crear una
<code>List</code> que podemos modificar.</span></p>
<p>Creamos un valor que es una instancia de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> y lo almacenamos en
una variable llamada <code>value</code> para que podamos acceder a él directamente más
tarde. Luego creamos una <code>List</code> en <code>a</code> con una variante <code>Cons</code> que contiene
<code>value</code>. Necesitamos clonar <code>value</code> para que tanto <code>a</code> como <code>value</code> tengan
ownership del valor interno <code>5</code> en lugar de transferir el ownership de <code>value</code>
a <code>a</code> o tener <code>a</code> pedir prestado de <code>value</code>.</p>
<p>Envolvemos la lista <code>a</code> en un <code>Rc&lt;T&gt;</code> para que cuando creemos las listas <code>b</code> y
<code>c</code>, ambas puedan referirse a <code>a</code>, que es lo que hicimos en el listado 15-18.</p>
<p>Después de haber creado las listas en <code>a</code>, <code>b</code> y <code>c</code>, queremos agregar 10 al
valor en <code>value</code>. Hacemos esto llamando a <code>borrow_mut</code> en <code>value</code>, que usa la
característica de dereferenciación automática que discutimos en el capítulo 5
(ver la sección <a href="ch05-03-method-syntax.html#donde-esta-el-operador--">“¿Dónde está el operador <code>-&gt;</code>?”</a><!--
ignore -->) para desreferenciar el <code>Rc&lt;T&gt;</code> al valor interno <code>RefCell&lt;T&gt;</code>.
El método <code>borrow_mut</code> devuelve un smart pointer <code>RefMut&lt;T&gt;</code>, y usamos el
operador de desreferenciación en él y cambiamos el valor interno.</p>
<p>Cuando imprimimos <code>a</code>, <code>b</code> y <code>c</code>, podemos ver que todos tienen el valor
modificado de 15 en lugar de 5:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>¡Esta técnica es bastante genial! Al usar <code>RefCell&lt;T&gt;</code>, tenemos un valor
<code>List</code> externamente inmutable. Pero podemos usar los métodos en <code>RefCell&lt;T&gt;</code>
que proporcionan acceso a su mutabilidad interior para que podamos modificar
nuestros datos cuando sea necesario. Las comprobaciones en tiempo de ejecución
de las reglas de borrowing nos protegen de las condiciones de carrera en los
datos y, a veces, vale la pena intercambiar un poco de velocidad por esta
flexibilidad en nuestras estructuras de datos. ¡Ten en cuenta que <code>RefCell&lt;T&gt;</code>
no funciona para código multihilo! <code>Mutex&lt;T&gt;</code> es la versión segura para hilos
de <code>RefCell&lt;T&gt;</code> y discutiremos <code>Mutex&lt;T&gt;</code> en el capítulo 16.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referencias-circulares-pueden-fugar-memoria"><a class="header" href="#referencias-circulares-pueden-fugar-memoria">Referencias Circulares Pueden Fugar Memoria</a></h2>
<p>Las garantías de seguridad de memoria de Rust hacen difícil, pero no imposible,
crear accidentalmente memoria que nunca se limpia (conocido como una <em>fuga de
memoria</em>). Prevenir fugas de memoria completamente no es una de las garantías de
Rust, lo que significa que las fugas de memoria son seguras en Rust. Podemos ver
que Rust permite fugas de memoria usando <code>Rc&lt;T&gt;</code> y <code>RefCell&lt;T&gt;</code>: es posible
crear referencias donde los elementos se refieren entre sí en un ciclo. Esto
crea fugas de memoria porque el recuento de referencias de cada elemento en el
ciclo nunca alcanzará 0, y los valores nunca serán descartados.</p>
<h3 id="creando-una-referencia-circular"><a class="header" href="#creando-una-referencia-circular">Creando una Referencia Circular</a></h3>
<p>Vamos a ver cómo podría ocurrir una referencia circular y cómo prevenirla, 
comenzando con la definición del enum <code>List</code> y un método <code>tail</code> en el Listado
15-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<p><span class="caption">Listing 15-25: Una definición de lista enlazada 
que contiene un <code>RefCell&lt;T&gt;</code> para poder modificar a que se refiere una
variante <code>Cons</code></span></p>
<p>Estamos usando otra variación de la definición de <code>List</code> del Listado 15-5. El
segundo elemento en la variante <code>Cons</code> es ahora <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, lo que
significa que en lugar de tener la capacidad de modificar el valor <code>i32</code> como lo
hicimos en el Listado 15-24, queremos modificar el valor <code>List</code> al que una
variante <code>Cons</code> está apuntando. También estamos agregando un método <code>tail</code> para
que sea conveniente para nosotros acceder al segundo elemento si tenemos una
variante <code>Cons</code>.</p>
<p>En el Listado 15-26, estamos agregando una función <code>main</code> que usa las
definiciones en el Listado 15-25. Este código crea una lista en <code>a</code> y una lista
en <code>b</code> que apunta a la lista en <code>a</code>. Luego modifica la lista en <code>a</code> para que
apunte a <code>b</code>, creando un ciclo de referencia. Hay declaraciones <code>println!</code> a lo
largo del camino para mostrar cuáles son los recuentos de referencia en varios
puntos de este proceso.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}</code></pre></pre>
<p><span class="caption">Listing 15-26: Creando un ciclo de referencia de dos 
valores <code>List</code> que se apuntan mutuamente.</span></p>
<p>Creamos una instancia <code>Rc&lt;List&gt;</code> que contiene un valor <code>List</code> en la variable
<code>a</code> con una lista inicial de <code>5, Nil</code>. Luego creamos una instancia <code>Rc&lt;List&gt;</code>
que contiene otro valor <code>List</code> en la variable <code>b</code> que contiene el valor 10 y
apunta a la lista en <code>a</code>.</p>
<p>Modificamos <code>a</code> para que apunte a <code>b</code> en lugar de <code>Nil</code>, creando un ciclo. 
Hacemos eso usando el método <code>tail</code> para obtener una referencia al 
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> en <code>a</code>, que ponemos en la variable <code>link</code>. Luego usamos el 
método <code>borrow_mut</code> en el <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> para cambiar el valor interno de 
un <code>Rc&lt;List&gt;</code> que contiene un valor <code>Nil</code> al <code>Rc&lt;List&gt;</code> en <code>b</code>.</p>
<p>Cuando ejecutamos este código, manteniendo el último <code>println!</code> comentado por
el momento, obtendremos este output:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>El recuento de referencia de las instancias <code>Rc&lt;List&gt;</code> en <code>a</code> y <code>b</code> son 2
después de cambiar la lista en <code>a</code> para que apunte a <code>b</code>. Al final de <code>main</code>,
Rust descarta la variable <code>b</code>, que disminuye el recuento de referencia de la
instancia <code>Rc&lt;List&gt;</code> de <code>b</code> de 2 a 1. La memoria que <code>Rc&lt;List&gt;</code> tiene en el
heap no se descartará en este punto, porque su recuento de referencia es 1, 
no 0. Luego Rust descarta <code>a</code>, que disminuye el recuento de referencia de la
instancia <code>Rc&lt;List&gt;</code> de <code>a</code> de 2 a 1 también. La memoria asignada a la lista
no se recogerá nunca. Para visualizar este ciclo de referencia, hemos creado
un diagrama en la Figura 15-4.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Figure 15-4: Un ciclo de referencia de las listas <code>a</code> 
y <code>b</code> apuntándose mutuamente.</span></p>
<p>Si descomentas el último <code>println!</code> y ejecutas el programa, Rust intentará
imprimir este ciclo con <code>a</code> apuntando a <code>b</code> apuntando a <code>a</code> y así sucesivamente
hasta que desborda el stack.</p>
<p>En comparación con un programa del mundo real, las consecuencias de crear un
ciclo de referencia en este ejemplo no son muy graves: justo después de crear
el ciclo de referencia, el programa termina. Sin embargo, si un programa más
complejo asignara mucha memoria en un ciclo y la mantuviera durante mucho
tiempo, el programa usaría más memoria de la que necesitaba y podría
abrumar el sistema, causando que se quede sin memoria disponible.</p>
<p>Crear ciclos de referencia no es algo fácil de hacer, pero tampoco es imposible.
Si tienes valores <code>RefCell&lt;T&gt;</code> que contienen valores <code>Rc&lt;T&gt;</code> o combinaciones
similares de tipos con mutabilidad interior y recuento de referencias anidados,
debes asegurarte de no crear ciclos; no puedes confiar en Rust para atraparlos.
Crear un ciclo de referencia sería un error de lógica en tu programa que 
deberías usar pruebas automatizadas, revisiones de código y otras prácticas de 
desarrollo de software para minimizar.</p>
<p>Otra solución para evitar ciclos de referencia es reorganizar tus estructuras
de datos para que algunas referencias expresen propiedad y algunas referencias
no expresen ownership. Como resultado, puedes tener ciclos compuestos por
algunas relaciones de ownership y algunas relaciones de no ownership, y solo
las relaciones de ownership afectan si un valor puede ser descartado. En el
Listado 15-25, siempre queremos que las variantes <code>Cons</code> posean su lista, por
lo que no es posible reorganizar la estructura de datos. Veamos un ejemplo
usando gráficos compuestos por nodos padres y nodos hijos para ver cuándo las
relaciones de no ownership son una forma apropiada de evitar ciclos de
referencia.</p>
<h3 id="previniendo-ciclos-de-referencia-convirtiendo-un-rct-en-un-weakt"><a class="header" href="#previniendo-ciclos-de-referencia-convirtiendo-un-rct-en-un-weakt">Previniendo ciclos de referencia: convirtiendo un <code>Rc&lt;T&gt;</code> en un <code>Weak&lt;T&gt;</code></a></h3>
<p>Hasta ahora, hemos demostrado que llamar a <code>Rc::clone</code> aumenta el <code>strong_count</code>
de una instancia <code>Rc&lt;T&gt;</code>, y una instancia <code>Rc&lt;T&gt;</code> solo se limpia si su
<code>strong_count</code> es 0. También puedes crear una <em>referencia débil</em> al valor
dentro de una instancia <code>Rc&lt;T&gt;</code> llamando a <code>Rc::downgrade</code> y pasando una
referencia a la <code>Rc&lt;T&gt;</code>. Las referencias fuertes son cómo puedes compartir el
ownership de una instancia <code>Rc&lt;T&gt;</code>. Las referencias débiles no expresan una
relación de ownership, y su recuento no afecta cuándo se limpia una instancia
<code>Rc&lt;T&gt;</code>. No causarán un ciclo de referencia porque cualquier ciclo que involucre
algunas referencias débiles se romperá una vez que el recuento de referencias
fuertes de los valores involucrados sea 0.</p>
<p>Cuando llamas a <code>Rc::downgrade</code>, obtienes un smart pointer de tipo <code>Weak&lt;T&gt;</code>. 
En lugar de aumentar el <code>strong_count</code> en la instancia de <code>Rc&lt;T&gt;</code> en 1, llamar a 
<code>Rc::downgrade</code> aumenta el <code>weak_count</code> en 1. El tipo <code>Rc&lt;T&gt;</code> utiliza el 
<code>weak_count</code> para realizar un seguimiento de cuántas referencias <code>Weak&lt;T&gt;</code> 
existen, de manera similar al <code>strong_count</code>. La diferencia es que el 
<code>weak_count</code> no necesita ser 0 para que se limpie la instancia de <code>Rc&lt;T&gt;</code>.</p>
<p>Dado que el valor al que apunta <code>Weak&lt;T&gt;</code> puede haber sido eliminado, para
hacer cualquier cosa con el valor al que apunta un <code>Weak&lt;T&gt;</code>, debes asegurarte
de que el valor aún exista. Haz esto llamando al método <code>upgrade</code> en una
instancia <code>Weak&lt;T&gt;</code>, que devolverá un <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Si el valor <code>Rc&lt;T&gt;</code> aún
no se ha eliminado, <code>upgrade</code> devolverá <code>Some</code>, y si el valor <code>Rc&lt;T&gt;</code> se ha
eliminado, <code>upgrade</code> devolverá <code>None</code>. Porque <code>upgrade</code> devuelve un
<code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust se asegurará de que se manejen los casos <code>Some</code> y <code>None</code>,
y no habrá un puntero no válido.</p>
<p>Como ejemplo, en lugar de usar una lista cuyos elementos solo conocen al
siguiente elemento, crearemos un árbol cuyos elementos conocen a sus elementos
hijos <em>y</em> a sus elementos padres.</p>
<h4 id="creando-una-estructura-de-datos-de-árbol-un-node-con-nodos-hijos"><a class="header" href="#creando-una-estructura-de-datos-de-árbol-un-node-con-nodos-hijos">Creando una estructura de datos de árbol: un <code>Node</code> con nodos hijos</a></h4>
<p>Para comenzar, construiremos un árbol con nodos que conocen a sus nodos hijos.
Crearemos una estructura llamada <code>Node</code> que contenga su propio valor <code>i32</code> así
como referencias a sus nodos hijos <code>Node</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>Queremos que un <code>Node</code> sea propietario de sus hijos, y queremos compartir
ese ownership con variables para que podamos acceder a cada <code>Node</code> en el árbol
directamente. Para hacer esto, definimos los elementos <code>Vec&lt;T&gt;</code> para ser
valores de tipo <code>Rc&lt;Node&gt;</code>. También queremos modificar qué nodos son hijos de
otro nodo, por lo que tenemos un <code>RefCell&lt;T&gt;</code> en <code>children</code> alrededor del
<code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>A continuación, usaremos la definición de nuestro struct y crearemos una
instancia <code>Node</code> llamada <code>leaf</code> con el valor 3 y sin hijos, y otra instancia
llamada <code>branch</code> con el valor 5 y <code>leaf</code> como uno de sus hijos, como se muestra
en el Listado 15-26:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<p><span class="caption">Listing 15-27: Creando un nodo <code>leaf</code> sin hijos y un nodo
<code>branch</code> con <code>leaf</code> como uno de sus hijos</span></p>
<p>Clonamos el <code>Rc&lt;Node&gt;</code> en <code>leaf</code> y lo almacenamos en <code>branch</code>, lo que significa
que el <code>Node</code> en <code>leaf</code> ahora tiene dos propietarios: <code>leaf</code> y <code>branch</code>. Podemos
ir de <code>branch</code> a <code>leaf</code> a través de <code>branch.children</code>, pero no hay forma de
ir de <code>leaf</code> a <code>branch</code>. La razón es que <code>leaf</code> no tiene referencia a <code>branch</code>
y no sabe que están relacionados. Queremos que <code>leaf</code> sepa que <code>branch</code> es su
padre. Lo haremos a continuación.</p>
<h4 id="agregando-una-referencia-de-un-hijo-a-su-padre"><a class="header" href="#agregando-una-referencia-de-un-hijo-a-su-padre">Agregando una referencia de un hijo a su padre</a></h4>
<p>Para hacer que el nodo hijo sea consciente de su padre, necesitamos agregar un
campo <code>parent</code> a nuestra definición de struct <code>Node</code>. El problema está en
decidir qué tipo de <code>parent</code> debería ser. Sabemos que no puede contener un
<code>Rc&lt;T&gt;</code>, porque eso crearía un ciclo de referencia con <code>leaf.parent</code> apuntando
a <code>branch</code> y <code>branch.children</code> apuntando a <code>leaf</code>, lo que haría que sus valores
<code>strong_count</code> nunca fueran 0.</p>
<p>Si pensamos en las relaciones de otra manera, un nodo padre debería ser
propietario de sus nodos hijos: si se elimina un nodo padre, sus nodos hijos
también deberían eliminarse. Sin embargo, un hijo no debería ser propietario de
su padre: si eliminamos un nodo hijo, el padre aún debería existir. ¡Este es un
caso para las referencias débiles!</p>
<p>Entonces en lugar de <code>Rc&lt;T&gt;</code>, usaremos <code>Weak&lt;T&gt;</code> como tipo de dato para <code>parent</code>
, específicamente <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Ahora nuestra definición de struct
<code>Node</code> se ve así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>Un nodo podrá referirse a su nodo padre, pero no será propietario de él. En
el Listado 15-28, actualizamos <code>main</code> para usar esta nueva definición, por lo
que el nodo <code>leaf</code> tendrá una forma de referirse a su nodo padre, <code>branch</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}</code></pre></pre>
<p><span class="caption">Listing 15-28: Un nodo <code>leaf</code> con una referencia débil a 
su nodo padre <code>branch</code></span></p>
<p>La creación del nodo <code>leaf</code> se ve similar al Listado 15-27 con la excepción del
campo <code>parent</code>: <code>leaf</code> comienza sin un padre, por lo que creamos una nueva
instancia de referencia <code>Weak&lt;Node&gt;</code> vacía.</p>
<p>En este punto, cuando intentamos obtener una referencia al padre de <code>leaf</code>
usando el método <code>upgrade</code>, obtenemos un valor <code>None</code>. Vemos esto en el output
de la primera instrucción <code>println!</code>:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Cuando creamos el nodo <code>branch</code>, también tendrá una nueva referencia 
<code>Weak&lt;Node&gt;</code> en el campo <code>parent</code>, porque <code>branch</code> no tiene un nodo padre.
Todavía tenemos <code>leaf</code> como uno de los hijos de <code>branch</code>. Una vez que tenemos
la instancia <code>Node</code> en <code>branch</code>, podemos modificar <code>leaf</code> para darle una
referencia <code>Weak&lt;Node&gt;</code> a su padre. Usamos el método <code>borrow_mut</code> en el
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> en el campo <code>parent</code> de <code>leaf</code>, y luego usamos la
función <code>Rc::downgrade</code> para crear una referencia <code>Weak&lt;Node&gt;</code> a <code>branch</code> desde
el <code>Rc&lt;Node&gt;</code> en <code>branch</code>.</p>
<p>Cuando imprimimos el padre de <code>leaf</code> nuevamente, esta vez obtendremos una
variante <code>Some</code> que contiene <code>branch</code>: ¡ahora <code>leaf</code> puede acceder a su padre!
Cuando imprimimos <code>leaf</code>, también evitamos el ciclo que eventualmente terminó
en un desbordamiento de pila como teníamos en el Listado 15-26; las referencias
<code>Weak&lt;Node&gt;</code> se imprimen como <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>La falta de output infinito indica que este código no creó un ciclo de
referencia. También podemos decir esto mirando los valores que obtenemos al
llamar a <code>Rc::strong_count</code> y <code>Rc::weak_count</code>.</p>
<h4 id="visualizando-cambios-en-strong_count-y-weak_count"><a class="header" href="#visualizando-cambios-en-strong_count-y-weak_count">Visualizando cambios en <code>strong_count</code> y <code>weak_count</code></a></h4>
<p>Veamos cómo cambian los valores <code>strong_count</code> y <code>weak_count</code> de las instancias
<code>Rc&lt;Node&gt;</code> al crear y modificar <code>branch</code>. El Listado 15-29 muestra el código
que usamos para crear <code>branch</code> en un nuevo scope interno y examinar los valores
de referencia <code>strong_count</code> y <code>weak_count</code>. Al hacerlo, podemos ver qué
sucede cuando se crea <code>branch</code> y luego se elimina cuando sale del scope. Las
modificaciones se muestran en el Listado 15-29:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<p><span class="caption">Listing 15-29: Creando <code>branch</code> en un scope interno y
examinando los recuentos de referencias fuertes y débiles</span></p>
<p>Después de crear <code>leaf</code>, el <code>Rc&lt;Node&gt;</code> tiene un <code>strong_count</code> de 1 y un
<code>weak_count</code> de 0. En el scope interno, creamos <code>branch</code> y lo asociamos con
<code>leaf</code>, momento en el que cuando imprimimos los conteos, el <code>Rc&lt;Node&gt;</code> en
<code>branch</code> tendrá un <code>strong_count</code> de 1 y un <code>weak_count</code> de 1 (porque
<code>leaf.parent</code> apunta a <code>branch</code> con un <code>Weak&lt;Node&gt;</code>). Cuando imprimimos los
conteos en <code>leaf</code>, veremos que tendrá un <code>strong_count</code> de 2, porque <code>branch</code>
ahora tiene un clon del <code>Rc&lt;Node&gt;</code> de <code>leaf</code> almacenado en <code>branch.children</code>,
pero aún tendrá un <code>weak_count</code> de 0.</p>
<p>Cuando el scope interno termina, <code>branch</code> sale del scope y el recuento fuerte
del <code>Rc&lt;Node&gt;</code> en <code>branch</code> se reduce a 0, por lo que su <code>Node</code> se elimina. El
recuento débil de 1 de <code>leaf.parent</code> no tiene ninguna consecuencia sobre si se
elimina o no <code>Node</code>, ¡así que no obtenemos fugas de memoria!</p>
<p>Si intentamos acceder al padre de <code>leaf</code> después del final del scope, 
obtendremos <code>None</code> nuevamente. Al final del programa, el <code>Rc&lt;Node&gt;</code> en <code>leaf</code>
tiene un recuento fuerte de 1 y un recuento débil de 0, porque la variable
<code>leaf</code> es nuevamente la única referencia al <code>Rc&lt;Node&gt;</code>.</p>
<p>Toda la lógica que gestiona los recuentos y la eliminación de valores está
incorporada en <code>Rc&lt;T&gt;</code> y <code>Weak&lt;T&gt;</code> y sus implementaciones del trait <code>Drop</code>. Al
especificar que la relación de un hijo con su padre debe ser una referencia
<code>Weak&lt;T&gt;</code> en la definición de <code>Node</code>, puede tener nodos padres que apunten a
nodos hijos y viceversa sin crear un ciclo de referencia y fugas de memoria.</p>
<h2 id="resumen-14"><a class="header" href="#resumen-14">Resumen</a></h2>
<p>Este capítulo cubrió cómo usar smart pointers para hacer diferentes garantías y
compensaciones de las que Rust hace de forma predeterminada con referencias
regulares. El tipo <code>Box&lt;T&gt;</code> tiene un tamaño conocido y apunta a datos
asignados en el heap. El tipo <code>Rc&lt;T&gt;</code> realiza un seguimiento del número de
referencias a los datos en el heap para que los datos puedan tener múltiples
propietarios. El tipo <code>RefCell&lt;T&gt;</code> con su mutabilidad interior nos da un tipo
que podemos usar cuando necesitamos un tipo inmutable, pero necesitamos cambiar
un valor interno de ese tipo; también hace cumplir las reglas de borrowing en
tiempo de ejecución en lugar de en tiempo de compilación.</p>
<p>También se discutieron los traits <code>Deref</code>, <code>Drop</code>,que habilitan gran parte
de la funcionalidad de los smart pointers. Exploramos los ciclos de referencia
que pueden causar fugas de memoria y cómo prevenirlos usando <code>Weak&lt;T&gt;</code>.</p>
<p>Si este capítulo ha despertado tu interés y quieres implementar tus propios
smart pointers, consulta <a href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a> para obtener más
información útil.</p>
<p>A continuación, hablaremos sobre la concurrencia en Rust. Incluso aprenderás
sobre algunos nuevos smart pointers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrencia-sin-miedo"><a class="header" href="#concurrencia-sin-miedo">Concurrencia sin miedo</a></h1>
<p>Manejar la programación concurrente de forma segura y eficiente es otro de los
principales objetivos de Rust. La <em>programación concurrente</em>, donde diferentes
partes de un programa se ejecutan de forma independiente, y la <em>programación
paralela</em>, donde diferentes partes de un programa se ejecutan al mismo tiempo,
son cada vez más importantes a medida que más computadoras aprovechan sus
múltiples procesadores. Históricamente, la programación en estos contextos ha
sido difícil y propensa a errores: ¡Rust espera cambiar eso!</p>
<p>Inicialmente, el equipo de Rust pensó que garantizar la seguridad de la memoria
y prevenir los problemas de concurrencia eran dos desafíos separados que se
resolverían con diferentes métodos. Con el tiempo, el equipo descubrió que los
sistemas de propiedad y tipos son un conjunto de herramientas poderosas para
ayudar a administrar la seguridad de la memoria <em>y</em> los problemas de
concurrencia. Al aprovechar la propiedad y la comprobación de tipos, muchos
errores de concurrencia son errores de tiempo de compilación en Rust en lugar
de errores de tiempo de ejecución. Por lo tanto, en lugar de hacer que pase
mucho tiempo tratando de reproducir las circunstancias exactas en las que se
produce un error de concurrencia en tiempo de ejecución, el código incorrecto
se negará a compilar y presentará un error que explica el problema. Como
resultado, puede corregir su código mientras lo está trabajando en lugar de
potencialmente después de que se haya enviado a producción. Hemos apodado este
aspecto de Rust como <em>concurrencia sin miedo</em>. La concurrencia sin miedo le
permite escribir código que no tiene errores sutiles y es fácil de refactorizar
sin introducir nuevos bugs.</p>
<blockquote>
<p>Nota: Para simplificar, nos referiremos a muchos de los problemas como
<em>concurrentes</em> en lugar de ser más precisos al decir <em>concurrentes y/o
paralelos</em>. Si este libro tratara sobre concurrencia y/o paralelismo, seríamos
más específicos. Para este capítulo, por favor sustituya mentalmente
<em>concurrente y/o paralelo</em> cada vez que usemos <em>concurrente</em>.</p>
</blockquote>
<p>Muchos lenguajes son dogmáticos sobre las soluciones que ofrecen para manejar
problemas concurrentes. Por ejemplo, Erlang tiene una funcionalidad elegante
para la concurrencia de paso de mensajes, pero solo tiene formas oscuras de
compartir estado entre hilos. Soportar solo un subconjunto de soluciones
posibles es una estrategia razonable para los lenguajes de más alto nivel,
porque un lenguaje de más alto nivel promete beneficios al renunciar a cierto
control para obtener abstracciones. Sin embargo, se espera que los lenguajes de
nivel inferior proporcionen la solución con el mejor rendimiento en cualquier
situación dada y tengan menos abstracciones sobre el hardware. Por lo tanto,
Rust ofrece una variedad de herramientas para modelar problemas de la manera
que sea apropiada para su situación y requisitos.</p>
<p>Aquí están los temas que cubriremos en este capítulo:</p>
<ul>
<li>Cómo crear hilos para ejecutar múltiples piezas de código al mismo tiempo</li>
<li><em>Message-passing</em> concurrencia, donde los canales envían mensajes entre hilos</li>
<li><em>Shared-state</em> concurrencia, donde múltiples hilos tienen acceso a alguna
pieza de datos</li>
<li>Los traits <code>Sync</code> y <code>Send</code>, que extienden las garantías de concurrencia de
Rust a los tipos definidos por el usuario, así como a los tipos proporcionados
por la biblioteca estándar</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-threads-para-ejecutar-código-simultáneamente"><a class="header" href="#usando-threads-para-ejecutar-código-simultáneamente">Usando Threads para Ejecutar Código Simultáneamente</a></h2>
<p>En la mayoría de los sistemas operativos actuales, el código de un programa
ejecutado se ejecuta en un <em>proceso</em>, y el sistema operativo administrará
múltiples procesos a la vez. Dentro de un programa, también puede tener partes
independientes que se ejecutan simultáneamente. Las características que ejecutan
estas partes independientes se llaman <em>threads</em>. Por ejemplo, un servidor web
podría tener múltiples hilos para que pudiera responder a más de una solicitud
al mismo tiempo.</p>
<p>Dividir la computación en su programa en múltiples hilos para ejecutar múltiples
tareas al mismo tiempo puede mejorar el rendimiento, pero también agrega
complejidad. Debido a que los hilos pueden ejecutarse simultáneamente, no hay
ninguna garantía inherente sobre el orden en que las partes de su código en
diferentes hilos se ejecutarán. Esto puede conducir a problemas, como:</p>
<ul>
<li>Race conditions, donde los hilos están accediendo a datos o recursos en
un orden inconsistente</li>
<li>Deadlocks, donde dos hilos están esperando el uno al otro, evitando que ambos
hilos continúen</li>
<li>Bugs que ocurren solo en ciertas situaciones y son difíciles de reproducir
y arreglar de manera confiable</li>
</ul>
<p>Rust intenta mitigar los efectos negativos de usar hilos, pero la programación
en un contexto multihilo aún requiere un pensamiento cuidadoso y requiere una
estructura de código que sea diferente de la de los programas que se ejecutan en
un solo hilo.</p>
<p>Los lenguajes de programación implementan hilos de varias maneras diferentes, y
muchos sistemas operativos proporcionan una API que el lenguaje puede llamar
para crear nuevos hilos. La biblioteca estándar de Rust utiliza un modelo <em>1:1</em>
de implementación de hilos, mediante el cual un programa utiliza un hilo del
sistema operativo por un hilo de lenguaje. Hay crates que implementan otros
modelos de enhebrado que hacen diferentes compensaciones al modelo 1:1.</p>
<h3 id="creando-un-nuevo-hilo-con-spawn"><a class="header" href="#creando-un-nuevo-hilo-con-spawn">Creando un Nuevo Hilo con <code>spawn</code></a></h3>
<p>Para crear un nuevo hilo, llamamos a la función <code>thread::spawn</code> y pasamos un
closure (hablamos sobre closures en el Capítulo 13) que contiene el código que
queremos ejecutar en el nuevo hilo. El ejemplo en el Listado 16-1 imprime
algunos textos desde un hilo principal y otros textos desde un nuevo hilo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {i} from the spawned thread!&quot;);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {i} from the main thread!&quot;);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p><span class="caption">Listing 16-1: Creando un nuevo hilo para imprimir una cosa
mientras el hilo principal imprime algo más</span></p>
<p>Nota que cuando el hilo principal de un programa Rust se completa, todos los
hilos creados se apagan, independientemente de si han terminado de ejecutarse o
no. La salida de este programa podría ser un poco diferente cada vez, pero se
verá similar a lo siguiente:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>Las llamadas a <code>thread::sleep</code> fuerzan a un hilo a detener su ejecución durante
una corta duración, permitiendo que se ejecute un hilo diferente. Los hilos
probablemente se turnarán, pero eso no está garantizado: depende de cómo su
sistema operativo programe los hilos. En esta ejecución, el hilo principal
imprimió primero, a pesar de que la instrucción de impresión del hilo creado
aparece primero en el código. Y aunque le dijimos al hilo creado que imprimiera
hasta que <code>i</code> sea 9, solo llegó a 5 antes de que el hilo principal se apagara.</p>
<p>Si ejecutas este código y solo ves el output del hilo principal, o no ves
ninguna superposición, intenta aumentar los números en los rangos para crear
más oportunidades para que el sistema operativo cambie entre los hilos.</p>
<h3 id="esperando-a-que-todos-los-hilos-terminen-usando-join-handles"><a class="header" href="#esperando-a-que-todos-los-hilos-terminen-usando-join-handles">Esperando a que todos los hilos terminen usando <code>join</code> Handles</a></h3>
<p>El código en el Listado 16-1 no solo detiene el hilo creado prematuramente la
mayoría de las veces debido a que el hilo principal termina, sino que debido a
que no hay garantía sobre el orden en que se ejecutan los hilos, ¡tampoco
podemos garantizar que el hilo creado se ejecute en absoluto!</p>
<p>Podemos solucionar el problema de que el hilo creado no se ejecute o termine
prematuramente guardando el valor de retorno de <code>thread::spawn</code> en una variable.
El tipo de retorno de <code>thread::spawn</code> es <code>JoinHandle</code>. Un <code>JoinHandle</code> es un
valor de propiedad que, cuando llamamos al método <code>join</code> en él, esperará a que
su hilo termine. El Listado 16-2 muestra cómo usar el <code>JoinHandle</code> del hilo que
creamos en el Listado 16-1 y llamar a <code>join</code> para asegurarnos de que el hilo
creado termine antes de que <code>main</code> salga:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {i} from the spawned thread!&quot;);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {i} from the main thread!&quot;);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 16-2: Guardando un <code>JoinHandle</code> devuelto por
<code>thread::spawn</code> para garantizar que el hilo se ejecute hasta completarse</span></p>
<p>Llamar a <code>join</code> en el handle bloquea el hilo que está actualmente en ejecución
hasta que el hilo representado por el handle termine. Bloquear un hilo significa
que ese hilo se impide realizar un trabajo o salir. Debido a que hemos puesto la
llamada a <code>join</code> después del bucle <code>for</code> del hilo principal, ejecutar el Listado
16-2 debería producir una salida similar a esta:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>Los dos hilos continúan alternándose, pero el hilo principal espera debido a la
llamada a <code>handle.join()</code> y no termina hasta que el hilo creado haya terminado.</p>
<p>Pero veamos que sucede cuando movemos la llamada a <code>handle.join()</code> antes del
bucle <code>for</code> en <code>main</code>, como esto:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {i} from the spawned thread!&quot;);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {i} from the main thread!&quot;);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p>El hilo principal ahora espera a que el hilo creado termine antes de comenzar su
bucle <code>for</code>, para que el output no se intercale más. La salida ahora se verá
así:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Pequeños detalles, como dónde se llama a <code>join</code>, pueden afectar si sus hilos se
ejecutan al mismo tiempo.</p>
<h3 id="usando-move-closures-con-threads"><a class="header" href="#usando-move-closures-con-threads">Usando <code>move</code> Closures con Threads</a></h3>
<p>A menudo usamos la keyword <code>move</code> con closures pasadas a <code>thread::spawn</code> porque
el closure tomará posesión de los valores que usa del entorno, transfiriendo así
el ownership de esos valores de un hilo a otro. En la sección <a href="ch13-01-closures.html#capturando-referencias-o-moviendo-el-ownership">&quot;Capturando
referencias o moviendo la propiedad&quot;</a><!-- ignore --> del Capítulo 13,
discutimos <code>move</code> en el contexto de las closures. Ahora, nos concentraremos más
en la interacción entre <code>move</code> y <code>thread::spawn</code>.</p>
<p>Observa en el Listado 16-1 que el closure que pasamos a <code>thread::spawn</code> no tiene
argumentos: no estamos usando ningún dato del hilo principal en el código del
hilo creado. Para usar datos del hilo principal en el hilo creado, el closure
del hilo creado debe capturar los valores que necesita. El Listado 16-3 muestra
un intento de crear un vector en el hilo principal y usarlo en el hilo creado.
Sin embargo, esto aún no funcionará, como verás en un momento.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {v:?}&quot;);
    });

    handle.join().unwrap();
}</code></pre>
<p><span class="caption">Listing 16-3: Intentando usar un vector creado por el hilo
principal en otro hilo</span></p>
<p>El closure usa <code>v</code>, por lo que capturará <code>v</code> y lo hará parte del entorno del
closure. Debido a que <code>thread::spawn</code> ejecuta este closure en un nuevo hilo,
deberíamos poder acceder a <code>v</code> dentro de ese nuevo hilo. Pero cuando compilamos
este ejemplo, obtenemos el siguiente error:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {v:?}&quot;);
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Here's a vector: {v:?}&quot;);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin &quot;threads&quot;) due to 1 previous error
</code></pre>
<p>Rust <em>infiere</em> cómo capturar <code>v</code>, y porque <code>println!</code> solo necesita una
referencia a <code>v</code>, el closure intenta pedir prestado <code>v</code>. Sin embargo, hay un
problema: Rust no puede decir cuánto tiempo se ejecutará el hilo creado, por lo
que no sabe si la referencia a <code>v</code> siempre será válida.</p>
<p>El Listado 16-4 proporciona un escenario que es más probable que tenga una
referencia a <code>v</code> que no sea válida:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {v:?}&quot;);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
<p><span class="caption">Listing 16-4: Un hilo con un closure que intenta capturar
una referencia a <code>v</code> desde un hilo principal que deja de tener <code>v</code></span></p>
<p>Si Rust nos permitiera ejecutar este código, existe la posibilidad de que el
hilo creado se ponga inmediatamente en segundo plano sin ejecutarse en absoluto.
El hilo creado tiene una referencia a <code>v</code> dentro, pero el hilo principal
inmediatamente deja caer <code>v</code>, usando la función <code>drop</code> que discutimos en el
Capítulo 15. Luego, cuando el hilo creado comienza a ejecutarse, <code>v</code> ya no es
válido, por lo que una referencia a él también es inválida. ¡Oh no!</p>
<p>Para solucionar el error en el Listado 16-3, podemos seguir el consejo del mensaje
de error:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>Al agregar la keyword <code>move</code> antes del closure, forzamos al closure a tomar
ownership de los valores que está usando en lugar de permitir que Rust infiera
que debería pedir prestado los valores. La modificación al Listado 16-3 que se
muestra en el Listado 16-5 se compilará y ejecutará como lo pretendemos:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {v:?}&quot;);
    });

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 16-5: Usando la keyword <code>move</code> para forzar a un
closure a tomar ownership de los valores que utiliza</span></p>
<p>Podríamos sentir la tentación de intentar lo mismo para arreglar el código en el
Listado 16-4 donde el hilo principal llamó a <code>drop</code> usando un closure <code>move</code>.
Sin embargo, esta solución no funcionará porque lo que el Listado 16-4 está
intentando hacer está prohibido por una razón diferente. Si agregáramos <code>move</code>
al closure, moveríamos <code>v</code> al entorno del closure, y ya no podríamos llamar a
<code>drop</code> en el hilo principal. En su lugar, obtendríamos este error del
compilador:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Here's a vector: {v:?}&quot;);
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin &quot;threads&quot;) due to 1 previous error
</code></pre>
<p>Las reglas de ownership de Rust nos han salvado de nuevo! Obtenemos un error del
código en el Listado 16-3 porque Rust es conservador y solo pide prestado <code>v</code>
para el hilo, lo que significa que el hilo principal podría teóricamente
invalidar la referencia del hilo creado. Al decirle a Rust que mueva la
propiedad de <code>v</code> al hilo creado, le garantizamos a Rust que el hilo principal no
usará <code>v</code> nunca más. Si cambiamos el Listado 16-4 de la misma manera, entonces
estamos violando las reglas de ownership cuando intentamos usar <code>v</code> en el hilo
principal. La keyword <code>move</code> anula la conservadora predeterminada de Rust de
pedir prestado; no nos permite violar las reglas de ownership.</p>
<p>Con una comprensión básica de los hilos y la API de hilos, veamos qué podemos
<em>hacer</em> con los hilos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-el-pasaje-de-mensajes-para-transferir-datos-entre-hilos"><a class="header" href="#usando-el-pasaje-de-mensajes-para-transferir-datos-entre-hilos">Usando el Pasaje de Mensajes para Transferir Datos entre Hilos</a></h2>
<p>Un enfoque cada vez más popular para garantizar una concurrencia segura es
<em>message passing</em>, donde los hilos o actores se comunican enviándose mensajes
que contienen datos. Aquí está la idea en un eslogan de <a href="https://golang.org/doc/effective_go.html#concurrency">la documentación del
lenguaje Go</a>: “No se
comunica compartiendo memoria; en su lugar, comparta memoria comunicándose”.</p>
<p>Para lograr la concurrencia mediante el envío de mensajes, la biblioteca
estándar de Rust proporciona una implementación de <em>canales</em>. Un canal es un
concepto de programación general por el cual se envían datos de un hilo a
otro.</p>
<p>Puede imaginar un canal en programación como un canal direccional de agua, como
un arroyo o un río. Si pones algo como un patito de goma en un río, viajará
aguas abajo hasta el final de la vía fluvial.</p>
<p>Un canal tiene dos partes: un transmisor y un receptor. La mitad del
transmisor es la ubicación aguas arriba donde pones patitos de goma en el río,
y la mitad del receptor es donde termina el patito de goma aguas abajo. Una
parte de su código llama a métodos en el transmisor con los datos que desea
enviar, y otra parte verifica el extremo receptor para ver si llegan mensajes.
Se dice que un canal está <em>cerrado</em> si se elimina la mitad del transmisor o
del receptor.</p>
<p>Aquí, iremos desarrollando un programa que tiene un hilo para generar valores
y enviarlos por un canal, y otro hilo que recibirá los valores e imprimirá
por pantalla. Enviaremos valores simples entre hilos usando un canal para
ilustrar la característica. Una vez que esté familiarizado con la técnica,
podría usar canales para cualquier hilo que necesite comunicarse entre sí,
como un sistema de chat o un sistema donde muchos hilos realizan partes de un
cálculo y envían las partes a un hilo que agrega los resultados.</p>
<p>Primero, en el Listado 16-6, crearemos un canal pero no haremos nada con él.
Tenga en cuenta que esto aún no se compilará porque Rust no puede determinar qué
tipo de valores queremos enviar por el canal.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<p><span class="caption">Listing 16-6: Creando un canal y asignando las dos mitades
a <code>tx</code> y <code>rx</code></span></p>
<p>Creamos un nuevo canal usando la función <code>mpsc::channel</code>; <code>mpsc</code> significa
<em>multiple producer, single consumer</em> (múltiples productores, un solo
consumidor). En resumen, la forma en que la biblioteca estándar de Rust
implementa los canales significa que un canal puede tener múltiples extremos
de <em>envío</em> que producen valores, pero solo un extremo de <em>recepción</em> que
consume esos valores. Imagínese varios arroyos que fluyen juntos en un gran
río: todo lo que se envía por cualquiera de los arroyos terminará en un río al
final. Comenzaremos con un solo productor por ahora, pero agregaremos
múltiples productores cuando hagamos que este ejemplo funcione.</p>
<p>La función <code>mpsc::channel</code> devuelve una tupla, donde el primer elemento es el
extremo de envío, y el segundo elemento es el extremo de recepción. Las
abreviaturas <code>tx</code> y <code>rx</code> se usan tradicionalmente en muchos campos para
<em>transmisor</em> y <em>receptor</em> respectivamente, por lo que nombramos nuestras
variables de esa manera para indicar cada extremo. Estamos usando una
sentencia <code>let</code> con un patrón que deconstruye las tuplas; discutiremos el uso
de patrones en las sentencias <code>let</code> y la deconstrucción en el Capítulo 18. Por
ahora, sepa que usar una sentencia <code>let</code> de esta manera es un enfoque
conveniente para extraer las piezas de la tupla devuelta por <code>mpsc::channel</code>.</p>
<p>Movamos el extremo de envío a un hilo generado y hagamos que envíe un string
para que el hilo generado se comunique con el hilo principal, como se muestra
en el Listado 16-7. Esto es como poner un patito de goma en el río aguas arriba
o enviar un mensaje de chat de un hilo a otro.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<p><span class="caption">Listing 16-7: Moviendo <code>tx</code> a un hilo generado y enviar
“hi”</span></p>
<p>Nuevamente, estamos usando <code>thread::spawn</code> para crear un nuevo hilo y luego
usando <code>move</code> para mover <code>tx</code> al cierre para que el hilo generado posea <code>tx</code>.
El hilo generado necesita poseer el transmisor para poder enviar mensajes a
través del canal. El transmisor tiene un método <code>send</code> que toma el valor que
queremos enviar. El método <code>send</code> devuelve un tipo <code>Result&lt;T, E&gt;</code>, por lo que
si el receptor se ha eliminado y no hay ningún lugar para enviar un valor, la
operación de envío devolverá un error. En este ejemplo, estamos llamando a
<code>unwrap</code> para que se produzca un pánico en caso de error. Pero en una
aplicación real, lo manejaríamos correctamente: vuelva al Capítulo 9 para
revisar las estrategias para el manejo adecuado de errores.</p>
<p>En el Listado 16-8, recibiremos el valor enviado en el hilo principal. Esto es
como recibir el patito de goma en el río aguas abajo o recibir un mensaje de
chat.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {received}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 16-8: Recibiendo el valor “hi” en el hilo thread
e imprimiéndolo</span></p>
<p>El receptor tiene dos métodos útiles: <code>recv</code> y <code>try_recv</code>. Estamos usando
<code>recv</code>, abreviatura de <em>receive</em> (recibir), que bloqueará la ejecución del
hilo principal y esperará hasta que se envíe un valor por el canal. Una vez que
se envía un valor, <code>recv</code> lo devolverá en un <code>Result&lt;T, E&gt;</code>. Cuando el
transmisor se cierra, <code>recv</code> devolverá un error para indicar que no se
enviarán más valores.</p>
<p>El método <code>try_recv</code> no bloquea, sino que en su lugar devuelve un <code>Result&lt;T, E&gt;</code> inmediatamente: un valor <code>Ok</code> que contiene un mensaje si hay uno
disponible y un valor <code>Err</code> si no hay mensajes esta vez. Usar <code>try_recv</code> es
útil si este hilo tiene otro trabajo que hacer mientras espera mensajes:
podríamos escribir un bucle que llame a <code>try_recv</code> cada cierto tiempo, maneje
un mensaje si hay uno disponible y, de lo contrario, haga otro trabajo por un
tiempo hasta que vuelva a verificar.</p>
<p>Hemos usado <code>recv</code> en este ejemplo por simplicidad; no tenemos otro trabajo
para que haga el hilo principal que esperar mensajes, por lo que bloquear el
hilo principal es apropiado.</p>
<p>Cuando ejecutamos el código en el Listado 16-8, veremos el valor impreso desde
el hilo principal:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>¡Perfecto!</p>
<h3 id="canales-y-transferencia-de-ownership"><a class="header" href="#canales-y-transferencia-de-ownership">Canales y transferencia de Ownership</a></h3>
<p>Las reglas de ownership juegan un papel vital en el envío de mensajes porque
ayudan a escribir código concurrente seguro. Prevenir errores en la
programación concurrente es la ventaja de pensar en el ownership en todos sus
programas Rust. Hagamos un experimento para mostrar cómo los canales y el
ownership funcionan juntos para evitar problemas: intentaremos usar un valor
<code>val</code> en el hilo generado <em>después</em> de haberlo enviado por el canal. Intente
compilar el código en el Listado 16-9 para ver por qué este código no está
permitido:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {val}&quot;);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {received}&quot;);
}</code></pre>
<p><span class="caption">Listing 16-9: Attempting to use <code>val</code> after we’ve sent it
down the channel</span></p>
<p>Aquí, intentamos imprimir <code>val</code> después de haberlo enviado por el canal a
través de <code>tx.send</code>. Permitir esto sería una mala idea: una vez que el valor
se ha enviado a otro hilo, ese hilo podría modificarlo o eliminarlo antes de
que intentemos usar el valor nuevamente. Potencialmente, las modificaciones de
otro hilo podrían causar errores o resultados inesperados debido a datos
inconsistentes o inexistentes. Sin embargo, Rust nos da un error si intentamos
compilar el código en el Listado 16-9:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from(&quot;hi&quot;);
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {val}&quot;);
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
   |
9  |         tx.send(val.clone()).unwrap();
   |                    ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin &quot;message-passing&quot;) due to 1 previous error
</code></pre>
<p>Nuestro error de concurrencia ha causado un error en tiempo de compilación. La
función <code>send</code> toma la propiedad de su parámetro, y cuando se mueve el valor,
el receptor se hace cargo de él. Esto nos impide usar accidentalmente el valor
nuevamente después de enviarlo; el sistema de propiedad verifica que todo
esté bien.</p>
<h3 id="enviando-múltiples-valores-y-viendo-al-receptor-esperando"><a class="header" href="#enviando-múltiples-valores-y-viendo-al-receptor-esperando">Enviando múltiples valores y viendo al receptor esperando</a></h3>
<p>El código en el Listado 16-8 compiló y se ejecutó, pero no nos mostró
claramente que dos hilos separados estaban hablando entre sí a través del
canal. En el Listado 16-10 hemos realizado algunas modificaciones que
demostrarán que el código en el Listado 16-8 se está ejecutando
concurrentemente: el hilo generado ahora enviará varios mensajes y se
pausará durante un segundo entre cada mensaje.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {received}&quot;);
    }
}</code></pre>
<p><span class="caption">Listing 16-10: Enviando múltiples mensajes y pausando
entre cada uno</span></p>
<p>Esta vez, el hilo generado tiene un vector de strings que queremos enviar al
hilo principal. Iteramos sobre ellos, enviando cada uno individualmente, y
pausamos entre cada uno llamando a la función <code>thread::sleep</code> con un valor
<code>Duration</code> de 1 segundo.</p>
<p>En el hilo principal, ya no estamos llamando explícitamente a la función
<code>recv</code>: en su lugar, estamos tratando <code>rx</code> como un iterator. Para cada valor
recibido, lo imprimimos. Cuando el canal está cerrado, la iteración terminará.</p>
<p>Al ejecutar el código del Listado 16-10, debería ver el siguiente resultado con
una pausa de 1 segundo entre cada línea:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Debido a que no tenemos ningún código que pause o retrase el bucle <code>for</code> en el
hilo principal, podemos decir que el hilo principal está esperando recibir
valores del hilo generado.</p>
<h3 id="creando-múltiples-productores-clonando-el-transmisor"><a class="header" href="#creando-múltiples-productores-clonando-el-transmisor">Creando múltiples productores clonando el transmisor</a></h3>
<p>Anteriormente mencionamos que <code>mpsc</code> era un acrónimo de <em>multiple producer,
single consumer</em> (múltiples productores, un solo consumidor). Pongamos <code>mpsc</code>
en uso y expandamos el código en el Listado 16-10 para crear múltiples hilos
que envíen valores al mismo receptor. Podemos hacerlo clonando el transmisor,
como se muestra en el Listado 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;more&quot;),
            String::from(&quot;messages&quot;),
            String::from(&quot;for&quot;),
            String::from(&quot;you&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {received}&quot;);
    }

    // --snip--
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 16-11: Envío de múltiples mensajes de múltiples
productores</span></p>
<p>Esta vez, antes de crear el primer hilo generado, llamamos a <code>clone</code> en el
transmisor, lo que nos dará un nuevo transmisor que podemos pasar al primer
hilo generado. Pasamos el transmisor original a un segundo hilo generado. Esto
nos da dos hilos, cada uno enviando mensajes diferentes al receptor.</p>
<p>Cuando ejecutamos el código, tu output debería verse así:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Es posible que veas los valores en otro orden según tu sistema. Esto es lo que 
hace que la concurrencia sea tan interesante como difícil. Si experimentas con
<code>thread::sleep</code>, dándole varios valores en los diferentes hilos, cada ejecución
será más no determinista y creará una salida diferente cada vez.</p>
<p>Ahora que hemos visto cómo funcionan los canales, veamos un método diferente de
concurrencia.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrencia-con-estado-compartido"><a class="header" href="#concurrencia-con-estado-compartido">Concurrencia con Estado Compartido</a></h2>
<p>El paso de mensajes es una buena manera de manejar la concurrencia, pero no es
la única. Otro método sería que varios hilos accedan a los mismos datos
compartidos. Considere esta parte del eslogan de la documentación del lenguaje
Go nuevamente: &quot;no se comunique compartiendo memoria&quot;.</p>
<p>¿Qué significaría comunicarse compartiendo memoria? Además, ¿por qué los
entusiastas del paso de mensajes advierten que no se debe usar el intercambio de
memoria?</p>
<p>En cierto modo, los canales en cualquier lenguaje de programación son similares
al ownership único, porque una vez que transfieres un valor por un canal, ya
no debes usar ese valor. La concurrencia de memoria compartida es como el
ownership múltiple: varios hilos pueden acceder a la misma ubicación de memoria
al mismo tiempo. Como viste en el Capítulo 15, donde los punteros inteligentes
hicieron posible el ownership múltiple, el ownership múltiple puede agregar
complejidad porque estos propietarios diferentes necesitan administración. El
sistema de tipos y las reglas de ownership de Rust ayudan mucho a obtener esta
administración correcta. Para un ejemplo, veamos los mutex, uno de los
primitivos de concurrencia más comunes para la memoria compartida.</p>
<h3 id="usando-mutexes-para-permitir-el-acceso-a-los-datos-de-un-hilo-a-la-vez"><a class="header" href="#usando-mutexes-para-permitir-el-acceso-a-los-datos-de-un-hilo-a-la-vez">Usando Mutexes para permitir el acceso a los datos de un hilo a la vez</a></h3>
<p><em>Mutex</em> es una abreviatura de <em>exclusión mutua</em>, como en, un mutex permite que
solo un hilo acceda a algunos datos en un momento dado. Para acceder a los
datos en un mutex, un hilo primero debe señalar que desea acceso solicitando
adquirir el <em>lock</em> del mutex. El lock es una estructura de datos que forma
parte del mutex que realiza un seguimiento de quién tiene actualmente acceso
exclusivo a los datos. Por lo tanto, el mutex se describe como <em>guardando</em> los
datos que contiene a través del sistema de bloqueo.</p>
<p>Los Mutexes tienen la reputación de ser difíciles de usar porque debes
recordar dos reglas:</p>
<ul>
<li>Debes intentar adquirir el bloqueo antes de utilizar los datos.</li>
<li>Cuando hayas terminado con los datos que protege el mutex, debes desbloquear
los datos para que otros hilos puedan adquirir el bloqueo.</li>
</ul>
<p>Para una metáfora del mundo real para un mutex, imagina un panel de discusión
en una conferencia con un solo micrófono. Antes de que un panelista pueda
hablar, debe preguntar o señalar que desea usar el micrófono. Cuando obtienen
el micrófono, pueden hablar todo el tiempo que quieran y luego entregar el
micrófono al siguiente panelista que solicite hablar. Si un panelista olvida
entregar el micrófono cuando haya terminado con él, nadie más puede hablar. Si
la administración del micrófono compartido sale mal, ¡el panel no funcionará
como estaba previsto!</p>
<p>La gestión de mutexes puede ser increíblemente difícil de hacer bien, razón por
la cual tanta gente está entusiasmada con los canales. Sin embargo, gracias al
sistema de tipos y las reglas de ownership de Rust, no puedes bloquear y
desbloquear incorrectamente.</p>
<h4 id="la-api-de-mutext"><a class="header" href="#la-api-de-mutext">La API de <code>Mutex&lt;T&gt;</code></a></h4>
<p>Como un ejemplo de como usar un mutex, comencemos usando un mutex en un
contexto de un solo hilo, como se muestra en el Listado 16-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {m:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 16-12: Explorando la API de <code>Mutex&lt;T&gt;</code> en un
contexto de un solo hilo para simplificar</span></p>
<p>Como con muchos tipos, creamos un <code>Mutex&lt;T&gt;</code> usando la función asociada <code>new</code>.
Para acceder a los datos dentro del mutex, usamos el método <code>lock</code> para
adquirir el bloqueo. Esta llamada bloqueará el hilo actual para que no pueda
hacer ningún trabajo hasta que sea nuestro turno de tener el bloqueo.</p>
<p>La llamada a <code>lock</code> fallaría si otro hilo que tiene el bloqueo se bloquea. En
ese caso, nadie nunca podría obtener el bloqueo, por lo que hemos elegido
<code>unwrap</code> y hacer que este hilo se bloquee si estamos en esa situación.</p>
<p>Después de que hayamos adquirido el bloqueo, podemos tratar el valor de
retorno llamado <code>num</code> en este caso, como una referencia mutable a los datos
internos. El sistema de tipos garantiza que adquirimos un bloqueo antes de
usar el valor en <code>m</code>. El tipo de <code>m</code> es <code>Mutex&lt;i32&gt;</code>, no <code>i32</code>, por lo que
<em>debemos</em> llamar a <code>lock</code> para poder usar el valor <code>i32</code> interno. No podemos
olvidar; el sistema de tipos no nos permitirá acceder al <code>i32</code> interno de
otra manera.</p>
<p>Como puedes sospechar, <code>Mutex&lt;T&gt;</code> es un smart pointer. Más precisamente, la
llamada a <code>lock</code> <em>devuelve</em> un smart pointer llamado <code>MutexGuard</code>, envuelto en
un <code>LockResult</code> que manejamos con la llamada a <code>unwrap</code>. El smart pointer
<code>MutexGuard</code> implementa <code>Deref</code> para apuntar a nuestros datos internos; el
smart pointer también tiene una implementación de <code>Drop</code> que libera el bloqueo
automáticamente cuando un <code>MutexGuard</code> sale del scope, lo que sucede al final
del scope interno. Como resultado, no corremos el riesgo de olvidar liberar
el bloqueo y bloquear el mutex para que otros hilos no puedan usarlo, porque
la liberación del bloqueo ocurre automáticamente.</p>
<p>Después de eliminar el bloqueo, podemos imprimir el valor mutex y ver que
pudimos cambiar el valor interno <code>i32</code> a 6.</p>
<h4 id="compartir-un-mutext-entre-varios-hilos"><a class="header" href="#compartir-un-mutext-entre-varios-hilos">Compartir un <code>Mutex&lt;T&gt;</code> entre varios hilos</a></h4>
<p>Ahora, intentemos compartir un valor entre múltiples hilos usando <code>Mutex&lt;T&gt;</code>.
Activaremos 10 hilos y haremos que cada uno incremente un valor de contador en
1, por lo que el contador va de 0 a 10. El siguiente ejemplo en el Listado
16-13 tendrá un error del compilador, y usaremos ese error para aprender más
sobre el uso de <code>Mutex&lt;T&gt;</code> y cómo Rust nos ayuda a usarlo correctamente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre>
<p><span class="caption">Listing 16-13: Diez hilos cada uno incrementa un contador
custodiado por un <code>Mutex&lt;T&gt;</code></span></p>
<p>Creamos una variable <code>counter</code> para contener un <code>i32</code> dentro de un <code>Mutex&lt;T&gt;</code>,
como hicimos en el Listado 16-12. A continuación, creamos 10 hilos iterando
sobre un rango de números. Usamos <code>thread::spawn</code> y damos a todos los hilos el
mismo closure: uno que mueve el contador al hilo, adquiere un bloqueo en el
<code>Mutex&lt;T&gt;</code> llamando al método <code>lock</code>, y luego agrega 1 al valor en el mutex.
Cuando un hilo termina de ejecutar su closure, <code>num</code> saldrá del scope y
liberará el bloqueo para que otro hilo pueda adquirirlo.</p>
<p>En el hilo principal, recopilamos todos los identificadores de unión. Luego,
como hicimos en el Listado 16-2, llamamos a <code>join</code> en cada identificador para
asegurarnos de que todos los hilos terminen. En ese momento, el hilo principal
adquirirá el bloqueo e imprimirá el resultado de este programa.</p>
<p>Sugerimos que este ejemplo no se compilaría ¡Ahora descubramos por qué!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin &quot;shared-state&quot;) due to 1 previous error
</code></pre>
<p>El mensaje de error indica que el valor de <code>counter</code> se movió en la anterior
iteración del bucle. El compilador nos está diciendo que no podemos mover la
propiedad de <code>counter</code> a múltiples hilos. Arreglemos el error del compilador
con un método de múltiples propietarios que discutimos en el Capítulo 15.</p>
<h4 id="ownership-multiple-con-múltiples-hilos"><a class="header" href="#ownership-multiple-con-múltiples-hilos">Ownership Multiple con múltiples hilos</a></h4>
<p>En el capítulo 15, le dimos a un valor múltiples dueños al usar el
smart pointer <code>Rc&lt;T&gt;</code> para crear un valor de recuento de referencia.
Hagamos lo mismo aquí y veamos qué sucede. Envolveremos el <code>Mutex&lt;T&gt;</code> en
<code>Rc&lt;T&gt;</code> en el Listado 16-14 y clonaremos el <code>Rc&lt;T&gt;</code> antes de mover el
ownership al hilo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre>
<p><span class="caption">Listing 16-14: Intentando usar <code>Rc&lt;T&gt;</code> para permitir
múltiples hilos para poseer <code>Mutex&lt;T&gt;</code></span></p>
<p>Una vez más, compilamos y obtenemos... ¡diferentes errores! El compilador nos
está enseñando mucho.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:677:1

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin &quot;shared-state&quot;) due to 1 previous error
</code></pre>
<p>Wow, ¡ese mensaje de error es muy extenso! Aquí está la parte importante en la
que debemos enfocarnos: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. El compilador también nos está diciendo la razón por la que:
<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;` </code>. Hablaremos de
<code>Send</code> en la siguiente sección: es uno de los traits que asegura que los tipos
que usamos con hilos están destinados a su uso en situaciones concurrentes.</p>
<p>Desafortunadamente, <code>Rc&lt;T&gt;</code> no es seguro para compartir entre hilos. Cuando
<code>Rc&lt;T&gt;</code> administra el recuento de referencia, agrega al recuento para cada
llamada a <code>clone</code> y resta del recuento cuando se descarta cada clon. Pero no
usa ningún primitivo de concurrencia para asegurarse de que los cambios en el
recuento no puedan ser interrumpidos por otro hilo. Esto podría conducir a
recuentos incorrectos: errores sutiles que podrían a su vez conducir a fugas
de memoria o que un valor se descarte antes de que hayamos terminado con él.
Lo que necesitamos es un tipo exactamente como <code>Rc&lt;T&gt;</code> pero que haga cambios en
el recuento de referencia de una manera segura para hilos.</p>
<h4 id="recuento-de-referencia-atómico-con-arct"><a class="header" href="#recuento-de-referencia-atómico-con-arct">Recuento de referencia atómico con <code>Arc&lt;T&gt;</code></a></h4>
<p>Afortunadamente, <code>Arc&lt;T&gt;</code> <em>es</em> un tipo como <code>Rc&lt;T&gt;</code> que es seguro de usar en
situaciones concurrentes. La <em>a</em> significa <em>atómico</em>, lo que significa que es
un tipo de recuento de referencia atómico. Los átomos son un tipo adicional de
primitiva de concurrencia que no cubriremos en detalle aquí: consulte la
documentación de la biblioteca estándar para <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a></p>
<!-- ignore --> para más detalles. En este punto, solo necesita saber que los
<p>Átomos funcionan como tipos primitivos, pero son seguros para compartir entre
hilos.</p>
<p>Entonces podrías preguntarte por qué todos los tipos primitivos no son atómicos
y por qué los tipos de biblioteca estándar no se implementan para usar <code>Arc&lt;T&gt;</code>
de forma predeterminada. La razón es que la seguridad de los hilos conlleva una
penalización de rendimiento que solo desea pagar cuando realmente lo necesita.
Si solo está realizando operaciones en valores dentro de un solo hilo, su
código puede ejecutarse más rápido si no tiene que hacer cumplir las garantías
que proporcionan los átomos.</p>
<p>Volvamos a nuestro ejemplo: <code>Arc&lt;T&gt;</code> y <code>Rc&lt;T&gt;</code> tienen la misma API, por lo que
arreglamos nuestro programa cambiando la línea <code>use</code>, la llamada a <code>new</code> y la
llamada a <code>clone</code>. El código en el Listado 16-15 finalmente se compilará y
ejecutará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Listing 16-15: Usando un <code>Arc&lt;T&gt;</code> para envolver <code>Mutex&lt;T&gt;</code>
para poder compartir el ownership a través de múltiples hilos</span></p>
<p>Este código imprimirá lo siguiente:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>¡Lo hicimos! Contamos de 0 a 10, lo que puede no parecer muy impresionante,
pero nos enseñó mucho sobre <code>Mutex&lt;T&gt;</code> y la seguridad de los hilos. También
podría usar la estructura de este programa para realizar operaciones más
complicadas que simplemente incrementar un contador. Usando esta estrategia,
puede dividir un cálculo en partes independientes, dividir esas partes en
hilos y luego usar un <code>Mutex&lt;T&gt;</code> para que cada hilo actualice el resultado
final con su parte.</p>
<p>Nota que si estás haciendo operaciones numéricas simples, hay tipos más
simples que los tipos <code>Mutex&lt;T&gt;</code> proporcionados por el <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code>
módulo de la biblioteca estándar</a><!-- ignore -->. Estos tipos
proporcionan acceso seguro y concurrente a tipos primitivos. Elegimos usar
<code>Mutex&lt;T&gt;</code> con un tipo primitivo para este ejemplo para que pudiéramos
concentrarnos en cómo funciona <code>Mutex&lt;T&gt;</code>.</p>
<h3 id="similitudes-entre-refcelltrct-y-mutextarct"><a class="header" href="#similitudes-entre-refcelltrct-y-mutextarct">Similitudes entre <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> y <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>Es posible que hayas notado que <code>counter</code> es inmutable, pero podríamos obtener
una referencia mutable al valor dentro de él; esto significa que <code>Mutex&lt;T&gt;</code>
proporciona mutabilidad interior, como lo hace la familia <code>Cell</code>. De la misma
manera que usamos <code>RefCell&lt;T&gt;</code> en el Capítulo 15 para permitirnos mutar
contenidos dentro de un <code>Rc&lt;T&gt;</code>, usamos <code>Mutex&lt;T&gt;</code> para mutar contenidos dentro
de un <code>Arc&lt;T&gt;</code>.</p>
<p>Un detalle a tener en cuenta es que Rust no puede protegerte de todos los 
errores lógicos al usar <code>Mutex&lt;T&gt;</code>. Recuerda en el Capítulo 15 que usar <code>Rc&lt;T&gt;</code>
venía con el riesgo de crear ciclos de referencia, donde dos valores <code>Rc&lt;T&gt;</code>
se refieren entre sí, causando fugas de memoria. De manera similar, <code>Mutex&lt;T&gt;</code>
viene con el riesgo de crear <em>deadlocks</em>. Estos ocurren cuando una operación
necesita bloquear dos recursos y dos hilos han adquirido cada uno de los
bloqueos, lo que los hace esperar el uno al otro para siempre. Si está
interesado en los deadlocks, intente crear un programa Rust que tenga un
deadlock; luego investigue las estrategias de mitigación de deadlock para
mutexes en cualquier lenguaje y pruebe implementarlas en Rust. La documentación 
de la API de la biblioteca estándar para <code>Mutex&lt;T&gt;</code> y <code>MutexGuard</code> ofrece
información útil.</p>
<p>Terminaremos este capítulo hablando sobre los traits <code>Send</code> y <code>Sync</code> y cómo
podemos usarlos con tipos personalizados.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrencia-extensible-con-los-traits-sync-y-send"><a class="header" href="#concurrencia-extensible-con-los-traits-sync-y-send">Concurrencia extensible con los traits <code>Sync</code> y <code>Send</code></a></h2>
<p>Curiosamente, el lenguaje Rust tiene <em>muy</em> pocas características de
concurrencia. Casi todas las características de concurrencia de las que hemos
hablado hasta ahora en este capítulo han sido parte de la biblioteca estándar,
no del lenguaje. Sus opciones para manejar la concurrencia no se limitan al
lenguaje o a la biblioteca estándar; puede escribir sus propias características
de concurrencia o usar las escritas por otros.</p>
<p>Sin embargo, dos conceptos de concurrencia están integrados en el lenguaje: los
traits <code>Sync</code> y <code>Send</code> de <code>std::marker</code>.</p>
<h3 id="permitiendo-la-transferencia-de-ownership-entre-hilos-con-send"><a class="header" href="#permitiendo-la-transferencia-de-ownership-entre-hilos-con-send">Permitiendo la transferencia de Ownership entre hilos con <code>Send</code></a></h3>
<p>El trait <code>Send</code> indica que la propiedad de un valor se puede transferir entre
hilos. Casi todos los tipos son <code>Send</code>, con algunas excepciones notables, como
<code>Rc&lt;T&gt;</code>, que no es <code>Send</code> porque si clonara un valor de <code>Rc&lt;T&gt;</code> y tratara de
transferir la propiedad del clon a otro hilo, ambos hilos podrían actualizar el
recuento de referencias al mismo tiempo. Por esta razón, <code>Rc&lt;T&gt;</code> está
implementado para su uso en situaciones de un solo hilo donde no desea pagar la
penalización de rendimiento segura para subprocesos.</p>
<p>Por lo tanto, el sistema de tipos y los límites de los traits de Rust garantizan
que nunca pueda enviar accidentalmente un valor <code>Rc&lt;T&gt;</code> a través de hilos de
forma insegura. Cuando intentamos hacer esto en el Listado 16-14, obtuvimos el
error <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. Cuando cambiamos a
<code>Arc&lt;T&gt;</code>, que es <code>Send</code>, el código se compiló.</p>
<p>Cualquier tipo compuesto enteramente de tipos <code>Send</code> se marca automáticamente
como <code>Send</code> también. Casi todos los tipos primitivos son <code>Send</code>, aparte de los
punteros sin procesar, que discutiremos en el Capítulo 19.</p>
<h3 id="permitiendo-el-acceso-desde-múltiples-hilos-con-sync"><a class="header" href="#permitiendo-el-acceso-desde-múltiples-hilos-con-sync">Permitiendo el acceso desde múltiples hilos con <code>Sync</code></a></h3>
<p>El trait <code>Sync</code> indica que es seguro que el tipo que implementa <code>Sync</code> se
referencie desde múltiples hilos. En otras palabras, cualquier tipo <code>T</code> es
<code>Sync</code> si <code>&amp;T</code> (una referencia inmutable a <code>T</code>) es <code>Send</code>, lo que significa que
la referencia se puede enviar de forma segura a otro hilo. De manera similar a
<code>Send</code>, los tipos primitivos son <code>Sync</code>, y los tipos compuestos enteramente de
tipos que son <code>Sync</code> también son <code>Sync</code>.</p>
<p>El smart pointer <code>Rc&lt;T&gt;</code> tampoco es <code>Sync</code> por las mismas razones por las que
no es <code>Send</code>. El tipo <code>RefCell&lt;T&gt;</code> (del que hablamos en el Capítulo 15) y la
familia de tipos relacionados <code>Cell&lt;T&gt;</code> no son <code>Sync</code>. La implementación de la
comprobación de préstamos que hace <code>RefCell&lt;T&gt;</code> en tiempo de ejecución no es
segura para subprocesos. El smart pointer <code>Mutex&lt;T&gt;</code> es <code>Sync</code> y se puede usar
para compartir el acceso con múltiples hilos como viste en la sección <a href="ch16-03-shared-state.html#compartir-un-mutext-entre-varios-hilos">“Compartir
un <code>Mutex&lt;T&gt;</code> entre múltiples
hilos”</a><!-- ignore -->.</p>
<h3 id="implementar-send-y-sync-manualmente-es-inseguro"><a class="header" href="#implementar-send-y-sync-manualmente-es-inseguro">Implementar <code>Send</code> y <code>Sync</code> manualmente es inseguro</a></h3>
<p>Debido a que los tipos que están compuestos de los traits <code>Send</code> y <code>Sync</code> se
automatizan también <code>Send</code> y <code>Sync</code>, no tenemos que implementar esos traits
manualmente. Como marcadores de traits, ni siquiera tienen ningún método para
implementar. Son útiles para hacer cumplir invariantes relacionados con la
concurrencia.</p>
<p>Implementar manualmente estos traits implica implementar código inseguro de
Rust. Hablaremos sobre el uso de código inseguro de Rust en el Capítulo 19; por
ahora, la información importante es que la construcción de nuevos tipos
concurrentes que no están compuestos de partes <code>Send</code> y <code>Sync</code> requiere un
pensamiento cuidadoso para mantener las garantías de seguridad. <a href="https://doc.rust-lang.org/nomicon/index.html">“The
Rustonomicon”</a> tiene más información sobre estas garantías y cómo
mantenerlas.</p>
<h2 id="resumen-15"><a class="header" href="#resumen-15">Resumen</a></h2>
<p>No es la última vez que verás la concurrencia en este libro: el proyecto del
Capítulo 20 usará los conceptos de este capítulo en una situación más realista
que los ejemplos más pequeños que se discuten aquí.</p>
<p>Como se mencionó anteriormente, debido a que muy poco de cómo Rust maneja la
concurrencia es parte del lenguaje, muchas soluciones de concurrencia se
implementan como cajones. Estos evolucionan más rápido que la biblioteca
estándar, así que asegúrese de buscar en línea las cajas actuales de última
generación para usar en situaciones de múltiples subprocesos.</p>
<p>La biblioteca estándar de Rust proporciona canales para el paso de mensajes y
tipos de smart pointer, como <code>Mutex&lt;T&gt;</code> y <code>Arc&lt;T&gt;</code>, que son seguros de usar en
contextos concurrentes. El sistema de tipos y el borrow checker garantizan que
el código que usa estas soluciones no terminará con carreras de datos o
referencias no válidas. Una vez que haya compilado su código, puede estar
seguro de que se ejecutará felizmente en múltiples hilos sin los tipos de
errores difíciles de rastrear comunes en otros lenguajes. La programación
concurrente ya no es un concepto del que tener miedo: ¡adelante y haga que sus
programas sean concurrentes, sin miedo!</p>
<p>A continuación, hablaremos sobre las formas idiomáticas de modelar problemas y
estructurar soluciones a medida que sus programas Rust se vuelven más grandes.
Además, discutiremos cómo los ideales de Rust se relacionan con los que
puede estar familiarizado con la programación orientada a objetos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-como-un-lenguaje-de-programación-orientado-a-objetos"><a class="header" href="#rust-como-un-lenguaje-de-programación-orientado-a-objetos">Rust como un Lenguaje de Programación Orientado a Objetos</a></h1>
<p>La programación orientada a objetos (POO) es una forma de modelar programas. Los
objetos como concepto programático fueron introducidos en el lenguaje de
programación Simula en la década de 1960. Esos objetos influyeron en la
arquitectura de programación de Alan Kay en la que los objetos se envían
mensajes entre sí. Para describir esta arquitectura, acuñó el término
<em>programación orientada a objetos</em> en 1967. Muchas definiciones en competencia
describen lo que es POO, y por algunas de estas definiciones Rust es
orientado a objetos, pero por otras no lo es. En este capítulo, exploraremos
ciertas características que comúnmente se consideran orientadas a objetos y cómo
esas características se traducen a Rust idiomático. Luego le mostraremos cómo
implementar un patrón de diseño orientado a objetos en Rust y discutiremos los
compromisos de hacerlo en lugar de implementar una solución utilizando algunas
de las fortalezas de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="características-de-lenguajes-orientados-a-objetos"><a class="header" href="#características-de-lenguajes-orientados-a-objetos">Características de lenguajes orientados a objetos</a></h2>
<p>No hay consenso en la comunidad de programación sobre qué características debe
tener un lenguaje para ser considerado orientado a objetos. Rust está
influenciado por muchos paradigmas de programación, incluido OOP; por ejemplo,
exploramos las características que provienen de la programación funcional en el
Capítulo 13. Es discutible que los lenguajes OOP compartan ciertas
características comunes, a saber, objetos, encapsulación y herencia. Veamos qué
significa cada una de esas características y si Rust la admite.</p>
<h3 id="los-objetos-contienen-datos-y-comportamiento"><a class="header" href="#los-objetos-contienen-datos-y-comportamiento">Los objetos contienen datos y comportamiento</a></h3>
<p>El libro <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> de
Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides (Addison-Wesley
Professional, 1994), coloquialmente conocido como el libro <em>Gang of Four</em>, es un
catálogo de patrones de diseño orientados a objetos. Define OOP de esta manera:</p>
<blockquote>
<p>Los programas orientados a objetos están compuestos por objetos. Un <em>objeto</em>
empaqueta tanto datos como los procedimientos que operan en esos datos. Los
procedimientos se denominan típicamente <em>métodos</em> u <em>operaciones</em>.</p>
</blockquote>
<p>Usando esta definición, Rust es orientado a objetos: los structs y los
enums tienen datos, y los bloques <code>impl</code> proporcionan métodos en structs y
enums. Aunque los structs y los enums con métodos no se llaman objetos,
proporcionan la misma funcionalidad, según la definición de objetos del
Gang of Four’s.</p>
<h3 id="encapsulacion-que-oculta-los-detalles-de-implementacion"><a class="header" href="#encapsulacion-que-oculta-los-detalles-de-implementacion">Encapsulacion que oculta los detalles de implementacion</a></h3>
<p>Otro aspecto comúnmente asociado con OOP es la idea de <em>encapsulación</em>, que
significa que los detalles de implementación de un objeto no son accesibles al
código que usa ese objeto. Por lo tanto, la única forma de interactuar con un
objeto es a través de su API pública; el código que usa el objeto no debería
poder acceder a los detalles internos del objeto y cambiar los datos o el
comportamiento directamente. Esto permite al programador cambiar y refactorizar
los detalles internos de un objeto sin necesidad de cambiar el código que usa
el objeto.</p>
<p>Hemos discutido cómo controlar la encapsulación en el Capítulo 7: podemos usar
la palabra clave <code>pub</code> para decidir qué módulos, tipos, funciones y métodos en
nuestro código deben ser públicos, y por defecto todo lo demás es privado. Por
ejemplo, podemos definir un struct <code>AveragedCollection</code> que tiene un campo que
contiene un vector de valores <code>i32</code>. El struct también puede tener un campo que
contiene el promedio de los valores en el vector, lo que significa que el
promedio no tiene que calcularse a pedido cada vez que alguien lo necesite. En
otras palabras, <code>AveragedCollection</code> almacenará en caché el promedio calculado
para nosotros. El Listado 17-1 tiene la definición del struct
<code>AveragedCollection</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
<p><span class="caption">Listing 17-1: Un struct <code>AveragedCollection</code> que
mantiene una lista de enteros y el promedio de los elementos en la colección
</span></p>
<p>El struct está marcado como <code>pub</code> para que otro código pueda usarlo, pero los
campos dentro del struct permanecen privados. Esto es importante en este caso
porque queremos asegurarnos de que cada vez que se agrega o elimina un valor de
la lista, el promedio también se actualiza. Hacemos esto implementando los
métodos públicos <code>add</code>, <code>remove</code> y <code>average</code> en el struct, como se muestra en
el Listado 17-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
<p><span class="caption">Listing 17-2: Implementaciones de los métodos públicos
<code>add</code>, <code>remove</code>, y <code>average</code> en <code>AveragedCollection</code></span></p>
<p>Los métodos públicos <code>add</code>, <code>remove</code>, y <code>average</code> son las únicas formas de
acceder o modificar los datos en una instancia de <code>AveragedCollection</code>. Cuando
se agrega un elemento a <code>list</code> usando el método <code>add</code> o se elimina usando el
método <code>remove</code>, las implementaciones de cada uno llaman al método privado
<code>update_average</code> que maneja la actualización del campo <code>average</code> también.</p>
<p>Dejamos los campos <code>list</code> y <code>average</code> privados para que no haya forma de que el
código externo agregue o elimine elementos de <code>list</code> directamente; de lo
contrario, el campo <code>average</code> podría quedar fuera de sincronización cuando
<code>list</code> cambia. El método <code>average</code> devuelve el valor en el campo <code>average</code>,
permitiendo que el código externo lea el <code>average</code> pero no lo modifique.</p>
<p>Debido a que hemos encapsulado la implementación de <code>AveragedCollection</code>, podemos
cambiar fácilmente los aspectos, como la estructura de datos, en el futuro. Por
ejemplo, podríamos usar un <code>HashSet&lt;i32&gt;</code> en lugar de un <code>Vec&lt;i32&gt;</code> para el
campo <code>list</code>. Mientras las firmas de los métodos públicos <code>add</code>, <code>remove</code>, y
<code>average</code> permanezcan iguales, el código que usa <code>AveragedCollection</code> no
necesitaría cambiar para compilar. Si hicimos <code>list</code> pública en su lugar, esto 
no sería necesariamente cierto: <code>HashSet&lt;i32&gt;</code> y <code>Vec&lt;i32&gt;</code> tienen diferentes 
métodos para agregar y eliminar elementos, por lo que el código externo 
probablemente tendría que cambiar si estuviera modificando <code>list</code> directamente.</p>
<p>Si la encapsulación es un aspecto requerido para que un lenguaje se considere
orientado a objetos, entonces Rust cumple con ese requisito. La opción de usar
<code>pub</code> o no para diferentes partes del código permite la encapsulación de los
detalles de implementación.</p>
<h3 id="herencia-como-un-sistema-de-tipos-y-como-code-sharing"><a class="header" href="#herencia-como-un-sistema-de-tipos-y-como-code-sharing">Herencia como un sistema de tipos y como Code Sharing</a></h3>
<p><em>Herencia</em> es un mecanismo mediante el cual un objeto puede heredar elementos de
la definición de otro objeto, obteniendo así los datos y el comportamiento del
objeto padre sin tener que definirlos nuevamente.</p>
<p>Si se considera que un lenguaje debe tener herencia para ser un lenguaje
orientado a objetos, entonces Rust no cumple con esta definición. No existe
una forma de definir un struct que herede los campos y las implementaciones de
métodos de un struct padre sin usar una macro.</p>
<p>Sin embargo, si estás acostumbrado a tener la herencia en tu caja de
programación, puedes usar otras soluciones en Rust, dependiendo de tu razón
para recurrir a la herencia en primer lugar.</p>
<p>Elegirías la herencia por dos razones principales. Una es reutilizar el código:
puedes implementar un comportamiento particular para un tipo, y la herencia te
permite reutilizar esa implementación para un tipo diferente. Puedes hacer esto
de una manera limitada en el código Rust usando implementaciones de métodos
predeterminados de un trait, que viste en el Listado 10-14 cuando agregamos una
implementación predeterminada del método <code>summarize</code> en el trait <code>Summary</code>.
Cualquier tipo que implemente el trait <code>Summary</code> tendría el método <code>summarize</code>
disponible sin ningún código adicional. Esto es similar a una clase padre que
tiene una implementación de un método y una clase hija heredada que también
tiene la implementación del método. También podemos anular la implementación
predeterminada del método <code>summarize</code> cuando implementamos el trait <code>Summary</code>,
lo que es similar a una clase hija anulando la implementación de un método
heredado de una clase padre.</p>
<p>La otra razón para usar la herencia está relacionada con el sistema de tipos:
permitir que un tipo hijo se use en los mismos lugares que el tipo padre. Esto
es también llamado <em>polimorfismo</em>, lo que significa que puedes sustituir
múltiples objetos entre sí en tiempo de ejecución si comparten ciertas
características.</p>
<blockquote>
<h3 id="polimorfismo"><a class="header" href="#polimorfismo">Polimorfismo</a></h3>
<p>Para muchas personas, el polimorfismo es sinónimo de herencia. Pero en
realidad es un concepto más general que se refiere al código que puede
trabajar con datos de múltiples tipos. Para la herencia, esos tipos son
generalmente subclases.</p>
<p>En cambio, Rust utiliza generics para abstraerse sobre diferentes tipos
posibles y los trait bounds para imponer restricciones sobre lo que
esos tipos deben proporcionar. Esto se llama a veces <em>polimorfismo paramétrico
acotado</em>.</p>
</blockquote>
<p>En los últimos tiempos, la herencia ha perdido popularidad como solución de
diseño de programas en muchos lenguajes de programación porque a menudo está en
riesgo de compartir más código del necesario. Las subclases no siempre deben
compartir todas las características de su clase padre, pero lo harán con la
herencia. Esto puede hacer que el diseño de un programa sea menos flexible.
También introduce la posibilidad de llamar a métodos en subclases que no tienen
sentido o que causan errores porque los métodos no se aplican a la subclase.
Además, algunos lenguajes solo permitirán una herencia única (lo que significa
que una subclase solo puede heredar de una clase), lo que restringe aún más la
flexibilidad del diseño de un programa.</p>
<p>Por estas razones, Rust toma un enfoque diferente utilizando trait objects en
lugar de herencia. Veamos cómo los trait objects permiten el polimorfismo en
Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-trait-objects-que-permiten-valores-de-diferentes-tipos"><a class="header" href="#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">Usando Trait Objects que permiten valores de diferentes tipos</a></h2>
<p>En el capítulo 8, mencionamos que una limitación de los vectores es que pueden
almacenar elementos de un solo tipo. Creamos una solución en el Listado 8-9
donde definimos un enum <code>SpreadsheetCell</code> que tenía variantes para almacenar
enteros, flotantes y texto. Esto significaba que podíamos almacenar diferentes
tipos de datos en cada celda y aun así tener un vector que representara una
fila de celdas. Esta es una solución perfectamente buena cuando nuestros
elementos intercambiables son un conjunto fijo de tipos que conocemos cuando
se compila nuestro código.</p>
<p>Sin embargo, a veces queremos que los usuarios de nuestra biblioteca puedan
ampliar el conjunto de tipos que pueden almacenar en una estructura de datos.
Para mostrar cómo podríamos lograr esto, crearemos una herramienta de
interfaz gráfica de usuario (GUI) de ejemplo que itera a través de una lista
de elementos, llamando a un método <code>draw</code> en cada uno para dibujarlo en la
pantalla, una técnica común para las herramientas de GUI. Crearemos una
caja de biblioteca llamada <code>gui</code> que contiene la estructura de una biblioteca
GUI. Esta caja podría incluir algunos tipos para que las personas los usen,
como <code>Button</code> o <code>TextField</code>. Además, los usuarios de <code>gui</code> querrán crear sus
propios tipos que se puedan dibujar: por ejemplo, un programador podría
agregar una <code>Image</code> y otro podría agregar un <code>SelectBox</code>.</p>
<p>No implementaremos una biblioteca GUI completamente desarrollada para este
ejemplo, pero mostraremos cómo encajarían las piezas. En el momento de
escribir la biblioteca, no podemos conocer y definir todos los tipos que
otros programadores podrían querer crear. Pero sí sabemos que <code>gui</code> necesita
hacer un seguimiento de muchos valores de diferentes tipos, y necesita llamar
a un método <code>draw</code> en cada uno de estos valores de diferentes tipos. No
necesita saber exactamente qué sucederá cuando llamemos al método <code>draw</code>, solo
que el valor tendrá ese método disponible para que lo llamemos.</p>
<p>Para hacer esto en un lenguaje con herencia, podríamos definir una clase
llamada <code>Component</code> que tenga un método llamado <code>draw</code> en ella. Las otras
clases, como <code>Button</code>, <code>Image</code> y <code>SelectBox</code>, heredarían de <code>Component</code> y,
por lo tanto, heredarían el método <code>draw</code>. Cada uno podría anular el método
<code>draw</code> para definir su comportamiento personalizado, pero el marco podría
tratar todos los tipos como si fueran instancias de <code>Component</code> y llamar a
<code>draw</code> en ellos. Pero como Rust no tiene herencia, necesitamos otra forma de
estructurar la biblioteca <code>gui</code> para permitir a los usuarios extenderla con
nuevos tipos.</p>
<h3 id="definir-un-trait-para-un-comportamiento-común"><a class="header" href="#definir-un-trait-para-un-comportamiento-común">Definir un Trait para un comportamiento común</a></h3>
<p>Para implementar el comportamiento que queremos que tenga <code>gui</code>, definiremos
un trait llamado <code>Draw</code> que tendrá un método llamado <code>draw</code>. Luego podemos
definir un vector que tome un <em>objeto de trait</em>. Un objeto de trait apunta
tanto a una instancia de un tipo que implementa nuestro trait especificado
como a una tabla utilizada para buscar métodos de trait en ese tipo en tiempo
de ejecución. Creamos un objeto de trait especificando algún tipo de puntero,
como una referencia <code>&amp;</code> o un puntero inteligente <code>Box&lt;T&gt;</code>, luego la palabra
clave <code>dyn</code> y luego especificando el trait relevante. (Hablaremos sobre la
razón por la que los objetos de trait deben usar un puntero en el Capítulo 19
en la sección <a href="ch19-04-advanced-types.html#tipos-de-tamano-dinamico-y-el-trait-sized">“Tipos de tamaño dinámico y el
trait <code>Sized</code>.”</a><!-- ignore -->) Podemos usar objetos de
trait en lugar de un tipo genérico o concreto. Donde sea que usemos un objeto
de trait, el sistema de tipos de Rust se asegurará en tiempo de compilación que
cualquier valor utilizado en ese contexto implemente el trait del objeto de
trait. En consecuencia, no necesitamos conocer todos los tipos posibles en
tiempo de compilación.</p>
<p>Hemos mencionado que, en Rust, nos abstenemos de llamar a los structs y enums
“objetos” para distinguirlos de los objetos de otros lenguajes. En un struct o
enum, los datos en los campos del struct y el comportamiento en los bloques
<code>impl</code> están separados, mientras que en otros lenguajes, los datos y el
comportamiento combinados en un solo concepto a menudo se etiquetan como un
objeto. Sin embargo, los objetos de trait son más como objetos en otros
lenguajes en el sentido de que combinan datos y comportamiento. Pero los
objetos de trait difieren de los objetos tradicionales en que no podemos
agregar datos a un objeto de trait. Los objetos de trait no son tan útiles en
general como los objetos en otros lenguajes: su propósito específico es
permitir la abstracción a través del comportamiento común.</p>
<p>El Listado 17-3 muestra cómo definir un trait llamado <code>Draw</code> con un método
llamado <code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
<p><span class="caption">Listing 17-3: Definición del trait <code>Draw</code></span></p>
<p>Esta sintaxis debería verse familiar de nuestras discusiones sobre cómo
definir traits en el Capítulo 10. A continuación viene una sintaxis nueva: el
Listado 17-4 define un struct llamado <code>Screen</code> que contiene un vector llamado
<code>components</code>. Este vector es de tipo <code>Box&lt;dyn Draw&gt;</code>, que es un objeto de
trait; es un sustituto de cualquier tipo dentro de una <code>Box</code> que implementa el
trait <code>Draw</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
<p><span class="caption">Listing 17-4: Definición del struct <code>Screen</code> con un campo
<code>components</code> que contiene un vector de trait objects que implementan el trait
<code>Draw</code></span></p>
<p>En el struct <code>Screen</code> hemos definido un método llamado <code>run</code> que llamará al
método <code>draw</code> en cada uno de sus <code>components</code>, como se muestra en el Listado
17-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-5: Un método <code>run</code> en <code>Screen</code> que llama al
método <code>draw</code> en cada componente</span></p>
<p>Esto funciona de manera diferente a la definición de un struct que usa un
parámetro de tipo generic con trait bound. Un parámetro de tipo generic
solo se puede sustituir con un tipo concreto a la vez, mientras que los
trait objects permiten que varios tipos concretos llenen el trait object
en tiempo de ejecución. Por ejemplo, podríamos haber definido el struct
<code>Screen</code> usando un parámetro de tipo generic y un trait bound como en el
Listado 17-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-6: Una implementación alternativa del struct
<code>Screen</code> y su método <code>run</code> usando generics y trait bounds</span></p>
<p>Esto nos restringe a una instancia de <code>Screen</code> que tiene una lista de
componentes de tipo <code>Button</code> o de tipo <code>TextField</code>. Si solo tendrá
colecciones homogéneas, usar generics y trait bounds es preferible porque las
definiciones se monomorfizarán en tiempo de compilación para usar los tipos
concretos.</p>
<p>Por otro lado, con el método que utiliza trait objects, una instancia de
<code>Screen</code> puede contener un <code>Vec&lt;T&gt;</code> que contiene una <code>Box&lt;Button&gt;</code> así como
una <code>Box&lt;TextField&gt;</code>. Veamos cómo funciona esto, y luego hablaremos sobre las
implicaciones de rendimiento en tiempo de ejecución.</p>
<h3 id="implementando-el-trait"><a class="header" href="#implementando-el-trait">Implementando el trait</a></h3>
<p>Ahora agregaremos algunos tipos que implementen el trait <code>Draw</code>.
Proporcionaremos el tipo <code>Button</code>. Nuevamente, implementar una biblioteca GUI
está más allá del alcance de este libro, por lo que el método <code>draw</code> no tendrá
ninguna implementación útil en su cuerpo. Para imaginar cómo podría ser la
implementación, un struct <code>Button</code> podría tener campos para <code>width</code>, <code>height</code>
y <code>label</code>, como se muestra en el Listado 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}</code></pre>
<p><span class="caption">Listing 17-7: Un <code>Button</code> que implementa el trait
<code>Draw</code></span></p>
<p>Los campos <code>width</code>, <code>height</code> y <code>label</code> en <code>Button</code> serán diferentes de los
campos en otros componentes; por ejemplo, un tipo <code>TextField</code> podría tener
esos mismos campos más un campo <code>placeholder</code>. Cada uno de los tipos que
queremos dibujar en la pantalla implementará el trait <code>Draw</code> pero usará
código diferente en el método <code>draw</code> para definir cómo dibujar ese tipo
particular, como lo hace <code>Button</code> aquí (sin el código GUI real, como se
mencionó). El tipo <code>Button</code>, por ejemplo, podría tener un bloque <code>impl</code>
adicional que contenga métodos relacionados con lo que sucede cuando un
usuario hace clic en el botón. Este tipo de métodos no se aplicarán a tipos
como <code>TextField</code>.</p>
<p>Si alguien que utiliza nuestra biblioteca decide implementar un struct
<code>SelectBox</code> que tiene campos <code>width</code>, <code>height</code> y <code>options</code>, también
implementará el trait <code>Draw</code> en el tipo <code>SelectBox</code>, como se muestra en el
Listado 17-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Listing 17-8: Otro crate usando <code>gui</code> e implementando
el trait <code>Draw</code> en un struct <code>SelectBox</code></span></p>
<p>El usuario de nuestra biblioteca ahora puede escribir su función <code>main</code> para
crear una instancia de <code>Screen</code>. A la instancia de <code>Screen</code>, pueden agregar
un <code>SelectBox</code> y un <code>Button</code> colocando cada uno en una <code>Box&lt;T&gt;</code> para
convertirse en un trait object. Luego pueden llamar al método <code>run</code> en la
instancia de <code>Screen</code>, que llamará a <code>draw</code> en cada uno de los componentes.
El Listado 17-9 muestra esta implementación:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Listing 17-9: Usando trait objects para almacenar valores
de diferentes tipos que implementan el mismo trait</span></p>
<p>Cuando escribimos la biblioteca, no sabíamos que alguien podría agregar el tipo
<code>SelectBox</code>, pero nuestra implementación de <code>Screen</code> pudo operar en el nuevo
tipo y dibujarlo porque <code>SelectBox</code> implementa el trait <code>Draw</code>, lo que significa
que implementa el método <code>draw</code>.</p>
<p>Este concepto, de preocuparnos solo por los mensajes a los que responde un valor
en lugar del tipo concreto del valor, es similar al concepto de <em>duck typing</em> en
lenguajes de tipado dinámico: si camina como un pato y grazna como un pato,
¡entonces debe ser un pato! En la implementación de <code>run</code> en <code>Screen</code> en el
Listado 17-5, <code>run</code> no necesita saber cuál es el tipo concreto de cada
componente. No verifica si un componente es una instancia de un <code>Button</code> o de
un <code>SelectBox</code>, simplemente llama al método <code>draw</code> en el componente. Al
especificar <code>Box&lt;dyn Draw&gt;</code> como el tipo de los valores en el vector
<code>components</code>, hemos definido que <code>Screen</code> necesita valores a los que podamos
llamar el método <code>draw</code>.</p>
<p>La ventaja de utilizar trait objects y el sistema de tipos de Rust para escribir
código similar al código que utiliza duck typing es que nunca tenemos que
verificar si un valor implementa un método en particular en tiempo de ejecución
o preocuparnos por obtener errores si un valor no implementa un método, pero lo
llamamos de todos modos. Rust no compilará nuestro código si los valores no
implementan los traits que necesitan los trait objects.</p>
<p>Por ejemplo, el Listado 17-10 muestra lo que sucede si intentamos crear una
<code>Screen</code> con un <code>String</code> como componente:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;Hi&quot;))],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Listing 17-10: Intentando utilizar un tipo que no
implementa the trait del trait object</span></p>
<p>Obtendremos este error porque <code>String</code> no implementa el trait <code>Draw</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;Hi&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin &quot;gui&quot;) due to 1 previous error
</code></pre>
<p>Este error nos indica que o bien estamos pasando algo a <code>Screen</code> que no
queríamos pasar y, por lo tanto, deberíamos pasar un tipo diferente o deberíamos
implementar <code>Draw</code> en <code>String</code> para que <code>Screen</code> pueda llamar a <code>draw</code> en él.</p>
<h3 id="los-trait-objects-realizan-dynamic-dispatch"><a class="header" href="#los-trait-objects-realizan-dynamic-dispatch">Los trait objects realizan <em>dynamic dispatch</em></a></h3>
<p>Recuerda que en la sección <a href="ch10-01-syntax.html#rendimiento-de-codigo-usando-genericos">“Performance of Code Using
Generics”</a><!-- ignore --> del Capítulo 10
hablamos sobre el proceso de monomorfización que realiza el compilador cuando
usamos <em>trait bounds</em> en los genéricos: el compilador genera implementaciones
no genéricas de funciones y métodos para cada tipo concreto que usamos en lugar
de un parámetro de tipo genérico. El código que resulta de la monomorfización
está realizando <em>static dispatch</em>, que es cuando el compilador sabe qué método
estás llamando en tiempo de compilación. Esto se opone al <em>dynamic dispatch</em>,
que es cuando el compilador no puede decir en tiempo de compilación qué método
estás llamando. En los casos de dynamic dispatch, el compilador emite código que
en tiempo de ejecución determinará qué método llamar.</p>
<p>Cuando usamos trait objects, Rust debe usar dynamic dispatch. El compilador no
conoce todos los tipos que podrían usarse con el código que está llamando a
trait objects, por lo que no sabe qué método implementado en qué tipo llamar. En
cambio, en tiempo de ejecución, Rust usa los punteros dentro del trait object
para saber qué método llamar. Esta búsqueda incurre en un costo de tiempo de
ejecución que no ocurre con el static dispatch. Dynamic dispatch también evita
que el compilador elija la opción de <em>inline</em> del código de un método, lo que a
su vez evita algunas optimizaciones. Sin embargo, obtuvimos flexibilidad
adicional en el código que escribimos en el Listado 17-5 y pudimos admitir en
el Listado 17-9, por lo que es un compromiso a considerar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implementando-un-patrón-de-diseño-orientado-a-objetos"><a class="header" href="#implementando-un-patrón-de-diseño-orientado-a-objetos">Implementando un patrón de diseño orientado a objetos</a></h2>
<p>El <em>state pattern</em> es un patrón de diseño orientado a objetos. La esencia del
patrón es que definimos un conjunto de estados que un valor puede tener
internamente. Los estados están representados por un conjunto de <em>state
objects</em>, y el comportamiento del valor cambia según su estado. Vamos a
trabajar a través de un ejemplo de un struct de publicación de blog que
tiene un campo para mantener su estado, que será un state object del conjunto
&quot;borrador&quot;, &quot;revisión&quot; o &quot;publicado&quot;.</p>
<p>Los state objects comparten funcionalidad: en Rust, por supuesto, usamos
structs y traits en lugar de objetos y herencia. Cada state object es
responsable de su propio comportamiento y de gobernar cuándo debe cambiar a
otro estado. El valor que contiene un state object no sabe nada sobre el
comportamiento diferente de los estados o cuándo hacer la transición entre
estados.</p>
<p>La ventaja de usar el state pattern es que, cuando los requisitos comerciales
del programa cambian, no necesitaremos cambiar el código del valor que
contiene el estado o el código que usa el valor. Solo necesitaremos actualizar
el código dentro de uno de los state objects para cambiar sus reglas o quizás
agregar más state objects.</p>
<p>Primero, vamos a implementar el state pattern de una manera más tradicional
orientada a objetos, luego usaremos un enfoque que es un poco más natural en
Rust. Vamos a profundizar en la implementación incremental de un flujo de
trabajo de publicación de blog usando el state pattern.</p>
<p>La funcionalidad final se verá así:</p>
<ol>
<li>Un post de blog que comienza como un borrador vacío.</li>
<li>Cuando se completa el borrador, se solicita una revisión de la publicación.</li>
<li>Cuando se aprueba la publicación, se publica.</li>
<li>Solo las publicaciones de blog publicadas devuelven contenido para imprimir,
por lo que las publicaciones no aprobadas no pueden publicarse
accidentalmente.</li>
</ol>
<p>Cualquier otro cambio que se intente realizar en una publicación no debería
tener ningún efecto. Por ejemplo, si intentamos aprobar un borrador de blog
antes de haber solicitado una revisión, la publicación debería seguir siendo
un borrador no publicado.</p>
<p>El Listado 17-11 muestra este flujo de trabajo en forma de código: este es un
ejemplo de uso de la API que implementaremos en una crate de biblioteca
llamada <code>blog</code>. Esto aún no se compilará porque no hemos implementado el crate
de biblioteca <code>blog</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}</code></pre>
<p><span class="caption">Listing 17-11: Código que demuestra el comportamiento
deseado que queremos que tenga nuestro crate <code>blog</code></span></p>
<p>Queremos permitir que el usuario cree una nueva publicación de blog en borrador
con <code>Post::new</code>. Queremos permitir que se agregue texto a la publicación del
blog. Si intentamos obtener el contenido de la publicación inmediatamente,
antes de la aprobación, no deberíamos obtener ningún texto porque la publicación
sigue siendo un borrador. Hemos agregado <code>assert_eq!</code> en el código con fines de
demostración. Una excelente prueba unitaria para esto sería afirmar que una
publicación de blog en borrador devuelve un string vacío del método <code>content</code>,
pero no vamos a escribir pruebas para este ejemplo.</p>
<p>A continuación, queremos permitir una solicitud de revisión de la publicación
y queremos que <code>content</code> devuelva un string vacío mientras espera la revisión.
Cuando la publicación reciba la aprobación, debería publicarse, lo que significa
que el texto de la publicación se devolverá cuando se llame a <code>content</code>.</p>
<p>Observa que el único tipo con el que estamos interactuando desde el crate es
el tipo <code>Post</code>. Este tipo utilizará el state pattern y contendrá un valor que
será uno de los tres state objects que representan los diversos estados
en los que puede estar una publicación: borrador, esperando revisión o
publicado. El cambio de un estado a otro se administrará internamente dentro
del tipo <code>Post</code>. Los estados cambian en respuesta a los métodos llamados por
los usuarios de nuestra biblioteca en la instancia <code>Post</code>, pero no tienen que
administrar los cambios de estado directamente. Además, los usuarios no pueden
cometer un error con los estados, como publicar una publicación antes de que
se revise.</p>
<h3 id="definiendo-post-y-creando-una-nueva-instancia-en-el-estado-de-borrador"><a class="header" href="#definiendo-post-y-creando-una-nueva-instancia-en-el-estado-de-borrador">Definiendo <code>Post</code> y creando una nueva instancia en el estado de borrador</a></h3>
<p>¡Comencemos con la implementación de la biblioteca! Sabemos que necesitamos
un struct <code>Post</code> público que contenga algún contenido, por lo que comenzaremos
con la definición del struct y una función pública <code>new</code> asociada para crear
una instancia de <code>Post</code>, como se muestra en el Listado 17-12. También haremos
un trait privado <code>State</code> que definirá el comportamiento que todos los objetos
de estado para un <code>Post</code> deben tener.</p>
<p>Luego, <code>Post</code> contendrá un trait object de <code>Box&lt;dyn State&gt;</code> dentro de un campo
privado llamado <code>state</code> para mantener el state object. Verás por qué
<code>Option&lt;T&gt;</code> es necesario en un momento.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<p><span class="caption">Listing 17-12: Definición de un struct <code>Post</code> y una
función <code>new</code> que crea una nueva instancia de <code>Post</code>, un trait <code>State</code>, y un
struct <code>Draft</code></span></p>
<p>El trait <code>State</code> define el comportamiento compartido por los diferentes estados
de una publicación. Los state objects son <code>Draft</code>, <code>PendingReview</code> y
<code>Published</code>, y todos implementarán el trait <code>State</code>. Por ahora, el trait no
tiene ningún método, y comenzaremos definiendo solo el estado <code>Draft</code> porque
ese es el estado en el que queremos que comience una publicación.</p>
<p>Cuando creamos un nuevo <code>Post</code>, estableceremos su campo <code>state</code> como un valor
<code>Some</code> que contiene un <code>Box</code> que apunta a una nueva instancia del struct
<code>Draft</code>. Esto asegura que cada vez que creemos una nueva instancia de <code>Post</code>,
comenzará como un borrador. Debido a que el campo <code>state</code> de <code>Post</code> es privado,
¡no hay forma de crear un <code>Post</code> en ningún otro estado! En la función
<code>Post::new</code>, establecemos el campo <code>content</code> en un nuevo <code>String</code> vacío.</p>
<h3 id="almacenando-el-texto-del-contenido-del-post"><a class="header" href="#almacenando-el-texto-del-contenido-del-post">Almacenando el texto del contenido del post</a></h3>
<p>Vimos en el Listado 17-11 que queremos poder llamar a un método llamado
<code>add_text</code> y pasarle un <code>&amp;str</code> que luego se agregará como el contenido de texto
de la publicación del blog. Implementaremos esto como un método, en lugar de
exponer el campo <code>content</code> como <code>pub</code>, para que más tarde podamos implementar
un método que controlará cómo se lee el campo <code>content</code>. El método <code>add_text</code>
es bastante sencillo, así que agreguemos la implementación en el Listado 17-13
al bloque <code>impl Post</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Listing 17-13: Implementando el método <code>add_text</code> para
agregar texto al campo <code>content</code> de una publicación</span></p>
<p>El método <code>add_text</code> toma una referencia mutable a <code>self</code> porque estamos
cambiando la instancia de <code>Post</code> en la que estamos llamando <code>add_text</code>. Luego
llamamos a <code>push_str</code> en el <code>String</code> en <code>content</code> y pasamos el argumento <code>text</code>
para agregar al <code>content</code> guardado. Este comportamiento no depende del estado
en el que se encuentre la publicación, por lo que no es parte del state pattern.
El método <code>add_text</code> no interactúa con el campo <code>state</code> en absoluto, pero es
parte del comportamiento que queremos admitir.</p>
<h3 id="asegurando-que-el-contenido-de-un-post-en-borrador-esté-vacío"><a class="header" href="#asegurando-que-el-contenido-de-un-post-en-borrador-esté-vacío">Asegurando que el contenido de un post en borrador esté vacío</a></h3>
<p>Incluso después de que hayamos llamado <code>add_text</code> y agregado algún contenido a
nuestra publicación, todavía queremos que el método <code>content</code> devuelva un slice
de string vacío porque la publicación todavía está en el estado de borrador,
como se muestra en la línea 7 del Listado 17-11. Por ahora, implementemos el
método <code>content</code> con lo más simple que cumplirá con este requisito: siempre
devolver un string slice vacío. Lo cambiaremos más tarde una vez que
implementemos la capacidad de cambiar el estado de una publicación para que
pueda publicarse. Hasta ahora, las publicaciones solo pueden estar en el estado
de borrador, por lo que el contenido de la publicación siempre debe estar
vacío. El Listado 17-14 muestra esta implementación de marcador de posición:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Listing 17-14: Agregando una implementación provisional
para el método <code>content</code> en <code>Post</code> que siempre devuelve un string slice vacío
</span></p>
<p>Con este método <code>content</code> añadido, todo en el Listado 17-11 hasta la línea 7
funciona como se pretendía.</p>
<h3 id="solicitar-una-revisión-de-los-cambios-de-publicación-de-su-estado"><a class="header" href="#solicitar-una-revisión-de-los-cambios-de-publicación-de-su-estado">Solicitar una revisión de los cambios de publicación de su estado</a></h3>
<p>A continuación, necesitamos agregar funcionalidad para solicitar una revisión
de una publicación, lo que debería cambiar su estado de <code>Draft</code> a
<code>PendingReview</code>. El Listado 17-15 muestra este código:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Listing 17-15: Implementando los métodos <code>request_review</code>
en <code>Post</code> y el trait <code>State</code></span></p>
<p>Agregamos un método público llamado <code>request_review</code> a <code>Post</code> que toma una
referencia mutable a <code>self</code>. Luego llamamos a un método interno <code>request_review</code>
en el estado actual de <code>Post</code>, y este segundo método <code>request_review</code> consume
el estado actual y devuelve un nuevo estado.</p>
<p>Agregamos el método <code>request_review</code> al trait <code>State</code>; todos los tipos que
implementan el trait ahora deberán implementar el método <code>request_review</code>.
Tenga en cuenta que en lugar de tener <code>self</code>, <code>&amp;self</code> o <code>&amp;mut self</code> como el
primer parámetro del método, tenemos <code>self: Box&lt;Self&gt;</code>. Esta sintaxis significa
que el método solo es válido cuando se llama en un <code>Box</code> que contiene el tipo.
Esta sintaxis toma posesión de <code>Box&lt;Self&gt;</code>, invalidando el estado anterior para
que el valor de estado de <code>Post</code> pueda transformarse en un nuevo estado.</p>
<p>Para consumir el antiguo estado, el método <code>request_review</code> debe tomar
ownership del valor de estado. Aquí es donde entra en juego la <code>Option</code> en el
campo <code>state</code> de <code>Post</code>: llamamos al método <code>take</code> para sacar el valor <code>Some</code>
del campo <code>state</code> y dejar un <code>None</code> en su lugar, porque Rust no nos permite
tener campos no poblados en los structs. Esto nos permite mover el valor
<code>state</code> fuera de <code>Post</code> en lugar de pedir borrowing. Luego estableceremos el
valor <code>state</code> de la publicación en el resultado de esta operación.</p>
<p>Necesitamos establecer <code>state</code> como <code>None</code> temporalmente en lugar de
establecerlo directamente con código como
<code>self.state = self.state.request_review();</code> para obtener la propiedad del
valor <code>state</code>. Esto asegura que <code>Post</code> no pueda usar el valor <code>state</code> antiguo
después de que lo hayamos transformado en un nuevo estado.</p>
<p>El método <code>request_review</code> en <code>Draft</code> devuelve una nueva instancia de un nuevo
struct llamado <code>PendingReview</code>, que representa el estado cuando un post está
esperando una revisión. El struct <code>PendingReview</code> también implementa
el método <code>request_review</code>, pero no hace ninguna transformación. En cambio,
devuelve a sí mismo, porque cuando solicitamos una revisión en una publicación
que ya está en el estado <code>PendingReview</code>, debe permanecer en el estado
<code>PendingReview</code>.</p>
<p>Ahora podemos comenzar a ver las ventajas del state pattern: el método
<code>request_review</code> en <code>Post</code> es el mismo sin importar su valor <code>state</code>. Cada
estado es responsable de sus propias reglas.</p>
<p>Dejaremos el método <code>content</code> en <code>Post</code> tal como está, devolviendo un string
slice vacío. Ahora podemos tener un <code>Post</code> en el estado <code>PendingReview</code> así
como en el estado <code>Draft</code>, pero queremos el mismo comportamiento en el estado
<code>PendingReview</code>. ¡El Listado 17-11 ahora funciona hasta la línea 10!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="agregando-approve-para-cambiar-el-comportamiento-de-content"><a class="header" href="#agregando-approve-para-cambiar-el-comportamiento-de-content">Agregando <code>approve</code> para cambiar el comportamiento de <code>content</code></a></h3>
<p>El método <code>approve</code> será similar al método <code>request_review</code>: establecerá el
valor de <code>state</code> al estado que el estado actual indique que debería tener
cuando ese estado sea aprobado, como se muestra en el Listado 17-16:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Listing 17-16: Implementando el método <code>approve</code> en
<code>Post</code> y el trait <code>State</code></span></p>
<p>Agregamos el método <code>approve</code> al trait <code>State</code> y agregamos un nuevo struct
que implementa el trait <code>State</code>, el estado <code>Published</code>.</p>
<p>De manera similar a cómo funciona <code>request_review</code> en <code>PendingReview</code>, si
llamamos al método <code>approve</code> en un estado <code>Draft</code>, no tendrá efecto porque
<code>approve</code> devolverá <code>self</code>. Cuando llamamos a <code>approve</code> en <code>PendingReview</code>,
devuelve una nueva instancia de <code>Published</code> struct. El struct <code>Published</code>
implementa el trait <code>State</code>, y para ambos el método <code>request_review</code> y el
método <code>approve</code>, devuelve a sí mismo, porque la publicación debe permanecer
en el estado <code>Published</code> en esos casos.</p>
<p>Ahora debemos actualizar el método <code>content</code> en <code>Post</code>. Queremos que el valor
devuelto por <code>content</code> dependa del estado actual de <code>Post</code>, por lo que vamos
a hacer que <code>Post</code> delegue a un método <code>content</code> definido en su <code>state</code>, como
se muestra en el Listado 17-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 17-17: Actualizando el método <code>content</code> en <code>Post</code>
para delegar en un método <code>content</code> en <code>State</code></span></p>
<p>Debido a que el objetivo es mantener todas estas reglas dentro de los structs
que implementan <code>State</code>, llamamos a un método <code>content</code> en el valor en <code>state</code>
y pasamos la instancia de publicación (es decir, <code>self</code>) como argumento. Luego
devolvemos el valor devuelto del uso del método <code>content</code> en el valor <code>state</code>.</p>
<p>Llamamos al método <code>as_ref</code> en un <code>Option</code> porque queremos una referencia al
valor dentro del <code>Option</code> en lugar del ownership del valor. Debido a que
<code>state</code> es un <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, cuando llamamos a <code>as_ref</code>, se
devuelve una <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>. Si no llamamos a <code>as_ref</code>, obtendríamos
un error porque no podemos mover <code>state</code> fuera del <code>&amp;self</code> prestado del
parámetro de la función.</p>
<p>Luego llamamos al método <code>unwrap</code>, el cual sabemos que nunca generará un error,
porque los métodos en <code>Post</code> aseguran que <code>state</code> siempre contendrá un valor
<code>Some</code> cuando esos métodos finalicen. Este es uno de los casos que mencionamos
en la sección <a href="ch09-03-to-panic-or-not-to-panic.html#casos-en-los-que-tienes-mas-informacion-que-el-compilador">“Casos en los que tienes más información que el
compilador”</a><!-- ignore --> del Capítulo 9 cuando
sabemos que un valor <code>None</code> nunca es posible, aunque el compilador no puede
entender eso.</p>
<p>En este punto, cuando llamamos a <code>content</code> en el <code>&amp;Box&lt;dyn State&gt;</code>, la coerción
de dereferencia entrará en vigencia en el <code>&amp;</code> y el <code>Box</code>, por lo que el método
<code>content</code> se llamará en el tipo que implementa el trait <code>State</code>. Eso significa
que debemos agregar <code>content</code> a la definición del trait <code>State</code>, y allí es
donde pondremos la lógica para qué contenido devolver dependiendo de qué
estado tengamos, como se muestra en el Listado 17-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<p><span class="caption">Listing 17-18: Agregando el método <code>content</code> al trait
<code>State</code></span></p>
<p>Agregamos una implementación predeterminada para el método <code>content</code> que
devuelve un string slice vacío. Eso significa que no necesitamos implementar
<code>content</code> en los structs <code>Draft</code> y <code>PendingReview</code>. El struct <code>Published</code>
anulará el método <code>content</code> y devolverá el valor en <code>post.content</code>.</p>
<p>Es importante destacar que necesitamos anotaciones de lifetime en este método,
como discutimos en el Capítulo 10. Estamos tomando una referencia a un <code>post</code>
como argumento y devolviendo una referencia a una parte de ese <code>post</code>, por lo
que el lifetime de la referencia devuelta está relacionado con el tiempo
de vida del argumento <code>post</code>.</p>
<p>¡Y hemos terminado! ¡Todo lo que se muestra en el Listado 17-11 ahora funciona!
Hemos implementado el patrón de estado con las reglas del flujo de trabajo de
la publicación de blog. La lógica relacionada con las reglas vive en los
objetos de estado en lugar de estar dispersa en <code>Post</code>.</p>
<blockquote>
<h4 id="por-qué-no-un-enum"><a class="header" href="#por-qué-no-un-enum">¿Por qué no un enum?</a></h4>
<p>Puede que te hayas preguntado por qué no usamos un <code>enum</code> con los diferentes
estados posibles de la publicación como variantes. Esa es ciertamente una
solución posible, ¡pruébala y compara los resultados finales para ver cuál
prefieres! Una desventaja de usar un enum es que cada lugar que verifica el
valor del enum necesitará una expresión <code>match</code> o similar para manejar cada
variante posible. Esto podría ser más repetitivo que esta solución de trait
object.</p>
</blockquote>
<h3 id="trade-offs-del-state-pattern"><a class="header" href="#trade-offs-del-state-pattern">Trade-offs del State Pattern</a></h3>
<p>Hemos demostrado que Rust es capaz de implementar el State Pattern orientado a
objetos para encapsular los diferentes tipos de comportamiento que un post
debería tener en cada estado. Los métodos en <code>Post</code> no saben nada sobre los
diferentes comportamientos. La forma en que organizamos el código, solo
tenemos que mirar en un solo lugar para conocer las diferentes formas en que
un post publicado puede comportarse: la implementación del trait <code>State</code> en el
struct <code>Published</code>.</p>
<p>Si creáramos una implementación alternativa que no usara el State Pattern,
en su lugar podríamos usar expresiones <code>match</code> en los métodos de <code>Post</code> o
incluso en el código <code>main</code> que verifica el estado del post y cambia el
comportamiento en esos lugares. ¡Eso significaría que tendríamos que mirar en
varios lugares para comprender todas las implicaciones de un post que se
encuentra en el estado publicado! ¡Esto solo aumentaría cuanto más estados
agregáramos: cada una de esas expresiones <code>match</code> necesitaría otra opción!</p>
<p>Con el State Pattern, los métodos <code>Post</code> y los lugares donde usamos <code>Post</code> no
necesitan expresiones <code>match</code>, y para agregar un nuevo estado, solo
necesitaríamos agregar un nuevo struct e implementar los métodos del trait en
ese struct.</p>
<p>La implementación utilizando el State Pattern es fácil de extender para agregar
más funcionalidad. Para ver la simplicidad de mantener el código que usa el
State Pattern, prueba algunas de estas sugerencias:</p>
<ul>
<li>Agrega un método <code>reject</code> que cambia el estado de un post de <code>PendingReview</code>
a <code>Draft</code>.</li>
<li>Requiere dos llamadas a <code>approve</code> antes de que el estado pueda cambiar a
<code>Published</code>.</li>
<li>Permite a los usuarios agregar contenido de texto solo cuando un post está en
el estado <code>Draft</code>. Sugerencia: haz que el objeto de estado sea responsable de
lo que podría cambiar sobre el contenido, pero no sea responsable de modificar
el <code>Post</code>.</li>
</ul>
<p>Un inconveniente del State Pattern es que, debido a que los estados implementan
las transiciones entre estados, algunos de los estados están acoplados entre sí.
Si agregamos otro estado entre <code>PendingReview</code> y <code>Published</code>, como <code>Scheduled</code>,
tendríamos que cambiar el código en <code>PendingReview</code> para hacer la transición a
<code>Scheduled</code> en su lugar. Sería menos trabajo si <code>PendingReview</code> no necesitara
cambiar con la adición de un nuevo estado, pero eso significaría cambiar a
otro patrón de diseño.</p>
<p>Otro inconveniente es que hemos duplicado algo de lógica. Para eliminar parte
de la duplicación, podríamos intentar hacer implementaciones predeterminadas
para los métodos <code>request_review</code> y <code>approve</code> en el trait <code>State</code> que devuelvan
<code>self</code>; sin embargo, esto violaría la seguridad del objeto, porque el trait no
sabe exactamente cuál será el <code>self</code> concreto. Queremos poder usar <code>State</code> como
un objeto de trait, por lo que sus métodos deben ser seguros para el objeto.</p>
<p>Otra duplicación incluye las implementaciones similares de los métodos
<code>request_review</code> y <code>approve</code> en <code>Post</code>. Ambos métodos delegan a la
implementación del mismo método en el valor del campo <code>state</code> de <code>Option</code> y
establecen el nuevo valor del campo <code>state</code> en el resultado. Si tuviéramos
muchos métodos en <code>Post</code> que siguieran este patrón, podríamos considerar
definir un macro para eliminar la repetición (ver la sección <a href="ch19-06-macros.html#macros">“Macros”</a>
en el Capítulo 19).</p>
<p>Al implementar el State Pattern exactamente como se define en lenguajes
orientados a objetos, no estamos aprovechando al máximo las fortalezas de Rust.
Veamos algunos cambios que podemos hacer en el crate <code>blog</code> que pueden hacer
que los estados y transiciones no válidos sean errores de tiempo de
compilación.</p>
<h4 id="codificando-estados-y-comportamiento-como-tipos"><a class="header" href="#codificando-estados-y-comportamiento-como-tipos">Codificando estados y comportamiento como tipos</a></h4>
<p>Vamos a mostrarte cómo replantear el State Pattern para obtener un conjunto
diferente de compensaciones. En lugar de encapsular los estados y las
transiciones por completo para que el código externo no tenga conocimiento de
ellos, codificaremos los estados en diferentes tipos. En consecuencia, el
sistema de verificación de tipos de Rust evitará los intentos de usar
publicaciones borradores donde solo se permiten publicaciones publicadas
emitiendo un error del compilador.</p>
<p>Consideremos la primera parte de <code>main</code> en el Listado 17-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
</span>}</code></pre>
<p>Todavía permitimos la creación de nuevas publicaciones en el estado de borrador
usando <code>Post::new</code> y la capacidad de agregar texto al contenido de la
publicación. Pero en lugar de tener un método <code>content</code> en una publicación en
borrador que devuelva un string vacío, haremos que las publicaciones en
borrador no tengan el método <code>content</code> en absoluto. De esa manera, si
intentamos obtener el contenido de una publicación en borrador, obtendremos un
error del compilador que nos dice que el método no existe. Como resultado,
será imposible mostrar accidentalmente el contenido de la publicación en
borrador en producción, porque ese código ni siquiera se compilará. El Listado
17-9 muestra la definición de un struct <code>Post</code> y un struct <code>DraftPost</code>, así
como métodos en cada uno:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<p><span class="caption">Listing 17-19: Un <code>Post</code> con un método <code>content</code> y un
<code>DraftPost</code> sin un método <code>content</code></span></p>
<p>Tanto los structs <code>Post</code> como <code>DraftPost</code> tienen un campo privado <code>content</code>
que almacena el texto de la publicación del blog. Los structs ya no tienen el
campo <code>state</code> porque estamos moviendo la codificación del estado a los tipos
de los structs. El struct <code>Post</code> representará una publicación publicada, y
tiene un método <code>content</code> que devuelve el <code>content</code>.</p>
<p>Todavía tenemos una función <code>Post::new</code>, pero en lugar de devolver una
instancia de <code>Post</code>, devuelve una instancia de <code>DraftPost</code>. Debido a que
<code>content</code> es privado y no hay funciones que devuelvan <code>Post</code>, no es posible
crear una instancia de <code>Post</code> en este momento.</p>
<p>El struct <code>DraftPost</code> tiene un método <code>add_text</code>, por lo que podemos agregar
texto al campo <code>content</code> como antes. Sin embargo, ten en cuenta que <code>DraftPost</code>
no tiene un método <code>content</code> definido. Entonces, ahora el programa garantiza
que todas las publicaciones comienzan como publicaciones en borrador, y las
publicaciones en borrador no tienen su contenido disponible para mostrar.
Cualquier intento de evitar estas restricciones dará como resultado un error
del compilador.</p>
<h4 id="implementando-transiciones-como-transformaciones-en-diferentes-tipos"><a class="header" href="#implementando-transiciones-como-transformaciones-en-diferentes-tipos">Implementando transiciones como transformaciones en diferentes tipos</a></h4>
<p>Entonces, ¿cómo obtenemos una publicación publicada? Queremos hacer cumplir
la regla de que una publicación en borrador debe ser revisada y aprobada antes
de que pueda publicarse. Una publicación en el estado de revisión pendiente
todavía no debe mostrar ningún contenido. Implementemos estas restricciones
agregando otro struct, <code>PendingReviewPost</code>, definiendo el método <code>request_review</code>
en <code>DraftPost</code> para devolver un <code>PendingReviewPost</code>, y definiendo un método
<code>approve</code> en <code>PendingReviewPost</code> para devolver un <code>Post</code>, como se muestra en
el Listado 17-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-20: Un <code>PendingReviewPost</code> que se crea
llamando a <code>request_review</code> en <code>DraftPost</code> y un método <code>approve</code> que convierte
un <code>PendingReviewPost</code> en un <code>Post</code> publicado</span></p>
<p>Los métodos <code>request_review</code> y <code>approve</code> toman ownership de <code>self</code>, consumiendo
así las instancias de <code>DraftPost</code> y <code>PendingReviewPost</code> y transformándolas en
un <code>PendingReviewPost</code> y un <code>Post</code> publicado, respectivamente. De esta manera,
no tendremos ninguna instancia de <code>DraftPost</code> persistente después de haber
llamado a <code>request_review</code> en ellas, y así sucesivamente. El struct
<code>PendingReviewPost</code> no tiene un método <code>content</code> definido en él, por lo que
intentar leer su contenido da como resultado un error del compilador, como con
<code>DraftPost</code>. Debido a que la única forma de obtener una instancia de <code>Post</code>
publicada que tiene un método <code>content</code> definido es llamar al método <code>approve</code>
en un <code>PendingReviewPost</code>, y la única forma de obtener un <code>PendingReviewPost</code>
es llamar al método <code>request_review</code> en un <code>DraftPost</code>, ahora hemos codificado
el workflow de la publicación del blog en el sistema de tipos.</p>
<p>Pero también debemos hacer algunos cambios pequeños en <code>main</code>. Los métodos
<code>request_review</code> y <code>approve</code> devuelven nuevas instancias en lugar de modificar
el struct en el que se llaman, por lo que debemos agregar más asignaciones de
sombreado <code>let post =</code> para guardar las instancias devueltas. Tampoco podemos
tener las afirmaciones sobre el contenido de las publicaciones en borrador y
revisión pendiente sean strings vacíos, ni los necesitamos: ya no podemos
compilar el código que intenta usar el contenido de las publicaciones en esos
estados. El código actualizado en <code>main</code> se muestra en el Listado 17-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}</code></pre>
<p><span class="caption">Listing 17-21: Modificaciones a <code>main</code> para usar la nueva
implementación del workflow de la publicación del blog</span></p>
<p>Las modificaciones que hicimos a <code>main</code> para reasignar <code>post</code> significan que
esta implementación ya no sigue el patrón de estado orientado a objetos: las
transformaciones entre los estados ya no están encapsuladas completamente
dentro de la implementación de <code>Post</code>. Sin embargo, nuestra ganancia es que
los estados inválidos ahora son imposibles debido al sistema de tipos y la
comprobación de tipos que ocurre en tiempo de compilación. Esto garantiza que
ciertos errores, como la visualización del contenido de una publicación no
publicada, se descubrirán antes de que lleguen a producción.</p>
<p>Prueba las tareas sugeridas al comienzo de esta sección en el crate <code>blog</code> tal
como está después del Listado 17-21 para evaluar el diseño de esta versión del
código. Ten en cuenta que es posible que algunas de las tareas ya estén
completadas en este diseño.</p>
<p>Hemos visto que aunque Rust es capaz de implementar patrones de diseño
orientados a objetos, también están disponibles en Rust otros patrones, como
la codificación del estado en el sistema de tipos. Estos patrones tienen
diferentes compensaciones. Aunque es posible que estés muy familiarizado con
los patrones orientados a objetos, repensar el problema para aprovechar las
características de Rust puede proporcionar beneficios, como prevenir algunos
errores en tiempo de compilación. Los patrones orientados a objetos no siempre
serán la mejor solución en Rust debido a ciertas características, como el
ownership, que los lenguajes orientados a objetos no tienen.</p>
<h2 id="resumen-16"><a class="header" href="#resumen-16">Resumen</a></h2>
<p>Sin importar si consideras a Rust como un lenguaje orientado a objetos después
de leer este capítulo, ahora sabes que puedes usar objetos de tipo trait para
obtener algunas características orientadas a objetos en Rust. La
despatronización dinámica puede brindarle a tu código cierta flexibilidad a
cambio de un poco de rendimiento en tiempo de ejecución. Puedes usar esta
flexibilidad para implementar patrones orientados a objetos que pueden ayudar
a la mantenibilidad de tu código. Rust también tiene otras características,
como el ownership, que los lenguajes orientados a objetos no tienen. Un patrón
orientado a objetos no siempre será la mejor manera de aprovechar las
fortalezas de Rust, pero es una opción disponible.</p>
<p>A continuación, veremos los patterns, que son otra de las características de
Rust que permiten mucha flexibilidad. Hemos visto brevemente los patterns a lo
largo del libro, pero aún no hemos visto su capacidad total. ¡Vamos allá!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns-and-matching"><a class="header" href="#patterns-and-matching">Patterns and Matching</a></h1>
<p>Los <em>Patterns</em> (Patrones) son una sintaxis especial en Rust para hacer coincidir
la estructura de los tipos, tanto complejos como simples. El uso de patrones en
conjunción con expresiones <code>match</code> y otros constructos le brinda más control
sobre el flujo de control de un programa. Un patrón consta de alguna
combinación de los siguientes:</p>
<ul>
<li>Literales</li>
<li>Arrays, Enums, Structs, o Tuplas desestructuradas</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<p>Algunos ejemplos de patrones incluyen <code>x</code>, <code>(a, 3)</code> y <code>Some(Color::Red)</code>. En
los contextos en los que los patrones son válidos, estos componentes describen
la forma de los datos. Nuestro programa luego compara los valores con los
patrones para determinar si tiene la forma correcta de datos para continuar
ejecutando un código en particular.</p>
<p>Para usar un patrón, lo comparamos con algún valor. Si el patrón coincide con el
valor, usamos las partes de valor en nuestro código. Recuerde las expresiones
<code>match</code> en el Capítulo 6 que usaron patrones, como el ejemplo de la máquina
clasificadora de monedas. Si el valor se ajusta a la forma del patrón, podemos
usar las piezas con nombre. Si no lo hace, el código asociado con el patrón no
se ejecutará.</p>
<p>Este capítulo es una referencia sobre todo lo relacionado con los patrones.
Cubriremos los lugares válidos para usar patrones, la diferencia entre patrones
refutables e irrefutables, y los diferentes tipos de sintaxis de patrones que
puede ver. Al final del capítulo, sabrá cómo usar patrones para expresar muchos
conceptos de una manera clara.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="todos-los-lugares-donde-se-pueden-usar-patterns"><a class="header" href="#todos-los-lugares-donde-se-pueden-usar-patterns">Todos los lugares donde se pueden usar Patterns</a></h2>
<p>Los Patterns aparecen en varios lugares en Rust, ¡y los has estado usando mucho
sin darte cuenta! Esta sección discute todos los lugares donde los Patterns son
válidos.</p>
<h3 id="opciones-de-match"><a class="header" href="#opciones-de-match">Opciones de <code>match</code></a></h3>
<p>Como se discutió en el Capítulo 6, usamos Patterns en las opciones de las
expresiones <code>match</code>. Formalmente, las expresiones <code>match</code> se definen como la
palabra clave <code>match</code>, un valor para hacer coincidir y una o más opciones de
coincidencia que consisten en un patrón y una expresión para ejecutar si el
valor coincide con el patrón de esa opción, así:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>Por ejemplo, aquí está la expresión <code>match</code> del Listado 6-5 que coincide con un
valor <code>Option&lt;i32&gt;</code> en la variable <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>Los patterns en esta expresión <code>match</code> son el <code>None</code> y el <code>Some(i)</code> a la
izquierda de cada flecha.</p>
<p>Un requisito para las expresiones <code>match</code> es que deben ser <em>exhaustivas</em> en el
sentido de que todas las posibilidades para el valor en la expresión <code>match</code>
deben tenerse en cuenta. Una forma de asegurarse de haber cubierto todas las
posibilidades es tener un patrón de captura para el último brazo: por ejemplo,
un nombre de variable que coincida con cualquier valor nunca puede fallar y,
por lo tanto, cubre todos los casos restantes.</p>
<p>El patrón específico <code>_</code> coincidirá con cualquier cosa, pero nunca se une a una
variable, por lo que a menudo se usa en la última opción de coincidencia. El
patrón <code>_</code> puede ser útil cuando desea ignorar cualquier valor no especificado,
por ejemplo. Cubriremos el patrón <code>_</code> con más detalle en la sección <a href="ch18-03-pattern-syntax.html#ignorando-valores-en-un-patron">“Ignorar
valores en un patrón”</a><!-- ignore --> más adelante
en este capítulo.</p>
<h3 id="expresiones-condicionales-if-let"><a class="header" href="#expresiones-condicionales-if-let">Expresiones condicionales <code>if let</code></a></h3>
<p>En el capítulo 6 discutimos cómo usar expresiones <code>if let</code> principalmente como
una forma más corta de escribir el equivalente de un <code>match</code> que solo coincide
con un caso. Opcionalmente, <code>if let</code> puede tener un <code>else</code> correspondiente que
contenga código para ejecutar si el patrón en el <code>if let</code> no coincide.</p>
<p>El Listado 18-1 muestra que también es posible mezclar y combinar expresiones
<code>if let</code>, <code>else if</code> y <code>else if let</code>. Hacerlo nos da más flexibilidad que una
expresión <code>match</code> en la que solo podemos expresar un valor para comparar con
los patrones. Además, Rust no requiere que las condiciones en una serie de
brazos <code>if let</code>, <code>else if</code>, <code>else if let</code> se relacionen entre sí.</p>
<p>El código en el Listado 18-1 determina de qué color hacer su fondo en función
de una serie de comprobaciones para varias condiciones. Para este ejemplo,
hemos creado variables con valores codificados que un programa real podría
recibir de la entrada del usuario.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {color}, as the background&quot;);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-1: Combinando
<code>if let</code>, <code>else if</code>, <code>else if let</code>, y <code>else</code></span></p>
<p>Si el usuario especifica un color favorito, ese color se usa como fondo. Si no
se especifica un color favorito y hoy es martes, el color de fondo es verde.
De lo contrario, si el usuario especifica su edad como una cadena y podemos
analizarla como un número con éxito, el color es púrpura o naranja dependiendo
del valor del número. Si ninguna de estas condiciones se aplica, el color de
fondo es azul.</p>
<p>Una estructura condicional nos permite cumplir con requisitos complejos.
Con los valores codificados que tenemos aquí, este ejemplo imprimirá <code>Using purple as the background color</code>.</p>
<p>Puedes ver que <code>if let</code> también puede introducir variables con shadowing de la
misma manera que lo hacen las opciones <code>match</code>: la línea <code>if let Ok(age) = age</code> introduce una nueva variable <code>age</code> que contiene el valor dentro de la
variante <code>Ok</code>. Esto significa que necesitamos colocar la condición <code>if age &gt; 30</code>
dentro de ese bloque: no podemos combinar estas dos condiciones en <code>if let Ok (age) = age &amp;&amp; age &gt; 30</code>. El <code>age</code> sombreado que queremos comparar con 30 no es
válido hasta que comience el nuevo alcance con la llave de apertura.</p>
<p>La desventaja de usar expresiones <code>if let</code> es que el compilador no verifica la
exhaustividad, mientras que con las expresiones <code>match</code> sí lo hace. Si
omitiéramos el último bloque <code>else</code> y, por lo tanto, no manejáramos algunos
casos, el compilador no nos alertaría sobre el posible bug de lógica.</p>
<h3 id="bucles-condicionales-while-let"><a class="header" href="#bucles-condicionales-while-let">Bucles condicionales <code>while let</code></a></h3>
<p>Similar en su construcción a <code>if let</code>, el bucle condicional <code>while let</code> permite
que un bucle <code>while</code> se ejecute mientras un patrón continúe coincidiendo. En
el Listado 18-2 codificamos un bucle <code>while let</code> que usa un vector como una
pila e imprime los valores en el vector en el orden opuesto en el que se
pusieron.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{top}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-2: Utilizando un bucle <code>while let</code> para
imprimir valores mientras <code>stack.pop()</code> devuelva <code>Some</code></span></p>
<p>Este ejemplo imprime 3, 2 y luego 1. El método <code>pop</code> toma el último elemento
del vector y devuelve <code>Some(value)</code>. Si el vector está vacío, <code>pop</code> devuelve
<code>None</code>. El bucle <code>while</code> continúa ejecutando el código en su bloque siempre que
<code>pop</code> devuelva <code>Some</code>. Cuando <code>pop</code> devuelve <code>None</code>, el bucle se detiene.
Podemos usar <code>while let</code> para sacar todos los elementos de nuestra pila.</p>
<h3 id="bucles-for"><a class="header" href="#bucles-for">Bucles <code>for</code></a></h3>
<p>En un bucle <code>for</code>, el valor que sigue directamente a la palabra clave <code>for</code> es
un pattern. Por ejemplo, en <code>for x in y</code> el <code>x</code> es el pattern. El Listado 18-3
demuestra cómo usar un pattern en un bucle <code>for</code> para destruir, o romper, una
tupla como parte del bucle <code>for</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{value} is at index {index}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-3: Usando un pattern en un bucle <code>for</code> para
desestructurar una tupla</span></p>
<p>El código en el Listado 18-3 imprimirá lo siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>Adaptamos un iterator usando el método <code>enumerate</code> para que produzca un valor y
el índice de ese valor, colocado en una tupla. El primer valor producido es la
tupla <code>(0, 'a')</code>. Cuando este valor se corresponde con el pattern <code>(index, value)</code>, <code>index</code> será <code>0</code> y <code>value</code> será <code>'a'</code>, imprimiendo la primera línea
del output.</p>
<h3 id="sentencias-let"><a class="header" href="#sentencias-let">Sentencias <code>let</code></a></h3>
<p>Antes de este capítulo, solo habíamos discutido explícitamente el uso de
patterns con <code>match</code> e <code>if let</code>, pero de hecho, también hemos usado patterns
en otros lugares, incluyendo en las sentencias <code>let</code>. Por ejemplo, considera
esta asignación de variable directa con <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Cada vez que has utilizado una declaración <code>let</code> como esta, has estado usando
patterns, aunque es posible que no te hayas dado cuenta. Más formalmente, una
sentencia <code>let</code> se ve así:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>En declaraciones como <code>let x = 5;</code>, con un nombre de variable en el slot
<code>PATTERN</code>, el nombre de la variable es solo una forma particularmente simple de
un pattern. Rust compara la expresión con el pattern y asigna cualquier nombre
que encuentre. Entonces, en el ejemplo <code>let x = 5;</code>, <code>x</code> es un pattern que
significa “vincula lo que coincide aquí a la variable <code>x</code>”. Debido a que el
nombre <code>x</code> es todo el pattern, este pattern significa efectivamente “vincula
todo a la variable <code>x</code>, sea cual sea el valor”.</p>
<p>Para ver más claramente el aspecto de coincidencia de patrones de <code>let</code>,
considera el Listado 18-4, que usa un pattern con <code>let</code> para destruir una
tupla.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-4: Usando un pattern para desestructurar una
tupla y crear tres variables a la vez</span></p>
<p>Aquí, emparejamos una tupla con un pattern. Rust compara el valor <code>(1, 2, 3)</code>
con el pattern <code>(x, y, z)</code> y ve que el valor y el pattern coinciden, por lo que
Rust asigna <code>1</code> a <code>x</code>, <code>2</code> a <code>y</code> y <code>3</code> a <code>z</code>. Puedes pensar que este pattern de
tupla anida tres patterns de variable individuales dentro de él.</p>
<p>Si el número de elementos en el pattern no coincide con el número de elementos
en la tupla, el tipo general no coincidirá y obtendremos un error del
compilador. Por ejemplo, el Listado 18-5 muestra un intento de destruir una
tupla con tres elementos en dos variables, lo cual no funcionará.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-5: Al construir incorrectamente un pattern
cuyas variables no coinciden con el número de elementos en la tupla</span></p>
<p>Intentar compilar este código resulta en este error de tipo:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin &quot;patterns&quot;) due to 1 previous error
</code></pre>
<p>Para solucionar el error, podríamos ignorar uno o más valores en la tupla
utilizando <code>_</code> o <code>..</code>, como verás en la sección <a href="ch18-03-pattern-syntax.html#ignorando-valores-en-un-patron">“Ignorando valores en un
pattern”</a><!-- ignore -->. Si el problema es que
tenemos demasiadas variables en el pattern, la solución es hacer que los tipos
coincidan eliminando variables para que el número de variables sea igual al
número de elementos en la tupla.</p>
<h3 id="parámetros-de-función"><a class="header" href="#parámetros-de-función">Parámetros de función</a></h3>
<p>Los parámetros de función también pueden ser patterns. El código del Listado
18-6, que declara una función llamada <code>foo</code> que toma un parámetro llamado <code>x</code>
de tipo <code>i32</code>, debería ser familiar a estas alturas.</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 18-6: La firma de una función que utiliza
patterns en los parámetros</span></p>
<p>¡La parte <code>x</code> es un pattern! Como hicimos con <code>let</code>, podríamos hacer coincidir
una tupla en los argumentos de una función con el pattern. El Listado 18-7
divide los valores en una tupla a medida que la pasamos a una función.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({x}, {y})&quot;);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<p><span class="caption">Listing 18-7: Una función con parámetros que desetructura
una tupla</span></p>
<p>Este código imprime <code>Current location: (3, 5)</code>. El valor <code>(3, 5)</code> coincide con
el pattern <code>(x, y)</code>, por lo que <code>x</code> es <code>3</code> y <code>y</code> es <code>5</code>.</p>
<p>También podemos usar patterns en las listas de parámetros de closures, de la
misma manera que en las listas de parámetros de funciones. Porque los closures
son similares a las funciones, como se discutió en el Capítulo 13.</p>
<p>Hasta ahora, has visto varias formas de usar patrones, pero los patrones no
funcionarán de la misma manera en todos los lugares donde podemos usarlos. En
algunos casos, los patrones deben ser irrefutables; en otras circunstancias,
pueden ser refutables. Discutiremos estos dos conceptos a continuación.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refutabilidad-si-un-pattern-puede-fallar-al-hacer-match"><a class="header" href="#refutabilidad-si-un-pattern-puede-fallar-al-hacer-match">Refutabilidad: Si un Pattern Puede Fallar al Hacer Match</a></h2>
<p>Los patterns se dividen en dos formas: refutables e irrefutables. Los patterns
que coinciden con cualquier valor posible son <em>irrefutables</em>. Un ejemplo sería
<code>x</code> en la declaración <code>let x = 5;</code> porque <code>x</code> coincide con cualquier cosa y,
por lo tanto, no puede fallar al hacer match. Los patterns que pueden fallar al
hacer match para algunos valores posibles son <em>refutables</em>. Un ejemplo sería
<code>Some(x)</code> en la expresión <code>if let Some(x) = a_value</code> porque si el valor en la
variable <code>a_value</code> es <code>None</code> en lugar de <code>Some</code>, el pattern <code>Some(x)</code> no
coincidirá.</p>
<p>Los parámetros de funciones, las declaraciones <code>let</code> y los bucles <code>for</code> solo
pueden aceptar patterns irrefutables, porque el programa no puede hacer nada
significativo cuando los valores no coinciden. Las expresiones <code>if let</code> y
<code>while let</code> aceptan patterns refutables e irrefutables, pero el compilador
advierte contra los patterns irrefutables porque, por definición, están
destinados a manejar posibles fallas: la funcionalidad de una condicional está
en su capacidad de realizar de manera diferente dependiendo del éxito o el
fracaso.</p>
<p>En general, no debería preocuparse por la distinción entre patterns refutables
e irrefutables; sin embargo, debe estar familiarizado con el concepto de
refutabilidad para poder responder cuando lo vea en un mensaje de error. En
esos casos, deberá cambiar el pattern o la construcción que está utilizando el
pattern, según el comportamiento previsto del código.</p>
<p>Veamos un ejemplo de lo que sucede cuando intentamos usar un pattern refutable
donde Rust requiere un pattern irrefutable y viceversa. El Listado 18-8 muestra
una declaración <code>let</code>, pero para el pattern hemos especificado <code>Some(x)</code>, un
pattern refutable. Como puede imaginar, este código no se compilará.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-8: Intentando utilizar un pattern refutable con
<code>let</code></span></p>
<p>Si <code>some_option_value</code> fuera un valor <code>None</code>, no coincidiría con el pattern
<code>Some(x)</code>, lo que significa que el pattern es refutable. Sin embargo, la 
declaración <code>let</code> solo puede aceptar un pattern irrefutable porque no hay nada
válido que el código pueda hacer con un valor <code>None</code>. En tiempo de compilación,
Rust se quejará de que hemos intentado usar un pattern refutable donde se
requiere un pattern irrefutable:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin &quot;patterns&quot;) due to 1 previous error
</code></pre>
<p>Debido a que no hemos cubierto (¡y no pudimos cubrir!) Cada valor válido con el
pattern <code>Some(x)</code>, Rust produce un error del compilador.</p>
<p>Si tenemos un pattern refutable donde se necesita un patrón irrefutable, 
podemos solucionarlo cambiando el código que utiliza el patrón: en lugar de 
usar <code>let</code>, podemos usar <code>if let</code>. Entonces, si el pattern no coincide, el 
código simplemente omitirá el código entre llaves, dándole una forma de 
continuar válidamente. El Listado 18-9 muestra cómo solucionar el código del 
Listado 18-8.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{x}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-9: Usando <code>if let</code> y un bloque con patterns 
refutables en lugar de <code>let</code></span></p>
<p>¡Le hemos dado una solución al código! Este código es perfectamente válido ahora.
Sin embargo, significa que no podemos usar un pattern irrefutable sin recibir un
error. Si le damos a <code>if let</code> un pattern que siempre coincidirá, como <code>x</code>, como
se muestra en el Listado 18-10, el compilador dará una advertencia.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{x}&quot;);
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-10: Intentando usar un pattern irrefutable
con <code>if let</code></span></p>
<p>Rust se queja de que no tiene sentido usar <code>if let</code> con un pattern 
irrefutable:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin &quot;patterns&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>Por esta razón, las opciones del match deben usar patterns refutables, excepto
por la última opción, que debe coincidir con cualquier valor restante con un
pattern irrefutable. Rust nos permite usar un pattern irrefutable en un <code>match</code>
con solo un brazo, pero esta sintaxis no es particularmente útil y podría
reemplazarse con una declaración <code>let</code> más simple.</p>
<p>Ahora que sabes dónde usar patterns y la diferencia entre patterns refutables e
irrefutables, cubramos toda la sintaxis que podemos usar para crear patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sintaxis-de-los-patterns"><a class="header" href="#sintaxis-de-los-patterns">Sintaxis de los Patterns</a></h2>
<p>En esta sección, reunimos toda la sintaxis válida en los patterns y discutimos
por qué y cuándo podría querer usar cada uno.</p>
<h3 id="coincidiendo-con-literales"><a class="header" href="#coincidiendo-con-literales">Coincidiendo con literales</a></h3>
<p>Como viste en el Capítulo 6, puedes hacer coincidir patterns contra literales
directamente. El siguiente código da algunos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Este código imprime <code>one</code> porque el valor en <code>x</code> es 1. Esta sintaxis es útil
cuando quieres que tu código tome una acción si obtiene un valor concreto
particular.</p>
<h3 id="coincidiendo-con-variables-nombradas"><a class="header" href="#coincidiendo-con-variables-nombradas">Coincidiendo con variables nombradas</a></h3>
<p>Las variables nombradas son patterns irrefutables que coinciden con cualquier
valor, y las hemos usado muchas veces en el libro. Sin embargo, hay una
complicación cuando usas variables nombradas en expresiones <code>match</code>. Debido a
que <code>match</code> inicia un nuevo alcance, las variables declaradas como parte de un
pattern dentro de la expresión <code>match</code> ocultarán aquellas con el mismo nombre
fuera del constructo <code>match</code>, como es el caso de todas las variables. En el
Listado 18-11, declaramos una variable llamada <code>x</code> con el valor <code>Some(5)</code> y una
variable <code>y</code> con el valor <code>10</code>. Luego creamos una expresión <code>match</code> en el valor
<code>x</code>. Mira los patterns en las opciones <code>match</code> y <code>println!</code> al final, e intenta
averiguar qué imprimirá el código antes de ejecutar este código o leer más.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {y}&quot;),
        _ =&gt; println!(&quot;Default case, x = {x:?}&quot;),
    }

    println!(&quot;at the end: x = {x:?}, y = {y}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-11: Una expresión <code>match</code> con una opción que
introduce una variable sombreada (shadowing) <code>y</code></span></p>
<p>Vamos a repasar lo que sucede cuando se ejecuta la expresión <code>match</code>. El pattern
en la primera opción de <code>match</code> no coincide con el valor definido de <code>x</code>, por
lo que el código continúa.</p>
<p>El pattern en la segunda opción de <code>match</code> introduce una nueva variable
llamada <code>y</code> que coincidirá con cualquier valor dentro de un valor <code>Some</code>.
Debido a que estamos en un nuevo scope dentro de la expresión <code>match</code>, esta
es una nueva variable <code>y</code>, no la que declaramos al principio con el valor 10.
Este nuevo enlace <code>y</code> coincidirá con cualquier valor dentro de un <code>Some</code>, que
es lo que tenemos en <code>x</code>. Por lo tanto, este nuevo <code>y</code> se vincula al valor
interno de <code>Some</code> en <code>x</code>. Ese valor es <code>5</code>, por lo que la expresión para esa
opción se ejecuta e imprime <code>Matched, y = 5</code>.</p>
<p>Si <code>x</code> hubiera sido un <code>None</code> en lugar de <code>Some(5)</code>, los patterns en las dos
primeras opciones no habrían coincidido, por lo que el valor habría coincidido
con el guion bajo. No introdujimos la variable <code>x</code> en el pattern de la opción
del guion bajo, por lo que el <code>x</code> en la expresión sigue siendo el <code>x</code> externo
que no ha sido sombreado. En este caso hipotético, el <code>match</code> imprimiría
<code>Default case, x = None</code>.</p>
<p>Cuando la expresión <code>match</code> termina, su scope termina, y también lo hace el
scope del <code>y</code> interno. El último <code>println!</code> produce <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Para crear una expresión <code>match</code> que compare los valores del <code>x</code> e <code>y</code> externos
en lugar de introducir una variable sombreada, necesitaríamos usar una
condición de guardia de <code>match</code>. Hablaremos de las guardias de <code>match</code> más
adelante en la sección <a href="ch18-03-pattern-syntax.html#condicionales-adicionales-con-match-guards">“Condicionales adicionales con <code>match</code> guards”</a><!-- ignore --></p>
<h3 id="múltiples-patterns"><a class="header" href="#múltiples-patterns">Múltiples Patterns</a></h3>
<p>En las expresiones <code>match</code>, puedes coincidir con múltiples patrones usando la
sintaxis <code>|</code>, que es el operador <em>or</em> del pattern. Por ejemplo, en el siguiente
código hacemos coincidir el valor de <code>x</code> con las opciones de <code>match</code>, el primero
de los cuales tiene una opción <em>or</em>, lo que significa que si el valor de <code>x</code>
coincide con cualquiera de los valores en esa opción, se ejecutará el código de
esa opción:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Este código imprime <code>one or two</code>.</p>
<h3 id="coincidiendo-con-rangos-de-valores-con-"><a class="header" href="#coincidiendo-con-rangos-de-valores-con-">Coincidiendo con rangos de valores con <code>..=</code></a></h3>
<p>La sintaxis <code>..=</code> nos permite emparejar un rango inclusivo de valores. En el
siguiente código, cuando un patrón coincide con cualquiera de los valores
dentro del rango dado, esa opción se ejecutará:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;one through five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Si <code>x</code> es 1, 2, 3, 4 o 5, la primera opción coincidirá. Esta sintaxis es más
conveniente para múltiples valores de coincidencia que usar el operador <code>|</code>
para expresar la misma idea; si usáramos <code>|</code> tendríamos que especificar <code>1 | 2 | 3 | 4 | 5</code>. Especificar un rango es mucho más corto, especialmente si
queremos coincidir, digamos, cualquier número entre 1 y 1.000.</p>
<p>El compilador verifica que el rango no esté vacío en tiempo de compilación, y
debido a que los únicos tipos para los que Rust puede decir si un rango está
vacío o no son los valores numéricos y <code>char</code>, los rangos solo están permitidos
con valores numéricos o <code>char</code>.</p>
<p>Aquí tienes un ejemplo que utiliza rangos de valores <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
        'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust puede determinar que <code>'c'</code> se encuentra dentro del rango especificado en
el primer pattern y se muestra por pantalla <code>early ASCII letter</code>.</p>
<h3 id="desestructurando-para-separar-valores"><a class="header" href="#desestructurando-para-separar-valores">Desestructurando para separar valores</a></h3>
<p>Podemos usar patterns para desestructurar structs, enums y tuplas para utilizar
diferentes partes de estos valores. Veamos cada uno de ellos.</p>
<h4 id="desestructurando-structs"><a class="header" href="#desestructurando-structs">Desestructurando Structs</a></h4>
<p>El Listado 18-12 muestra un struct <code>Point</code> con dos campos, <code>x</code> e <code>y</code>, que
podemos desestructurar usando un pattern con una declaración <code>let</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<p><span class="caption">Listing 18-12: Desestructurando los campos de un struct
en variables separadas</span></p>
<p>Este código crear las variables <code>a</code> y <code>b</code> que coinciden con los valores de los
campos <code>x</code> e <code>y</code> del struct <code>p</code>. Este ejemplo muestra que los nombres de las
variables en el pattern no tienen que coincidir con los nombres de los campos
del struct. Sin embargo, es común que los nombres de las variables coincidan
con los nombres de los campos para facilitar recordar qué variables provienen
de qué campos. Debido a este uso común, y porque escribir <code>let Point { x: x, y: y } = p;</code> contiene mucha duplicación, Rust tiene una abreviatura para los
patterns que coinciden con los campos de los structs: solo necesitas listar el
nombre del campo del struct, y las variables creadas a partir del pattern
tendrán los mismos nombres. El Listado 18-13 se comporta de la misma manera que
el código del Listado 18-12, pero las variables creadas en el pattern <code>let</code> son
<code>x</code> e <code>y</code> en lugar de <code>a</code> y <code>b</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<p><span class="caption">Listing 18-13: Desestructurando los campos de un struct
utilizando la forma abreviada de los campos struct</span></p>
<p>Este código crea las variables <code>x</code> e <code>y</code> que coinciden con los campos <code>x</code> e <code>y</code>
del struct <code>p</code>. El resultado es que las variables <code>x</code> e <code>y</code> contienen los
valores de los campos <code>x</code> e <code>y</code> del struct.</p>
<p>También podemos desestructurar y con valores literales como parte del pattern
del struct en lugar de crear variables para todos los campos. Hacerlo nos
permite probar algunos de los campos para valores particulares mientras
creamos variables para desestructurar los otros campos.</p>
<p>En el Listado 18-14, tenemos una expresión <code>match</code> que separa los valores de
<code>Point</code> en tres casos: puntos que se encuentran directamente en el eje <code>x</code> (lo
cual es cierto cuando <code>y = 0</code>), en el eje <code>y</code> (<code>x = 0</code>), o ninguno.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {x}&quot;),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {y}&quot;),
        Point { x, y } =&gt; {
            println!(&quot;On neither axis: ({x}, {y})&quot;);
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-14: Desestructurar y coincidir valores
literales en un solo pattern</span></p>
<p>El primer bloque coincidirá con cualquier punto que se encuentre en el eje <code>x</code>
especificando que el campo <code>y</code> debe coincidir con el valor <code>0</code>. El pattern aún
crea una variable <code>x</code> que podemos usar en el código de este bloque.</p>
<p>De manera similar, el segundo bloque coincide con cualquier punto en el eje <code>y</code>,
especificando que el campo <code>x</code> coincida si su valor es <code>0</code> y crea una variable
<code>y</code> para el valor del campo <code>y</code>. El tercer bloque no especifica literales, por
lo que coincide con cualquier otro <code>Point</code> y crea variables para ambos campos
<code>x</code> e <code>y</code>.</p>
<p>En este ejemplo, el valor <code>p</code> coincide con el segundo bloque debido a que <code>x</code>
contiene un <code>0</code>, por lo que este código imprimirá <code>On the y axis at 7</code>.</p>
<p>Recuerda que una expresión <code>match</code> detiene la verificación de los bloques una
vez que ha encontrado el primer patrón que coincide, por lo que, aunque <code>Point { x: 0, y: 0 }</code> está en el eje <code>x</code> y en el eje <code>y</code>, este código solo imprimirá
<code>On the x axis at 0</code>.</p>
<h4 id="desestructurando-enums"><a class="header" href="#desestructurando-enums">Desestructurando Enums</a></h4>
<p>Hemos desestructurado enums en este libro (por ejemplo, el Listado 6-5 en el
Capítulo 6), pero aún no hemos discutido explícitamente que el pattern para
desestructurar un enum corresponde a la forma en que se define los datos
almacenados dentro del enum. Como ejemplo, en el Listado 18-15 usamos el enum
<code>Message</code> del Listado 6-2 y escribimos un <code>match</code> con patterns que desestructuran
cada valor interno.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;);
        }
        Message::Move { x, y } =&gt; {
            println!(&quot;Move in the x direction {x} and in the y direction {y}&quot;);
        }
        Message::Write(text) =&gt; {
            println!(&quot;Text message: {text}&quot;);
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!(&quot;Change the color to red {r}, green {g}, and blue {b}&quot;)
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-15: Desestructurando variantes enum que
contienen diferentes tipos de valores</span></p>
<p>Este código imprimirá <code>Change the color to red 0, green 160, and blue 255</code>.
Prueba cambiar el valor de <code>msg</code> para ver el código de las otras opciones.</p>
<p>Para variantes de enum sin ningún dato, como <code>Message::Quit</code>, no podemos
desestructurar el valor más allá. Solo podemos coincidir con el valor literal
<code>Message::Quit</code>, y no hay variables en ese pattern.</p>
<p>Para variantes de enum similares a structs, como <code>Message::Move</code>, podemos
usar un pattern similar al que especificamos para coincidir con structs. Después
del nombre de la variante, colocamos llaves y luego enumeramos los campos con
variables para que desarmemos las piezas para usar en el código de esta opción.
Aquí usamos la forma abreviada como lo hicimos en el Listado 18-13.</p>
<p>Para variantes de enum similares a tuplas, como <code>Message::Write</code> que contiene
una tupla con un elemento y <code>Message::ChangeColor</code> que contiene una tupla con
tres elementos, el pattern es similar al pattern que especificamos para
coincidir con tuplas. El número de variables en el pattern debe coincidir con
el número de elementos en la variante que estamos coincidiendo.</p>
<h4 id="desestructurando-structs-y-enums-anidados"><a class="header" href="#desestructurando-structs-y-enums-anidados">Desestructurando Structs y Enums Anidados</a></h4>
<p>So far, our examples have all been matching structs or enums one level deep,
but matching can work on nested items too! For example, we can refactor the
code in Listing 18-15 to support RGB and HSV colors in the <code>ChangeColor</code>
message, as shown in Listing 18-16.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(&quot;Change color to red {r}, green {g}, and blue {b}&quot;);
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(&quot;Change color to hue {h}, saturation {s}, value {v}&quot;)
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-16: Matching on nested enums</span></p>
<p>El pattern de la primera opción en la expresión <code>match</code> coincide con la
variante de enum <code>Message::ChangeColor</code> que contiene una variante
<code>Color::Rgb</code>; luego el pattern se une a los tres valores internos <code>i32</code>. El
pattern de la segunda opción también coincide con una variante de enum
<code>Message::ChangeColor</code>, pero el enum interno coincide con <code>Color::Hsv</code> en su
lugar. Podemos especificar estas condiciones complejas en una expresión
<code>match</code>, incluso cuando están involucrados dos enums.</p>
<h4 id="desestructurando-structs-y-tuplas"><a class="header" href="#desestructurando-structs-y-tuplas">Desestructurando Structs y Tuplas</a></h4>
<p>Podemos mezclar, combinar y anidar los patrones de desestructuración de formas
aún más complejas. El siguiente ejemplo muestra una desestructuración
complicada donde anidamos structs y tuplas dentro de una tupla y
desestructuramos todos los valores primitivos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>Este código nos permite descomponer tipos complejos en sus partes componentes
para que podamos usar los valores que nos interesan por separado.</p>
<p>El uso de patrones para desestructurar es una forma conveniente de utilizar
partes de valores, como el valor de cada campo en un struct, por separado.</p>
<h3 id="ignorando-valores-en-un-patron"><a class="header" href="#ignorando-valores-en-un-patron">Ignorando valores en un patron</a></h3>
<p>Has visto que a veces es útil ignorar valores en un pattern, como en la última
opción de un <code>match</code>, para obtener una opción que no hace nada, pero que abarca
todos los posibles valores restantes. Hay varias formas de ignorar valores
completos o partes en un pattern: usando el pattern <code>_</code> (que has visto), usando
el pattern <code>_</code> dentro de otro pattern, usando un nombre que comienza con un
guion bajo y usando <code>..</code> para ignorar las partes restantes de un valor.
Exploraremos cómo y por qué usar cada uno de estos patterns.</p>
<h4 id="ignorando-un-valor-completo-con-_"><a class="header" href="#ignorando-un-valor-completo-con-_">Ignorando un Valor Completo con <code>_</code></a></h4>
<p>Hemos utilizado el guion bajo como un pattern comodín que coincide con
cualquier valor pero no se enlaza con él. Esto es especialmente útil como la
última opción en una expresión <code>match</code>, pero también podemos usarlo en
cualquier pattern, incluyendo los parámetros de una función, como se muestra en
el Listado 18-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {y}&quot;);
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<p><span class="caption">Listing 18-17: Utilizando <code>_</code> en la firma de una
función</span></p>
<p>Este código ignorará completamente el valor <code>3</code> pasado como primer argumento,
e imprimirá <code>This code only uses the y parameter: 4</code>.</p>
<p>En la mayoría de los casos, cuando ya no necesitas un parámetro de una función,
deberías cambiar la firma de la función para que no incluya el parámetro no
utilizado. Ignorar un parámetro de una función puede ser especialmente útil en
casos en los que, por ejemplo, estás implementando un trait cuando necesitas
una firma de tipo específico, pero el cuerpo de la función en tu implementación
no necesita uno de los parámetros. Luego evitas obtener una advertencia del
compilador sobre parámetros de función no utilizados, como lo harías si
utilizaras un nombre en su lugar.</p>
<h4 id="ignorando-partes-de-un-valor-con-un-_-anidado"><a class="header" href="#ignorando-partes-de-un-valor-con-un-_-anidado">Ignorando partes de un valor con un <code>_</code> anidado</a></h4>
<p>En este caso, el pattern <code>_</code> se utiliza dentro de otro pattern para ignorar
solo una parte del valor. Esto puede ser útil cuando queremos probar solo una
parte del valor, pero no tenemos uso para las otras partes en el código
correspondiente que queremos ejecutar. El Listado 18-18 muestra un código
encargado de gestionar el valor de una configuración. Los requisitos
son que el usuario no debe poder sobrescribir una personalización existente de
una configuración, pero puede eliminar la configuración y asignarle un valor si
actualmente no está establecida.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Can't overwrite an existing customized value&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;setting is {setting_value:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-18: Utilizando un guion bajo dentro de patterns
que coinciden con variantes <code>Some</code> cuando no necesitamos usar el valor dentro
del <code>Some</code></span></p>
<p>Este código imprimirá <code>setting is None</code> y luego <code>setting is Some(5)</code>. En la
primera opción de <code>match</code>, no necesitamos hacer coincidir ni usar los valores
dentro de ninguna de las variantes <code>Some</code>, pero si necesitamos comprobar en
el caso en el que tanto <code>setting_value</code> como <code>new_setting_value</code> son la
variante <code>Some</code>. En ese caso, imprimimos la razón por la que no cambiamos
<code>setting_value</code>, y no lo cambiamos.</p>
<p>En todos los demás casos (si <code>setting_value</code> o <code>new_setting_value</code> son <code>None</code>)
expresados por el pattern <code>_</code> en la segunda opción, queremos permitir que
<code>new_setting_value</code> se convierta en <code>setting_value</code>.</p>
<p>También podemos usar guiones bajos en múltiples lugares dentro de un solo
pattern para ignorar valores particulares. El Listado 18-19 muestra un ejemplo
de ignorar el segundo y cuarto valores en una tupla de cinco elementos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Some numbers: {first}, {third}, {fifth}&quot;)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-19: Ignorando múltiples partes de una tupla</span></p>
<p>Este código imprimirá <code>Some numbers: 2, 8, 32</code>, y los valores 4 y 16 serán
ignorados.</p>
<h4 id="ignorando-una-variable-no-utilizada-comenzando-su-nombre-con-_"><a class="header" href="#ignorando-una-variable-no-utilizada-comenzando-su-nombre-con-_">Ignorando una variable no utilizada comenzando su nombre con <code>_</code></a></h4>
<p>Si creas una variable, pero no la utilizas en ningún lugar, Rust generalmente
emitirá una advertencia porque una variable no utilizada podría causar un bug.
Sin embargo, a veces es útil poder crear una variable que aún no se utilizará,
como cuando estás prototipando o simplemente comenzando un proyecto. En esta
situación, puedes decirle a Rust que no te advierta sobre la variable no
utilizada comenzando el nombre de la variable con un guion bajo. En el Listado
18-20, creamos dos variables no utilizadas, pero cuando compilamos este código,
solo deberíamos obtener una advertencia sobre una de ellas.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<p><span class="caption">Listing 18-20: Comenzar el nombre de una variable con un
guion bajo para evitar recibir advertencias de variables no utilizadas</span></p>
<p>Aquí recibimos una advertencia sobre no utilizar la variable <code>y</code>, pero no
recibimos una advertencia sobre no utilizar <code>_x</code>.</p>
<p>Es importante destacar que hay una diferencia sutil entre usar solo <code>_</code> y usar
un nombre que comienza con un guion bajo. La sintaxis <code>_x</code> todavía enlaza el
valor a la variable, mientras que <code>_</code> no enlaza en absoluto. Para mostrar un
caso en el que esta distinción importa, el Listado 18-21 nos proporcionará un
error.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_s) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{s:?}&quot;);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-21: Una variable no utilizada que comienza con
un guion bajo aún vincula el valor, lo que puede tomar ownership del
valor</span></p>
<p>Recibiremos un error porque el valor de <code>s</code> se mueve a <code>_s</code>, lo que invalida
usar <code>s</code> nuevamente. Sin embargo, usar solo el guion bajo no vincula el valor
en ningún momento. El Listado 18-22 se compilará sin errores porque <code>s</code> no se
mueve a <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{s:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-22: Usar un guion bajo no vincula el
valor</span></p>
<p>Este código funciona bien porque nunca vinculamos <code>s</code> a nada; no se mueve.</p>
<h4 id="ignorando-las-partes-restantes-de-un-valor-con-"><a class="header" href="#ignorando-las-partes-restantes-de-un-valor-con-">Ignorando las partes restantes de un valor con <code>..</code></a></h4>
<p>Con los valores que tiene muchas partes, podemos usar la sintaxis <code>..</code> para
usar partes específicas e ignorar el resto, evitando la necesidad de enumerar
guiones bajos para cada valor ignorado. El pattern <code>..</code> ignora cualquier parte
de un valor que no hayamos coincidido explícitamente en el resto del pattern.
En el Listado 18-23, tenemos un struct <code>Point</code> que contiene una coordenada en
el espacio tridimensional. En la expresión <code>match</code>, queremos operar solo en la
coordenada <code>x</code> e ignorar los valores en los campos <code>y</code> y <code>z</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x is {x}&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-23: Ignorando todos los campos de un <code>Point</code>
excepto <code>x</code> mediante el uso de <code>..</code></span></p>
<p>Listamos el valor <code>x</code> y luego simplemente incluimos el pattern <code>..</code>. Esto es
más rápido que tener que listar <code>y: _</code> y <code>z: _</code>, particularmente cuando
estamos trabajando con structs que tienen muchos campos en situaciones en las
que solo uno o dos campos son relevantes.</p>
<p>La sintaxis <code>..</code> se expandirá a tantos valores como sea necesario. El Listado
18-24 muestra cómo usar <code>..</code> con una tupla.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {first}, {last}&quot;);
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-24: Coincidir solo con el primer y último
valor en una tupla e ignorar todos los demás valores</span></p>
<p>En este código, el primer y último valor se coinciden con <code>first</code> y <code>last</code>. El
<code>..</code> coincidirá con cualquier número de valores entre el primero y el último.</p>
<p>Sin embargo, el uso de <code>..</code> debe ser inequívoco. Si no está claro qué valores
deben coincidir y cuáles deben ignorarse, Rust nos dará un error. El Listado
18-25 muestra un ejemplo de usar <code>..</code> de manera ambigua, por lo que no se
compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {second}&quot;)
        },
    }
}</code></pre>
<p><span class="caption">Listing 18-25: Un intento de usar <code>..</code> de manera
ambigua</span></p>
<p>Cuando compilamos este ejemplo, obtenemos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin &quot;patterns&quot;) due to 1 previous error
</code></pre>
<p>Es imposible para Rust determinar cuántos valores en la tupla ignorar antes de
hacer coincidir un valor con <code>second</code> y luego cuántos valores más ignorar
después. Este código podría significar que queremos ignorar <code>2</code>, vincular
<code>second</code> a <code>4</code> y luego ignorar <code>8</code>, <code>16</code> y <code>32</code>; o que queremos ignorar <code>2</code> y
<code>4</code>, vincular <code>second</code> a <code>8</code> y luego ignorar <code>16</code> y <code>32</code>; y así sucesivamente.
El nombre de la variable <code>second</code> no significa nada especial para Rust, por lo
que obtenemos un error del compilador porque usar <code>..</code> en dos lugares como este
es ambiguo.</p>
<h3 id="condicionales-adicionales-con-match-guards"><a class="header" href="#condicionales-adicionales-con-match-guards">Condicionales adicionales con Match Guards</a></h3>
<p>Un <em>match guard</em> es una condición adicional <code>if</code>, especificada después del
pattern en una opción <code>match</code>, que también debe coincidir para que se elija
esa opción. Los match guards son útiles para expresar ideas más complejas que
las que permite un pattern solo.</p>
<p>La condición puede utilizar variables creadas en el pattern. El Listado 18-26
muestra un <code>match</code> donde la primera opción tiene el pattern <code>Some(x)</code> y también
tiene un match guard de <code>if x % 2 == 0</code> (que será verdadero si el número es
par).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;The number {x} is even&quot;),
        Some(x) =&gt; println!(&quot;The number {x} is odd&quot;),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-26: Agregando un match guard a un
pattern</span></p>
<p>Este ejemplo imprimirá <code>The number 4 is even</code>. Cuando <code>num</code> se compara con el
pattern en la primera opción, coincide, porque <code>Some(4)</code> coincide con <code>Some(x)</code>.
Luego, el match guard verifica si el resto de dividir <code>x</code> por 2 es igual a 0,
y porque lo es, se selecciona la primera opción.</p>
<p>Si <code>num</code> hubiera sido <code>Some(5)</code>, el match guard en la primera opción habría
sido falso porque el resto de 5 dividido por 2 es 1, que no es igual a 0. Rust
entonces pasaría a la segunda opción, que coincidiría porque la segunda opción
no tiene un match guard y, por lo tanto, coincide con cualquier variante <code>Some</code>.</p>
<p>No hay forma de expresar la condición <code>if x % 2 == 0</code> dentro de un pattern, por
lo que el match guard nos da la capacidad de expresar esta lógica. La
desventaja de esta expresividad adicional es que el compilador no intenta
verificar la exhaustividad cuando están involucradas las expresiones de match
guard.</p>
<p>En el Listado 18-11, mencionamos que podríamos usar match guards para resolver
nuestro problema de shadowing de pattern. Recordemos que creamos una nueva
variable dentro del pattern en la expresión <code>match</code> en lugar de usar la
variable fuera del <code>match</code>. Esa nueva variable significaba que no podíamos
probar contra el valor de la variable externa. El Listado 18-27 muestra cómo
podemos usar un match guard para solucionar este problema.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {n}&quot;),
        _ =&gt; println!(&quot;Default case, x = {x:?}&quot;),
    }

    println!(&quot;at the end: x = {x:?}, y = {y}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 18-27: Utilizando un match guard para probar
la igualdad con una variable externa</span></p>
<p>Este código imprimirá <code>Default case, x = Some(5)</code>. El pattern en la segunda
opción no introduce una nueva variable <code>y</code> que sombree la variable externa <code>y</code>,
por lo que podemos usar la variable externa <code>y</code> en el match guard. En lugar de
especificar el pattern como <code>Some(y)</code>, que habría sombreado la variable externa
<code>y</code>, especificamos <code>Some(n)</code>. Esto crea una nueva variable <code>n</code> que no sombrea
nada porque no hay una variable <code>n</code> fuera del <code>match</code>.</p>
<p>El match guard <code>if n == y</code> no es un pattern y, por lo tanto, no introduce nuevas
variables. Este <code>y</code> <em>es</em> el <code>y</code> externo en lugar de un nuevo <code>y</code> sombreado, y
podemos buscar un valor que tenga el mismo valor que el <code>y</code> externo comparando
<code>n</code> con <code>y</code>.</p>
<p>También puedes usar el operador <em>or</em> <code>|</code> en un match guard para especificar
múltiples patterns; la condición del match guard se aplicará a todos los
patterns. El Listado 18-28 muestra la precedencia al combinar un pattern que
usa <code>|</code> con un match guard. La parte importante de este ejemplo es que el
match guard <code>if y</code> se aplica a <code>4</code>, <code>5</code> y <em>6</em>, aunque podría parecer que <code>if y</code>
solo se aplica a <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-28: Combinando múltiples patterns con un match
guard</span></p>
<p>La condición de match establece que la opción solo coincide si el valor de <code>x</code>
es igual a <code>4</code>, <code>5</code> o <code>6</code> <em>y</em> si <code>y</code> es <code>true</code>. Cuando se ejecuta este código,
el pattern de la primera opción coincide porque <code>x</code> es <code>4</code>, pero el match guard
<code>if y</code> es falso, por lo que no se elige la primera opción. El código pasa a la
segunda opción, que coincide, y este programa imprime <code>no</code>. La razón es que la
condición <code>if</code> se aplica a todo el pattern <code>4 | 5 | 6</code>, no solo al último valor
<code>6</code>. En otras palabras, la precedencia de un match guard en relación con un
pattern se comporta así:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>en lugar de esto:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Después de ejecutar el código, el comportamiento de precedencia es evidente: si
el match guard se aplicara solo al último valor en la lista de valores
especificados usando el operador <code>|</code>, la opción habría coincidido y el programa
habría impreso <code>yes</code>.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>El operador <code>@</code>, conocido como <em>at</em>, nos permite crear una variable que almacena
un valor al mismo tiempo que lo comprobamos para una coincidencia de pattern.
En el Listado 18-29, queremos probar que el campo <code>id</code> de un <code>Message::Hello</code>
está dentro del rango <code>3..=7</code>. También queremos vincular el valor a la variable
<code>id_variable</code> para poder usarlo en el código asociado con la opción. Podríamos
nombrar esta variable <code>id</code>, igual que el campo, pero para este ejemplo usaremos
un nombre diferente.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Found an id in range: {id_variable}&quot;),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {id}&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-29: Usando <code>@</code> para enlazar un valor en un
pattern mientras también lo testeamos</span></p>
<p>Este ejemplo imprimirá <code>Found an id in range: 5</code>. Al especificar <code>id_variable  @</code> antes del rango <code>3..=7</code>, estamos capturando cualquier valor que coincida con
el rango mientras también probamos que el valor coincidió con el pattern de
rango.</p>
<p>En la segunda opción, donde solo tenemos especificado un rango en el patrón,
el código asociado a la opción no tiene una variable que contenga el valor real
del campo <code>id</code>. El campo <code>id</code> podría haber sido <code>10</code>, <code>11</code> o <code>12</code>, pero el
código asociado al pattern no sabe cuál es. El código del pattern no puede usar
el valor del campo <code>id</code> porque no hemos guardado el valor <code>id</code> en una variable.</p>
<p>En la última opción, donde hemos especificado una variable sin un rango, sí
tenemos el valor disponible para usar en el código de la opción en una variable
llamada <code>id</code>. La razón es que hemos usado la sintaxis de campo de struct
shorthand. Pero no hemos aplicado ninguna prueba al valor en el campo <code>id</code> en
esta opción, como hicimos con las dos primeras opciones: cualquier valor
coincidiría con este pattern.</p>
<p>Usar <code>@</code> nos permite probar un valor y guardarlo en una variable dentro de un
mismo pattern.</p>
<h2 id="resumen-17"><a class="header" href="#resumen-17">Resumen</a></h2>
<p>Los patterns en Rust son muy útiles para distinguir entre diferentes tipos de
datos. Cuando se usan en expresiones <code>match</code>, Rust garantiza que tus patterns
cubran todos los valores posibles, o tu programa no se compilará. Los patterns
en las declaraciones <code>let</code> y en los parámetros de las funciones hacen que esos
constructos sean más útiles, permitiendo la deconstrucción de valores en partes
más pequeñas al mismo tiempo que se asignan a variables. Podemos crear patterns
simples o complejos para adaptarse a nuestras necesidades.</p>
<p>A continuación, para el penúltimo capítulo del libro, exploraremos algunos
aspectos avanzados de varias características de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="características-avanzadas"><a class="header" href="#características-avanzadas">Características Avanzadas</a></h1>
<p>Por ahora, has aprendido las partes más comúnmente usadas del lenguaje de
programación Rust. Antes de hacer otro proyecto en el Capítulo 20, veremos
algunos aspectos del lenguaje que podrías encontrar de vez en cuando, pero
que no usarás todos los días. Puede usar este capítulo como referencia para
cuando encuentre algo desconocido. Las características cubiertas aquí son
útiles en situaciones muy específicas. Aunque es posible que no alcances
a menudo, queremos asegurarnos de que tengas un dominio de todas las
características que Rust tiene para ofrecer.</p>
<p>En este capítulo, cubriremos:</p>
<ul>
<li>Unsafe Rust: cómo optar por algunas de las garantías de Rust y asumir la
responsabilidad de mantener manualmente esas garantías</li>
<li>Traits avanzados: tipos asociados, parámetros de tipo predeterminados,
sintaxis completamente calificada, supertraits y el patrón newtype en
relación con los traits</li>
<li>Tipos avanzados: más sobre el pattern newtype, tipo alias, el tipo never y
tipos de tamaño dinámico</li>
<li>Funciones y closures avanzados: punteros a funciones y devolución de
closures</li>
<li>Macros: formas de definir código que define más código en tiempo de
compilación</li>
</ul>
<p>¡Es una panoplia de características de Rust con algo para todos! ¡Vamos a
sumergirnos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<p>Todo el código que hemos discutido hasta ahora ha tenido las garantías de
seguridad de memoria de Rust aplicadas en tiempo de compilación. Sin embargo,
Rust tiene un segundo lenguaje oculto dentro de él que no hace cumplir estas
garantías de seguridad de memoria: se llama <em>unsafe Rust</em> y funciona como
Rust regular, pero nos da superpoderes adicionales.</p>
<p>Unsafe Rust existe porque, por naturaleza, el análisis estático es
conservador. Cuando el compilador intenta determinar si el código cumple o no
con las garantías, es mejor que rechace algunos programas válidos que aceptar
algunos programas no válidos. Aunque el código <em>podría</em> estar bien, si el
compilador de Rust no tiene suficiente información para estar seguro, rechazará
el código. En estos casos, puede usar código inseguro para decirle al
compilador: &quot;Confía en mí, sé lo que estoy haciendo&quot;. Sin embargo, debes tener
cuidado, ya que el uso de Unsafe Rust conlleva riesgos: si usas código inseguro
de manera incorrecta, pueden ocurrir problemas debido a la inseguridad de la
memoria, como la desreferenciación de puntero nulo.</p>
<p>Otra razón por la que Rust tiene un alter ego inseguro es que el hardware
informático subyacente es inherentemente inseguro. Si Rust no le permitiera
realizar operaciones inseguras, no podría realizar ciertas tareas. Rust
necesita permitirle realizar programación de sistemas de bajo nivel, como
interactuar directamente con el sistema operativo o incluso escribir su propio
sistema operativo. Trabajar con programación de sistemas de bajo nivel es uno
de los objetivos del lenguaje. Veamos qué podemos hacer con Rust inseguro y
cómo hacerlo.</p>
<h3 id="superpoderes-unsafe"><a class="header" href="#superpoderes-unsafe">Superpoderes Unsafe</a></h3>
<p>Para cambiar a Unsafe Rust, use la palabra clave <code>unsafe</code> y luego comience un
nuevo bloque que contenga el código inseguro. Puede tomar cinco acciones en
Rust inseguro que no puede en Rust seguro, que llamamos <em>superpoderes
Unsafe</em>. Esos superpoderes incluyen la capacidad de:</p>
<ul>
<li>Desreferenciar un puntero crudo</li>
<li>Llamar a una función o método inseguro</li>
<li>Acceder o modificar una variable estática mutable</li>
<li>Implementar un trait inseguro</li>
<li>Acceder a los campos de un <code>union</code></li>
</ul>
<p>Es importante entender que <code>unsafe</code> no desactiva el borrow checker ni
deshabilita ninguna otra de las comprobaciones de seguridad de Rust: si usa una
referencia en código inseguro, aún se verificará. La palabra clave <code>unsafe</code>
solo le da acceso a estas cinco funciones que luego no son verificadas por el
compilador para la seguridad de la memoria. Aún obtendrá cierto grado de
seguridad dentro de un bloque inseguro.</p>
<p>Además, <code>unsafe</code> no significa que el código dentro del bloque sea
necesariamente peligroso o que definitivamente tendrá problemas de seguridad de
memoria: la intención es que, como programador, se asegurará de que el código
dentro de un bloque <code>unsafe</code> acceda a la memoria de una manera válida.</p>
<p>Las personas son falibles y pueden cometer errores, pero al requerir que estas
cinco operaciones inseguras estén dentro de bloques anotados con <code>unsafe</code>,
sabrá que cualquier error relacionado con la seguridad de la memoria debe estar
dentro de un bloque <code>unsafe</code>. Mantenga los bloques <code>unsafe</code> pequeños; lo
agradecerá más tarde cuando investigue bugs de memoria.</p>
<p>Para aislar el código inseguro tanto como sea posible, es mejor encerrar el
código inseguro dentro de una abstracción segura y proporcionar una API segura,
que discutiremos más adelante en el capítulo cuando examinemos las funciones y
métodos inseguros. Partes de la biblioteca estándar se implementan como
abstracciones seguras sobre código inseguro que ha sido auditado. Envolver el
código inseguro en una abstracción segura evita que los usos de <code>unsafe</code> se
filtren en todos los lugares que usted o sus usuarios puedan querer usar la
funcionalidad implementada con código <code>unsafe</code>, porque usar una abstracción
segura es seguro.</p>
<p>Veamos cada uno de los cinco superpoderes unsafe a su vez. También
veremos algunas abstracciones que proporcionan una interfaz segura al código
inseguro.</p>
<h3 id="desreferenciación-de-un-puntero-crudo"><a class="header" href="#desreferenciación-de-un-puntero-crudo">Desreferenciación de un puntero crudo</a></h3>
<p>En el Capítulo 4, en la sección <a href="ch04-02-references-and-borrowing.html#referencias-colgantes"><code>Referencias y punteros</code></a></p>
<!-- ignore--> mencionamos que el compilador garantiza que las referencias siempre son válidas.
<p>Unsafe Rust tiene dos nuevos tipos llamados <em>punteros crudos</em> que son similares
a las referencias. Al igual que con las referencias, los punteros crudos pueden
ser inmutables o mutables y
se escriben como <code>*const T</code> y <code>*mut T</code>, respectivamente. El asterisco no es el
operador de desreferencia; es parte del nombre del tipo. En el contexto de los
punteros crudos, <em>inmutable</em> significa que el puntero no se puede asignar
directamente después de ser desreferenciado.</p>
<p>A Diferencia de las referencias y los smart pointers, los punteros crudos:</p>
<ul>
<li>Son permitidos ignorar las reglas de borrowing al tener tanto punteros
inmutables como mutables o múltiples punteros mutables al mismo lugar</li>
<li>No se garantiza que apunten a una memoria válida</li>
<li>Se les permite ser nulos</li>
<li>No implementan ninguna limpieza automática</li>
</ul>
<p>Al optar por no hacer que Rust haga cumplir estas garantías, puede renunciar a
la seguridad garantizada a cambio de un mayor rendimiento o la capacidad de
interactuar con otro lenguaje o hardware donde las garantías de Rust no se
aplican.</p>
<p>El Listing 19-1 muestra cómo crear un puntero crudo inmutable y mutable a
partir de referencias.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-1: Creando punteros crudos a partir de
referencias</span></p>
<p>Observa que no incluimos la palabra clave <code>unsafe</code> en este código. Podemos
crear punteros crudos en código seguro; simplemente no podemos desreferenciar
punteros crudos fuera de un bloque <code>unsafe</code>, como verás en un momento.</p>
<p>Hemos creado punteros crudos utilizando <code>as</code> para convertir una referencia
inmutable y una mutable en sus tipos de puntero crudo correspondientes. Como
los creamos directamente a partir de referencias garantizadas como válidas,
sabemos que estos punteros crudos particulares son válidos, pero no podemos
hacer esa suposición sobre cualquier puntero crudo.</p>
<p>Para demostrar esto, a continuación crearemos un puntero crudo cuya validez
no podemos estar tan seguros. El Listado 19-2 muestra cómo crear un puntero
crudo a una ubicación arbitraria en la memoria. Intentar usar memoria arbitraria
es indefinido: puede haber datos en esa dirección o no, el compilador puede
optimizar el código para que no haya acceso a la memoria, o el programa puede
generar un error con un fallo de segmentación. Por lo general, no hay una buena
razón para escribir código como este, pero es posible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-2: Creando un puntero crudo a una dirección de
memoria arbitraria</span></p>
<p>Recuerda que podemos crear punteros crudos en código seguro, pero no podemos
<em>desreferenciar</em> punteros crudos y leer la memoria a la que apuntan fuera de un
bloque <code>unsafe</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        println!(&quot;r2 is: {}&quot;, *r2);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-3: Desreferenciando punteros crudos dentro de
un bloque <code>unsafe</code></span></p>
<p>Crear un puntero no causa daño; solo cuando intentamos acceder al valor al que
apunta que podríamos terminar tratando con un valor no válido.</p>
<p>También ten en cuenta que en los Listados 19-1 y 19-3, creamos <code>*const i32</code> y
<code>*mut i32</code> punteros crudos que apuntaban a la misma ubicación de memoria, donde
se almacena <code>num</code>. Si en su lugar intentáramos crear una referencia inmutable y
mutable a <code>num</code>, el código no se compilaría porque las reglas de ownership de
Rust no permiten una referencia mutable al mismo tiempo que cualquier referencia
inmutable. Con punteros crudos, podemos crear un puntero mutable y un puntero
inmutable a la misma ubicación y cambiar los datos a través del puntero mutable,
potencialmente creando una carrera de datos. ¡Ten cuidado!</p>
<p>Con todos estos peligros, ¿por qué usarías punteros crudos? Un caso de uso
importante es cuando se interactúa con código C, como verás en la siguiente
sección, <a href="ch19-01-unsafe-rust.html#llamando-a-una-funcion-o-metodo-inseguro">“Llamando a una función o método
inseguro”</a>.<!-- ignore --> Otro caso es
cuando se construyen abstracciones seguras que el borrow checker no entiende.
Presentaremos funciones inseguras y luego veremos un ejemplo de una abstracción
segura que usa código inseguro.</p>
<h3 id="llamando-a-una-funcion-o-metodo-inseguro"><a class="header" href="#llamando-a-una-funcion-o-metodo-inseguro">Llamando a una funcion o metodo inseguro</a></h3>
<p>El segundo tipo de operación que solo se puede realizar en un bloque unsafe es
llamar a una función o método inseguro. Podemos crear funciones inseguras y
métodos inseguros que se ven exactamente como funciones y métodos regulares,
pero tienen un <code>unsafe</code> adicional antes del resto de la definición. La palabra
clave <code>unsafe</code> en este contexto indica que la función tiene requisitos que
debemos cumplir cuando llamamos a esta función porque Rust no puede garantizar
que hayamos cumplido con estos requisitos. Al llamar a una función insegura
dentro de un bloque <code>unsafe</code>, estamos diciendo que hemos leído la documentación
de esta función y asumimos la responsabilidad de cumplir con los contratos de
la función.</p>
<p>Aquí hay un ejemplo de una función insegura llamada <code>dangerous</code> que no hace
nada en su cuerpo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>Debemos llamar a la función <code>dangerous</code> dentro de un bloque <code>unsafe</code> separado.
Si intentamos llamar a esta función sin un bloque <code>unsafe</code>, obtendremos un<br />
error:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin &quot;unsafe-example&quot;) due to 1 previous error
</code></pre>
<p>Con el bloque <code>unsafe</code>, le estamos indicando a Rust que hemos leído la
documentación de la función, entendemos cómo usarla correctamente y hemos
verificado que estamos cumpliendo con el contrato de la función.</p>
<p>Los cuerpos de las funciones <code>unsafe</code> son similares a los bloques <code>unsafe</code>,
por lo que para realizar otras operaciones <code>unsafe</code> dentro de una función
<code>unsafe</code>, no necesitamos agregar otro bloque <code>unsafe</code>.</p>
<h4 id="creando-una-abstracción-segura-sobre-código-inseguro"><a class="header" href="#creando-una-abstracción-segura-sobre-código-inseguro">Creando una abstracción segura sobre código inseguro</a></h4>
<p>Solo porque una función contiene código inseguro no significa que debamos
marcar toda la función como insegura. De hecho, envolver el código inseguro en
una función segura es una abstracción común. Como ejemplo, estudiemos la
función <code>split_at_mut</code> de la biblioteca estándar, que requiere algo de código
inseguro. Exploraremos cómo podríamos implementarlo. Este método seguro está
definido en slices mutables: toma un slice y lo divide en dos al dividir
el slice en el índice dado como argumento. El Listado 19-4 muestra cómo usar
<code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-4: Usando la función segura
<code>split_at_mut</code></span></p>
<p>No podemos implementar esta función utilizando solo Rust seguro. Un intento
podría ser algo como el Listado 19-5, que no se compilará. Para simplificar,
implementaremos <code>split_at_mut</code> como una función en lugar de un método y solo
para slices de valores <code>i32</code> en lugar de para un tipo genérico <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 19-5: Un intento de implementación de
<code>split_at_mut</code> usando solo Rust seguro</span></p>
<p>Esta función primero obtiene la longitud total del slice. Luego verifica si el
índice dado como parámetro está dentro del slice al verificar si es menor o
igual a la longitud. La aserción significa que si pasamos un índice que es
mayor que la longitud para dividir el slice, la función entrará en panic
antes de intentar usar ese índice.</p>
<p>Luego, devolvemos dos slices mutables en una tupla: uno desde el inicio del
slice original hasta el índice <code>mid</code> y otro desde <code>mid</code> hasta el final del
slice.</p>
<p>Cuando intentamos compilar el código en el Listado 19-5, obtendremos un error:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin &quot;unsafe-example&quot;) due to 1 previous error
</code></pre>
<p>El borrow checker de Rust no puede entender que estamos tomando prestado
diferentes partes del slice; solo sabe que estamos tomando prestado el mismo
slice dos veces. Tomar prestadas diferentes partes de un slice es
fundamentalmente correcto porque los dos slices no se superponen, pero Rust no
es lo suficientemente inteligente como para saber esto. Cuando sabemos que el
código está bien, pero Rust no lo sabe, es hora de recurrir al código inseguro.</p>
<p>El Listado 19-6 muestra cómo usar un bloque <code>unsafe</code>, un puntero sin procesar
y algunas llamadas a funciones inseguras para hacer que la implementación de
<code>split_at_mut</code> funcione.</p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-6: Usando código inseguro en la implementación
de la función <code>split_at_mut</code></span></p>
<p>Recordemos la sección <a href="ch04-03-slices.html#el-tipo-slice">“The Slice Type”</a><!-- ignore --> del
Capítulo 4 que los slices son un puntero a algunos datos y la longitud del
slice. Usamos el método <code>len</code> para obtener la longitud del slice y el método
<code>as_mut_ptr</code> para acceder al puntero sin procesar de un slice. En este caso,
porque tenemos un slice mutable a valores <code>i32</code>, <code>as_mut_ptr</code> devuelve un
puntero sin procesar con el tipo <code>*mut i32</code>, que hemos almacenado en la
variable <code>ptr</code>.</p>
<p>Mantenemos la afirmación de que el índice <code>mid</code> está dentro del slice. Luego
llegamos al código inseguro: la función <code>slice::from_raw_parts_mut</code> toma un
puntero sin procesar y una longitud, y crea un slice. Usamos esta función para
crear un slice que comienza desde <code>ptr</code> y es <code>mid</code> elementos de largo. Luego
llamamos al método <code>add</code> en <code>ptr</code> con <code>mid</code> como argumento para obtener un
puntero sin procesar que comienza en <code>mid</code>, y creamos un slice usando ese
puntero y el número restante de elementos después de <code>mid</code> como la longitud.</p>
<p>La función <code>slice::from_raw_parts_mut</code> es insegura porque toma un puntero sin
procesar y debe confiar en que este puntero es válido. El método <code>add</code> en
punteros sin procesar también es inseguro porque debe confiar en que la
ubicación del desplazamiento también es un puntero válido. Por lo tanto,
tuvimos que poner un bloque <code>unsafe</code> alrededor de nuestras llamadas a
<code>slice::from_raw_parts_mut</code> y <code>add</code> para poder llamarlas. Al mirar el código y
al agregar la afirmación de que <code>mid</code> debe ser menor o igual a <code>len</code>, podemos
decir que todos los punteros sin procesar utilizados dentro del bloque
<code>unsafe</code> serán punteros válidos a datos dentro del slice. Este es un uso
aceptable y apropiado de <code>unsafe</code>.</p>
<p>Tenga en cuenta que no necesitamos marcar la función resultante <code>split_at_mut</code>
como <code>unsafe</code>, y podemos llamar a esta función desde Rust seguro. Hemos creado
una abstracción segura para el código inseguro con una implementación de la
función que usa código <code>unsafe</code> de manera segura, porque crea solo punteros
válidos a partir de los datos a los que esta función tiene acceso.</p>
<p>Por el contrario, el uso de <code>slice::from_raw_parts_mut</code> en el Listado 19-7
probablemente se bloqueará cuando se use el slice. Este código toma una
ubicación de memoria arbitraria y crea un slice de 10,000 elementos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-7: Creando un slice a partir de una ubicación
de memory arbitraria</span></p>
<p>No somos propietarios de la memoria en esta ubicación arbitraria, y no hay
garantía de que el slice que este código crea contenga valores <code>i32</code> válidos.
Intentar usar <code>values</code> como si fuera un slice válido da como resultado un
comportamiento indefinido.</p>
<h4 id="usando-funciones-extern-para-llamar-código-externo"><a class="header" href="#usando-funciones-extern-para-llamar-código-externo">Usando funciones <code>extern</code> para llamar código externo</a></h4>
<p>A veces, tu código en Rust necesita interactuar con código escrito en otro
lenguaje. Para esto, Rust tiene la palabra clave <code>extern</code> que facilita la
creación y el uso de una <em>Foreign Function Interface (FFI)</em>. Una FFI es una
forma para que un lenguaje de programación defina funciones y permita que un
lenguaje de programación diferente (extranjero) llame a esas funciones.</p>
<p>El Listado 19-8 demuestra cómo configurar una integración con la función <code>abs</code>
de la biblioteca estándar de C. Las funciones declaradas dentro de bloques
<code>extern</code> siempre son inseguras de llamar desde el código Rust. La razón es que
otros lenguajes no hacen cumplir las reglas y garantías de Rust, y Rust no
puede verificarlas, por lo que la responsabilidad recae en el programador para
garantizar la seguridad.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}</code></pre></pre>
<p><span class="caption">Listing 19-8: Declarando y llamando a una función <code>extern</code>
definida en otro lenguaje</span></p>
<p>Dentro del bloque <code>extern &quot;C&quot;</code> en el Listado 19-8, enumeramos los nombres y
las firmas de las funciones externas que queremos llamar. El nombre y la firma
de la función <code>abs</code> se definen en el estándar C y son parte de la biblioteca
estándar de C. La firma de la función <code>abs</code> es <code>int abs(int)</code>, lo que significa
que toma un argumento <code>int</code> y devuelve un <code>int</code>. La función <code>abs</code> devuelve el
valor absoluto de su argumento.</p>
<blockquote>
<h4 id="llamando-a-funciones-rust-desde-otros-lenguajes"><a class="header" href="#llamando-a-funciones-rust-desde-otros-lenguajes">Llamando a funciones Rust desde otros lenguajes</a></h4>
<p>También podemos usar <code>extern</code> para crear una interfaz que permita que otros
lenguajes llamen funciones Rust. En lugar de crear un bloque <code>extern</code>, podemos
agregar la palabra clave <code>extern</code> y especificar la ABI a usar justo antes de
la palabra clave <code>fn</code> para la función relevante. También necesitamos agregar
una anotación <code>#[no_mangle]</code> para decirle al compilador de Rust que no
cambie el nombre de esta función. <em>Mangling</em> es cuando un compilador cambia
el nombre que le hemos dado a una función a un nombre diferente que contiene
más información para otras partes del proceso de compilación para consumir,
, pero es menos legible para los humanos. Cada compilador de lenguaje de
programación mangla los nombres de manera ligeramente diferente, por lo que
para que una función Rust sea nombrable por otros lenguajes, debemos
deshabilitar el mangling del compilador de Rust.</p>
<p>En el siguiente ejemplo, hacemos que la función <code>call_from_c</code> sea accesible
desde el código C, después de que se compile a una biblioteca compartida y
se vincule desde C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Este uso de <code>extern</code> no requiere <code>unsafe</code>.</p>
</blockquote>
<h3 id="acceder-o-modificar-una-variable-estática-mutable"><a class="header" href="#acceder-o-modificar-una-variable-estática-mutable">Acceder o modificar una variable estática mutable</a></h3>
<p>En este libro, aún no hemos hablado de <em>variables globales</em>, las cuales Rust
admite, pero pueden ser problemáticas con las reglas de ownership de Rust. Si
dos hilos acceden a la misma variable global mutable, puede causar una
condición de carrera.</p>
<p>En Rust, las variables globales son llamadas variables <em>static</em>. El Listado
19-9 muestra un ejemplo de declaración y uso de una variable static con un
string slice como valor.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {HELLO_WORLD}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 19-9: Definición y uso de una variable static
inmutable</span></p>
<p>Las static variables son similares a las constantes, que discutimos en la
sección <a href="ch03-01-variables-and-mutability.html#constantes">&quot;Diferencias entre variables y
constantes&quot;</a> en el Capítulo 3. Los
nombres de las variables static están en <code>SCREAMING_SNAKE_CASE</code> por convención.
Las variables static solo pueden almacenar referencias con el lifetime
<code>'static</code>, lo que significa que el compilador de Rust puede calcular el
lifetime y no estamos obligados a anotarlo explícitamente. Acceder a una
variable static inmutable es seguro.</p>
<p>Una diferencia sutil entre constantes y variables static inmutables es que los
valores en una variable static tienen una dirección fija en la memoria. Usar el
valor siempre accederá a los mismos datos. Las constantes, por otro lado,
pueden duplicar sus datos cada vez que se usan. Otra diferencia es que las
variables static pueden ser mutables. Acceder y modificar variables static
mutables es <em>inseguro</em>. El Listado 19-10 muestra cómo declarar, acceder y
modificar una variable static mutable llamada <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {COUNTER}&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listing 19-10: Leer o escribir en una variable static
mutable es inseguro</span></p>
<p>Como con las variables regulares, especificamos la mutabilidad usando la
palabra clave <code>mut</code>. Cualquier código que lea o escriba desde <code>COUNTER</code> debe
estar dentro de un bloque <code>unsafe</code>. Este código se compila e imprime <code>COUNTER: 3</code> como esperaríamos porque es de un solo hilo. Tener múltiples hilos accediendo
a <code>COUNTER</code>, probablemente habría condiciones de carrera.</p>
<p>Con datos mutables que son accesibles globalmente, es difícil asegurarse de que
no haya carreras de datos, por lo que Rust considera que las variables static
mutables son inseguras. Cuando sea posible, es preferible usar las técnicas de
concurrencia y los smart pointers seguros para los hilos que discutimos en el
Capítulo 16, para que el compilador verifique que los datos a los que se accede
desde diferentes hilos se hagan de manera segura.</p>
<h3 id="implementando-un-trait-inseguro"><a class="header" href="#implementando-un-trait-inseguro">Implementando un trait inseguro</a></h3>
<p>Podemos usar <code>unsafe</code> para implementar un trait inseguro. Un trait se considera
inseguro cuando al menos uno de sus métodos tiene algún invariante que el
compilador no puede verificar. Declaramos que un trait es <code>unsafe</code> agregando la
palabra clave <code>unsafe</code> antes de <code>trait</code> y marcando la implementación del trait
como <code>unsafe</code> también, como se muestra en el Listado 19-11.</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}</code></pre></pre>
<p><span class="caption">Listing 19-11: Definiendo e implementando un trait
inseguro</span></p>
<p>Al utilizar <code>unsafe impl</code>, estamos prometiendo que mantendremos las invariantes
que el compilador no puede verificar.</p>
<p>Como ejemplo, recordemos los marcadores de traits <code>Sync</code> y <code>Send</code> que
discutimos en la sección <a href="ch16-04-extensible-concurrency-sync-and-send.html#concurrencia-extensible-con-los-traits-sync-y-send">&quot;Concurrencia extensible con los traits <code>Sync</code> y
<code>Send</code>&quot;</a> en el Capítulo
16: el compilador implementa estos traits automáticamente si nuestros tipos se
componen únicamente de tipos <code>Send</code> y <code>Sync</code>. Si implementamos un tipo que
contiene un tipo que no es <code>Send</code> o <code>Sync</code>, como punteros crudos, y queremos
marcar ese tipo como <code>Send</code> o <code>Sync</code>, debemos usar <code>unsafe</code>. Rust no puede
verificar que nuestro tipo cumpla con las garantías de que se puede enviar
seguramente a través de hilos o acceder desde múltiples hilos; por lo tanto,
debemos hacer esas comprobaciones manualmente e indicarlo con <code>unsafe</code>.</p>
<h3 id="acceder-a-los-campos-de-una-union"><a class="header" href="#acceder-a-los-campos-de-una-union">Acceder a los campos de una union</a></h3>
<p>La última acción que solo se puede realizar con <code>unsafe</code> es acceder a los
campos de una <em>union</em>. Una <code>union</code> es similar a una <code>struct</code>, pero solo un
campo declarado se usa en una instancia particular en un momento dado. Las
unions se usan principalmente para interactuar con unions en código C. Acceder
a los campos de la union es inseguro porque Rust no puede garantizar el tipo de
los datos que se almacenan actualmente en la instancia de la union. Puedes
aprender más sobre las uniones en <a href="https://doc.rust-lang.org/reference/items/unions.html">la Referencia de Rust</a>.</p>
<h3 id="cuándo-usar-código-inseguro"><a class="header" href="#cuándo-usar-código-inseguro">Cuándo usar código inseguro</a></h3>
<p>Utilizar <code>unsafe</code> para llevar a cabo una de las cinco acciones (superpoderes)
que se acaban de mencionar no está mal ni se desaconseja. Sin embargo, es más
difícil obtener código <code>unsafe</code> correcto porque el compilador no puede ayudar a
mantener la seguridad de la memoria. Cuando tengas una razón para usar código
<code>unsafe</code>, puedes hacerlo, y tener la anotación <code>unsafe</code> explícita hace que sea
más fácil rastrear la fuente de los problemas cuando ocurren.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="traits-avanzados"><a class="header" href="#traits-avanzados">Traits Avanzados</a></h2>
<p>Primero cubrimos los traits en la sección <a href="ch10-02-traits.html#traits-definiendo-comportamiento-compartido">&quot;Traits: Defining Shared
Behavior&quot;</a><!-- ignore --> del Capítulo 10, pero
no discutimos los detalles más avanzados. Ahora que conoces más Rust, podemos
entrar en los detalles más minuciosos.</p>
<h3 id="especificando-tipos-de-marcador-en-definiciones-de-traits-con-tipos-asociados"><a class="header" href="#especificando-tipos-de-marcador-en-definiciones-de-traits-con-tipos-asociados">Especificando Tipos de Marcador en Definiciones de Traits con Tipos Asociados</a></h3>
<p>Los <em>tipos asociados</em> conectan un marcador de tipo con un trait de modo que los
métodos de definición de trait puedan usar estos marcadores de tipo en sus
firmas. El implementador de un trait especificará el tipo concreto que se
utilizará en lugar del tipo de marcador para la implementación particular. De
esa manera, podemos definir un trait que use algunos tipos sin necesidad de
saber exactamente cuáles son esos tipos hasta que se implemente el trait.</p>
<p>Hemos descrito la mayoría de las características avanzadas en este capítulo
como poco necesarias. Los tipos asociados están en algún lugar en el medio: se
utilizan con menos frecuencia que las características explicadas en el resto
del libro, pero con más frecuencia que muchas de las otras características
discutidas en este capítulo.</p>
<p>Un ejemplo de un trait con un tipo asociado es el trait <code>Iterator</code> que la
biblioteca estándar proporciona. El tipo asociado se llama <code>Item</code> y representa
el tipo de los valores que el tipo que implementa el trait <code>Iterator</code> está
iterando. La definición del trait <code>Iterator</code> es como se muestra en el Listado
19-12.</p>
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<p><span class="caption">Listing 19-12: La definición del trait <code>Iterator</code> que
tiene un tipo asociado <code>Item</code></span></p>
<p>El tipo <code>Item</code> es un marcador de tipo, y la definición del método <code>next</code> muestra
que devolverá valores del tipo <code>Option&lt;Self::Item&gt;</code>. Los implementadores del
trait <code>Iterator</code> especificarán el tipo concreto para <code>Item</code>, y el método <code>next</code>
devolverá una <code>Option</code> que contiene un valor de ese tipo concreto.</p>
<p>Los tipos asociados pueden parecer un concepto similar a los generics, ya que
estos últimos nos permiten definir una función sin especificar qué tipos puede
manejar. Para examinar la diferencia entre los dos conceptos, veremos una
implementación del trait <code>Iterator</code> en un tipo llamado <code>Counter</code> que especifica
que el tipo <code>Item</code> es <code>u32</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Esta sintaxis parece comparable a la de los generics. Entonces, ¿por qué no
definir simplemente el trait <code>Iterator</code> con generics, como se muestra en el
Listado 19-13?</p>
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<p><span class="caption">Listing 19-13: Una definición hipotética del trait
<code>Iterator</code> usando generics</span></p>
<p>La diferencia es que cuando usamos generics, como en el Listado 19-13, debemos
anotar los tipos en cada implementación; porque también podemos implementar
<code>Iterator&lt;String&gt; for Counter</code> o cualquier otro tipo, podríamos tener
múltiples implementaciones de <code>Iterator</code> para <code>Counter</code>. En otras palabras,
cuando un trait tiene un parámetro genérico, puede implementarse para un tipo
múltiples veces, cambiando los tipos concretos de los parámetros genéricos de
tipo cada vez. Cuando usamos el método <code>next</code> en <code>Counter</code>, tendríamos que
proporcionar anotaciones de tipo para indicar qué implementación de <code>Iterator</code>
queremos usar.</p>
<p>Con los tipos asociados, no necesitamos anotar los tipos porque no podemos
implementar un trait en un tipo múltiples veces. En el Listado 19-12 con la
definición que usa tipos asociados, solo podemos elegir cuál será el tipo de
<code>Item</code> una vez, porque solo puede haber un <code>impl Iterator for Counter</code>. No
tenemos que especificar que queremos un iterador de valores <code>u32</code> en todas
partes que llamamos a <code>next</code> en <code>Counter</code>.</p>
<p>Los tipos asociados también forman parte del contrato del trait: los
implementadores del trait deben proporcionar un tipo para que se use en lugar
del marcador de tipo. Los tipos asociados a menudo tienen un nombre que
describe cómo se usará el tipo, y documentar el tipo asociado en la
documentación de la API es una buena práctica.</p>
<h3 id="parámetros-generics-predeterminados-y-sobrecarga-de-operadores"><a class="header" href="#parámetros-generics-predeterminados-y-sobrecarga-de-operadores">Parámetros Generics Predeterminados y Sobrecarga de Operadores</a></h3>
<p>Cuando utilizamos parámetros de tipo generic, podemos especificar un tipo
concreto predeterminado para el tipo generic. Esto elimina la necesidad de que
los implementadores del trait especifiquen un tipo concreto si el tipo
predeterminado funciona. Especificas un tipo predeterminado al declarar un tipo
generic con la sintaxis <code>&lt;TipoMarcador=TipoConcreto&gt;</code>.</p>
<p>Un ejemplo excelente de una situación en la que esta técnica es útil es con la
sobrecarga de operadores, en la que personalizas el comportamiento de un
operador (como <code>+</code>) en situaciones particulares.</p>
<p>Rust no te permite crear tus propios operadores o sobrecargar operadores
arbitrarios. Pero puedes sobrecargar las operaciones y los traits
correspondientes enumerados en <code>std::ops</code> implementando los traits asociados
con el operador. Por ejemplo, en el Listado 19-14 sobrecargamos el operador <code>+</code>
para agregar dos instancias de <code>Point</code> juntas. Hacemos esto implementando el
trait <code>Add</code> en un struct <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<p><span class="caption">Listing 19-14: Implementando el trait <code>Add</code> para
sobrecargar el operador <code>+</code> para instancias <code>Point</code></span></p>
<p>El método <code>add</code> suma los valores <code>x</code> de dos instancias <code>Point</code> y los valores <code>y</code>
de dos instancias <code>Point</code> para crear una nueva instancia <code>Point</code>. El trait <code>Add</code>
tiene un tipo asociado llamado <code>Output</code> que determina el tipo devuelto desde el
método <code>add</code>.</p>
<p>El tipo generic predeterminado en este código está dentro del trait <code>Add</code>. Aquí
está su definición:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>Este código debería resultar familiar en general: un trait con un método y un
tipo asociado. La nueva parte es <code>Rhs=Self</code>: esta sintaxis se llama <em>parámetros
de tipo predeterminados</em>. El parámetro de tipo generic <code>Rhs</code> (abreviatura de
“lado derecho”) define el tipo del parámetro <code>rhs</code> en el método <code>add</code>. Si no
especificamos un tipo concreto para <code>Rhs</code> cuando implementamos el trait <code>Add</code>,
el tipo de <code>Rhs</code> será predeterminado a <code>Self</code>, que será el tipo en el que
estamos implementando <code>Add</code>.</p>
<p>Cuando implementamos <code>Add</code> para <code>Point</code>, utilizamos el valor predeterminado para
<code>Rhs</code> porque queremos agregar dos <code>Point</code> instancias. Veamos un ejemplo de
implementación del trait <code>Add</code> donde queremos personalizar el tipo <code>Rhs</code> en
lugar de usar el predeterminado.</p>
<p>Tenemos dos structs, <code>Millimeters</code> y <code>Meters</code>, que contienen valores en
unidades diferentes. Este envoltorio ligero de un tipo existente en otro struct
se conoce como el <em>patrón newtype</em>, que describimos con más detalle en la
sección <a href="ch19-03-advanced-traits.html#usando-el-pattern-newtype-para-implementar-traits-externos-en-tipos-externos">“Usando el Patrón Newtype para Implementar Traits Externos en Tipos
Externos”</a>. Queremos agregar valores en milímetros a valores en metros
y que la implementación de <code>Add</code> haga la conversión correctamente. Podemos
implementar <code>Add</code> para <code>Millimeters</code> con <code>Meters</code> como <code>Rhs</code>, como se muestra en
el Listado 19-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<p><span class="caption">Listing 19-15: Implementando el trait <code>Add</code> en
<code>Millimeters</code> para sumar <code>Millimeters</code> a <code>Meters</code></span></p>
<p>Para agregar <code>Millimeters</code> y <code>Meters</code>, especificamos <code>impl Add&lt;Meters&gt;</code> para
establecer el valor del parámetro de tipo <code>Rhs</code> en lugar de usar el
predeterminado de <code>Self</code>.</p>
<p>Se utilizan los parámetros de tipo predeterminados en dos casos principales:</p>
<ul>
<li>Para extender un tipo sin romper el código existente</li>
<li>Para permitir la personalización en casos específicos que la mayoría de los
usuarios no necesitarán</li>
</ul>
<p>El trait <code>Add</code> de la biblioteca estándar es un ejemplo del segundo propósito:
normalmente, agregarás dos tipos similares, pero el trait <code>Add</code> proporciona la
capacidad de personalizar más allá de eso. El uso de un parámetro de tipo
predeterminado en la definición del trait <code>Add</code> significa que no tienes que
especificar el parámetro extra la mayor parte del tiempo. En otras palabras, no
se necesita un poco de boilerplate de implementación, lo que facilita el uso del
trait.</p>
<p>El primer propósito es similar al segundo, pero al revés: si quieres agregar un
parámetro de tipo a un trait existente, puedes darle un valor predeterminado
para permitir la extensión de la funcionalidad del trait sin romper el código
de implementación existente.</p>
<h3 id="sintaxis-completamente-calificada-para-la-desambiguación-llamando-métodos-con-el-mismo-nombre"><a class="header" href="#sintaxis-completamente-calificada-para-la-desambiguación-llamando-métodos-con-el-mismo-nombre">Sintaxis Completamente Calificada para la Desambiguación: Llamando Métodos con el Mismo Nombre</a></h3>
<p>Nada en Rust impide que un trait tenga un método con el mismo nombre que el
método de otro trait, ni Rust te impide implementar ambos traits en un solo
tipo. También es posible implementar un método directamente en el tipo con el
mismo nombre que los métodos de los traits.</p>
<p>Cuando llamas a métodos con el mismo nombre, necesitarás decirle a Rust cuál
quieres usar. Considera el código en el Listado 19-16 donde hemos definido dos
traits, <code>Pilot</code> y <code>Wizard</code>, que ambos tienen un método llamado <code>fly</code>. Luego
implementamos ambos traits en un tipo <code>Human</code> que ya tiene un método llamado
<code>fly</code> implementado en él. Cada método <code>fly</code> hace algo diferente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 19-16: Se definen dos traits para tener un
método <code>fly</code> y se implementan en el tipo <code>Human</code>, además se implementa
directamente un método <code>fly</code> en <code>Human</code></span></p>
<p>Cuando llamamos al método <code>fly</code> en una instancia de <code>Human</code>, el compilador
por defecto llama al método que está implementado directamente en el tipo, como
se muestra en el Listado 19-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<p><span class="caption">Listing 19-17: Llamando al método <code>fly</code> en una instancia
de <code>Human</code></span></p>
<p>Ejecutando este código imprimirá <code>*waving arms furiously*</code>, mostrando que Rust
llamó al método <code>fly</code> implementado directamente en <code>Human</code>.</p>
<p>Para llamar a los métodos <code>fly</code> de los traits <code>Pilot</code> o <code>Wizard</code>, necesitamos
usar una sintaxis más explícita para especificar cuál método <code>fly</code> queremos
llamar. El Listado 19-18 demuestra esta sintaxis.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<p><span class="caption">Listing 19-18: Especificando qué método <code>fly</code> del trait
queremos llamar</span></p>
<p>Especificar el nombre del trait antes del nombre del método aclara a Rust qué
implementación del método <code>fly</code> queremos llamar. También podríamos escribir
<code>Human::fly(&amp;person)</code>; esto es equivalente a <code>person.fly()</code>, pero es un poco
más largo de escribir si no necesitamos desambiguar.</p>
<p>Al ejecutar este código imprime lo siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Debido a que el método <code>fly</code> toma un parámetro <code>self</code>, si tuviéramos dos
<em>tipos</em> que implementan el mismo <em>trait</em>, Rust podría determinar cuál implementación
del trait utilizar en función del tipo de <code>self</code>.</p>
<p>Sin embargo, las funciones asociadas que no son métodos no tienen un parámetro
<code>self</code>. Cuando hay múltiples tipos o traits que definen funciones no métodos
con el mismo nombre de función, Rust no siempre sabe a qué tipo te refieres a
menos que uses <em>sintaxis completamente calificada</em>. Por ejemplo, en el Listado
19-19 creamos un trait para un refugio de animales que quiere nombrar a todos
los perros bebés <em>Spot</em>. Creamos un trait <code>Animal</code> con una función no método
asociada <code>baby_name</code>. El trait <code>Animal</code> se implementa para la estructura <code>Dog</code>,
en la que también proporcionamos una función no método asociada <code>baby_name</code>
directamente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}</code></pre></pre>
<p><span class="caption">Listing 19-19: Un trait con una función asociada y un
tipo con una función asociada del mismo nombre que también implementa el
trait</span></p>
<p>Implementamos el código para nombrar a todos los cachorros Spot en la función
asociada <code>baby_name</code> que se define en <code>Dog</code>. El tipo <code>Dog</code> también implementa
el trait <code>Animal</code>, que describe las características que todos los animales
tienen. Los cachorros de perro se llaman cachorros, y eso se expresa en la
implementación del trait <code>Animal</code> en <code>Dog</code> en la función <code>baby_name</code> asociada
con el trait <code>Animal</code>.</p>
<p>En <code>main</code>, llamamos a la función <code>Dog::baby_name</code>, que llama directamente a la
función asociada definida en <code>Dog</code> directamente. Este código imprime lo
siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>El output no es el que queríamos. Queremos llamar a la función <code>baby_name</code> que
forma parte del trait <code>Animal</code> que implementamos en <code>Dog</code>, por lo que el código
imprime <code>A baby dog is called a puppy</code>. La técnica de especificar el nombre del
trait que usamos en el Listado 19-18 no ayuda aquí; si cambiamos <code>main</code> al
código del Listado 19-20, obtendremos un error de compilación.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}</code></pre>
<p><span class="caption">Listing 19-20: Al intentar llamar a la función
<code>baby_name</code> del trait <code>Animal</code>, Rust no sabe qué implementación usar</span></p>
<p>Debido a que <code>Animal::baby_name</code> no tiene un parámetro <code>self</code> y podría haber
otros tipos que implementen el trait <code>Animal</code>, Rust no puede averiguar qué
implementación de <code>Animal::baby_name</code> queremos. Obtendremos este error de
compilación:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin &quot;traits-example&quot;) due to 1 previous error
</code></pre>
<p>Para desambiguar y decirle a Rust que queremos usar la implementación de
<code>Animal</code> para <code>Dog</code> en lugar de la implementación de <code>Animal</code> para algún otro
tipo, necesitamos usar la sintaxis completamente calificada. El Listado 19-21
demuestra cómo usar la sintaxis completamente calificada.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<p><span class="caption">Listing 19-21: Usando la sintaxis completamente
calificada para especificar que queremos llamar a la función <code>baby_name</code> del
trait <code>Animal</code> implementado en <code>Dog</code></span></p>
<p>Estamos proporcionando a Rust una anotación de tipo dentro de los corchetes
angulares, lo que indica que queremos llamar al método <code>baby_name</code> del trait
<code>Animal</code> implementado en <code>Dog</code> diciendo que queremos tratar el tipo <code>Dog</code> como
un <code>Animal</code> para esta llamada de función. Este código ahora imprimirá lo que
queremos:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>En general, la sintaxis completamente calificada se define de la siguiente</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>Para las funciones asociadas que no son métodos, no habría un <code>receiver</code>:
solo habría una lista de otros argumentos. Podrías usar la sintaxis
completamente calificada en todas partes donde llames a funciones o métodos.
Sin embargo, se te permite omitir cualquier parte de esta sintaxis que Rust
pueda deducir de otra información en el programa. Solo necesitas usar esta
sintaxis más verbosa en casos en los que haya múltiples implementaciones que
usen el mismo nombre y Rust necesite ayuda para identificar qué implementación
quieres llamar.</p>
<h3 id="usando-supertraits-para-requerir-la-funcionalidad-de-un-trait-dentro-de-otro-trait"><a class="header" href="#usando-supertraits-para-requerir-la-funcionalidad-de-un-trait-dentro-de-otro-trait">Usando supertraits para requerir la funcionalidad de un trait dentro de otro trait</a></h3>
<p>A veces, es posible que desees escribir una definición de trait que dependa de
otro trait: para que un tipo implemente el primer trait, quieres exigir que
este tipo también implemente el segundo trait. Esto se hace para que la
definición de tu trait pueda hacer uso de los elementos asociados del segundo
trait. El trait en el que se basa la definición de tu trait se llama
<em>supertrait</em> de tu trait.</p>
<p>Por ejemplo, supongamos que queremos crear un trait llamado <code>OutlinePrint</code> con
un método <code>outline_print</code> que imprima un valor dado enmarcado entre asteriscos.
Es decir, dado un struct <code>Point</code> que implementa el trait de la biblioteca
estándar <code>Display</code> para que el resultado sea <code>(x, y)</code>, cuando llamemos a
<code>outline_print</code> en una instancia de <code>Point</code> que tenga <code>1</code> para <code>x</code> y <code>3</code> para
<code>y</code>, debería imprimir lo siguiente:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>Al implementar el método <code>outline_print</code>, queremos usar la funcionalidad de
<code>Display</code>. Por lo tanto, necesitamos indicar que el trait <code>OutlinePrint</code> solo
funcionará con tipos que también implementen <code>Display</code> y proporcionen la
funcionalidad que <code>OutlinePrint</code> necesita. Podemos hacer eso en la definición
del trait especificando <code>OutlinePrint: Display</code>. Esta técnica es similar a
agregar un límite de trait al trait. El Listado 19-22 muestra una
implementación del trait <code>OutlinePrint</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {output} *&quot;);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 19-22: Implementando el trait <code>OutlinePrint</code>
que requiere la funcionalidad de <code>Display</code></span></p>
<p>Dado que hemos especificado que <code>OutlinePrint</code> requiere el trait <code>Display</code>, el
utilizar la función <code>to_string</code> que se implementa automáticamente para cualquier
tipo que implemente <code>Display</code> está bien. Si intentáramos usar <code>to_string</code> sin
agregar dos puntos y especificar el trait <code>Display</code> después del nombre del
trait, obtendríamos un error diciendo que no se encontró ningún método llamado
<code>to_string</code> para el tipo <code>&amp;Self</code> en el scope actual.</p>
<p>Veamos qué sucede cuando intentamos usar <code>OutlinePrint</code> en un tipo que
no implementa <code>Display</code>, como el struct <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {output} *&quot;);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
<p>Obtenemos un error que indica que se requiere implementar <code>Display</code>, pero no
está implementado:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin &quot;traits-example&quot;) due to 2 previous errors
</code></pre>
<p>Para solucionar esto, implementamos <code>Display</code> en <code>Point</code> y cumplimos con la
restricción que requiere <code>OutlinePrint</code>, de la siguiente manera:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {output} *&quot;);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
<p>Entonces, al implementar el trait <code>OutlinePrint</code> en <code>Point</code>, se compilará
exitosamente, y podemos llamar a <code>outline_print</code> en una instancia de <code>Point</code>
para mostrarla dentro de un contorno de asteriscos.</p>
<h3 id="usando-el-pattern-newtype-para-implementar-traits-externos-en-tipos-externos"><a class="header" href="#usando-el-pattern-newtype-para-implementar-traits-externos-en-tipos-externos">Usando el pattern Newtype para implementar traits externos en tipos externos</a></h3>
<p>En el capítulo 10 en la sección <a href="ch10-02-traits.html#implementando-un-trait-en-un-tipo">“Implementando un trait en un
tipo”</a><!-- ignore -->, mencionamos los orphan
rules que establecen que solo podemos implementar un trait en un tipo si
bien el trait o el tipo son locales a nuestro crate. Es posible evitar esta
restricción usando el <em>patrón newtype</em>, que implica crear un nuevo tipo en un
struct de tupla. (Cubrimos los structs de tupla en la sección <a href="ch05-01-defining-structs.html#usando-structs-de-tuplas-sin-campos-nombrados-para-crear-diferentes-tipos">“Usando
structs de tupla sin campos nombrados para crear diferentes
tipos”</a><!-- ignore --> del capítulo 5.) El struct de tupla
tendrá un campo y será un envoltorio delgado alrededor del tipo en el que
queremos implementar un trait. Entonces, el tipo de envoltorio es local a
nuestro crate, y podemos implementar el trait en el envoltorio. <em>Newtype</em> es
un término que se origina en el lenguaje de programación Haskell. No hay
penalización de rendimiento en tiempo de ejecución por usar este patrón, y el
tipo de wrapper se omite en tiempo de compilación.</p>
<p>Como ejemplo, supongamos que queremos implementar <code>Display</code> en <code>Vec&lt;T&gt;</code>, lo
cual nos impide hacerlo directamente debido a regla de los &quot;orphan rules&quot;, ya
que el trait <code>Display</code> y el tipo <code>Vec&lt;T&gt;</code> están definidos fuera de nuestro
crate. Podemos hacer un struct llamado <code>Wrapper</code> que contenga una instancia de
<code>Vec&lt;T&gt;</code>. Luego podemos implementar <code>Display</code> en <code>Wrapper</code> y usar el valor de
<code>Vec&lt;T&gt;</code>, como se muestra en el Listado 19-23.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {w}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 19-23: Crear un tipo <code>Wrapper</code> alrededor de
<code>Vec&lt;String&gt;</code> para implementar <code>Display</code></span></p>
<p>La implementación de <code>Display</code> usa <code>self.0</code> para acceder al <code>Vec&lt;T&gt;</code> interno,
porque <code>Wrapper</code> es un struct de tupla y <code>Vec&lt;T&gt;</code> es el item en el índice 0 de
la tupla. Luego podemos usar la funcionalidad del trait <code>Display</code> en <code>Wrapper</code>.</p>
<p>La desventaja de usar esta técnica es que <code>Wrapper</code> es un nuevo tipo, por lo
que no tiene los métodos del valor que contiene. Tendríamos que implementar
todos los métodos de <code>Vec&lt;T&gt;</code> directamente en <code>Wrapper</code> de tal manera que los
métodos deleguen a <code>self.0</code>, lo que nos permitiría tratar a <code>Wrapper</code>
exactamente como un <code>Vec&lt;T&gt;</code>. Si quisiéramos que el nuevo tipo tenga todos los
métodos del tipo interno, implementar el trait <code>Deref</code> (discutido en el
capítulo 15 en la sección <a href="ch15-02-deref.html#tratando-los-smart-pointers-como-referencias-regulares-con-el-trait-deref">“Tratando a los smart pointers como referencias
regulares con el trait <code>Deref</code>”</a><!-- ignore -->) en
<code>Wrapper</code> para devolver el tipo interno sería una solución. Si no queremos que
el tipo <code>Wrapper</code> tenga todos los métodos del tipo interno, por ejemplo, para
restringir el comportamiento del tipo <code>Wrapper</code>, tendríamos que implementar
manualmente solo los métodos que queremos.</p>
<p>El pattern newtype también es útil incluso cuando no se involucran traits.
Ahora cambiemos de enfoque y exploremos algunas formas avanzadas de interactuar
con el sistema de tipos de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-avanzados"><a class="header" href="#tipos-avanzados">Tipos Avanzados</a></h2>
<p>El sistema de tipos de Rust tiene algunas características que hemos mencionado
hasta ahora, pero que aún no hemos discutido. Comenzaremos discutiendo los
newtypes en general mientras examinamos por qué los newtypes son útiles
como tipos. Luego pasaremos a los type aliases, una característica similar a
los newtypes pero con semántica ligeramente diferente. También discutiremos
el tipo <code>!</code> y los tipos de tamaño dinámico.</p>
<h3 id="usando-el-newtype-pattern-para-seguridad-de-tipos-y-abstracción"><a class="header" href="#usando-el-newtype-pattern-para-seguridad-de-tipos-y-abstracción">Usando el Newtype Pattern para Seguridad de Tipos y Abstracción</a></h3>
<blockquote>
<p>Nota: Esta sección asume que has leído la sección anterior <a href="ch19-03-advanced-traits.html#usando-el-pattern-newtype-para-implementar-traits-externos-en-tipos-externos">“Usando el
Pattern Newtype para Implementar Traits Externos en Tipos
Externos.”</a><!-- ignore --></p>
</blockquote>
<p>El newtype pattern también es útil para tareas más allá de las que hemos
discutido hasta ahora, incluyendo hacer cumplir estáticamente que los valores
nunca se confundan e indicar las unidades de un valor. Viste un ejemplo de
usar newtypes para indicar unidades en el Listado 19-15: recuerda que los
structs <code>Millimeters</code> y <code>Meters</code> envolvieron valores <code>u32</code> en un newtype. Si
escribiéramos una función con un parámetro de tipo <code>Millimeters</code>, no podríamos
compilar un programa que accidentalmente intentara llamar a esa función con
un valor de tipo <code>Meters</code> o un <code>u32</code> simple.</p>
<p>También podemos usar el pattern newtype para abstraer algunos detalles de
implementación de un tipo: el nuevo tipo puede exponer una API pública que es
diferente de la API del tipo interno privado.</p>
<p>Los newtypes también pueden ocultar la implementación interna. Por ejemplo,
podríamos proporcionar un tipo <code>People</code> para envolver un <code>HashMap&lt;i32, String&gt;</code>
que almacena el ID de una persona asociado con su nombre. El código que usa
<code>People</code> solo interactuaría con la API pública que proporcionamos, como un
método para agregar un string de nombre a la colección <code>People</code>; ese código
no necesitaría saber que asignamos un ID <code>i32</code> a los nombres internamente. El
newtype pattern es una forma ligera de lograr la encapsulación para ocultar
los detalles de implementación, que discutimos en la sección <a href="ch17-01-what-is-oo.html#encapsulacion-que-oculta-los-detalles-de-implementacion">“Encapsulación
que Oculta los Detalles de
Implementación”</a><!-- ignore -->
del Capítulo 17.</p>
<h3 id="creando-type-synonyms-con-type-aliases"><a class="header" href="#creando-type-synonyms-con-type-aliases">Creando Type Synonyms con Type Aliases</a></h3>
<p>Rust proporciona la capacidad de declarar un <em>type alias</em> para darle a un
tipo existente otro nombre. Para esto usamos la palabra clave <code>type</code>. Por
ejemplo, podemos crear el alias <code>Kilometers</code> a <code>i32</code> de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Ahora, el alias <code>Kilometers</code> es un <em>sinónimo</em> para <code>i32</code>; a diferencia de los
tipos <code>Millimeters</code> y <code>Meters</code> que creamos en el Listado 19-15, <code>Kilometers</code>
no es un tipo nuevo y separado. Los valores que tienen el tipo <code>Kilometers</code>
se tratarán de la misma manera que los valores del tipo <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}</span></code></pre></pre>
<p>Debido a que <code>Kilometers</code> e <code>i32</code> son el mismo tipo, podemos agregar valores
de ambos tipos y podemos pasar valores <code>Kilometers</code> a funciones que toman
parámetros <code>i32</code>. Sin embargo, usando este método, no obtenemos los beneficios
de verificación de tipos que obtenemos del newtype pattern discutido
anteriormente. En otras palabras, si mezclamos valores <code>Kilometers</code> e <code>i32</code>
en algún lugar, el compilador no nos dará un error.</p>
<p>El caso de uso principal para los sinónimos de tipo es reducir la repetición.
Por ejemplo, podríamos tener un tipo largo como este:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Escribir este tipo extenso en firmas de función y como anotaciones de tipo
en todo el código puede ser tedioso y propenso a errores. Imagina tener un
proyecto lleno de código como el del Listado 19-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-24: Usando un tipo largo en muchos
lugares</span></p>
<p>Un type alias hace que este código sea más manejable al reducir la repetición.
En el Listado 19-25, hemos introducido un alias llamado <code>Thunk</code> para el tipo
extenso y podemos reemplazar todos los usos del tipo con el alias más corto
<code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-25: Introduciendo un type alias <code>Thunk</code> para
reducir la repetición</span></p>
<p>¡Este código es mucho más fácil de leer y escribir! Elegir un nombre
significativo para un alias de tipo también puede ayudar a comunicar tu
intención (<em>thunk</em> es una palabra para código que se evaluará en un momento
posterior, por lo que es un nombre apropiado para un cierre que se almacena).</p>
<p>Los type alias también se utilizan con frecuencia con el tipo <code>Result&lt;T, E&gt;</code>
para reducir la repetición. Considera el módulo <code>std::io</code> en la biblioteca
estándar. Las operaciones de E/S a menudo devuelven un <code>Result&lt;T, E&gt;</code> para
manejar situaciones en las que las operaciones no funcionan. Esta biblioteca
tiene una estructura <code>std::io::Error</code> que representa todos los posibles errores
de E/S. Muchas de las funciones en <code>std::io</code> devolverán <code>Result&lt;T, E&gt;</code> donde
<code>E</code> es <code>std::io::Error</code>, como estas funciones en el trait <code>Write</code>:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>Él <code>Result&lt;..., Error&gt;</code> se repite mucho. Como tal, <code>std::io</code> tiene esta
declaración de alias de tipo:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Dado que esta declaración está en el módulo <code>std::io</code>, podemos usar el alias
completamente calificado <code>std::io::Result&lt;T&gt;</code>; es decir, un <code>Result&lt;T, E&gt;</code>
con <code>E</code> lleno como <code>std::io::Error</code>. Las firmas de las funciones del trait
<code>Write</code> terminan viéndose así:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>El type alias ayuda de dos maneras: hace que el código sea más fácil de
escribir <em>y</em> nos da una interfaz consistente en todo <code>std::io</code>. Debido a que
es un alias, es solo otro <code>Result&lt;T, E&gt;</code>, lo que significa que podemos usar
cualquier método que funcione en <code>Result&lt;T, E&gt;</code> con él, así como la sintaxis
especial como el operador <code>?</code>.</p>
<h3 id="el-tipo-que-nunca-retorna"><a class="header" href="#el-tipo-que-nunca-retorna">El tipo que nunca retorna</a></h3>
<p>Rust tiene un tipo especial llamado <code>!</code>, conocido en la jerga de la teoría de
tipos como <em>tipo vacío</em> porque no tiene valores. Preferimos llamarlo <em>tipo
never</em> porque se encuentra en el lugar del tipo de retorno cuando una función
nunca retornará. Aquí hay un ejemplo:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>Este código se lee como “la función <code>bar</code> devuelve never”. Las funciones que
devuelven never se llaman <em>funciones divergentes</em>. No podemos crear valores
del tipo <code>!</code> por lo que <code>bar</code> nunca puede devolver.</p>
<p>Pero, ¿qué utilidad tiene un tipo del que nunca se pueden crear valores?
Recuerda el código del Juego de Adivinar el Número mostrado en el Listado
2-5; hemos reproducido parte de él aquí en el Listado 19-26.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 19-26: Un <code>match</code> con una opción que termina en
<code>continue</code></span></p>
<p>En ese momento, omitimos algunos detalles en este código. En el Capítulo 6 en
la sección <a href="ch06-02-match.html#the-match-control-flow-operator">“El operador de control de flujo
<code>match</code>”</a><!-- ignore -->
discutimos que las opciones de <code>match</code> deben devolver todos el mismo tipo. Por
lo tanto, por ejemplo, el siguiente código no funciona:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}</span></code></pre>
<p>El tipo de <code>guess</code> en este código tendría que ser un entero <em>y</em> un string, y
Rust requiere que <code>guess</code> tenga solo un tipo. Entonces, ¿qué devuelve
<code>continue</code>? ¿Cómo se nos permitió devolver un <code>u32</code> de una opción y tener otra
opción que termina con <code>continue</code> en el Listado 19-26?</p>
<p>Como habrás adivinado, <code>continue</code> tiene un valor <code>!</code>. Es decir, cuando Rust
calcula el tipo de <code>guess</code>, mira ambas opciones de <code>match</code>, el primero con un
valor de <code>u32</code> y el segundo con un valor de <code>!</code>. Debido a que <code>!</code> nunca puede
tener un valor, Rust decide que el tipo de <code>guess</code> es <code>u32</code>.</p>
<p>La forma formal de describir este comportamiento es que las expresiones de tipo
<code>!</code> se pueden convertir en cualquier otro tipo. Se nos permite terminar esta
opción de <code>match</code> con <code>continue</code> porque <code>continue</code> no devuelve un valor; en
cambio, mueve el control de nuevo a la parte superior del bucle, por lo que en
el caso de <code>Err</code>, nunca asignamos un valor a <code>guess</code>.</p>
<p>El tipo never también es útil con la macro <code>panic!</code>. Recordemos la función
<code>unwrap</code> que llamamos en valores <code>Option&lt;T&gt;</code> para producir un valor o
generar un panic con esta definición:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}</code></pre>
<p>en este código, ocurre lo mismo que en el <code>match</code> del Listado 19-26: Rust ve
que <code>val</code> tiene el tipo <code>T</code> y <code>panic!</code> tiene el tipo <code>!</code>, por lo que el
resultado de la expresión <code>match</code> es <code>T</code>. Este código funciona porque <code>panic!</code>
no produce un valor; termina el programa. En el caso de <code>None</code>, no devolveremos
un valor de <code>unwrap</code>, por lo que este código es válido.</p>
<p>Una expresión final que tiene el tipo <code>!</code> es un <code>loop</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;forever &quot;);

    loop {
        print!(&quot;and ever &quot;);
    }
<span class="boring">}</span></code></pre>
<p>Aquí, el bucle nunca termina, por lo que <code>!</code> es el valor de la expresión. Sin
embargo, esto no sería cierto si incluyéramos un <code>break</code>, porque el bucle
terminaría cuando llegara al <code>break</code>.</p>
<h3 id="tipos-de-tamano-dinamico-y-el-trait-sized"><a class="header" href="#tipos-de-tamano-dinamico-y-el-trait-sized">Tipos de tamano dinamico y el trait <code>Sized</code></a></h3>
<p>Rust necesita conocer ciertos detalles sobre sus tipos, como la cantidad de
espacio para asignar a un valor de un tipo particular. Esto deja una esquina de
su sistema de tipos un poco confusa al principio: el concepto de <em>tipos de
tamaño dinámico</em>. A veces se refiere como <em>DST</em> o <em>tipos no dimensionados</em>,
estos tipos nos permiten escribir código usando valores cuyo tamaño solo
podemos conocer en tiempo de ejecución.</p>
<p>Profundicemos en los detalles de un tipo de tamaño dinámico llamado <code>str</code>, que
hemos estado usando a lo largo del libro. Así es, no <code>&amp;str</code>, sino <code>str</code> por sí
solo, es un DST. No podemos saber cuánto tiempo es la cadena hasta el tiempo de
ejecución, lo que significa que no podemos crear una variable de tipo <code>str</code>, ni
podemos tomar un argumento de tipo <code>str</code>. Considera el siguiente código, que
no funciona:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Hello there!&quot;;
    let s2: str = &quot;How's it going?&quot;;
<span class="boring">}</span></code></pre>
<p>Rust necesita conocer cuánta memoria asignar para cualquier valor de un tipo
particular, y todos los valores de un tipo deben usar la misma cantidad de
memoria. Si Rust nos permitiera escribir este código, estos dos valores <code>str</code>
necesitarían ocupar el mismo espacio. Pero tienen longitudes diferentes: <code>s1</code>
necesita 12 bytes de almacenamiento y <code>s2</code> necesita 15. Es por eso que no es
posible crear una variable que contenga un tipo de tamaño dinámico.</p>
<p>Entonces, ¿qué hacemos en este caso? En este caso, como ya sabes, la solución
es hacer que los tipos de <code>s1</code> y <code>s2</code> sean <code>&amp;str</code> en lugar de <code>str</code>. Recuerda
de la sección <a href="ch04-03-slices.html#string-slices">“String Slices”</a><!-- ignore --> del
Capítulo 4 que la estructura de datos de slice solo almacena la posición de
inicio y la longitud del slice. Por lo tanto, aunque un <code>&amp;T</code> es un solo
valor que almacena la dirección de memoria de donde se encuentra el <code>T</code>, un
<code>&amp;str</code> son <em>dos</em> valores: la dirección del <code>str</code> y su longitud. Como tal,
podemos conocer el tamaño de un valor <code>&amp;str</code> en tiempo de compilación: es dos
veces la longitud de un <code>usize</code>. Es decir, siempre conocemos el tamaño de un
<code>&amp;str</code>, sin importar cuán larga sea la cadena a la que se refiere. En general,
esta es la forma en que se usan los tipos de tamaño dinámico en Rust: tienen un
bit adicional de metadatos que almacena el tamaño de la información dinámica.
La regla de oro de los tipos de tamaño dinámico es que debemos envolverlos en
algún tipo de puntero.</p>
<p>Podemos combinar <code>str</code> con todo tipo de punteros: por ejemplo, <code>Box&lt;str&gt;</code> o
<code>Rc&lt;str&gt;</code>. De hecho, ya has visto esto antes, pero con un tipo de tamaño
dinámico diferente: los traits. Cada trait es un tipo de tamaño dinámico al que
podemos referirnos usando el nombre del trait. En el Capítulo 17 en la
sección <a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">“Usando trait objects que permiten valores de diferentes
tipos”</a><!--
ignore -->, mencionamos que para usar traits como objetos de trait, debemos
ponerlos detrás de un puntero, como <code>&amp;dyn Trait</code> o <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> también funcionaría).</p>
<p>Para trabajar con DST, Rust proporciona el trait <code>Sized</code> para determinar si el
tamaño de un tipo es conocido en tiempo de compilación o no. Este trait se
implementa automáticamente para todo lo cuyo tamaño es conocido en tiempo de
compilación. Además, Rust agrega implícitamente un límite en <code>Sized</code> a cada
función generic. Es decir, una definición de función generic como esta:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>en realidad se trata como si hubiéramos escrito esto:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>De forma predeterminada, las funciones generic solo funcionarán en tipos que
tienen un tamaño conocido en tiempo de compilación. Sin embargo, puede usar la
siguiente sintaxis especial para relajar esta restricción:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p>Un trait bound en <code>?Sized</code> significa “<code>T</code> puede o no ser <code>Sized</code>” y esta
notación anula el valor predeterminado de que los tipos generic deben tener un
tamaño conocido en tiempo de compilación. La sintaxis <code>?Trait</code> con este
significado solo está disponible para <code>Sized</code>, no para ningún otro trait.</p>
<p>También debes tener en cuenta que hemos cambiado el tipo del parámetro <code>t</code> de
<code>T</code> a <code>&amp;T</code>. Debido a que el tipo puede no ser <code>Sized</code>, necesitamos usarlo
detrás de algún tipo de puntero. En este caso, hemos elegido una referencia.</p>
<p>¡A continuación, hablaremos sobre funciones y closures!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funciones-y-closures-avanzados"><a class="header" href="#funciones-y-closures-avanzados">Funciones y Closures Avanzados</a></h2>
<p>Esta sección cubre algunas características avanzadas relacionadas con
funciones y closures, incluyendo punteros a funciones y retornar closures.</p>
<h3 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h3>
<p>Hemos hablado de cómo pasar closures a funciones; ¡también puedes pasar
funciones regulares a funciones! Esta técnica es útil cuando quieres pasar una
función que ya has definido en lugar de definir un nuevo closure. Las funciones
se coercen al tipo <code>fn</code> (con una f minúscula), no confundir con el trait de
cierre <code>Fn</code>. El tipo <code>fn</code> se llama <em>puntero a función</em>. Pasar funciones con
punteros a función te permitirá usar funciones como argumentos para otras
funciones.</p>
<p>La sintaxis para especificar que un parámetro es un puntero a función es
similar a la de los closures, como se muestra en el Listado 19-27, donde hemos
definido una función <code>add_one</code> que suma uno a su parámetro. La función
<code>do_twice</code> toma dos parámetros: un puntero a función a cualquier función que
tome un parámetro <code>i32</code> y devuelva un <code>i32</code>, y un valor <code>i32</code>. La función
<code>do_twice</code> llama a la función <code>f</code> dos veces, pasándole el valor <code>arg</code>, luego
suma los dos resultados de la llamada a la función. La función <code>main</code> llama a
<code>do_twice</code> con los argumentos <code>add_one</code> y <code>5</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {answer}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 19-27: Usando el tipo <code>fn</code> para aceptar un
puntero a function como un argumento</span></p>
<p>Este código imprime <code>The answer is: 12</code>. Especificamos que el parámetro <code>f</code> en
<code>do_twice</code> es un <code>fn</code> que toma un parámetro de tipo <code>i32</code> y devuelve un <code>i32</code>.
Luego podemos llamar a <code>f</code> en el cuerpo de <code>do_twice</code>. En <code>main</code>, podemos pasar
el nombre de la función <code>add_one</code> como el primer argumento a <code>do_twice</code>.</p>
<p>A diferencia de los closures, <code>fn</code> es un tipo en lugar de un trait, por lo que
especificamos <code>fn</code> como el tipo de parámetro directamente en lugar de declarar
un parámetro de tipo genérico con uno de los traits <code>Fn</code> como un trait bound.</p>
<p>Los punteros a funciones implementan los tres closure traits (<code>Fn</code>, <code>FnMut</code> y
<code>FnOnce</code>), lo que significa que siempre puedes pasar un puntero a función como
un argumento para una función que espera un closure. Es mejor escribir
funciones usando un tipo generic y uno de los closure traits para que tus
funciones puedan aceptar funciones o closures.</p>
<p>Dicho esto, un ejemplo de dónde querrías aceptar solo <code>fn</code> y no closures es
cuando te comunicas con código externo que no tiene closures: las funciones de
C pueden aceptar funciones como argumentos, pero C no tiene closures.</p>
<p>Como ejemplo de dónde podrías usar un closure definido en línea o una función
nombrada, veamos un uso del método <code>map</code> proporcionado por el trait <code>Iterator</code>
en la biblioteca estándar. Para usar la función <code>map</code> para convertir un vector
de números en un vector de strings, podríamos usar un closure, como este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p>O podríamos nombrar una función como argumento para <code>map</code> en lugar del
closure, como este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p>Ten en cuenta que debemos utilizar la sintaxis completamente calificada que
mencionamos anteriormente en la sección <a href="ch19-03-advanced-traits.html#traits-avanzados">“Traits avanzados”</a></p>
<!-- ignore --> porque hay múltiples funciones disponibles llamadas `to_string`.
<p>Aquí, estamos usando la función <code>to_string</code> definida en el trait <code>ToString</code>,
que la biblioteca estándar ha implementado para cualquier tipo que implemente
<code>Display</code>.</p>
<p>Recuerda la sección <a href="ch06-01-defining-an-enum.html#valores-enum">“Valores de Enum”</a><!-- ignore --> del
Capítulo 6, que el nombre de cada variante de enum que definimos también se
convierte en una función inicializadora. Podemos usar estas funciones
inicializadoras como punteros a función que implementan los closure traits,
lo que significa que podemos especificar las funciones inicializadoras como
argumentos para los métodos que toman closures, como se muestra a continuación:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p>Aquí creamos instancias de <code>Status::Value</code> usando cada valor <code>u32</code> en el rango
en el que se llama a <code>map</code> usando la función inicializadora de <code>Status::Value</code>.
A algunas personas les gusta este estilo, y a otras les gusta usar closures.
Compilan al mismo código, así que usa el estilo que sea más claro para ti.</p>
<h3 id="retornando-closures"><a class="header" href="#retornando-closures">Retornando Closures</a></h3>
<p>Los closures se representan mediante traits, lo que significa que no puedes
devolver closures directamente. En la mayoría de los casos en los que podrías
querer devolver un trait, puedes usar en su lugar el tipo concreto que
implementa el trait como el valor de retorno de la función. Sin embargo, no
puedes hacer eso con los closures porque no tienen un tipo concreto que se
pueda devolver; no se te permite usar el puntero a función <code>fn</code> como un tipo
de retorno, por ejemplo.</p>
<p>El siguiente código intenta devolver un closure directamente, pero no
compilará:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre>
<p>El error del compilador es el siguiente:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type
  |
1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
  |                         ~~~~
help: box the return type, and wrap all of the returned values in `Box::new`
  |
1 ~ fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
2 ~     Box::new(|x| x + 1)
  |

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` (lib) due to 1 previous error
</code></pre>
<p>¡El error hace referencia nuevamente al trait <code>Sized</code>! Rust no sabe cuánto
espacio necesitará para almacenar el closure. Vimos una solución a este
problema anteriormente. Podemos usar un trait object:</p>
<pre><code class="language-rust noplayground">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}</code></pre>
<p>Este código se compilará correctamente. Para obtener más información sobre los
trait objects, consulta la sección <a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">“Usando trait objects que permiten valores
de diferentes
tipos”</a></p>
<!-- ignore --> en el Capítulo 17.
<p>¡Ahora veamos las macros!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Hemos utilizado macros como <code>println!</code> a lo largo de este libro, pero no hemos
explorado completamente qué es una macro y cómo funciona. El término <em>macro</em> se
refiere a una familia de características en Rust: macros <em>declarativas</em> con
<code>macro_rules!</code> y tres tipos de macros <em>procedurales</em>:</p>
<ul>
<li>Macros Personalizadas <code>#[derive]</code> que especifican código agregado con el</li>
<li>atributo <code>derive</code> usado en structs y enums</li>
<li>Macros similares a atributos que definen atributos personalizados utilizables
en cualquier item</li>
<li>Macros similares a funciones que se ven como llamadas a funciones, pero
operan en los tokens especificados como argumento</li>
</ul>
<p>Hablaremos de cada uno de estos a su vez, pero primero, veamos por qué
necesitamos macros cuando ya tenemos funciones.</p>
<h3 id="la-diferencia-entre-macros-y-funciones"><a class="header" href="#la-diferencia-entre-macros-y-funciones">La Diferencia Entre Macros y Funciones</a></h3>
<p>Fundamentalmente, las macros son una forma de escribir código que escribe otro
código, lo que se conoce como <em>metaprogramación</em>. En el Apéndice C, discutimos
el atributo <code>derive</code>, que genera una implementación de varios traits para ti.
También hemos usado las macros <code>println!</code> y <code>vec!</code> a lo largo del libro. Todas
estas macros <em>se expanden</em> para producir más código que el código que has
escrito manualmente.</p>
<p>La metaprogramación es útil para reducir la cantidad de código que tienes que
escribir y mantener, que también es uno de los roles de las funciones. Sin
embargo, las macros tienen algunos poderes adicionales que las funciones no
tienen.</p>
<p>Una función debe declarar el número y el tipo de parámetros que tiene la
función. Las macros, por otro lado, pueden tomar un número variable de
parámetros: podemos llamar a <code>println!(&quot;hello&quot;)</code> con un argumento o
<code>println!(&quot;hello {}&quot;, name)</code> con dos argumentos. Además, las macros se
expanden antes de que el compilador interprete el significado del código, por
lo que una macro puede, por ejemplo, implementar un trait en un tipo dado. Una
función no puede, porque se llama en tiempo de ejecución y un trait debe
implementarse en tiempo de compilación.</p>
<p>La desventaja de implementar una macro en lugar de una función es que las
definiciones de macros son más complejas que las definiciones de funciones
porque estás escribiendo código Rust que escribe código Rust. Debido a esta
indirección, las definiciones de macros generalmente son más difíciles de leer,
entender y mantener que las definiciones de funciones.</p>
<p>Otra diferencia importante entre las macros y las funciones es que debes
definir macros o traerlas al scope <em>antes</em> de llamarlas en un archivo, a
diferencia de las funciones que puedes definir en cualquier lugar y llamar en
cualquier lugar.</p>
<h3 id="macros-declarativas-con-macro_rules-para-metaprogramacion-general"><a class="header" href="#macros-declarativas-con-macro_rules-para-metaprogramacion-general">Macros Declarativas con <code>macro_rules!</code> para Metaprogramacion General</a></h3>
<p>La forma más utilizada de macros en Rust es la <em>macro declarativa</em>. A veces
también se denominan “macros por ejemplo”, “<code>macro_rules!</code> macros” o simplemente
“macros”. En su núcleo, las macros declarativas te permiten escribir algo
similar a una expresión <code>match</code> de Rust. Como se discutió en el Capítulo 6, las
expresiones <code>match</code> son estructuras de control que toman una expresión,
comparan el valor resultante de la expresión con patrones y luego ejecutan el
código asociado con el patrón coincidente. Las macros también comparan un valor
con patrones que están asociados con un código particular: en esta situación,
el valor es el código fuente literal de Rust que se pasa a la macro; los
patrones se comparan con la estructura de ese código fuente; y el código
asociado con cada patrón, cuando coincide, reemplaza el código pasado a la
macro. Todo esto sucede durante la compilación.</p>
<p>Para definir una macro, usas el constructor <code>macro_rules!</code>. Exploremos cómo
usar <code>macro_rules!</code> mirando cómo se define la macro <code>vec!</code>. El Capítulo 8
cubrió cómo podemos usar la macro <code>vec!</code> para crear un nuevo vector con valores
particulares. Por ejemplo, la siguiente macro crea un nuevo vector que contiene
tres enteros:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>También podemos usar la macro <code>vec!</code> para crear un vector de dos enteros o un
vector de cinco string slices. No podríamos usar una función porque no
conoceríamos el número o el tipo de valores.</p>
<p>El Listado 19-28 muestra una definición ligeramente simplificada de la macro
<code>vec!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<p><span class="caption">Listing 19-28: Una versión simplificada de la definición
de la macro <code>vec!</code></span></p>
<blockquote>
<p>Nota: La definición real de la macro <code>vec!</code> en la biblioteca estándar incluye
código para preasignar la cantidad correcta de memoria por adelantado. Ese
código es una optimización que no incluimos aquí para hacer el ejemplo más
simple.</p>
</blockquote>
<p>La anotación <code>#[macro_export]</code> indica que esta macro debe estar disponible
siempre que la biblioteca en la que se define la macro se traiga al scope. Sin
esta anotación, la macro no se puede traer al scope.</p>
<p>Luego comenzamos la definición de la macro con <code>macro_rules!</code> y el nombre de la
macro que estamos definiendo <em>sin</em> el signo de exclamación. El nombre, en este
caso <code>vec</code>, va seguido de llaves que denotan el cuerpo de la definición de la
macro.</p>
<p>La estructura en el cuerpo de <code>vec!</code> es similar a la estructura de una
expresión <code>match</code>. Aquí tenemos un brazo con el patrón <code>( $( $x:expr ),* )</code>,
seguido de <code>=&gt;</code> y el bloque de código asociado con este patrón. Si el patrón
coincide, se emitirá el bloque de código asociado. Dado que este es el único
patrón en esta macro, solo hay una forma válida de coincidir; cualquier otro
patrón dará como resultado un error. Las macros más complejas tendrán más de una
opción.</p>
<p>La sintaxis válida del pattern en una macro es diferente de la sintaxis de los
patterns cubiertos en el Capítulo 18 porque los patterns de macro se comparan
con la estructura del código Rust en lugar de con valores. Recorramos lo que
significan las piezas del pattern en el Listado 19-28; para obtener la sintaxis
completa del pattern de macro, consulte la <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Referencia de Rust</a>.</p>
<p>Primero, usamos un conjunto de paréntesis para englobar todo el patrón. Usamos
el signo de dólar (<code>$</code>) para declarar una variable en el sistema de macros que
contendrá el código Rust que coincida con el patrón. El signo de dólar hace que
quede claro que esta es una variable de macro en lugar de una variable regular
de Rust. A continuación, viene un conjunto de paréntesis que captura los valores
que coinciden con el patrón dentro de los paréntesis para su uso en el código de
reemplazo. Dentro de <code>$()</code> está <code>$x:expr</code>, que coincide con cualquier expresión
de Rust y le da el nombre <code>$x</code>.</p>
<p>La coma que sigue a <code>$()</code> índica que opcionalmente podría aparecer un carácter
de coma separador literal después del código que coincide con el código en
<code>$()</code>. Él <code>*</code> especifica que el patrón coincide cero o más veces con lo que
precede al <code>*</code>.</p>
<p>Cuando llamamos a esta macro con <code>vec![1, 2, 3];</code>, el patrón <code>$x</code> coincide tres
veces con las tres expresiones <code>1</code>, <code>2</code> y <code>3</code>.</p>
<p>Ahora veamos el pattern en el cuerpo del código asociado con esta opción:
<code>temp_vec.push($x);</code>. Dentro de <code>$()*</code> se genera para cada parte que coincide
con <code>$()</code> en el patrón cero o más veces dependiendo de cuántas veces coincida
el patrón. Él <code>$x</code> se reemplaza con cada expresión que coincida. Cuando llamamos
a esta macro con <code>vec![1, 2, 3];</code>, el código generado que reemplaza esta
llamada a la macro será el siguiente:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>Hemos definido una macro que puede tomar cualquier número de argumentos de
cualquier tipo y puede generar código para crear un vector que contenga los
elementos especificados.</p>
<p>Para obtener más información sobre cómo escribir macros, consulta la
documentación en línea u otros recursos, como <a href="https://veykril.github.io/tlborm/">“The Little Book of Rust
Macros”</a> iniciado por Daniel Keep y continuado por Lukas Wirth.</p>
<h3 id="macros-procedurales-para-generar-código-a-partir-de-atributos"><a class="header" href="#macros-procedurales-para-generar-código-a-partir-de-atributos">Macros Procedurales para Generar Código a partir de Atributos</a></h3>
<p>Las macros procedurales, que es la segunda forma de macros, actúan más como
una función (y son un tipo de procedimiento). Las macros procedurales aceptan
código como entrada, operan en ese código y producen código como salida en
lugar de coincidir con patrones y reemplazar el código por otro código como lo
hacen las macros declarativas. Los tres tipos de macros procedurales son
derivaciones personalizadas, atributos y funciones, y todas funcionan de manera
similar.</p>
<p>Al crear macros procedurales, las definiciones deben residir en su propio
crate con un tipo de crate especial. Esto se debe a razones técnicas complejas
que esperamos eliminar en el futuro. En el Listado 19-29 se muestra cómo se
define una macro procedural, donde <code>some_attribute</code> es un marcador de posición
para usar un tipo específico de macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Listing 19-29: Un ejemplo de definición de una macro
procedural</span></p>
<p>La función que define una macro procedural tome un <code>TokenStream</code> como entrada y
devuelve un <code>TokenStream</code> como salida. El <code>TokenStream</code> tipo es definido por el
<code>proc_macro</code> crate que se incluye con Rust y representa una secuencia de tokens.
Esta es la base de la macro: el código fuente en el que la macro está operando
constituye la entrada <code>TokenStream</code>, y el código que la macro produce es el
<code>TokenStream</code> de salida. La función también tiene un atributo adjunto que
especifica qué tipo de macro procedural estamos creando. Podemos tener varios
tipos de macros procedurales en el mismo crate.</p>
<p>Veamos los diferentes tipos de macros procedurales. Comenzaremos con una
derivación personalizada y luego explicaremos las pequeñas diferencias que
hacen que las otras formas sean diferentes.</p>
<h3 id="cómo-escribir-una-macro-derive-personalizada"><a class="header" href="#cómo-escribir-una-macro-derive-personalizada">Cómo Escribir una Macro <code>derive</code> Personalizada</a></h3>
<p>Creemos un crate llamado <code>hello_macro</code> que defina un trait llamado
<code>HelloMacro</code> con una función asociada llamada <code>hello_macro</code>. En lugar de hacer
que nuestros usuarios implementen el trait <code>HelloMacro</code> para cada uno de sus
tipos, proporcionaremos una macro procedural para que los usuarios puedan
anotar sus tipos con <code>#[derive(HelloMacro)]</code> para obtener una implementación
predeterminada de la función <code>hello_macro</code>. La implementación predeterminada
imprimirá <code>Hello, Macro! My name is TypeName!</code>, donde <code>TypeName</code> es el nombre
del tipo en el que se ha definido este trait. En otras palabras, escribiremos
un crate que permita a otro programador escribir código como el Listado 19-30
usando nuestro crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Listing 19-30: El código que un usuario de nuestro crate
podrá escribir cunado se use nuestra macro procedural</span></p>
<p>Este código imprimirá <code>Hello, Macro! My name is Pancakes!</code> cuando hayamos
terminado. El primer paso es hacer un nuevo crate de biblioteca, así:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>A continuación, definiremos el trait <code>HelloMacro</code> y su función asociada:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<p>Tenemos un trait y su función. En este punto, nuestro usuario de crate podría
implementar el trait para lograr la funcionalidad deseada, así:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>Sin embargo, tendrían que escribir el bloque de implementación para cada tipo
que quisieran usar con <code>hello_macro</code>; queremos evitar que tengan que hacer este
trabajo.</p>
<p>Además, aún no podemos proporcionar una implementación predeterminada de
la función <code>hello_macro</code> que imprimirá el nombre del tipo en el que se
implementa el trait: rust no tiene capacidades de reflexión, por lo que no
puede buscar el nombre del tipo en tiempo de ejecución. Necesitamos una macro
para generar código en tiempo de compilación.</p>
<p>El siguiente paso es definir la macro procedural. En el momento de escribir
esto, las macros procedurales deben estar en su propio crate. Eventualmente,
esta restricción podría ser levantada. La convención para estructurar crates y
macro crates es la siguiente: para un crate llamado <code>foo</code>, un crate de macro
procedural de derivación personalizada se llama <code>foo_derive</code>. Creemos un nuevo
crate llamado <code>hello_macro_derive</code> dentro de nuestro proyecto <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Nuestros dos crates están estrechamente relacionados, por lo que creamos el
crate de macro procedural dentro del directorio de nuestro crate <code>hello_macro</code>.
Si cambiamos la definición del trait en <code>hello_macro</code>, también tendremos que
cambiar la implementación de la macro procedural en <code>hello_macro_derive</code>. Los
dos crates deberán publicarse por separado, y los programadores que usen estos
crates deberán agregar ambos como dependencias y traerlos a ambos al scope.
En su lugar, podríamos hacer que el crate <code>hello_macro</code> use <code>hello_macro_derive</code>
como una dependencia y vuelva a exportar el código de la macro procedural.
Sin embargo, la forma en que hemos estructurado el proyecto hace posible que
los programadores usen <code>hello_macro</code> incluso si no quieren la funcionalidad
<code>derive</code>.</p>
<p>Necesitamos declarar el crate <code>hello_macro_derive</code> como un crate de macro
procedural. También necesitaremos funcionalidad de los crates <code>syn</code> y <code>quote</code>,
como veremos en un momento, por lo que necesitamos agregarlos como dependencias.
Agrega lo siguiente al archivo <em>Cargo.toml</em> para <code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;2.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>Para comenzar a definir la macro procedural, coloca el código del Listado 19-31
en tu archivo <em>src/lib.rs</em> para el crate <code>hello_macro_derive</code>. Ten en cuenta que
este código no se compilará hasta que agreguemos una definición para la función
<code>impl_hello_macro</code>.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}</code></pre>
<p><span class="caption">Listing 19-31: Código que la mayoría de los crates de
macros procedurales requerirán para procesar código Rust</span></p>
<p>Observa que hemos dividido el código en la función <code>hello_macro_derive</code>, que
es responsable de analizar el <code>TokenStream</code>, y la función <code>impl_hello_macro</code>,
que es responsable de transformar el árbol de sintaxis: esto hace que escribir
una macro procedural sea más conveniente. El código en la función externa
(<code>hello_macro_derive</code> en este caso) será el mismo para casi todos los crates de
macros procedurales que veas o crees. El código que especifiques en el cuerpo
de la función interna (<code>impl_hello_macro</code> en este caso) será diferente
dependiendo del propósito de tu macro procedural.</p>
<p>Hemos introducido tres nuevos crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, y <a href="https://crates.io/crates/quote"><code>quote</code></a>. El
crate <code>proc_macro</code> viene con Rust, por lo que no necesitamos agregarlo a las
dependencias en <em>Cargo.toml</em>. El crate <code>proc_macro</code> es la API del compilador
que nos permite leer y manipular código Rust desde nuestro código.</p>
<p>El crate <code>syn</code> analiza el código Rust desde un string en una estructura de
datos en la que podemos realizar operaciones. El crate <code>quote</code> convierte las
estructuras de datos de <code>syn</code> nuevamente en código Rust. Estos crates hacen que
sea mucho más simple analizar cualquier tipo de código Rust que deseemos
manipular: escribir un analizador completo para el código Rust no es una tarea
sencilla.</p>
<p>La función <code>hello_macro_derive</code> se llamará cuando un usuario de nuestro crate
especifique <code>#[derive(HelloMacro)]</code> en un tipo. Esto es posible porque hemos
anotado la función <code>hello_macro_derive</code> aquí con <code>proc_macro_derive</code> y
especificado el nombre <code>HelloMacro</code>, que coincide con el nombre de nuestro
trait; esta es la convención que siguen la mayoría de las macros procedurales.</p>
<p>La función <code>hello_macro_derive</code> convierte primero el <code>input</code> de un
<code>TokenStream</code> a una estructura de datos que podemos interpretar y realizar
operaciones. Aquí es donde entra en juego <code>syn</code>. La función <code>parse</code> en <code>syn</code>
toma un <code>TokenStream</code> y devuelve un struct <code>DeriveInput</code> que representa el
código Rust analizado. El Listado 19-32 muestra las partes relevantes del
struct <code>DeriveInput</code> que obtenemos al analizar el string <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Listing 19-32: La instancia <code>DeriveInput</code> que obtenemos
al analizar el código que tiene el atributo de la macro en el
Listado 19-30</span></p>
<p>Los campos de este struct muestran que el código Rust que hemos analizado es un
struct unitario con el <code>ident</code> (identificador, es decir, el nombre) de
<code>Pancakes</code>. Hay más campos en este struct para describir todo tipo de código
Rust; consulta la <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html">documentación de <code>syn</code> para <code>DeriveInput</code></a> para
obtener más información.</p>
<p>Pronto definiremos la función <code>impl_hello_macro</code>, que es donde construiremos el
código Rust que queremos incluir. Pero antes de hacerlo, ten en cuenta que la
salida de nuestra macro derive también es un <code>TokenStream</code>. El <code>TokenStream</code>
devuelto se agrega al código que escriben los usuarios de nuestro crate, por lo
que cuando compilan su crate, obtendrán la funcionalidad adicional que
proporcionamos en el <code>TokenStream</code> modificado.</p>
<p>Es posible que hayas notado que estamos usando <code>unwrap</code> para hacer que la
función <code>hello_macro_derive</code> genere un panic si la llamada a la función
<code>syn::parse</code> falla. Es necesario que nuestra macro procedural genere un panic
en caso de error porque las funciones <code>proc_macro_derive</code> deben devolver
<code>TokenStream</code> en lugar de <code>Result</code> para cumplir con la API de las macros
procedurales. Hemos simplificado este ejemplo usando <code>unwrap</code>; en código de
producción, debes proporcionar mensajes de error más específicos sobre lo que
salió mal usando <code>panic!</code> o <code>expect</code>.</p>
<p>Ahora que tenemos el código para convertir el código de Rust anotado de un
<code>TokenStream</code> a una instancia <code>DeriveInput</code>, generemos el código que implementa
el trait <code>HelloMacro</code> en el tipo anotado, como se muestra en el Listado 19-33.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<p><span class="caption">Listing 19-33: Implementando el trait <code>HelloMacro</code> usando
el código Rust analizado</span></p>
<p>Obtenemos una instancia del struct <code>DeriveInput</code> que contiene el nombre
(identificador) del tipo anotado usando <code>ast.ident</code>. El struct en el Listado
19-32 muestra que cuando ejecutamos la función <code>impl_hello_macro</code> en el código
del Listado 19-30, el <code>ident</code> que obtenemos tendrá el campo <code>ident</code> con un
valor de <code>&quot;Pancakes&quot;</code>. Por lo tanto, la variable <code>name</code> en el Listado 19-33
contendrá una instancia del struct <code>Ident</code> que, cuando se imprima, será la
cadena <code>&quot;Pancakes&quot;</code>, el nombre del struct en el Listado 19-30.</p>
<p>La macro <code>quote!</code> nos permite construir el código que queremos devolver. El
compilador espera algo diferente al resultado directo de la ejecución de la
macro <code>quote!</code>, por lo que debemos convertirlo a un <code>TokenStream</code>. Hacemos esto
llamando al método <code>into</code>, que consume esta representación intermedia y
devuelve un valor del tipo <code>TokenStream</code> requerido.</p>
<p>La macro <code>quote!</code> también proporciona algunas mecánicas de plantillas muy
interesantes: podemos ingresar <code>#name</code>, y <code>quote!</code> lo reemplazará con el valor
de la variable <code>name</code>. Incluso puedes hacer alguna repetición similar a la forma
en que funcionan las macros regulares. Consulta <a href="https://docs.rs/quote">la documentación del crate
<code>quote</code></a> para obtener una introducción completa.</p>
<p>Queremos que nuestra macro procedural genere una implementación de nuestro
trait <code>HelloMacro</code> para el tipo que el usuario ha anotado, lo cual podemos
lograr utilizando <code>#name</code>. La implementación del trait tiene la función
<code>hello_macro</code>, cuyo cuerpo contiene la funcionalidad que queremos proporcionar:
imprimir <code>Hello, Macro! My name is</code> y luego el nombre del tipo anotado.</p>
<p>La macro <code>stringify!</code> utilizada aquí está incorporada en Rust. Toma una
expresión de Rust como <code>1 + 2</code> y en tiempo de compilación convierte la
expresión en un literal de string como <code>&quot;1 + 2&quot;</code>. Esto es diferente a <code>format!</code>
o <code>println!</code>, macros que evalúan la expresión y luego convierten el resultado en
un <code>String</code>. Existe la posibilidad de que la entrada <code>#name</code> sea una expresión
para imprimir literalmente, por lo que usamos <code>stringify!</code>. El uso de
<code>stringify!</code> también ahorra una asignación al convertir <code>#name</code> en un literal
de string en tiempo de compilación.</p>
<p>En este punto, <code>cargo build</code> debería completarse correctamente tanto en
<code>hello_macro</code> como en <code>hello_macro_derive</code>. ¡Conectemos estos crates al código
del Listado 19-30 para ver la macro procedural en acción! Crea un nuevo
proyecto binario en tu directorio <em>projects</em> usando <code>cargo new pancakes</code>.
Necesitamos agregar <code>hello_macro</code> y <code>hello_macro_derive</code> como dependencias en el
<em>Cargo.toml</em> de <code>pancakes</code>. Si estás publicando tus versiones de <code>hello_macro</code>
y <code>hello_macro_derive</code> en <a href="https://crates.io/">crates.io</a>, serían dependencias
regulares; si no, puedes especificarlas como dependencias <code>path</code> de la
siguiente manera:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Coloca el código del Listado 19-30 en <em>src/main.rs</em> y ejecuta <code>cargo run</code>:
debería imprimir <code>Hello, Macro! My name is Pancakes!</code> La implementación del
trait <code>HelloMacro</code> de la macro procedural se incluyó sin que el crate <code>pancakes</code>
tuviera que implementarlo; la macro <code>#[derive(HelloMacro)]</code> agregó la
implementación del trait.</p>
<p>A continuación, vamos a explorar cómo los otros tipos de macros procedurales
difieren de las macros derive personalizadas.</p>
<h3 id="macros-similares-a-atributos"><a class="header" href="#macros-similares-a-atributos">Macros similares a atributos</a></h3>
<p>Las macros similares a atributos son similares a las macros derivadas
personalizadas, pero en lugar de generar código para el atributo <code>derive</code>,
permiten crear nuevos atributos. También son más flexibles: <code>derive</code> solo
funciona para structs y enums; los atributos se pueden aplicar a otros items
también, como funciones. Aquí hay un ejemplo de uso de una macro similar a un
atributo: digamos que tienes un atributo llamado <code>route</code> que anota funciones
cuando se usa un framework de aplicación web:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {</code></pre>
<p>El atributo <code>#[route]</code> será definido por el framework como una macro procedural.
La firma de la función de definición de la macro se vería así:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Aquí, tenemos dos parámetros de tipo <code>TokenStream</code>. El primero es para el
contenido del atributo: la parte <code>GET, &quot;/&quot;</code>. El segundo es el cuerpo del item
al que se adjunta el atributo: en este caso, <code>fn index() {}</code> y el resto del
cuerpo de la función.</p>
<p>Aparte de eso, las macros similares a atributos funcionan de la misma manera
que las macros derivadas personalizadas: creas un crate con el tipo <code>proc-macro</code>
y defines una función que genera el código que deseas.</p>
<h3 id="macros-similares-a-funciones"><a class="header" href="#macros-similares-a-funciones">Macros similares a funciones</a></h3>
<p>Las macros tipo función definen macros que se ven como llamadas a funciones.
De manera similar a las macros <code>macro_rules!</code>, son más flexibles que las
funciones; por ejemplo, pueden tomar un número desconocido de argumentos. Sin
embargo, las macros <code>macro_rules!</code> solo se pueden definir usando la sintaxis
similar a la de los patterns que discutimos en la sección <a href="ch19-06-macros.html#macros-declarativas-con-macro_rules-para-metaprogramacion-general">“Macros declarativas
con <code>macro_rules!</code> para metaprogramación general”</a><!-- ignore -->
anteriormente. Las macros tipo función toman un parámetro <code>TokenStream</code> y su
definición manipula ese <code>TokenStream</code> usando código Rust como los otros dos
tipos de macros procedurales. Un ejemplo de una macro tipo función es una macro
<code>sql!</code> que podría ser llamada así:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>Esta macro analizaría la declaración SQL dentro de ella y verificaría que sea
sintácticamente correcta, lo cual es un procesamiento mucho más complejo de lo
que una macro <code>macro_rules!</code> puede hacer. La macro <code>sql!</code> se definiría así:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Esta definición es similar a la firma de la macro de derivación personalizada:
recibimos los tokens que están dentro de los paréntesis y devolvemos el código
que queremos generar.</p>
<h2 id="resumen-18"><a class="header" href="#resumen-18">Resumen</a></h2>
<p>¡Uf! Ahora que tienes algunas características de Rust en tu caja de herramientas
que probablemente no usarás a menudo, pero sabrás que están disponibles en
circunstancias muy particulares. Hemos introducido varios temas complejos para
que cuando los encuentres en sugerencias de mensajes de error o en el código de
otras personas, puedas reconocer estos conceptos y sintaxis. Usa este capítulo
como referencia para guiarte hacia soluciones.</p>
<p>¡A continuación, pondremos en práctica todo lo que hemos discutido a lo largo
del libro y haremos un proyecto más!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proyecto-final-construyendo-un-servidor-web-multithread"><a class="header" href="#proyecto-final-construyendo-un-servidor-web-multithread">Proyecto final: Construyendo un servidor web multithread</a></h1>
<p>Ha sido un largo viaje, pero hemos llegado al final del libro. En este
capítulo, construiremos un proyecto más para demostrar algunos de los
conceptos que cubrimos en los capítulos finales, así como recapitular algunas
lecciones anteriores.</p>
<p>Para nuestro proyecto final, haremos un servidor web que diga &quot;hola&quot; y se vea
como la Figura 20-1 en un navegador web.</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">Figure 20-1: Nuestro proyecto final compartido</span></p>
<p>Aquí está nuestro plan para construir el web server:</p>
<ol>
<li>Aprender un poco sobre TCP y HTTP.</li>
<li>Escuchar conexiones TCP en un socket.</li>
<li>Analizar un pequeño número de peticiones HTTP.</li>
<li>Crear una respuesta HTTP adecuada.</li>
<li>Mejorar el rendimiento de nuestro servidor con un <em>thread pool</em>.</li>
</ol>
<p>Antes de comenzar, debemos mencionar un detalle: el método que usaremos no
será la mejor manera de construir un servidor web con Rust. Los miembros de la
comunidad han publicado una serie de <em>crates</em> listos para producción
disponibles en <a href="https://crates.io/">crates.io</a> que proporcionan servidores web
y <em>thread pools</em> más completos que los que construiremos. Sin embargo, nuestra
intención en este capítulo es ayudarte a aprender, no tomar el camino fácil.
Debido a que Rust es un lenguaje de programación de sistemas, podemos elegir el
nivel de abstracción con el que queremos trabajar y podemos ir a un nivel más
bajo de lo que es posible o práctico en otros lenguajes. Por lo tanto,
escribiremos el servidor HTTP básico y el <em>thread pool</em> manualmente para que
puedas aprender las ideas y técnicas generales detrás de los <em>crates</em> que
podrías usar en el futuro.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="construyendo-un-servidor-web-de-un-solo-hilo"><a class="header" href="#construyendo-un-servidor-web-de-un-solo-hilo">Construyendo un servidor web de un solo hilo</a></h2>
<p>Comenzaremos haciendo funcionar un servidor web de un solo hilo. Antes de
comenzar, veamos una breve descripción general de los protocolos involucrados
en la construcción de servidores web. Los detalles de estos protocolos están
fuera del alcance de este libro, pero una breve descripción general le dará la
información que necesita.</p>
<p>Los dos protocolos principales involucrados en los servidores web son <em>Hypertext
Transfer Protocol</em> <em>(HTTP)</em> y <em>Transmission Control Protocol</em> <em>(TCP)</em>. Ambos
protocolos son protocolos de <em>solicitud-respuesta</em>, lo que significa que un
<em>cliente</em> inicia solicitudes y un <em>servidor</em> escucha las solicitudes y
proporciona una respuesta al cliente. El contenido de esas solicitudes y
respuestas está definido por los protocolos.</p>
<p>TCP es el protocolo de nivel inferior que describe los detalles de cómo la
información pasa de un servidor a otro, pero no especifica qué es esa
información. HTTP se basa en TCP definiendo el contenido de las solicitudes y
respuestas. Técnicamente, es posible usar HTTP con otros protocolos, pero en la
gran mayoría de los casos, HTTP envía sus datos a través de TCP. Trabajaremos
con los bytes sin procesar de las solicitudes y respuestas de TCP y HTTP.</p>
<h3 id="escuchando-la-conexión-tcp"><a class="header" href="#escuchando-la-conexión-tcp">Escuchando la conexión TCP</a></h3>
<p>Nuestro servidor web debe escuchar una conexión TCP, por lo que esa es la
primera parte en la que trabajaremos. La biblioteca estándar ofrece un módulo
<code>std::net</code> que nos permite hacer esto. Hagamos un nuevo proyecto de la manera
habitual:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Ahora agreguemos el código en el Listado 20-1 en <em>src/main.rs</em> para comenzar.
Este código escuchará en la dirección local <code>127.0.0.1:7878</code> para flujos TCP
entrantes. Cuando recibe un flujo entrante, imprimirá <code>¡Conexión establecida!</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listing 20-1: Escuchar transmisiones entrantes e imprimir
un mensaje cuando recibimos una transmisión</span></p>
<p>Usando <code>TcpListener</code>, podemos escuchar conexiones TCP en la dirección
<code>127.0.0.1:7878</code>. En la dirección, la sección antes de los dos puntos es una
dirección IP que representa su computadora (esto es lo mismo en todas las
computadoras y no representa la computadora de los autores en particular), y
<code>7878</code> es el puerto. Hemos elegido este puerto por dos razones: HTTP no se
acepta normalmente en este puerto, por lo que es poco probable que nuestro
servidor entre en conflicto con cualquier otro servidor web que pueda tener
ejecutándose en su máquina, y 7878 es <em>rust</em> escrito en un teléfono.</p>
<p>La función <code>bind</code> en este escenario funciona como la función <code>new</code> en que
devolverá una nueva instancia de <code>TcpListener</code>. La función se llama <code>bind</code>
porque, en redes, conectarse a un puerto para escuchar se conoce como “enlazar
a un puerto”.</p>
<p>La función <code>bind</code> devuelve un <code>Result&lt;T, E&gt;</code>, que indica que es posible que el
enlace falle. Por ejemplo, conectarse al puerto 80 requiere privilegios de
administrador (los no administradores solo pueden escuchar en puertos superiores
a 1023), por lo que si intentáramos conectarnos al puerto 80 sin ser un
administrador, el enlace no funcionaría. El enlace tampoco funcionaría, por
ejemplo, si ejecutáramos dos instancias de nuestro programa y, por lo tanto,
tuvimos dos programas escuchando el mismo puerto. Debido a que estamos
escribiendo un servidor básico solo con fines de aprendizaje, no nos
preocuparemos por manejar este tipo de errores; en su lugar, usamos <code>unwrap</code>
para detener el programa si ocurren errores.</p>
<p>El método <code>incoming</code> en <code>TcpListener</code> devuelve un iterator que nos da una
secuencia de flujos (más específicamente, flujos de tipo <code>TcpStream</code>). Un solo
<em>flujo</em> representa una conexión abierta entre el cliente y el servidor. Una
<em>conexión</em> es el nombre del proceso de solicitud y respuesta completo en el que
un cliente se conecta al servidor, el servidor genera una respuesta y el
servidor cierra la conexión. Como tal, leeremos del <code>TcpStream</code> para ver lo que
el cliente envió y luego escribiremos nuestra respuesta en el flujo para enviar
datos de vuelta al cliente. En general, este bucle <code>for</code> procesará cada
conexión a su vez y producirá una serie de flujos para que los manejemos.</p>
<p>Por ahora, nuestro manejo del flujo consiste en llamar a <code>unwrap</code> para terminar
nuestro programa si el flujo tienen algún error; si no hay errores, el programa
imprime un mensaje. Agregaremos más funcionalidad para el caso de éxito en el
siguiente listado. La razón por la que podríamos recibir errores del método
<code>incoming</code> cuando un cliente se conecta al servidor es que en realidad no
iteramos sobre las conexiones. En cambio, iteramos sobre <em>intentos de
conexión</em>. La conexión podría no tener éxito por una serie de razones, muchas
de ellas específicas del sistema operativo. Por ejemplo, muchos sistemas
operativos tienen un límite para el número de conexiones abiertas simultáneas
que pueden admitir; los nuevos intentos de conexión más allá de ese número
producirán un error hasta que algunas de las conexiones abiertas se cierren.</p>
<p>¡Intentemos ejecutar este código! Invoca <code>cargo run</code> en la terminal y luego
carga <em>127.0.0.1:7878</em> en un navegador web. El navegador debería mostrar un
mensaje de error como “Conexión restablecida”, porque el servidor no está
enviando ningún dato actualmente. ¡Pero cuando miras tu terminal, deberías ver
varios mensajes que se imprimieron cuando el navegador se conectó al servidor!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>A veces, verás múltiples mensajes impresos para una solicitud del navegador; la
razón podría ser que el navegador está haciendo una solicitud para la página
además de una solicitud para otros recursos, como el icono <em>favicon.ico</em> que
aparece en la pestaña del navegador.</p>
<p>También podría ser que el navegador esté intentando conectarse al servidor
varias veces porque el servidor no está respondiendo con ningún dato. Cuando
<code>stream</code> sale del scope y se descarta al final del bucle, la conexión se cierra
como parte de la implementación de <code>drop</code>. Los navegadores a veces tratan con
conexiones cerradas volviendo a intentar, porque el problema podría ser
temporal. ¡El factor importante es que hemos obtenido con éxito un controlador
para una conexión TCP!</p>
<p>Recuerda detener el programa presionando <span class="keystroke">ctrl-c</span>
cuando hayas terminado de ejecutar una versión particular del código. Luego
reinicia el programa invocando el comando <code>cargo run</code> después de haber hecho
cambios de código para asegurarte de que estás ejecutando el código más nuevo.</p>
<h3 id="leyendo-la-solicitud"><a class="header" href="#leyendo-la-solicitud">Leyendo la solicitud</a></h3>
<p>¡Vamos a implementar la funcionalidad para leer la solicitud del navegador!. Para
separar las preocupaciones de obtener primero una conexión y luego tomar alguna
acción con la conexión, iniciaremos una nueva función para procesar conexiones.
En esta nueva función <code>handle_connection</code>, leeremos datos del flujo TCP e
imprimiremos para que podamos ver los datos que se envían desde el navegador.
Cambia el código para que se vea como el Listado 20-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!(&quot;Request: {http_request:#?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 20-2: Leyendo desde el <code>TcpStream</code> e imprimiendo
los datos</span></p>
<p>Importamos <code>std::io::prelude</code> y <code>std::io::BufReader</code> para obtener acceso a los
traits y tipos que nos permiten leer del flujo. En el bucle <code>for</code> en la función
<code>main</code>, en lugar de imprimir un mensaje que diga que hicimos una conexión,
ahora llamamos a la nueva función <code>handle_connection</code> y le pasamos el <code>stream</code>.</p>
<p>En la función <code>handle_connection</code>, creamos una nueva instancia de <code>BufReader</code>
que envuelve una referencia mutable al <code>stream</code>. <code>BufReader</code> agrega
almacenamiento en búfer al administrar las llamadas a los métodos del trait
<code>std::io::Read</code> por nosotros.</p>
<p>Creamos una variable llamada <code>http_request</code> para recopilar las líneas de la
solicitud que el navegador envía a nuestro servidor. Indicamos que queremos
recopilar estas líneas en un vector agregando la anotación de tipo <code>Vec&lt;_&gt;</code>.</p>
<p><code>BufReader</code> implementa el trait <code>std::io::BufRead</code>, que proporciona el método
<code>lines</code>. El método <code>lines</code> devuelve un iterator de <code>Result&lt;String, std::io::Error&gt;</code> al dividir el flujo de datos cada vez que ve un byte de nueva
línea. Para obtener cada <code>String</code>, mapeamos y <code>unwrap</code> cada <code>Result</code>. El
<code>Result</code> podría ser un error si los datos no son válidos UTF-8 o si hubo un
problema al leer del flujo. Nuevamente, un programa de producción debería
manejar estos errores de manera más elegante, pero estamos eligiendo detener el
programa en el caso de error por simplicidad.</p>
<p>El navegador señala el final de una solicitud HTTP enviando dos caracteres de
nueva línea seguidos, por lo que para obtener una solicitud del flujo, tomamos
líneas hasta que obtenemos una línea que es el string vacío. Una vez que hemos
recopilado las líneas en el vector, las imprimimos usando el formato de
depuración bonito para que podamos echar un vistazo a las instrucciones que el
navegador web está enviando a nuestro servidor.</p>
<p>¡Probemos este código! Inicia el programa y luego carga realiza una solicitud
en un navegador web nuevamente. Ten en cuenta que aún obtendremos una página de
error en el navegador, pero la salida del programa en la terminal se verá
similar a esto:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    &quot;GET / HTTP/1.1&quot;,
    &quot;Host: 127.0.0.1:7878&quot;,
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0&quot;,
    &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Language: en-US,en;q=0.5&quot;,
    &quot;Accept-Encoding: gzip, deflate, br&quot;,
    &quot;DNT: 1&quot;,
    &quot;Connection: keep-alive&quot;,
    &quot;Upgrade-Insecure-Requests: 1&quot;,
    &quot;Sec-Fetch-Dest: document&quot;,
    &quot;Sec-Fetch-Mode: navigate&quot;,
    &quot;Sec-Fetch-Site: none&quot;,
    &quot;Sec-Fetch-User: ?1&quot;,
    &quot;Cache-Control: max-age=0&quot;,
]
</code></pre>
<p>Dependiendo de tu navegador, podrías obtener una salida ligeramente diferente.
Ahora que estamos imprimiendo los datos de la solicitud, podemos ver por qué
obtenemos múltiples conexiones desde una solicitud del navegador al mirar la
ruta después de <code>GET</code> en la primera línea de la solicitud. Si las conexiones
repetidas están solicitando <em>/</em>, sabemos que el navegador está tratando de
obtener <em>/</em> repetidamente porque no está obteniendo una respuesta de nuestro
programa.</p>
<p>Descompongamos estos datos de solicitud para comprender lo que el navegador
está pidiendo a nuestro programa.</p>
<h3 id="una-mirada-más-cercana-a-una-solicitud-http"><a class="header" href="#una-mirada-más-cercana-a-una-solicitud-http">Una mirada más cercana a una solicitud HTTP</a></h3>
<p>HTTP es un protocolo de texto, y una solicitud toma este formato:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>La primera línea es la <em>línea de solicitud</em> que contiene información sobre lo
que el cliente está solicitando. La primera parte de la línea de solicitud
indica el <em>método</em> que se está utilizando, como <code>GET</code> o <code>POST</code>, que describe
cómo el cliente está haciendo esta solicitud. Nuestro cliente usó una solicitud
<code>GET</code>, lo que significa que está solicitando información.</p>
<p>La siguiente parte de la línea de solicitud es <em>/</em>, que indica el
<em>Uniform Resource Identifier</em> <em>(URI)</em> que el cliente está solicitando: un URI
es casi, pero no exactamente, lo mismo que un <em>Uniform Resource Locator</em>
<em>(URL)</em>. La diferencia entre URIs y URLs no es importante para nuestros
propósitos en este capítulo, pero la especificación HTTP usa el término URI,
por lo que podemos simplemente sustituir mentalmente URL por URI aquí.</p>
<p>La última parte es la versión de HTTP que utiliza el cliente, y luego la línea
de solicitud termina en una secuencia <em>CRLF</em>. (CRLF significa <em>carriage return</em>
y <em>line feed</em>, que son términos de los días de la máquina de escribir!) La
secuencia CRLF también se puede escribir como <code>\r\n</code>, donde <code>\r</code> es un retorno
de carro y <code>\n</code> es un avance de línea. La secuencia CRLF separa la línea de
solicitud del resto de los datos de la solicitud. Tenga en cuenta que cuando se
imprime el CRLF, vemos que comienza una nueva línea en lugar de <code>\r\n</code>.</p>
<p>Al examinar los datos de la línea de solicitud que hemos recibido al ejecutar
nuestro programa hasta ahora, vemos que <code>GET</code> es el método, <em>/</em> es el URI de
solicitud y <code>HTTP/1.1</code> es la versión.</p>
<p>Después de la línea de solicitud, las líneas restantes a partir de <code>Host:</code> en
adelante son encabezados. Las solicitudes <code>GET</code> no tienen cuerpo.</p>
<p>Intenta hacer una solicitud desde un navegador diferente o solicitar una
dirección diferente, como <em>127.0.0.1:7878/test</em>, para ver cómo cambian los
datos de la solicitud.</p>
<p>Ahora que sabemos lo que el navegador está solicitando, ¡enviemos algunos
datos de vuelta!</p>
<h3 id="escribiendo-una-respuesta"><a class="header" href="#escribiendo-una-respuesta">Escribiendo una respuesta</a></h3>
<p>Vamos a implementar el envío de datos en respuesta a una solicitud del
cliente. Las respuestas tienen el siguiente formato:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>La primera línea es una <em>línea de estado</em> que contiene la versión HTTP 
utilizada en la respuesta, un código de estado numérico que resume el resultado
de la solicitud y una frase de motivo que proporciona una descripción textual
del código de estado. Después de la secuencia CRLF hay encabezados, otra
secuencia CRLF y el cuerpo de la respuesta.</p>
<p>Aquí hay un ejemplo de respuesta que usa la versión HTTP 1.1, tiene un código
de estado 200, una frase de motivo OK, no tiene encabezados y no tiene cuerpo:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>El código de estado 200 es la respuesta de éxito estándar. El texto es una
respuesta HTTP exitosa. ¡Escribamos esto en el flujo como nuestra respuesta a
una solicitud exitosa! Desde la función <code>handle_connection</code>, elimine el
<code>println!</code> que estaba imprimiendo los datos de la solicitud y reemplácelo con
el código en el Listado 20-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-3: Escribiendo una pequeña respuesta HTTP
exitosa en el flujo de datos</span></p>
<p>El primer cambio introduce la variable <code>response</code>, que contiene los datos
del mensaje de éxito. Luego, llamamos a <code>as_bytes</code> en nuestra <code>response</code> para
convertir los datos de string en bytes. El método <code>write_all</code> en <code>stream</code> toma
un <code>&amp;[u8]</code> y envía esos bytes directamente por la conexión. Debido a que la
operación <code>write_all</code> podría fallar, usamos <code>unwrap</code> en cualquier resultado de
error como antes. Nuevamente, en una aplicación real agregarías manejo de
errores aquí.</p>
<p>Con estos cambios, ejecutemos nuestro código y hagamos una solicitud. Como ya
no estamos imprimiendo ningún dato en la terminal, no veremos ninguna salida
aparte de la salida generada por Cargo. Cuando cargues <em>127.0.0.1:7878</em> en un
navegador web, deberías ver una página en blanco en lugar de un error. ¡Acabas
de codificar a mano la recepción de una solicitud HTTP y el envío de una
respuesta!</p>
<h3 id="devolviendo-html-real"><a class="header" href="#devolviendo-html-real">Devolviendo HTML real</a></h3>
<p>Vamos a implementar la funcionalidad para devolver algo más que una página en
blanco. Crea el nuevo archivo <em>hello.html</em> en la raíz de tu directorio del
proyecto, no en el directorio <em>src</em>. Puedes introducir cualquier HTML que
quieras; el Listado 20-4 muestra una posibilidad.</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-4: Un ejemplo de archivo HTML para devolver en 
una respuesta</span></p>
<p>Esto es un documento HTML5 mínimo con un encabezado y un poco de texto. Para
devolver esto desde el servidor cuando se recibe una solicitud, modificaremos
<code>handle_connection</code> como se muestra en el Listado 20-5 para leer el archivo
HTML, agregarlo a la respuesta como un cuerpo y enviarlo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = &quot;HTTP/1.1 200 OK&quot;;
    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-5: Enviando el contenido de <em>hello.html</em> como 
el cuerpo de la respuesta</span></p>
<p>Hemos agregado <code>fs</code> a la declaración <code>use</code> para traer el módulo del sistema de
archivos de la biblioteca estándar al scope. El código para leer el contenido
de un archivo a una cadena debería ser familiar; lo usamos en el Capítulo 12
cuando leímos el contenido de un archivo para nuestro proyecto de I/O en el
Listado 12-4.</p>
<p>A continuación, utilizamos <code>format!</code> para agregar el contenido del archivo como
el cuerpo de la respuesta de éxito. Para asegurar una respuesta HTTP válida,
agregamos el encabezado <code>Content-Length</code> que se establece en el tamaño del
cuerpo de nuestra respuesta, en este caso el tamaño de <code>hello.html</code>.</p>
<p>Ejecuta este código con <code>cargo run</code> y carga <em>127.0.0.1:7878</em> en tu navegador;
¡Deberías ver tu HTML renderizado!</p>
<p>Actualmente, estamos ignorando los datos de la solicitud en <code>http_request</code> y
enviando de vuelta el contenido del archivo HTML incondicionalmente. Eso
significa que si intentas solicitar <em>127.0.0.1:7878/something-else</em> en tu
navegador, aún obtendrás esta misma respuesta HTML. En este momento, nuestro
servidor es muy limitado y no hace lo que hacen la mayoría de los servidores
web. Queremos personalizar nuestras respuestas dependiendo de la solicitud y
solo enviar el archivo HTML para una solicitud bien formada a <em>/</em>.</p>
<h3 id="validando-la-solicitud-y-respondiendo-selectivamente"><a class="header" href="#validando-la-solicitud-y-respondiendo-selectivamente">Validando la solicitud y respondiendo selectivamente</a></h3>
<p>En este momento, nuestro servidor web devolverá el HTML del archivo sin 
importar lo que el cliente haya solicitado. Agreguemos funcionalidad para
verificar que el navegador esté solicitando <em>/</em> antes de devolver el archivo
HTML y devolver un error si el navegador solicita cualquier otra cosa. Para
esto necesitamos modificar <code>handle_connection</code>, como se muestra en el Listado
20-6. Este nuevo código verifica el contenido de la solicitud recibida contra
lo que sabemos que se parece una solicitud para <em>/</em> y agrega bloques <code>if</code> y
<code>else</code> para tratar las solicitudes de manera diferente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == &quot;GET / HTTP/1.1&quot; {
        let status_line = &quot;HTTP/1.1 200 OK&quot;;
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
<p><span class="caption">Listing 20-6: Tratar las solicitudes a <em>/</em> de manera 
diferente a las demás solicitudes</span></p>
<p>Solo vamos a analizar la primera línea de la solicitud HTTP, por lo que en 
lugar de leer toda la solicitud en un vector, estamos llamando a <code>next</code> para
obtener el primer elemento del iterator. El primer <code>unwrap</code> se encarga de la
<code>Option</code> y detiene el programa si el iterator no tiene elementos. El segundo
<code>unwrap</code> maneja el <code>Result</code> y tiene el mismo efecto que el <code>unwrap</code> que estaba
en el <code>map</code> agregado en el Listado 20-2.</p>
<p>A continuación, verificamos si la <code>request_line</code> es igual a la línea de
solicitud de una solicitud GET a la ruta */**. Si es así, el bloque <code>if</code>
devuelve el contenido de nuestro archivo HTML.</p>
<p>Si la <code>request_line</code> no es igual a la línea de solicitud GET al camino <em>/</em>,
significa que hemos recibido alguna otra solicitud. Agregaremos código al
bloque <code>else</code> en un momento para responder a todas las demás solicitudes.</p>
<p>Ejecuta este código ahora y solicita <em>127.0.0.1:7878</em>; deberías ver el HTML
en <em>hello.html</em>. Si haces cualquier otra solicitud, como 
<em>127.0.0.1:7878/something-else</em>, obtendrás un error de conexión como los que
viste al ejecutar el código en el Listado 20-1 y el Listado 20-2.</p>
<p>Ahora agreguemos el código del Listado 20-7 al bloque <code>else</code> para devolver
una respuesta con el código de estado 404, que indica que el contenido de la
solicitud no se encontró. También devolveremos un poco de HTML para una página
que se renderizará en el navegador indicando la respuesta al usuario final.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == &quot;GET / HTTP/1.1&quot; {
</span><span class="boring">        let status_line = &quot;HTTP/1.1 200 OK&quot;;
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 20-7: Respondiendo con el código de estado 404 y
una página de error si se solicita algo distinto a <em>/</em></span></p>
<p>Aquí, nuestra respuesta tiene una línea de estado con el código de estado 404
y la frase de motivo <code>NOT FOUND</code>. El cuerpo de la respuesta será el HTML en el
archivo <em>404.html</em>. Necesitarás crear un archivo <em>404.html</em> junto a
<em>hello.html</em> para la página de error; nuevamente, siéntete libre de usar
cualquier HTML que desees o usa el HTML de ejemplo en el Listado 20-8.</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Contenido de ejemplo para la página que
se enviará como respuesta en cualquier caso de error 404</span></p>
<p>Con estos cambios, ejecuta tu servidor nuevamente. Al solicitar <em>127.0.0.1:7878</em>
deberías obtener el contenido de <em>hello.html</em>, y cualquier otra solicitud,
como <em>127.0.0.1:7878/foo</em>, debería devolver el HTML de <em>404.html</em>.</p>
<h3 id="un-toque-de-refactorización"><a class="header" href="#un-toque-de-refactorización">Un toque de refactorización</a></h3>
<p>En este momento, los bloques <code>if</code> y <code>else</code> tienen mucha repetición: ambos
están leyendo archivos y escribiendo el contenido de los archivos en el
stream. Las únicas diferencias son la línea de estado y el nombre del archivo.
Hagamos que el código sea más conciso extrayendo esas diferencias en líneas
<code>if</code> y <code>else</code> separadas que asignarán los valores de la línea de estado y el
nombre del archivo a variables; luego podemos usar esas variables
incondicionalmente en el código para leer el archivo y escribir la respuesta.
El Listado 20-9 muestra el código resultante después de reemplazar los grandes
bloques <code>if</code> y <code>else</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == &quot;GET / HTTP/1.1&quot; {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-9: Refactorizando los bloques <code>if</code> y <code>else</code>
para que contengan solo el código que difiere entre los dos casos</span></p>
<p>Ahora los bloques <code>if</code> y <code>else</code> solo devuelven los valores apropiados para la
línea de estado y el nombre de archivo en una tupla; luego usamos la
destructuración para asignar estos dos valores a <code>status_line</code> y <code>filename</code>
usando un patrón en la declaración <code>let</code>, como se discutió en el Capítulo 18.</p>
<p>El código previamente duplicado ahora está fuera de los bloques <code>if</code> y <code>else</code>
y usa las variables <code>status_line</code> y <code>filename</code>. Esto hace que sea más fácil
ver la diferencia entre los dos casos, y significa que solo tenemos un lugar
para actualizar el código si queremos cambiar la forma en que funciona la
lectura de archivos y la escritura de respuestas. El comportamiento del código
en el Listado 20-9 será el mismo que el del Listado 20-7.</p>
<p>¡Increíble! Ahora tenemos un servidor web simple en aproximadamente 40 líneas
de código Rust que responde a una solicitud con una página de contenido y
responde a todas las demás solicitudes con una respuesta 404.</p>
<p>Actualmente, nuestro servidor se ejecuta en un solo hilo, lo que significa que
solo puede atender una solicitud a la vez. Analicemos cómo esto puede ser un
problema al simular algunas solicitudes lentas. Luego lo arreglaremos para que
nuestro servidor pueda manejar múltiples solicitudes a la vez.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="convirtiendo-nuestro-servidor-de-un-solo-hilo-en-un-servidor-multihilo"><a class="header" href="#convirtiendo-nuestro-servidor-de-un-solo-hilo-en-un-servidor-multihilo">Convirtiendo nuestro servidor de un solo hilo en un servidor multihilo</a></h2>
<p>Actualmente, el servidor procesará cada solicitud de forma secuencial, lo que
significa que no procesará una segunda conexión hasta que se termine de
procesar la primera. Si el servidor recibe más y más solicitudes, esta
ejecución en serie será menos y menos óptima. Si el servidor recibe una
solicitud que tarda mucho tiempo en procesarse, las solicitudes posteriores
tendrán que esperar hasta que la solicitud larga haya terminado, incluso si las
nuevas solicitudes se pueden procesar rápidamente. Tendremos que solucionar
esto, pero primero, veremos el problema en acción.</p>
<h3 id="simulando-una-solicitud-lenta-en-la-implementación-actual-del-servidor"><a class="header" href="#simulando-una-solicitud-lenta-en-la-implementación-actual-del-servidor">Simulando una solicitud lenta en la implementación actual del servidor</a></h3>
<p>Para simular una solicitud lenta, podemos hacer que el servidor duerma durante
un tiempo antes de responder. Veremos cómo una solicitud de procesamiento
lento puede afectar a otras solicitudes realizadas a nuestra implementación
actual del servidor. El listado 20-10 implementa el manejo de una solicitud a
<em>/sleep</em> con una respuesta lenta simulada que hará que el servidor duerma
durante 5 segundos antes de responder.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
<p><span class="caption">Listing 20-10: Simulando una solicitud lenta durmiendo
durante 5 segundos</span></p>
<p>Hemos cambiado de <code>if</code> a <code>match</code> ahora que tenemos tres casos. Necesitamos
hacer coincidir explícitamente con un slice de <code>request_line</code> para hacer
coincidir con los valores literales de string; <code>match</code> no hace referencia
automática y desreferenciación como el método de igualdad.</p>
<p>La primera opción es la misma que el bloque <code>if</code> del Listado 20-9. La segunda
opción coincide con una solicitud a <em>/sleep</em>. Cuando se recibe esa solicitud, el
servidor dormirá durante 5 segundos antes de representar la página HTML
correcta. La tercera opción es la misma que el bloque <code>else</code> del Listado 20-9.</p>
<p>Puedes ver cómo nuestro servidor es primitivo: ¡las bibliotecas reales
manejarían el reconocimiento de múltiples solicitudes de una manera mucho menos
verbosa!</p>
<p>Iniciamos el servidor con <code>cargo run</code>. Luego abrimos dos ventanas del navegador:
una para <em>http://127.0.0.1:7878/</em> y la otra para <em>http://127.0.0.1:7878/sleep</em>.
Si ingresas la URI <em>/</em> varias veces, como antes, verás que responde rápidamente.
Pero si ingresas <em>/sleep</em> y luego cargas <em>/</em>, verás que <em>/</em> espera hasta que
<code>sleep</code> haya dormido durante sus 5 segundos completos antes de cargarse.</p>
<p>Existen varias técnicas que podríamos usar para evitar que las solicitudes se
acumulen detrás de una solicitud lenta; la que implementaremos es un <em>pool de
hilos</em>.</p>
<h3 id="mejorando-el-rendimiento-con-un-pool-de-hilos"><a class="header" href="#mejorando-el-rendimiento-con-un-pool-de-hilos">Mejorando el rendimiento con un pool de hilos</a></h3>
<p>Un <em>pool de hilos</em> es un grupo de hilos generados que están esperando y listos
para manejar una tarea. Cuando el programa recibe una nueva tarea, asigna uno
de los hilos del grupo a la tarea, y ese hilo procesará la tarea. Los hilos
restantes en el grupo están disponibles para manejar cualquier otra tarea que
llegue mientras el primer hilo está procesando. Cuando el primer hilo termina
de procesar su tarea, se devuelve al grupo de hilos inactivos, listo para
manejar una nueva tarea. Un pool de hilos le permite procesar conexiones de
forma concurrente, aumentando el rendimiento de su servidor.</p>
<p>Limitaremos el número de hilos en el grupo a un número pequeño para protegernos
de los ataques de denegación de servicio (DoS); si nuestro programa creara un
nuevo hilo para cada solicitud que llegara, alguien que hiciera 10 millones de
solicitudes a nuestro servidor podría crear el caos al agotar todos los
recursos de nuestro servidor y detener el procesamiento de las solicitudes.</p>
<p>En lugar de crear un nuevo hilo para cada solicitud, crearemos un grupo de
hilos que actuarán como un pool de hilos. Cuando llega una solicitud, el
servidor enviará la solicitud al pool de hilos. El pool de hilos mantendrá una
cola de solicitudes entrantes. Cada uno de los hilos en el pool sacará una
solicitud de esta cola, manejará la solicitud y luego pedirá a la cola otra
solicitud. Con este diseño, podemos procesar hasta <code>N</code> solicitudes
simultáneamente, donde <code>N</code> es el número de hilos. Si cada hilo responde a una
solicitud de larga duración, las solicitudes posteriores aún pueden acumularse
en la cola, pero hemos aumentado el número de solicitudes de larga duración que
podemos manejar antes de llegar a ese punto.</p>
<p>Esta técnica es solo una de las muchas formas de mejorar el rendimiento de un
servidor web. Otras opciones que puede explorar son el modelo <em>fork / join</em>,
el modelo de <em>I / O asincrónico de un solo hilo</em> o el <em>modelo de I / O
asincrónico de múltiples hilos</em>. Si está interesado en este tema, puedes leer
más sobre otras soluciones e intentar implementarlas; con un lenguaje de bajo
nivel como Rust, todas estas opciones son posibles.</p>
<p>Antes de comenzar a implementar un pool de hilos, hablemos sobre cómo debería
verse el uso del pool. Cuando intentas diseñar código, escribir la interfaz del
cliente primero puede ayudar a guiar tu diseño. Escribe la API del código para
que esté estructurado de la manera en que deseas llamarlo; luego implementa la
funcionalidad dentro de esa estructura en lugar de implementar la funcionalidad
y luego diseñar la API pública.</p>
<p>Similar a cómo usamos el desarrollo impulsado por pruebas en el proyecto en el
Capítulo 12, usaremos el desarrollo impulsado por el compilador aquí.
Escribiremos el código que llama a las funciones que queremos, y luego
analizaremos los errores del compilador para determinar qué debemos cambiar a
continuación para que el código funcione. Antes de hacer eso, sin embargo,
exploraremos la técnica que no vamos a usar como punto de partida.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="creando-un-hilo-para-cada-solicitud"><a class="header" href="#creando-un-hilo-para-cada-solicitud">Creando un hilo para cada solicitud</a></h4>
<p>Primero, exploremos cómo podría lucir nuestro código si creáramos un nuevo hilo
para cada conexión. Como se mencionó anteriormente, este no es nuestro plan
final debido a los problemas con la posibilidad de generar un número ilimitado
de hilos, pero es un punto de partida para obtener un servidor web
multihilo. Luego agregaremos el pool de hilos como una mejora, y contrastar las
dos soluciones será más fácil. El Listado 20-11 muestra los cambios que debe
realizar en <code>main</code> para crear un nuevo hilo para manejar cada flujo dentro del
bucle <code>for</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 20-11: Creando un hilo para cada stream</span></p>
<p>Como aprendiste en el Capítulo 16, <code>thread::spawn</code> creará un nuevo hilo y luego
ejecutará el código en el cierre en el nuevo hilo. Si ejecutas este código y
cargas <em>/sleep</em> en tu navegador, luego <em>/</em> en otras dos pestañas del navegador,
verás que las solicitudes a <em>/</em> no tienen que esperar a que <em>/sleep</em> termine.
Sin embargo, como mencionamos, esto eventualmente abrumará el sistema porque
estarías creando nuevos hilos sin ningún límite.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="creando-un-número-finito-de-hilos"><a class="header" href="#creando-un-número-finito-de-hilos">Creando un número finito de hilos</a></h4>
<p>Queremos que nuestro pool de hilos funcione de manera similar y familiar, de
modo que cambiar de hilos a un pool de hilos no requiera grandes cambios en el
código que usa nuestra API. El Listado 20-12 muestra la interfaz hipotética
para un struct <code>ThreadPool</code> que queremos usar en lugar de <code>thread::spawn</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-12: Nuestra interfaz ideal de
<code>ThreadPool</code></span></p>
<p>Utilizamos <code>ThreadPool::new</code> para crear un nuevo pool de hilos con un número
configurable de hilos, en este caso cuatro. Luego, en el bucle <code>for</code>,
<code>pool.execute</code> tiene una interfaz similar a <code>thread::spawn</code> en que toma un
cierre que el pool debe ejecutar para cada flujo. Necesitamos implementar
<code>pool.execute</code> para que tome el cierre y se lo dé a un hilo en el pool para que
lo ejecute. Este código aún no se compilará, pero lo intentaremos para que el
compilador pueda guiarnos en cómo solucionarlo.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="construyendo-threadpool-usando-el-desarrollo-impulsado-por-el-compilador"><a class="header" href="#construyendo-threadpool-usando-el-desarrollo-impulsado-por-el-compilador">Construyendo <code>ThreadPool</code> usando el desarrollo impulsado por el compilador</a></h4>
<p>Realiza los cambios en el Listado 20-12 a <em>src/main.rs</em>, y luego usemos los
errores del compilador de <code>cargo check</code> para impulsar nuestro desarrollo. Aquí
está el primer error que obtenemos:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin &quot;hello&quot;) due to 1 previous error
</code></pre>
<p>¡Eso es genial! Este error nos dice que necesitamos un tipo o módulo
<code>ThreadPool</code>, así que lo construiremos ahora. Nuestra implementación de
<code>ThreadPool</code> será independiente del tipo de trabajo que nuestro servidor web
está haciendo. Entonces, cambiemos el crate de <code>hello</code> de un crate binario a un
crate de biblioteca para contener nuestra implementación de <code>ThreadPool</code>.
Después de cambiar a un crate de biblioteca, también podríamos usar la
biblioteca de pool de hilos separada para cualquier trabajo que queramos hacer
usando un pool de hilos y no solo para servir solicitudes web.</p>
<p>Crea un <em>src/lib.rs</em> que contenga lo siguiente, que es la definición más simple
de un struct <code>ThreadPool</code> que podemos tener por ahora:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
<p>Luego edita el archivo <em>main.rs</em> para traer <code>ThreadPool</code> al scope del crate
desde el crate de la biblioteca agregando el siguiente código en la parte
superior de <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p>Este código aún no funcionará, pero verifiquémoslo nuevamente para obtener el
siguiente error que debemos abordar:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin &quot;hello&quot;) due to 1 previous error
</code></pre>
<p>Este error indica que a continuación debemos crear una función asociada
llamada <code>new</code> para <code>ThreadPool</code>. También sabemos que <code>new</code> debe tener un
parámetro que pueda aceptar <code>4</code> como argumento y debe devolver una instancia de
<code>ThreadPool</code>. Implementemos la función <code>new</code> más simple que tendrá esas
características:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
<p>Elegimos <code>usize</code> como el tipo del parámetro <code>size</code>, porque sabemos que un número
negativo de hilos no tiene sentido. También sabemos que usaremos este <code>4</code> como
el número de elementos en una colección de hilos, que es para lo que se usa el
tipo <code>usize</code>, como se discutió en la sección <a href="ch03-02-data-types.html#tipos-de-enteros">“Tipos de enteros”</a>
del Capítulo 3.</p>
<p>Let’s check the code again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin &quot;hello&quot;) due to 1 previous error
</code></pre>
<p>Ahora ocurre un error porque no tenemos un método <code>execute</code> en <code>ThreadPool</code>.
Recordemos de la sección <a href="ch20-02-multithreaded.html#creating-a-similar-interface-for-a-finite-number-of-threads">“Creando un número finito de
hilos”</a><!--
ignore --> que decidimos que nuestro pool de hilos debería tener una interfaz
similar a <code>thread::spawn</code>. Además, implementaremos la función <code>execute</code> para
que tome el cierre que se le da y se lo dé a un hilo inactivo en el pool para
que lo ejecute.</p>
<p>Definiremos el método <code>execute</code> en <code>ThreadPool</code> para tomar un closure como
parámetro. Recordemos de la sección <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">“Mover valores capturados fuera del
closure y los traits <code>Fn</code>”</a><!-- ignore --> en el Capítulo 13 que
podemos tomar cierres como parámetros con tres traits diferentes: <code>Fn</code>,
<code>FnMut</code> y <code>FnOnce</code>. Necesitamos decidir qué tipo de cierre usar aquí. Sabemos
que terminaremos haciendo algo similar a la implementación de la biblioteca
estándar <code>thread::spawn</code>, por lo que podemos ver qué límites tiene la firma de
<code>thread::spawn</code> en su parámetro. La documentación nos muestra lo siguiente:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>El parámetro de tipo <code>F</code> es el que nos preocupa aquí; el parámetro de tipo <code>T</code>
está relacionado con el valor de retorno, y no nos preocupa eso. Podemos ver
que <code>spawn</code> usa <code>FnOnce</code> como límite de trait en <code>F</code>. Esto es probablemente lo
que queremos también, porque eventualmente pasaremos el argumento que obtenemos
en <code>execute</code> a <code>spawn</code>. Podemos estar más seguros de que <code>FnOnce</code> es el trait
que queremos usar porque el hilo para ejecutar una solicitud solo ejecutará el
closure de esa solicitud una vez, lo que coincide con el <code>Once</code> en <code>FnOnce</code>.</p>
<p>El trait <code>FnOnce</code> también tiene un trait bound <code>Send</code> y un lifetime bound
<code>'static</code>, que son útiles en nuestra situación: necesitamos <code>Send</code> para
transferir el closure de un hilo a otro y <code>'static</code> porque no sabemos cuánto
tiempo tomará el hilo para ejecutarse. Creemos un método <code>execute</code> en
<code>ThreadPool</code> que tomará un parámetro genérico de tipo <code>F</code> con estos bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
<p>Aún usamos <code>()</code> después de <code>FnOnce</code> porque este <code>FnOnce</code> representa un closure
que no toma parámetros y devuelve el tipo de unidad <code>()</code>. Al igual que las
definiciones de funciones, el tipo de retorno se puede omitir de la firma, pero
incluso si no tenemos parámetros, todavía necesitamos los paréntesis.</p>
<p>Una vez más, esta es la implementación más simple del método <code>execute</code>: no hace
nada, pero estamos tratando de que nuestro código compile. Verifiquemos
nuevamente:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>¡Compila! Pero ten en cuenta que si intentas <code>cargo run</code> y haces una solicitud
en el navegador, verás los errores en el navegador que vimos al comienzo del
capítulo. ¡Nuestra biblioteca aún no está llamando al closure pasado a
<code>execute</code>!</p>
<blockquote>
<p>Nota: Una frase que podrías escuchar sobre lenguajes con compiladores
estrictos, como Haskell y Rust, es “si el código se compila, funciona”. Pero
esta frase no es universalmente cierta. Nuestro proyecto se compila, ¡pero no
hace absolutamente nada! Si estuviéramos construyendo un proyecto real y
completo, este sería un buen momento para comenzar a escribir pruebas
unitarias para verificar que el código se compile <em>y</em> tenga el comportamiento
que queremos.</p>
</blockquote>
<h4 id="validando-el-número-de-hilos-en-new"><a class="header" href="#validando-el-número-de-hilos-en-new">Validando el número de hilos en <code>new</code></a></h4>
<p>No estamos haciendo nada con los parámetros a <code>new</code> y <code>execute</code>. Implementemos
los cuerpos de estas funciones con el comportamiento que queremos. Para
comenzar, pensemos en <code>new</code>. Anteriormente, elegimos un tipo sin signo para el
parámetro <code>size</code>, porque un pool con un número negativo de hilos no tiene
sentido. Sin embargo, un pool con cero hilos tampoco tiene sentido, pero cero
es un <code>usize</code> perfectamente válido. Agregaremos código para verificar que
<code>size</code> es mayor que cero antes de devolver una instancia de <code>ThreadPool</code> y
hacer que el programa se bloquee si recibe un cero usando el macro <code>assert!</code>,
como se muestra en el Listado 20-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listing 20-13: Implementando <code>ThreadPool::new</code> para
generar un panic si <code>size</code> es cero</span></p>
<p>Hemos agregado documentación para nuestro <code>ThreadPool</code> con comentarios de
documentación. Ten en cuenta que seguimos las buenas prácticas de documentación
agregando una sección que llama a las situaciones en las que nuestra función
puede entrar en panic, como se discutió en el Capítulo 14. ¡Intenta ejecutar
<code>cargo doc --open</code> y hacer clic en la estructura <code>ThreadPool</code> para ver cómo se
ven los documentos generados para <code>new</code>!</p>
<p>En lugar de agregar la macro <code>assert!</code> como lo hicimos aquí, podríamos cambiar
<code>new</code> a <code>build</code> y devolver un <code>Result</code> como lo hicimos con <code>Config::build</code> en
el proyecto I/O en el Listado 12-9. Pero hemos decidido en este caso que
intentar crear un pool de hilos sin ningún hilo debería ser un error
irrecuperable. Si te sientes ambicioso, intenta escribir una función llamada
<code>build</code> con la siguiente firma para comparar con la función <code>new</code>:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="creando-espacio-para-almacenar-los-hilos"><a class="header" href="#creando-espacio-para-almacenar-los-hilos">Creando espacio para almacenar los hilos</a></h4>
<p>Ahora que tenemos una forma de saber que tenemos un número válido de hilos para
almacenar en el pool, podemos crear esos hilos y almacenarlos en el struct
<code>ThreadPool</code> antes de devolver el struct. Pero, ¿cómo “almacenamos” un hilo?
Echemos otro vistazo a la firma de <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>La función <code>spawn</code> devuelve un <code>JoinHandle&lt;T&gt;</code>, donde <code>T</code> es el tipo que el
closure devuelve. Intentemos usar <code>JoinHandle</code> también y veamos qué sucede. En
nuestro caso, los closures que estamos pasando al pool de hilos manejarán la
conexión y no devolverán nada, por lo que <code>T</code> será el tipo de unidad <code>()</code>.</p>
<p>El código en el Listado 20-14 se compilará, pero aún no creará ningún hilo.
Hemos cambiado la definición de <code>ThreadPool</code> para contener un vector de
instancias de <code>thread::JoinHandle&lt;()&gt;</code>, inicializado el vector con una
capacidad de <code>size</code>, configurado un bucle <code>for</code> que ejecutará algún código para
crear los hilos y devuelto una instancia de <code>ThreadPool</code> que los contiene.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listing 20-14: Creando un vector para que <code>ThreadPool</code>
contenga los hilos</span></p>
<p>Hemos llevado <code>std::thread</code> al scope en la biblioteca, porque estamos usando
<code>thread::JoinHandle</code> como el tipo de los elementos en el vector en
<code>ThreadPool</code>.</p>
<p>Una vez que se recibe un tamaño válido, nuestro <code>ThreadPool</code> crea un nuevo
vector que puede contener <code>size</code> elementos. La función <code>with_capacity</code>
realiza la misma tarea que <code>Vec::new</code>, pero con una diferencia importante: se
asigna espacio en el vector. Debido a que sabemos que necesitamos almacenar
<code>size</code> elementos en el vector, hacer esta asignación por adelantado es
ligeramente más eficiente que usar <code>Vec::new</code>, que se redimensiona a sí mismo a
medida que se insertan elementos.</p>
<p>Cuando ejecutes <code>cargo check</code> nuevamente, debería tener éxito:</p>
<h4 id="un-struct-worker-responsable-de-enviar-código-desde-el-threadpool-a-un-hilo"><a class="header" href="#un-struct-worker-responsable-de-enviar-código-desde-el-threadpool-a-un-hilo">Un struct <code>Worker</code> responsable de enviar código desde el <code>ThreadPool</code> a un hilo</a></h4>
<p>Dejamos un comentario en el bucle <code>for</code> en el Listado 20-14 con respecto a la
creación de hilos. Aquí, veremos cómo creamos hilos. La biblioteca estándar
proporciona <code>thread::spawn</code> como una forma de crear hilos, y <code>thread::spawn</code>
espera obtener algún código que el hilo debe ejecutar tan pronto como se cree
el hilo. Sin embargo, en nuestro caso, queremos crear los hilos y hacer que
<em>esperen</em> el código que enviaremos más tarde. La implementación de la biblioteca
estándar de hilos no incluye ninguna forma de hacer eso; tenemos que
implementarlo manualmente.</p>
<p>Implementaremos este comportamiento introduciendo una nueva estructura de datos
entre <code>ThreadPool</code> y los hilos que administrarán este nuevo comportamiento.
Llamaremos a esta estructura de datos <em>&quot;Worker&quot;</em>, que es un término común en las
implementaciones de pooling. El Worker recoge el código que debe ejecutarse y
ejecuta el código en el hilo del Worker. Piensa en las personas que trabajan
en la cocina de un restaurante: los trabajadores esperan hasta que lleguen los
pedidos de los clientes, y luego son responsables de tomar esos pedidos y
cumplirlos.</p>
<p>En lugar de almacenar un vector de instancias <code>JoinHandle&lt;()&gt;</code> en el pool de
hilos, almacenaremos instancias del struct <code>Worker</code>. Cada <code>Worker</code> contendrá
una instancia <code>JoinHandle&lt;()&gt;</code>. Luego, implementaremos un método en <code>Worker</code>
que tomará un closure de código para ejecutar y lo enviará al hilo en ejecución
para su ejecución. También daremos a cada trabajador un <code>id</code> para que podamos
distinguir entre los diferentes trabajadores en el pool al registrar o depurar.</p>
<p>Aquí está el nuevo proceso que ocurrirá cuando creemos un <code>ThreadPool</code>.
Implementaremos el código que envía el closure al hilo después de que tengamos
<code>Worker</code> configurado de esta manera:</p>
<ol>
<li>Definimos un struct <code>Worker</code> que contiene un <code>id</code> y un <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Cambiamos <code>ThreadPool</code> para contener un vector de instancias <code>Worker</code>.</li>
<li>Definimos una función <code>Worker::new</code> que toma un número <code>id</code> y devuelve una
instancia <code>Worker</code> que contiene un <code>id</code> y un hilo creado con un closure
vacío.</li>
<li>En <code>ThreadPool::new</code>, usamos el contador del bucle <code>for</code> para generar un
<code>id</code>, creamos un nuevo <code>Worker</code> con ese <code>id</code> y almacenamos el trabajador en
el vector.</li>
</ol>
<p>Si estás listo para un desafío, intenta implementar estos cambios por ti mismo
antes de ver el código en el Listado 20-15.</p>
<p>¿Listo? Aquí está el Listado 20-15 con una forma de hacer las modificaciones</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-15: Modificando <code>ThreadPool</code> para contener
instancias de <code>Worker</code> en lugar de contener hilos directamente</span></p>
<p>Hemos cambiado el nombre del campo en <code>ThreadPool</code> de <code>threads</code> a <code>workers</code>
porque ahora contiene instancias de <code>Worker</code> en lugar de instancias de
<code>JoinHandle&lt;()&gt;</code>. Usamos el contador en el bucle <code>for</code> como argumento para
<code>Worker::new</code>, y almacenamos cada nuevo <code>Worker</code> en el vector llamado
<code>workers</code>.</p>
<p>El código externo (como nuestro servidor en <em>src/main.rs</em>) no necesita conocer
los detalles de implementación con respecto al uso de un struct <code>Worker</code> dentro
de <code>ThreadPool</code>, por lo que hacemos que el struct <code>Worker</code> y su función <code>new</code>
sean privadas. La función <code>Worker::new</code> utiliza el <code>id</code> que le damos y almacena
una instancia <code>JoinHandle&lt;()&gt;</code> que se crea al generar un nuevo hilo usando un
closure vacío.</p>
<blockquote>
<p>Nota: Si el sistema operativo no puede crear un hilo porque no hay suficientes
recursos del sistema, <code>thread::spawn</code> entrará en panic. Eso hará que todo
nuestro servidor entre en panic, incluso si la creación de algunos hilos
tiene éxito. Por simplicidad, este comportamiento está bien, pero en una
implementación de grupo de hilos de producción, es probable que desee usar
<a href="https://doc.rust-lang.org/std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> y su método
<a href="https://doc.rust-lang.org/std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore --> que devuelve <code>Result</code> en su lugar.</p>
</blockquote>
<p>Este código se compilará y almacenará el número de instancias <code>Worker</code> que
especificamos como argumento para <code>ThreadPool::new</code>. Pero todavía no estamos
procesando el closure que obtenemos en <code>execute</code>. Veamos cómo hacer eso a
continuación.</p>
<h4 id="enviando-solicitudes-a-hilos-a-través-de-canales"><a class="header" href="#enviando-solicitudes-a-hilos-a-través-de-canales">Enviando solicitudes a hilos a través de canales</a></h4>
<p>El siguiente problema que abordaremos es que los closures que se pasan a
<code>tread::spawn</code> no hacen absolutamente nada. Actualmente, obtenemos el closure
que queremos ejecutar en el método <code>execute</code>. Pero necesitamos darle a
<code>thread::spawn</code> un closure para ejecutar cuando creamos cada <code>Worker</code> durante
la creación del <code>ThreadPool</code>.</p>
<p>Queremos que los structs <code>Worker</code> que acabamos de crear obtengan el código a
ejecutar desde una cola mantenida en <code>ThreadPool</code> y envíen ese código a su
hilo para su ejecución.</p>
<p>Los canales que aprendimos en el Capítulo 16, una forma simple de comunicarse
entre dos hilos, serían perfectos para este caso de uso. Usaremos un canal para
funcionar como la cola de trabajos, y <code>execute</code> enviará un trabajo desde el
<code>ThreadPool</code> a las instancias <code>Worker</code>, que enviarán el trabajo a su hilo. Aquí
está el plan:</p>
<ol>
<li>El <code>ThreadPool</code> creará un canal y mantendrá el emisor.</li>
<li>Cada <code>Worker</code> mantendrá el receptor.</li>
<li>Crearemos un nuevo struct <code>Job</code> que contendrá los closures que queremos
enviar a través del canal.</li>
<li>El método <code>execute</code> enviará el trabajo que desea ejecutar a través del
emisor.</li>
<li>En su hilo, el <code>Worker</code> recorrerá su receptor y ejecutará los closures de
cualquier trabajo que reciba.</li>
</ol>
<p>Empecemos por crear un canal en <code>ThreadPool::new</code> y mantener el emisor en la
instancia <code>ThreadPool</code>, como se muestra en el Listado 20-16. El struct <code>Job</code>
no contiene nada por ahora, pero será el tipo de elemento que enviaremos por el
canal.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-16: Modificando <code>ThreadPool</code> para almacenar el
emisor de un canal que transmite instancias <code>Job</code></span></p>
<p>En <code>ThreadPool::new</code>, creamos nuestro nuevo canal y hacemos que el pool
mantenga el emisor. Esto se compilará correctamente.</p>
<p>Intentemos pasar un receptor del canal a cada trabajador mientras el pool de
hilos crea el canal. Sabemos que queremos usar el receptor en el hilo que los
trabajadores generan, por lo que haremos referencia al parámetro <code>receiver</code> en
el closure. El código en el Listado 20-17 aún no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-17: Pasando el receptor a los
trabajadores</span></p>
<p>Hemos hecho algunos cambios pequeños y sencillos: pasamos el receptor al
constructor <code>Worker::new</code>, y luego lo usamos dentro del closure.</p>
<p>Cuando intentamos compilar este código, obtenemos este error:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>El código está intentando pasar <code>receiver</code> a múltiples instancias de <code>Worker</code>.
Esto no funcionará, como recordará del Capítulo 16: la implementación de canal
que Rust proporciona es de múltiples <em>productores</em>, un solo <em>consumidor</em>. Esto
significa que no podemos simplemente clonar el extremo consumidor del canal
para solucionar este código. Tampoco queremos enviar un mensaje varias veces a
múltiples consumidores; queremos una lista de mensajes con múltiples
trabajadores de modo que cada mensaje se procese una vez.</p>
<p>Además, quitar un trabajo de la cola del canal implica modificar el <code>receiver</code>,
por lo que los hilos necesitan una forma segura de compartir y modificar el
<code>receiver</code>; de lo contrario, podríamos obtener condiciones de carrera (como se
explicó en el Capítulo 16).</p>
<p>Recuerda los smart pointers thread-safe discutidos en el Capítulo 16: para
compartir la propiedad entre varios hilos y permitir que los hilos muten el
valor, necesitamos usar <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. El tipo <code>Arc</code> permitirá que varios
trabajadores sean propietarios del receptor, y <code>Mutex</code> garantizará que solo un
trabajador obtenga un trabajo del receptor a la vez. El Listado 20-18 muestra
los cambios que debemos hacer.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
<p><span class="caption">Listing 20-18: Compartiendo el receptor entre los
trabajadores usando <code>Arc</code> y <code>Mutex</code></span></p>
<p>En <code>ThreadPool::new</code>, ponemos el receptor en un <code>Arc</code> y un <code>Mutex</code>. Para cada
nuevo trabajador, clonamos el <code>Arc</code> para aumentar el recuento de referencias
para que los trabajadores puedan compartir la propiedad del receptor.</p>
<p>Con estos cambios, ¡el código se compila! ¡Estamos llegando!</p>
<h4 id="implementando-el-método-execute"><a class="header" href="#implementando-el-método-execute">Implementando el método <code>execute</code></a></h4>
<p>En este punto, finalmente implementaremos el método <code>execute</code> en <code>ThreadPool</code>.
También cambiaremos <code>Job</code> de un struct a un alias de tipo para un objeto de
trait que contiene el tipo de cierre que recibe <code>execute</code>. Como se discutió en
la sección <a href="ch19-04-advanced-types.html#creando-type-synonyms-con-type-aliases">“Creación de sinónimos de tipo con alias de
tipo”</a><!-- ignore -->
del Capítulo 19, los alias de tipo nos permiten hacer tipos largos más cortos
para facilitar su uso. Mira el Listado 20-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-19: Creando un alias de tipo <code>Job</code> para un
<code>Box</code> que contenga cada closure y luego enviamos el trabajo por el canal</span></p>
<p>Después de crear una nueva instancia de <code>Job</code> usando el closure que obtenemos
en <code>execute</code>, enviamos ese trabajo por el extremo de envío del canal. Estamos
llamando a <code>unwrap</code> en <code>send</code> para el caso de que el envío falle. Esto podría
suceder si, por ejemplo, detenemos todos nuestros hilos de ejecución, lo que
significa que el extremo receptor ha dejado de recibir nuevos mensajes. En este
momento, no podemos detener que nuestros hilos se ejecuten: nuestros hilos
continúan ejecutándose mientras exista el pool. La razón por la que usamos
<code>unwrap</code> es que sabemos que el caso de falla no sucederá, pero el compilador no
sabe eso.</p>
<p>¡Pero aún no hemos terminado! En el trabajador, nuestro cierre que se pasa a
<code>thread::spawn</code> todavía solo <em>hace referencia</em> al extremo receptor del canal.
En su lugar, necesitamos que el cierre se repita para siempre, preguntando al
extremo receptor del canal por un trabajo y ejecutando el trabajo cuando lo
obtiene. Hagamos el cambio que se muestra en el Listado 20-20 a <code>Worker::new</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {id} got a job; executing.&quot;);

            job();
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-20: Recibiendo y ejecutando los trabajos en el
hilo del trabajador</span></p>
<p>Aquí, primero llamamos a <code>lock</code> en el <code>receiver</code> para adquirir el mutex, y
luego llamamos a <code>unwrap</code> para que el hilo actual se bloquee en caso de que
ocurra algún error. Adquirir un bloqueo puede fallar si el mutex está en un
estado <em>envenenado</em>, lo que puede suceder si algún otro hilo se bloqueó mientras
sostenía el bloqueo en lugar de liberar el bloqueo. En esta situación, llamar a
<code>unwrap</code> para que este hilo se bloquee es la acción correcta a tomar. Siéntase
libre de cambiar este <code>unwrap</code> a un <code>expect</code> con un mensaje de error que sea
significativo para ti.</p>
<p>Si obtenemos el bloqueo en el mutex, llamamos a <code>recv</code> en el receptor para
recibir un <code>Job</code>. Un <code>unwrap</code> final mueve más allá de cualquier error aquí
también, que podría ocurrir si el hilo que tiene el extremo de envío se ha
apagado, similar a cómo el método <code>send</code> devuelve <code>Err</code> si el receptor se
apaga.</p>
<p>La llamada a <code>recv</code> bloquea, por lo que si aún no hay un trabajo, el hilo
actual esperará hasta que haya un trabajo disponible. El <code>Mutex&lt;T&gt;</code> garantiza
que solo un hilo <code>Worker</code> a la vez está tratando de solicitar un trabajo.</p>
<p>¡Nuestro pool de hilos ahora está en un estado funcional! Ejecuta <code>cargo run</code>
y haz algunas solicitudes:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>¡Éxito! Ahora tenemos un pool de hilos que ejecuta conexiones de forma
asincrónica. Nunca hay más de cuatro hilos creados, por lo que nuestro sistema
no se sobrecargará si el servidor recibe muchas solicitudes. Si hacemos una
solicitud a <em>/sleep</em>, el servidor podrá atender otras solicitudes haciendo que
otro hilo las ejecute.</p>
<blockquote>
<p>Nota: Si abres <em>/sleep</em> en múltiples ventanas del navegador simultáneamente,
podrían cargarse una a la vez en intervalos de 5 segundos. Algunos navegadores
web ejecutan múltiples instancias de la misma solicitud secuencialmente por
razones de almacenamiento en caché. Esta limitación no es causada por nuestro
servidor web.</p>
</blockquote>
<p>Después de aprender sobre el bucle <code>while let</code> en el Capítulo 18, es posible que
te preguntes por qué no escribimos el código del hilo del trabajador como se
muestra en el Listado 20-21.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {id} got a job; executing.&quot;);

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-21: Una implementación alternativa de
<code>Worker::new</code> usando <code>while let</code></span></p>
<p>Este código se compila y se ejecuta, pero no produce el comportamiento de
sub procesamiento deseado: una solicitud lenta aún hará que otras solicitudes
esperen ser procesadas. La razón es algo sutil: el struct <code>Mutex</code> no tiene
un método público <code>unlock</code> porque el ownership del bloqueo se basa en la
duración del <code>MutexGuard&lt;T&gt;</code> dentro del <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> que el
método <code>lock</code> devuelve. En tiempo de compilación, el borrow checker puede hacer
cumplir la regla de que un recurso protegido por un <code>Mutex</code> no se puede acceder
a menos que tengamos el bloqueo. Sin embargo, esta implementación también puede
resultar en que el bloqueo se mantenga más tiempo de lo previsto si no somos
conscientes de la duración del <code>MutexGuard&lt;T&gt;</code>.</p>
<p>El código en el Listado 20-21 que usa <code>let job = receiver.lock().unwrap().recv().unwrap();</code> funciona porque con <code>let</code>, los
valores temporales utilizados en la expresión del lado derecho del signo igual
se descartan inmediatamente cuando finaliza la declaración <code>let</code>. Sin embargo,
<code>while let</code> (y <code>if let</code> y <code>match</code>) no descarta los valores temporales hasta el
final del bloque asociado. En el Listado 20-21, el bloqueo permanece retenido
durante la duración de la llamada a <code>job()</code>, lo que significa que otros
trabajadores no pueden recibir trabajos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apagado-y-limpieza-eficientes"><a class="header" href="#apagado-y-limpieza-eficientes">Apagado y limpieza eficientes</a></h2>
<p>El código del Listing 20-20 está respondiendo requests de forma asíncrona 
mediante el uso de un pool de threads, como pretendíamos, Recibimos 
algunas advertencias sobre los campos <code>workers</code>, <code>id</code> y <code>thread</code> que no
estamos usando de forma directa que nos recuerda que no estamos limpiando
nada. Cuando usamos el método menos elegante <span class="keystroke">ctrl-c</span>
para detener el thread principal, todos los demás threads se detienen inmediatamente
también, incluso si están en medio de servir una request.</p>
<p>A continuación, implementaremos el trait <code>Drop</code> para llamar a <code>join</code> en cada uno
de los threads del pool para que puedan terminar las requests en las que están
trabajando antes de cerrar. Luego implementaremos una forma de decirle a los 
threads que deben dejar de aceptar nuevas requests y cerrarse. Para ver este
código en acción, modificaremos nuestro servidor para que acepte solo dos
requests antes de cerrar el pool de threads correctamente.</p>
<h3 id="implementando-el-trait-drop-en-threadpool"><a class="header" href="#implementando-el-trait-drop-en-threadpool">Implementando el Trait <code>Drop</code> en <code>ThreadPool</code></a></h3>
<p>Comencemos implementando <code>Drop</code> en nuestro pool de threads. Cuando el pool se
destruye, nuestros threads deberían unirse para asegurarse de que terminan su
trabajo. El Listing 20-22 muestra un primer intento de implementación de <code>Drop</code>;
este código aún no funcionará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-22: Uniendo cada thread cuando el thread pool
se sale del scope</span></p>
<p>Primero, iteramos a través de cada uno de los <code>workers</code> del pool de threads.
Usamos <code>&amp;mut</code> para esto porque <code>self</code> es una referencia mutable, y también
necesitamos poder mutar <code>worker</code>. Para cada worker, imprimimos un mensaje
diciendo que este worker en particular se está cerrando, y luego llamamos a
<code>join</code> en el thread de ese worker. Si la llamada a <code>join</code> falla, usamos
<code>unwrap</code> para que Rust entre en pánico y haga una salida poco elegante.</p>
<p>Aquí está el error que obtenemos cuando compilamos este código:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
   |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:1657:17

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>El error nos dice que no podemos llamar a <code>join</code> porque solo tenemos un
mutable borrow de cada <code>worker</code> y <code>join</code> toma el ownership de su argumento. 
Para solucionar este problema, necesitamos mover el thread fuera de la
instancia de <code>Worker</code> que posee <code>thread</code> para que <code>join</code> pueda consumir el
thread. Hicimos esto en el Listing 17-15: si <code>Worker</code> tiene un
<code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> en su lugar, podemos llamar al método
<code>take</code> en el <code>Option</code> para mover el valor fuera de la variante <code>Some</code> y
dejar una variante <code>None</code> en su lugar. En otras palabras, un <code>Worker</code> que
se está ejecutando tendrá una variante <code>Some</code> en <code>thread</code>, y cuando
queramos limpiar un <code>Worker</code>, reemplazaremos <code>Some</code> con <code>None</code> para que el
<code>Worker</code> no tenga un thread para ejecutar.</p>
<p>Entonces sabemos que queremos actualizar la definición de <code>Worker</code> de esta
manera:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ahora usemos el compilador para encontrar los otros lugares que necesitan
cambiar. Al verificar este código, obtenemos dos errores:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`
   |
note: the method `join` exists on the type `JoinHandle&lt;()&gt;`
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:1657:5
help: consider using `Option::expect` to unwrap the `JoinHandle&lt;()&gt;` value, panicking if the value is an `Option::None`
   |
52 |             worker.thread.expect(&quot;REASON&quot;).join().unwrap();
   |                          +++++++++++++++++

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected `Option&lt;JoinHandle&lt;()&gt;&gt;`, found `JoinHandle&lt;_&gt;`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` (lib) due to 2 previous errors
</code></pre>
<p>Abordemos el segundo error, que apunta al código al final de <code>Worker::new</code>;
necesitamos envolver el valor <code>thread</code> en <code>Some</code> cuando creamos un nuevo
<code>Worker</code>. Haga los siguientes cambios para corregir este error:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>El primer error está en nuestra implementación de <code>Drop</code>. Mencionamos
anteriormente que pretendíamos llamar a <code>take</code> en el valor <code>Option</code> para mover
<code>thread</code> fuera de <code>worker</code>. Los siguientes cambios lo harán:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Como discutimos en el Capítulo 17, el método <code>take</code> en <code>Option</code> toma la variante
<code>Some</code> y deja <code>None</code> en su lugar. Estamos usando <code>if let</code> para deconstruir el
<code>Some</code> y obtener el thread; luego llamamos a <code>join</code> en el thread. Si el thread
de un worker ya es <code>None</code>, sabemos que ese worker ya ha tenido su thread
limpiado, por lo que en ese caso no sucede nada.</p>
<h3 id="señalando-a-los-threads-que-dejen-de-escuchar-por-jobs"><a class="header" href="#señalando-a-los-threads-que-dejen-de-escuchar-por-jobs">Señalando a los threads que dejen de escuchar por jobs</a></h3>
<p>Con todos los cambios que hemos hecho, nuestro código se compila sin advertencias.
Sin embargo, las malas noticias son que este código aún no funciona de la manera
que queremos. La clave es la lógica en los closures ejecutados por los threads
de las instancias de <code>Worker</code>: en este momento, llamamos a <code>join</code>, pero eso no
detendrá los threads porque se ejecutan en un <code>loop</code> para siempre buscando jobs.
Si intentamos dejar caer nuestro <code>ThreadPool</code> con nuestra implementación actual
de <code>drop</code>, el thread principal se bloqueará para siempre esperando a que el
primer thread termine.</p>
<p>Para solucionar este problema, necesitamos un cambio en la implementación de
<code>drop</code> de <code>ThreadPool</code> y luego un cambio en el loop de <code>Worker</code>.</p>
<p>En primer lugar, cambiemos la implementación de <code>drop</code> de <code>ThreadPool</code> para
soltar explícitamente el <code>sender</code> antes de esperar a que los threads terminen.
El Listing 20-23 muestra los cambios en <code>ThreadPool</code> para soltar explícitamente
<code>sender</code>. Usamos la misma técnica <code>Option</code> y <code>take</code> que hicimos con el thread
para poder mover <code>sender</code> fuera de <code>ThreadPool</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-23: Dejar caer explícitamente <code>sender</code> antes de 
unirse a los threads del worker</span></p>
<p>Soltar <code>sender</code> cierra el canal, lo que indica que no se enviarán más mensajes.
Cuando eso sucede, todas las llamadas a <code>recv</code> que los workers hacen en el loop
infinito devolverán un error. En el Listing 20-24, cambiamos el loop de <code>Worker</code>
para salir del loop con gracia en ese caso, lo que significa que los hreads
terminarán cuando la implementación de <code>drop</code> de <code>ThreadPool</code> llame a <code>join</code>
en ellos.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p><span class="caption">Listing 20-24: Saliendo explícitamente del loop cuando 
<code>recv</code> devuelve un error</span></p>
<p>Para ver este código en acción, modifiquemos <code>main</code> para aceptar solo dos
requests antes de cerrar el servidor con gracia, como se muestra en el
Listing 20-25.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-25: Apagando el servidor después de servir dos 
requests saliendo del loop</span></p>
<p>No querríamos que un servidor web del mundo real se apague después de servir
solo dos requests. Este código solo demuestra que el apagado y la limpieza
con gracia funcionan.</p>
<p>El método <code>take</code> es definido en el trait <code>Iterator</code> y limita la iteración
de los primeros dos items como máximo. El <code>ThreadPool</code> saldrá del scope 
al final de <code>main</code> y la implementación <code>drop</code> correrá.</p>
<p>Iniciamos el servidor con <code>cargo run</code> y hacemos tres requests. La tercera
request debería fallar, y en su terminal debería ver una salida similar a esta:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Es posible que vea un orden diferente de workers y mensajes impresos. Podemos
ver cómo funciona este código a partir de los mensajes: los workers 0 y 3
obtuvieron las dos primeras requests. El servidor dejó de aceptar conexiones
después de la segunda conexión, y la implementación <code>Drop</code> en <code>ThreadPool</code>
comienza a ejecutarse antes de que el worker 3 comience su trabajo. Al soltar
<code>sender</code> desconecta a todos los workers y les dice que se apaguen. Los workers
imprimen un mensaje cuando se desconectan, y luego el pool de threads llama a
<code>join</code> para esperar a que cada thread worker termine.</p>
<p>Fijémonos en un aspecto interesante de esta ejecución en particular: el
<code>ThreadPool</code> soltó el <code>sender</code>, y antes de que cualquier worker recibiera un
error, intentamos unirnos al worker 0. El worker 0 aún no había recibido un
error de <code>recv</code>, por lo que el thread principal se bloqueó esperando a que el
worker 0 terminara. Mientras tanto, el worker 3 recibió un job y luego todos
los threads recibieron un error. Cuando el worker 0 terminó, el thread principal
esperó a que el resto de los workers terminaran. En ese momento, todos habían
salido de sus loops y se detuvieron.</p>
<p>¡Enhorabuena! Hemos completado nuestro proyecto; tenemos un servidor web básico
que usa un pool de threads para responder de forma asíncrona. Podemos realizar
un apagado con gracia del servidor, que limpia todos los threads del pool.</p>
<p>Aquí está el código completo como referencia:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>¡Podríamos hacer más! Si quieres seguir mejorando este proyecto, aquí hay algunas
ideas:</p>
<ul>
<li>Añadir más documentación a <code>ThreadPool</code> y sus métodos públicos.</li>
<li>Añadir tests de la funcionalidad de la librería.</li>
<li>Cambiar las llamadas a <code>unwrap</code> por un manejo de errores más robusto.</li>
<li>Usar <code>ThreadPool</code> para realizar alguna tarea que no sea servir requests web.</li>
<li>Encontrar una librería de pool de threads en <a href="https://crates.io/">crates.io</a> e
implementar un servidor web similar usando la librería en su lugar. Luego
compara su API y robustez con el pool de threads que implementamos.</li>
</ul>
<h2 id="resumen-19"><a class="header" href="#resumen-19">Resumen</a></h2>
<p>¡Bien hecho! ¡Has llegado al final del libro! Queremos agradecerte por unirte
a nosotros en este tour de Rust. Ahora estás listo para implementar tus propios
proyectos en Rust y ayudar con los proyectos de otras personas. Ten en cuenta
que hay una comunidad acogedora de otros Rustaceans que estarían encantados de
ayudarte con cualquier desafío que encuentres en tu viaje con Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apéndice"><a class="header" href="#apéndice">Apéndice</a></h1>
<p>Las siguientes secciones contienen material de referencia que le puede ser útil 
en su viaje a Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-a-palabras-clave"><a class="header" href="#apéndice-a-palabras-clave">Apéndice A: Palabras clave</a></h2>
<p>La siguiente lista contiene palabras clave que están reservadas para el uso
actual o futuro del lenguaje Rust. Por lo tanto, no se pueden usar como
identificadores (excepto como identificadores brutos como discutiremos en la
sección “<a href="appendix-01-keywords.html#identificadores-brutos">Identificadores brutos</a><!-- ignore -->”). Los
identificadores son nombres de funciones, variables, parámetros, campos de
estructuras, módulos, cajas, constantes, macros, valores estáticos, atributos,
tipos, rasgos o lifetimes.</p>
<h3 id="palabras-clave-actuales-en-uso"><a class="header" href="#palabras-clave-actuales-en-uso">Palabras clave actuales en uso</a></h3>
<p>La siguiente lista contiene las palabras clave actuales en uso, con su
funcionalidad descrita.</p>
<ul>
<li><code>as</code> - realiza una conversión primitiva, elimina la ambigüedad del <em>trait</em>
específico que contiene
un elemento, o cambiar el nombre de los elementos en las declaraciones <code>use</code> y 
<code>extern crate</code></li>
<li><code>async</code> -  retornar un <code>Future</code> en lugar de bloquear el hilo actual</li>
<li><code>await</code> - suspender la ejecución hasta que el resultado de un <code>Future</code> esté 
listo</li>
<li><code>break</code> - salir de un bucle inmediatamente</li>
<li><code>const</code> - define elementos constantes o punteros crudos constantes</li>
<li><code>continue</code> - continuar con la siguiente iteración del bucle</li>
<li><code>crate</code> - en un camino de módulo, se refiere a la raíz del módulo</li>
<li><code>dyn</code> - despacho dinámico a un objeto de rasgo</li>
<li><code>else</code> - alternativa para las construcciones de flujo de control <code>if</code> y 
<code>if let</code></li>
<li><code>enum</code> - define una enumeración</li>
<li><code>extern</code> - enlaza una función o variable externa</li>
<li><code>false</code> - literal booleano falso</li>
<li><code>fn</code> - define una función o el tipo de puntero de función</li>
<li><code>for</code> - bucle sobre elementos de un iterador, implementa un rasgo, o 
especifica una vida más alta</li>
<li><code>if</code> - ramificación basada en el resultado de una expresión condicional</li>
<li><code>impl</code> - implementa funcionalidad propia o de rasgo</li>
<li><code>in</code> - parte de la sintaxis del bucle <code>for</code></li>
<li><code>let</code> - vincula una variable</li>
<li><code>loop</code> - bucle sin condición</li>
<li><code>match</code> - combina un valor con patrones</li>
<li><code>mod</code> - define un módulo</li>
<li><code>move</code> - hace que una función clausura tome posesión de todos sus capturas</li>
<li><code>mut</code> - denota mutabilidad en referencias, punteros crudos o vinculaciones de 
patrones</li>
<li><code>pub</code> - denota visibilidad pública en campos de estructuras, bloques <code>impl</code> o 
módulos</li>
<li><code>ref</code> - vincula por referencia</li>
<li><code>return</code> - retorna de una función</li>
<li><code>Self</code> - un alias de tipo para el tipo que estamos definiendo o implementando</li>
<li><code>self</code> - sujeto de método o módulo actual</li>
<li><code>static</code> - variable global o duración de vida que dura toda la ejecución del 
programa</li>
<li><code>struct</code> - define una estructura</li>
<li><code>super</code> - módulo padre del módulo actual</li>
<li><code>trait</code> - define un rasgo</li>
<li><code>true</code> - literal booleano verdadero</li>
<li><code>type</code> - define un alias de tipo o tipo asociado</li>
<li><code>union</code> - define una <a href="https://doc.rust-lang.org/reference/items/unions.html">unión</a><!-- ignore -->; solo es una palabra clave 
cuando se usa en una declaración de unión</li>
<li><code>unsafe</code> - denota código, funciones, rasgos o implementaciones inseguras</li>
<li><code>use</code> - importa símbolos en el ámbito</li>
<li><code>where</code> - denota cláusulas que restringen un tipo</li>
<li><code>while</code> - bucle condicionalmente basado en el resultado de una expresión</li>
</ul>
<h3 id="palabras-clave-reservadas-para-uso-futuro"><a class="header" href="#palabras-clave-reservadas-para-uso-futuro">Palabras clave reservadas para uso futuro</a></h3>
<p>Las siguientes palabras clave no tienen aún ninguna funcionalidad, pero están
reservadas por Rust para un uso potencial en el futuro.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="identificadores-brutos"><a class="header" href="#identificadores-brutos">Identificadores brutos</a></h3>
<p><em>Identificadores brutos</em> son la sintaxis que le permite usar palabras clave
donde normalmente no se permitirían. Usted usa un identificador bruto
prefijando una palabra clave con <code>r#</code>.</p>
<p>Por ejemplo, <code>match</code> es una palabra clave. Si intenta compilar la siguiente
función que usa <code>match</code> como su nombre:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>obtendrá este error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>El error muestra que no se puede usar la palabra clave <code>match</code> como
identificador de función. Para usar <code>match</code> como nombre de función, necesita
usar la sintaxis de identificador bruto, como esta:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}</code></pre></pre>
<p>Este código compilará sin errores. Note el prefijo <code>r#</code> en el nombre de la
función en su definición, así como donde se llama la función en <code>main</code>.</p>
<p>Los identificadores brutos permiten usar cualquier palabra como identificador,
incluso si esa palabra es una palabra clave. Esto nos da más libertad para
elegir nombres de identificadores, así como nos permite integrarnos con
programas escritos en un lenguaje donde estas palabras no son palabras clave.
Además, los identificadores brutos nos permiten usar bibliotecas escritas en
una edición de Rust diferente a la de su crate. Por ejemplo, <code>try</code> no es una
palabra clave en la edición 2015, pero lo es en la edición 2018. Si depende de
una biblioteca que está escrita usando la edición 2015 y tiene una función
<code>try</code>, necesitará usar la sintaxis de identificador bruto para llamar a esa
función desde su código de la edición 2018. Vea <a href="appendix-05-editions.html">Apéndice E</a><!--
ignore --> para obtener más información sobre las ediciones.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-b-operators-and-symbols"><a class="header" href="#appendix-b-operators-and-symbols">Appendix B: Operators and Symbols</a></h2>
<h2 id="apéndice-b-operadores-y-símbolos"><a class="header" href="#apéndice-b-operadores-y-símbolos">Apéndice B: Operadores y símbolos</a></h2>
<p>Este apéndice contiene una lista de los operadores y símbolos que aparecen en
Rust, incluyendo los operadores y otros símbolos que aparecen por sí mismos o en
el contexto de rutas, genéricos, límites de trait, macros, atributos, comentarios,
tuplas y corchetes.</p>
<h3 id="operadores"><a class="header" href="#operadores">Operadores</a></h3>
<p>La tabla B-1 contiene los operadores en Rust, un ejemplo de cómo aparecería el
operador en contexto, una breve explicación y si ese operador es
sobrecargable. Si un operador es sobrecargable, se lista el rasgo relevante para
sobrecargar ese operador.</p>
<p><span class="caption">Tabla B-1: Operadores</span></p>
<div class="table-wrapper"><table><thead><tr><th>Operador</th><th>Ejemplo</th><th>Explicación</th><th>Sobrecargable?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Expansor de Macros</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Operador bit a bit o complemento lógico</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Comparador de No Igualdad</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Modulo</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Modulo y asignación</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Préstamo</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Préstamo del puntero del tipo</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Operador bit a bit AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Operador bit a bit AND y asignación</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Operador lógico AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Multiplicación</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Multiplicación y asignación</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Direferencia</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Puntero</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Restricción de tipo compuesta</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Aritmético adición</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Adición y asignación</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Separador de argumentos y elementos</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Aritmético de Negación</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Aritmético de sustracción</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Aritmético de sustracción y asignación</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Tipo de retorno en funciones y clausuras</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Acceso a miembro</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Rango exclusivo a la derecha</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Rango inclusivo a la derecha</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Sintaxis de actualización de estructuras</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Patrón “y el resto”</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Obsoleto, use <code>..=</code> en su lugar) En un patrón: Patrón de rango inclusivo</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>División aritmética</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>División aritmética y asignación</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Restricciones</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Inicializador de campo de estructura</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Etiqueta de bucle</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Terminador de declaración y elemento</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Parte de la sintaxis de arreglos de tamaño fijo</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Desplazamiento a la izquierda</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Desplazamiento a la izquierda y asignación</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Comparador de menor que</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Comparador de menor o igual que</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Asignación/equivalencia</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Comparador de igualdad</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Parte de la sintaxis de match</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Comparador de mayor que</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Comparador de mayor o igual que</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Desplazamiento a la derecha</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Desplazamiento a la derecha y asignación</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Patrón de enlace</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Operador bit a bit XOR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Operador bit a bit XOR y asignación</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Patrón alternativo</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Operador bit a bit OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Operador bit a bit OR y asignación</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Operador lógico OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Operador de propagación de errores</td><td></td></tr>
</tbody></table>
</div>
<h3 id="simbolos-no-operadores"><a class="header" href="#simbolos-no-operadores">Simbolos no operadores</a></h3>
<p>La siguiente lista contiene todos los símbolos que no funcionan como
operadores; es decir, no se comportan como una llamada de función o método.</p>
<p>Tabla B-2 muestra los símbolos que aparecen por sí mismos y son válidos en una
variedad de ubicaciones.</p>
<p><span class="caption">Tabla B-2: Sintaxis únicas</span></p>
<div class="table-wrapper"><table><thead><tr><th>Símbolos</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Lifetime nombrado o etiqueta de bucle</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Literal numérico de un tipo especifico</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>Literal de tipo String</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>Literal de tipo String sin procesar</td></tr>
<tr><td><code>b'...'</code></td><td>Literal de tipo byte; construye un array de bytes en lugar de una cadena</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>Literal de tipo String sin procesar, combinación de literal de tipo String y literal de tipo byte</td></tr>
<tr><td><code>'...'</code></td><td>Literal de tipo caracter</td></tr>
<tr><td><code>b'...'</code></td><td>Literal de tipo byte ASCII</td></tr>
<tr><td><code>|...| expr</code></td><td>Clausura</td></tr>
<tr><td><code>!</code></td><td>Tipo de dato vacío siempre vacío para funciones divergentes</td></tr>
<tr><td><code>_</code></td><td>“Ignored” patrón de enlace; también se usa para hacer que los literales enteros sean legibles</td></tr>
</tbody></table>
</div>
<p>Tabla B-3 muestra los símbolos que aparecen en el contexto de un camino a través
del módulo de la jerarquía para un elemento.</p>
<p><span class="caption">Tabla B-3: Sintaxis relacionado a Rutas</span></p>
<div class="table-wrapper"><table><thead><tr><th>Símbolos</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Namespace path</td></tr>
<tr><td><code>::path</code></td><td>Path relative to the crate root (i.e., an explicitly absolute path)</td></tr>
<tr><td><code>self::path</code></td><td>Path relative to the current module (i.e., an explicitly relative path)</td></tr>
<tr><td><code>super::path</code></td><td>Path relative to the parent of the current module</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Associated constants, functions, and types</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Associated item for a type that cannot be directly named (e.g., <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Disambiguating a method call by naming the trait that defines it</td></tr>
<tr><td><code>type::method(...)</code></td><td>Disambiguating a method call by naming the type for which it’s defined</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Disambiguating a method call by naming the trait and type</td></tr>
</tbody></table>
</div>
<p>Tabla B-4 muestra los símbolos que aparecen en el contexto de usar parámetros de
tipo genérico.</p>
<p><span class="caption">Tabla B-4: Genericos</span></p>
<div class="table-wrapper"><table><thead><tr><th>Símbolos</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Especifica parámetros de tipo genérico en un tipo (por ejemplo, <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Especifica parámetros de tipo genérico, función o método en una expresión; a menudo se refiere como pez espada (por ejemplo, <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Define una función genérica</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Define una estructura genérica</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Define una enumeración genérica</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Define una implementación genérica</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Límites de vida de rango superior</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Un tipo genérico donde uno o más tipos asociados tienen asignaciones específicas (por ejemplo, <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Tabla B-5 muestra los símbolos que aparecen en el contexto de restringir
parámetros de tipo genérico con límites de tipo.</p>
<p><span class="caption">Tabla B-5: Restricciones de tipo</span></p>
<div class="table-wrapper"><table><thead><tr><th>Simbolos</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Parámetro de tipo genérico <code>T</code> restringido a tipos que implementan <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Tipo genérico <code>T</code> debe sobrevivir al tiempo de vida <code>'a</code> (es decir, el tipo no puede contener de forma transitiva referencias con tiempos de vida más cortos que <code>'a</code>)</td></tr>
<tr><td><code>T: 'static</code></td><td>Tipo genérico <code>T</code> no contiene referencias prestadas, excepto las de <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>Tiempo de vida genérico <code>'b</code> debe sobrevivir al tiempo de vida <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Permitir que el parámetro de tipo genérico sea un tipo de tamaño dinámico</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Restricción de tipo compuesta</td></tr>
</tbody></table>
</div>
<p>Tabla B-6 muestra los símbolos que aparecen en el contexto de llamar o definir
macros y especificar atributos en un elemento.</p>
<p><span class="caption">Tabla B-6: Macros y Atributos</span></p>
<div class="table-wrapper"><table><thead><tr><th>Símbolos</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Atributo externo</td></tr>
<tr><td><code>#![meta]</code></td><td>Atributo interno</td></tr>
<tr><td><code>$ident</code></td><td>Sustitución de macro</td></tr>
<tr><td><code>$ident:kind</code></td><td>Captura de macro</td></tr>
<tr><td><code>$(...)...</code></td><td>Repetición de macro</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Invocación de macro</td></tr>
</tbody></table>
</div>
<p>Tabla B-7 muestra los símbolos que crean comentarios.</p>
<p><span class="caption">Tabla B-7: Comentarios</span></p>
<div class="table-wrapper"><table><thead><tr><th>Símbolos</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Comentario de línea</td></tr>
<tr><td><code>//!</code></td><td>Comentario de línea de documentación interna</td></tr>
<tr><td><code>///</code></td><td>Comentario de línea de documentación externa</td></tr>
<tr><td><code>/*...*/</code></td><td>Comentario de bloque</td></tr>
<tr><td><code>/*!...*/</code></td><td>Comentario de bloque de documentación interna</td></tr>
<tr><td><code>/**...*/</code></td><td>Comentario de bloque de documentación externa</td></tr>
</tbody></table>
</div>
<p>Tabla B-8 muestra los símbolos que aparecen en el contexto de usar tuplas.</p>
<p><span class="caption">Tabla B-8: Tuplas</span></p>
<div class="table-wrapper"><table><thead><tr><th>Símbolos</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Tupla vacía (también conocida como unidad), tanto literal como tipo</td></tr>
<tr><td><code>(expr)</code></td><td>Expresión entre paréntesis</td></tr>
<tr><td><code>(expr,)</code></td><td>Expresión de tupla de un solo elemento</td></tr>
<tr><td><code>(type,)</code></td><td>Tipo de tupla de un solo elemento</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Expresión de tupla</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tipo de tupla</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Expresión de llamada de función; también se usa para inicializar <code>struct</code>s de tupla y variantes de <code>enum</code> de tupla</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Índice de tupla</td></tr>
</tbody></table>
</div>
<p>Tabla B-9 muestra los contextos en los que se usan las llaves.</p>
<p><span class="caption">Tabla B-9: Llaves</span></p>
<div class="table-wrapper"><table><thead><tr><th>Contexto</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Expresión de bloque</td></tr>
<tr><td><code>Type {...}</code></td><td>Literal de <code>struct</code></td></tr>
</tbody></table>
</div>
<p>Tabla B-10 muestra los contextos en los que se usan los corchetes.</p>
<p><span class="caption">Tabla B-10: Corchetes</span></p>
<div class="table-wrapper"><table><thead><tr><th>Contexto</th><th>Explicación</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Expresión de arreglo</td></tr>
<tr><td><code>[type; expr]</code></td><td>Arreglo de tipo y tamaño</td></tr>
<tr><td><code>expr[expr]</code></td><td>Índice de colección. Sobrecargable (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Índice de colección fingiendo ser recortes de colección, usando <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, o <code>RangeFull</code> como el “índice”</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-c-traits-derivables"><a class="header" href="#apéndice-c-traits-derivables">Apéndice C: Traits derivables</a></h2>
<p>En varios lugares del libro, hemos discutido el atributo <code>derive</code>, que puede
aplicar a una definición de estructura o enumeración. El atributo <code>derive</code>
genera código que implementará un rasgo con su propia implementación
predeterminada en el tipo que ha anotado con la sintaxis <code>derive</code>.</p>
<p>En este apéndice, proporcionamos una referencia de todos los traits en la
biblioteca estándar que puede usar con <code>derive</code>. Cada sección cubre:</p>
<ul>
<li>Qué operadores y métodos que derivan este trait se habilitarán</li>
<li>Qué hace la implementación del trait proporcionado por <code>derive</code></li>
<li>Qué significa implementar el trait sobre el tipo</li>
<li>Las condiciones en las que se le permite o no implementar el trait</li>
<li>Ejemplos de operaciones que requieren el trait</li>
</ul>
<p>Si desea un comportamiento diferente al proporcionado por el atributo <code>derive</code>,
consulte la documentación de la <a href="../std/index.html">biblioteca estándar</a><!-- ignore -->
para cada trait para obtener detalles sobre cómo implementarlos manualmente.</p>
<p>Estos traits enumerados aquí son los únicos definidos por la biblioteca
estándar que se pueden implementar en sus tipos usando <code>derive</code>. Otros traits
definidos en la biblioteca estándar no tienen un comportamiento predeterminado
sensato, por lo que depende de usted implementarlos de la manera que tenga
sentido para lo que está tratando de lograr.</p>
<p>Un ejemplo de un trait que no se puede derivar es <code>Display</code>, que maneja el
formateo para los usuarios finales. Siempre debe considerar la forma apropiada
de mostrar un tipo a un usuario final. ¿Qué partes del tipo puede ver un
usuario final? ¿Qué partes encontrarían relevantes? ¿Qué formato de los datos
sería más relevante para ellos? El compilador Rust no tiene esta idea, por lo
que no puede proporcionar un comportamiento predeterminado apropiado para
usted.</p>
<p>La lista de traits derivables proporcionada en este apéndice no es
exhaustiva: las bibliotecas pueden implementar <code>derive</code> para sus propios
traits, lo que hace que la lista de traits que puede usar <code>derive</code> sea
realmente abierta. Implementar <code>derive</code> implica usar una macro procedural, que
se cubre en la sección <a href="ch19-06-macros.html#macros">“Macros”</a><!-- ignore --> del Capítulo 19.</p>
<h3 id="debug-para-el-output-del-programador"><a class="header" href="#debug-para-el-output-del-programador"><code>Debug</code> para el Output del programador</a></h3>
<p>El trait <code>Debug</code> permite el formateo de depuración en cadenas de formato, que
indica agregando <code>:?</code> dentro de los marcadores <code>{}</code>.</p>
<p>El trait <code>Debug</code> te permite imprimir instancias de un tipo con fines de
depuración, para que tú y otros programadores que usen tu tipo puedan
inspeccionar una instancia en un punto particular de la ejecución de un
programa.</p>
<p>El trait <code>Debug</code> es necesario, por ejemplo, en el uso de la macro <code>assert_eq!</code>.
Esta macro imprime los valores de las instancias dadas como argumentos si la
aserción de igualdad falla, por lo que los programadores pueden ver por qué
las dos instancias no eran iguales.</p>
<h3 id="partialeq-y-eq-para-comparaciones-de-igualdad"><a class="header" href="#partialeq-y-eq-para-comparaciones-de-igualdad"><code>PartialEq</code> y <code>Eq</code> para comparaciones de igualdad</a></h3>
<p>El trait <code>PartialEq</code> te permite comparar instancias de un tipo para verificar
la igualdad y habilita el uso de los operadores <code>==</code> y <code>!=</code>.</p>
<p>Derivar <code>PartialEq</code> implementa el método <code>eq</code>. Cuando se deriva <code>PartialEq</code>
en estructuras, dos instancias son iguales solo si <em>todos</em> los campos son
iguales, y las instancias no son iguales si alguno de los campos no es igual.
Cuando se deriva en enumeraciones, cada variante es igual a sí misma y no
igual a las otras variantes.</p>
<p>El trait <code>PartialEq</code> es necesario, por ejemplo, con el uso de la macro
<code>assert_eq!</code>, que necesita poder comparar dos instancias de un tipo para la
igualdad.</p>
<p>El trait <code>Eq</code> no tiene métodos. Su propósito es señalar que para cada valor
del tipo anotado, el valor es igual a sí mismo. El trait <code>Eq</code> solo se puede
aplicar a tipos que también implementan <code>PartialEq</code>, aunque no todos los tipos
que implementan <code>PartialEq</code> pueden implementar <code>Eq</code>. Un ejemplo de esto son
los tipos de números de punto flotante: la implementación de los números de
punto flotante establece que dos instancias del valor no es un número (<code>NaN</code>)
no son iguales entre sí.</p>
<p>Un ejemplo de cuando se necesita <code>Eq</code> es para las claves en un <code>HashMap&lt;K, V&gt;</code>
para que el <code>HashMap&lt;K, V&gt;</code> pueda decir si dos claves son iguales.</p>
<h3 id="partialord-y-ord-para-comparaciones-de-orden"><a class="header" href="#partialord-y-ord-para-comparaciones-de-orden"><code>PartialOrd</code> y <code>Ord</code> para comparaciones de orden</a></h3>
<p>El trait <code>PartialOrd</code> te permite comparar instancias de un tipo para fines de
ordenación. Un tipo que implementa <code>PartialOrd</code> se puede usar con los
operadores <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> y <code>&gt;=</code>. Solo puede aplicar el trait <code>PartialOrd</code> a
tipos que también implementan <code>PartialEq</code>.</p>
<p>Derivar <code>PartialOrd</code> implementa el método <code>partial_cmp</code>, que devuelve un
<code>Option&lt;Ordering&gt;</code> que será <code>None</code> cuando los valores dados no produzcan un
orden. Un ejemplo de un valor que no produce un orden, a pesar de que la
mayoría de los valores de ese tipo se pueden comparar, es el valor de punto
flotante no es un número (<code>NaN</code>). Llamar a <code>partial_cmp</code> con cualquier número
de punto flotante y el valor de punto flotante <code>NaN</code> devolverá <code>None</code>.</p>
<p>Cuando se deriva en structs, <code>PartialOrd</code> compara dos instancias comparando el
valor en cada campo en el orden en que aparecen los campos en la definición
del struct. Cuando se deriva en enums, las variantes del enum declaradas
anteriormente en la definición de la enumeración se consideran menores
que las variantes enumeradas más tarde.</p>
<p>El trait <code>PartialOrd</code> es necesario, por ejemplo, para el método <code>gen_range</code>
del crate <code>rand</code> que genera un valor aleatorio en el rango especificado por
una expresión de rango.</p>
<p>El trait <code>Ord</code> permite saber que para cualquier dos valores del tipo anotado,
existirá un orden válido. El trait <code>Ord</code> implementa el método <code>cmp</code>, que
devuelve un <code>Ordering</code> en lugar de un <code>Option&lt;Ordering&gt;</code> porque siempre será
posible un orden válido. Solo puede aplicar el trait <code>Ord</code> a tipos que también
implementan <code>PartialOrd</code> y <code>Eq</code> (y <code>Eq</code> requiere <code>PartialEq</code>). Cuando se
deriva en structs y enums, <code>cmp</code> se comporta de la misma manera que la
implementación derivada para <code>partial_cmp</code> con <code>PartialOrd</code>.</p>
<p>Un ejemplo de cuando se necesita <code>Ord</code> es cuando se almacenan valores en un
<code>BTreeSet&lt;T&gt;</code>, una estructura de datos que almacena datos basados en el orden
de clasificación de los valores.</p>
<h3 id="clone-y-copy-para-duplicar-valores"><a class="header" href="#clone-y-copy-para-duplicar-valores"><code>Clone</code> y <code>Copy</code> para duplicar valores</a></h3>
<p>El trait <code>Clone</code> te permite crear explícitamente una copia profunda de un
valor, y el proceso de duplicación puede implicar la ejecución de código
arbitrario y la copia de datos de la pila. Consulte la sección <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">“Ways
Variables and Data Interact: Clone”</a><!-- ignore -->
en el Capítulo 4 para obtener más información sobre <code>Clone</code>.</p>
<p>Derivar <code>Clone</code> implementa el método <code>clone</code>, que cuando se implementa para
todo el tipo, llama a <code>clone</code> en cada una de las partes del tipo. Esto
significa que todos los campos o valores en el tipo también deben implementar
<code>Clone</code> para derivar <code>Clone</code>.</p>
<p>Un ejemplo de cuando se requiere <code>Clone</code> es cuando se llama al método <code>to_vec</code>
en una rebanada. La rebanada no posee las instancias de tipo que contiene, pero
el vector devuelto de <code>to_vec</code> necesitará poseer sus instancias, por lo que
<code>to_vec</code> llama a <code>clone</code> en cada elemento. Por lo tanto, el tipo almacenado en
la rebanada debe implementar <code>Clone</code>.</p>
<p>El trait <code>Copy</code> te permite duplicar un valor copiando solo los bits almacenados
en la pila; no es necesario ningún código arbitrario. Consulte la sección
<a href="ch04-01-what-is-ownership.html#solo-datos-del-stack-copiar">“Stack-Only Data: Copy”</a><!-- ignore --> en el Capítulo 4
para obtener más información sobre <code>Copy</code>.</p>
<p>El trait <code>Copy</code> no define ningún método para evitar que los programadores
sobrecarguen esos métodos y violen la suposición de que no se está ejecutando
código arbitrario. De esa manera, todos los programadores pueden asumir que
copiar un valor será muy rápido.</p>
<p>Puede derivar <code>Copy</code> en un tipo solo si todas las partes del tipo implementan
<code>Copy</code>. Un tipo que implementa <code>Copy</code> también debe implementar <code>Clone</code>, porque
un tipo que implementa <code>Copy</code> tiene una implementación trivial de <code>Clone</code> que
realiza la misma tarea que <code>Copy</code>.</p>
<p>El trait <code>Copy</code> es rara vez requerido; los tipos que implementan <code>Copy</code> tienen
optimizaciones disponibles, lo que significa que no tiene que llamar a <code>clone</code>,
lo que hace que el código sea más conciso.</p>
<p>Todo lo posible con <code>Copy</code> también se puede lograr con <code>Clone</code>, pero el código
podría ser más lento o tener que usar <code>clone</code> en lugares.</p>
<h3 id="hash-para-mapear-un-valor-a-un-valor-de-tamaño-fijo"><a class="header" href="#hash-para-mapear-un-valor-a-un-valor-de-tamaño-fijo"><code>Hash</code> para mapear un valor a un valor de tamaño fijo</a></h3>
<p>El trait <code>Hash</code> te permite tomar una instancia de un tipo de tamaño arbitrario
y asignar esa instancia a un valor de tamaño fijo usando una función hash.
Derivar <code>Hash</code> implementa el método <code>hash</code>. La implementación derivada del
método <code>hash</code> combina el resultado de llamar a <code>hash</code> en cada una de las partes
del tipo, lo que significa que todos los campos o valores también deben
implementar <code>Hash</code> para derivar <code>Hash</code>.</p>
<p>Un ejemplo de cuando se requiere <code>Hash</code> es en el almacenamiento de claves en
un <code>HashMap&lt;K, V&gt;</code> para almacenar datos de manera eficiente.</p>
<h3 id="default-para-valores-predeterminados"><a class="header" href="#default-para-valores-predeterminados"><code>Default</code> para valores predeterminados</a></h3>
<p>El trait <code>Default</code> te permite crear un valor predeterminado para un tipo.
Derivar <code>Default</code> implementa la función <code>default</code>. La implementación derivada
de la función <code>default</code> llama a la función <code>default</code> en cada parte del tipo,
lo que significa que todos los campos o valores en el tipo también deben
implementar <code>Default</code> para derivar <code>Default</code>.</p>
<p>La función <code>Default::default</code> es comúnmente usada en combinación con la
sintaxis de actualización de struct discutida en la sección <a href="ch05-01-defining-structs.html#creando-instancias-de-otras-instancias-con-sintaxis-de-struct-update">“Creating
Instances From Other Instances With
Struct Update Syntax”</a><!-- ignore -->
en el Capítulo 5. Puede personalizar algunos campos de un struct y luego
establecer y usar un valor predeterminado para el resto de los campos usando
<code>..Default::default()</code>.</p>
<p>El trait <code>Default</code> es necesario, por ejemplo, cuando se usa el método
<code>unwrap_or_default</code> en instancias de <code>Option&lt;T&gt;</code>. Si el <code>Option&lt;T&gt;</code> es <code>None</code>,
el método <code>unwrap_or_default</code> devolverá el resultado de <code>Default::default</code> para
el tipo <code>T</code> almacenado en el <code>Option&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-d---herramientas-de-desarrollo-útiles"><a class="header" href="#apéndice-d---herramientas-de-desarrollo-útiles">Apéndice D - Herramientas de desarrollo útiles</a></h2>
<p>En este apéndice, hablaremos sobre algunas herramientas de desarrollo útiles
que proporciona el proyecto Rust. Veremos el formato automático, formas rápidas
de aplicar correcciones de advertencia, un linter e integración con IDE.</p>
<h3 id="formato-automático-con-rustfmt"><a class="header" href="#formato-automático-con-rustfmt">Formato automático con <code>rustfmt</code></a></h3>
<p>La herramienta <code>rustfmt</code> reformatea su código de acuerdo con el estilo de código
de la comunidad. Muchos proyectos colaborativos usan <code>rustfmt</code> para evitar
discusiones sobre qué estilo usar al escribir Rust: todos formatean su código
usando la herramienta.</p>
<p>Para instalar <code>rustfmt</code>, ingrese lo siguiente:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Este comando le da <code>rustfmt</code> y <code>cargo-fmt</code>, similar a cómo Rust le da <code>rustc</code> y
<code>cargo</code>. Para formatear cualquier proyecto de carga útil, ingrese lo siguiente:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Ejecutando este comando reformatea todo el código Rust en la carga útil actual.
Esto solo debería cambiar el estilo de código, no la semántica del código. Para
más información sobre <code>rustfmt</code>, vea <a href="https://github.com/rust-lang/rustfmt">su documentación</a>.</p>
<h3 id="corregir-su-código-con-rustfix"><a class="header" href="#corregir-su-código-con-rustfix">Corregir su código con <code>rustfix</code></a></h3>
<p>La herramienta <code>rustfix</code> se incluye con las instalaciones de Rust y puede
corregir automáticamente las advertencias del compilador que tienen una forma
clara de corregir el problema que es probablemente lo que desea. Es probable que
haya visto advertencias del compilador antes. Por ejemplo, considere este código:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Aquí, estamos llamando a la función <code>do_something</code> 100 veces, pero nunca usamos
la variable <code>i</code> en el cuerpo del bucle <code>for</code>. Rust nos advierte sobre eso:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Esta advertencia sugiere que usemos <code>_i</code> como nombre en su lugar: el guión bajo
indica que pretendemos que esta variable no se use. Podemos aplicar
automáticamente esa sugerencia usando la herramienta <code>rustfix</code> ejecutando el
comando <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Cuando volvemos a mirar <em>src/main.rs</em>, veremos que <code>cargo fix</code> ha cambiado el
código:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>La variable del bucle <code>for</code> ahora se llama <code>_i</code>, y la advertencia ya no aparece.</p>
<p>También puede usar <code>cargo fix</code> para transformar su código entre diferentes
ediciones de Rust. Las ediciones se tratan en el <a href="appendix-05-editions.html">Apéndice E</a>.</p>
<h3 id="más-lints-con-clippy"><a class="header" href="#más-lints-con-clippy">Más lints con Clippy</a></h3>
<p>La herramienta <code>clippy</code> es una colección de lints para analizar su código para
que pueda detectar errores comunes y mejorar su código Rust.</p>
<p>Para instalar <code>clippy</code>, ingrese lo siguiente:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Para ejecutar los lints de Clippy en cualquier proyecto de carga útil, ingrese
lo siguiente:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Por ejemplo, digamos que escribe un programa que usa una aproximación de una
constante matemática, como pi, como lo hace este programa:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}</code></pre></pre>
<p>Ejecutando <code>cargo clippy</code> en este proyecto resulta en este error:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Este error le informa que Rust ya tiene una constante <code>PI</code> más precisa definida
y que su programa sería más correcto si usara la constante en su lugar. Luego
cambiaría su código para usar la constante <code>PI</code>. El siguiente código no
produce ningún error ni advertencia de Clippy:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}</code></pre></pre>
<p>Para obtener más información sobre Clippy, consulte <a href="https://github.com/rust-lang/rust-clippy">su documentación</a>.</p>
<h3 id="integración-de-ide-con-rust-analyzer"><a class="header" href="#integración-de-ide-con-rust-analyzer">Integración de IDE con <code>rust-analyzer</code></a></h3>
<p>Para ayudar a la integración del IDE, la comunidad Rust recomienda usar
<a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a>. Esta herramienta es un conjunto de utilidades
centradas en el compilador que habla el <a href="http://langserver.org/">Protocolo del servidor de lenguaje</a></p>
<!-- ignore -->, que es una especificación para que los IDE y los lenguajes de
<p>programación se comuniquen entre sí. Diferentes clientes pueden usar
<code>rust-analyzer</code>, como <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">el complemento del analizador Rust para Visual Studio
Code</a>.</p>
<p>Visite la <a href="https://rust-analyzer.github.io">página de inicio del proyecto <code>rust-analyzer</code></a><!-- ignore -->
para obtener instrucciones de instalación, luego instale el soporte del servidor
de lenguaje en su IDE en particular. Su IDE ganará habilidades como
autocompletado, salto a la definición y errores en línea. </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-e---ediciones"><a class="header" href="#apéndice-e---ediciones">Apéndice E - Ediciones</a></h2>
<p>En el Capítulo 1, viste que <code>cargo new</code> agrega un poco de metadatos a tu archivo
<em>Cargo.toml</em> sobre una edición. ¡Este apéndice habla sobre lo que eso significa!</p>
<p>El lenguaje Rust y el compilador tienen un ciclo de lanzamiento de seis semanas,
lo que significa que los usuarios obtienen un flujo constante de nuevas
características. Otros lenguajes de programación lanzan cambios más grandes con
menos frecuencia; Rust lanza actualizaciones más pequeñas con más frecuencia.
Después de un tiempo, todos estos pequeños cambios se suman. Pero de una
versión a otra, puede ser difícil mirar hacia atrás y decir: “Wow, entre Rust
1.10 y Rust 1.31, Rust ha cambiado mucho!”</p>
<p>Cada dos o tres años, el equipo de Rust produce una nueva <em>edición</em> de Rust.
Cada edición reúne las características que han aterrizado en un paquete claro
con documentación y herramientas completamente actualizadas. Las nuevas
ediciones se envían como parte del proceso de lanzamiento habitual de seis
semanas.</p>
<p>Las ediciones sirven para diferentes propósitos para diferentes personas:</p>
<ul>
<li>Para los usuarios activos de Rust, una nueva edición reúne los cambios
incrementales en un paquete fácil de entender.</li>
<li>Para los no usuarios, una nueva edición señala que se han realizado algunos
avances importantes, lo que podría hacer que Rust valga la pena volver a
mirar.</li>
<li>Para aquellos que desarrollan Rust, una nueva edición proporciona un punto de
reunión para todo el proyecto.</li>
</ul>
<p>En el momento de escribir esto, hay tres ediciones de Rust disponibles: Rust
2015, Rust 2018 y Rust 2021. Este libro está escrito utilizando los
modismos de la edición Rust 2021.</p>
<p>La clave <code>edition</code> en <em>Cargo.toml</em> indica qué edición debe usar el compilador
para su código. Si la clave no existe, Rust usa <code>2015</code> como el valor de la
edición por razones de compatibilidad con versiones anteriores.</p>
<p>Cada proyecto puede optar por una edición que no sea la edición predeterminada
2015. Las ediciones pueden contener cambios incompatibles, como incluir una
nueva palabra clave que entra en conflicto con los identificadores en el código.
Sin embargo, a menos que opte por esos cambios, su código seguirá compilando
incluso cuando actualice la versión del compilador Rust que usa.</p>
<p>Todas las versiones del compilador Rust admiten cualquier edición que existía
antes del lanzamiento de ese compilador, y pueden vincular cajas de cualquier
edición compatible entre sí. Los cambios de edición solo afectan la forma en
que el compilador analiza inicialmente el código. Por lo tanto, si está usando
Rust 2015 y una de sus dependencias usa Rust 2018, su proyecto se compilará y
podrá usar esa dependencia. La situación opuesta, donde su proyecto usa Rust
2018 y una dependencia usa Rust 2015, también funciona.</p>
<p>Para ser claros: la mayoría de las características estarán disponibles en todas
las ediciones. Los desarrolladores que usen cualquier edición de Rust seguirán
viendo mejoras a medida que se realicen nuevos lanzamientos estables. Sin
embargo, en algunos casos, principalmente cuando se agregan nuevas palabras
clave, algunas nuevas características pueden estar disponibles solo en ediciones
posteriores. Deberá cambiar de edición si desea aprovechar dichas
características.</p>
<p>Para más detalles, la <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Guía de edición</em></a>
es un libro completo sobre ediciones que enumera las diferencias entre ediciones
y explica cómo actualizar automáticamente su código a una nueva edición a través
de <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-f-traducciones-del-libro"><a class="header" href="#apéndice-f-traducciones-del-libro">Apéndice F: Traducciones del libro</a></h2>
<p>Para recursos en idiomas distintos al inglés. La mayoría aún están en progreso;
consulte <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">la etiqueta de traducciones</a> para ayudar o informarnos sobre
una nueva traducción.</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Portugués (Brasil)</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Portugués</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">Chino simplificado</a></li>
<li><a href="https://github.com/rust-tw/book-tw">Chino tradicional (Taiwán)</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Ucraniano</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a>
, <a href="https://github.com/RustLangES/rust-book-es">esta versión</a></li>
<li><a href="https://github.com/EmanueleGurini/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Ruso</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">Coreano</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">Japonés</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Francés</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polaco</a></li>
<li><a href="https://github.com/agentzero1/book">Cubano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalo</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">Griego</a></li>
<li><a href="https://github.com/sebras/book">Sueco</a></li>
<li><a href="https://github.com/RustFarsi/book">Persa</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Alemán</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">Hindú</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">Tailandés</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danés</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-g---cómo-se-hace-rust-y-rust-nightly"><a class="header" href="#apéndice-g---cómo-se-hace-rust-y-rust-nightly">Apéndice G - Cómo se hace Rust y “Rust Nightly”</a></h2>
<p>Este apéndice trata sobre cómo se hace Rust y cómo eso te afecta como
desarrollador de Rust.</p>
<h3 id="estabilidad-sin-estancamiento"><a class="header" href="#estabilidad-sin-estancamiento">Estabilidad sin estancamiento</a></h3>
<p>Como lenguaje, Rust se preocupa <em>mucho</em> por la estabilidad de tu código.
Queremos que Rust sea una base sólida sobre la que puedas construir, y si las
cosas cambian constantemente, eso sería imposible. Al mismo tiempo, si no
podemos experimentar con nuevas características, es posible que no descubramos
fallos importantes hasta después de su lanzamiento, cuando ya no podamos
cambiar las cosas.</p>
<p>Nuestra solución a este problema es lo que llamamos “estabilidad sin
estancamiento”, y nuestro principio rector es el siguiente: nunca debes temer
actualizar a una nueva versión de Rust estable. Cada actualización debe ser
indolora, pero también debe traerte nuevas características, menos errores y
tiempos de compilación más rápidos.</p>
<h3 id="choo-choo-canales-de-lanzamiento-y-montando-los-trenes"><a class="header" href="#choo-choo-canales-de-lanzamiento-y-montando-los-trenes">¡Choo, Choo! Canales de lanzamiento y montando los trenes</a></h3>
<p>El desarrollo de Rust funciona con un <em>horario de trenes</em>. Es decir, todo el
desarrollo se hace en la rama <code>master</code> del repositorio de Rust. Las versiones
siguen un modelo de tren de lanzamiento de software, que ha sido utilizado por
Cisco IOS y otros proyectos de software. Hay tres <em>canales de lanzamiento</em> para
Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>La mayoría de los desarrolladores de Rust utilizan principalmente el canal
estable, pero aquellos que quieran probar nuevas características experimentales
pueden utilizar nightly o beta.</p>
<p>Aquí hay un ejemplo de cómo funciona el proceso de desarrollo y lanzamiento:
supongamos que el equipo de Rust está trabajando en el lanzamiento de Rust 1.5.
Ese lanzamiento ocurrió en diciembre de 2015, pero nos proporcionará números de
versión realistas. Se añade una nueva característica a Rust: un nuevo commit
aterriza en la rama <code>master</code>. Cada noche, se produce una nueva versión nightly
de Rust. Cada día es un día de lanzamiento, y estos lanzamientos son creados
por nuestra infraestructura de lanzamiento automáticamente. Así que a medida
que pasa el tiempo, nuestros lanzamientos se ven así, una vez por noche:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Cada seis semanas, es hora de preparar un nuevo lanzamiento! La rama <code>beta</code> del
repositorio de Rust se ramifica de la rama <code>master</code> utilizada por nightly.
Ahora, hay dos lanzamientos:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>La mayoría de los usuarios de Rust no utilizan las versiones beta activamente,
pero prueban contra beta en su sistema CI para ayudar a Rust a descubrir
posibles regresiones. Mientras tanto, hay un lanzamiento nightly cada
noche:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Digamos que se encuentra una regresión. ¡Qué bueno que tuvimos algo de tiempo
para probar la versión beta antes de que la regresión se colara en una versión
estable! La solución se aplica a <code>master</code>, de modo que nightly se arregla, y
luego la solución se vuelve a aplicar a la rama <code>beta</code>, y se produce una nueva
versión de beta:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Seis semanas después de que se creó la primera beta, ¡es hora de un lanzamiento
estable! La rama <code>stable</code> se produce a partir de la rama <code>beta</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>¡Hurra! ¡Rust 1.5 está listo! Sin embargo, nos hemos olvidado de una cosa:
porque han pasado las seis semanas, también necesitamos una nueva beta de la
<em>siguiente</em> versión de Rust, 1.6. Así que después de que <code>stable</code> se ramifica de
<code>beta</code>, la siguiente versión de <code>beta</code> se ramifica de <code>nightly</code> de nuevo:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>Esto se llama el “modelo de tren” porque cada seis semanas, un lanzamiento
“sale de la estación”, pero aún tiene que hacer un viaje a través del canal
beta antes de llegar como un lanzamiento estable.</p>
<p>Rust se lanza cada seis semanas, como un reloj. Si conoces la fecha de un
lanzamiento de Rust, puedes conocer la fecha del siguiente: es seis semanas
después. Un aspecto agradable de tener lanzamientos programados cada seis
semanas es que el próximo tren está llegando pronto. Si una característica
llega a perder un lanzamiento en particular, no hay necesidad de preocuparse:
¡otro está sucediendo en un corto tiempo! Esto ayuda a reducir la presión para
colar posiblemente características poco pulidas cerca de la fecha límite de
lanzamiento.</p>
<p>Gracias a este proceso, siempre puedes comprobar la siguiente compilación de
Rust y verificar por ti mismo que es fácil de actualizar: si una versión beta
no funciona como se esperaba, puedes informarlo al equipo y solucionarlo antes
de que ocurra el siguiente lanzamiento estable! La rotura en una versión beta
es relativamente rara, pero <code>rustc</code> sigue siendo un software, y los errores
existen.</p>
<h3 id="tiempo-de-mantenimiento"><a class="header" href="#tiempo-de-mantenimiento">Tiempo de Mantenimiento</a></h3>
<p>El proyecto Rust admite la versión estable más reciente. Cuando una nueva 
versión estable es lanzada, la versión anterior llega al final de su vida útil 
(EOL). Esto significa que cada versión tiene soporte durante seis semanas.</p>
<p><a id="caracteristicas-inestables"></a></p>
<h2 id="características-inestables"><a class="header" href="#características-inestables">Características inestables</a></h2>
<p>Hay alo más con este modelo de lanzamiento: características inestables.
Rust utiliza una técnica llamada “indicadores de características” para
determinar qué características están habilitadas en un lanzamiento dado. Si una
nueva característica está en desarrollo activo, aterriza en <code>master</code>, y por lo
tanto, en nightly, pero detrás de un <em>indicador de característica</em>. Si, como
usuario, desea probar la característica en progreso, puede hacerlo, pero debe
estar utilizando una versión nightly de Rust y anotar su código fuente con el
indicador apropiado para optar por ello.</p>
<p>Si está utilizando una versión beta o estable de Rust, no puede utilizar
indicadores de características. Esta es la clave que nos permite obtener un uso
práctico con nuevas características antes de declararlas estables para siempre.
Aquellos que deseen optar por el borde sangrante pueden hacerlo, y aquellos que
deseen una experiencia sólida pueden quedarse con estable y saber que su código
no se romperá. Estabilidad sin estancamiento.</p>
<p>Este libro sólo contiene información sobre características estables, ya que las
características en progreso aún están cambiando, y seguramente serán diferentes
entre cuando se escribió este libro y cuando se habiliten en compilaciones
estables. Puede encontrar documentación para características sólo nocturnas en
línea.</p>
<h2 id="rustup-y-el-papel-de-rust-nightly"><a class="header" href="#rustup-y-el-papel-de-rust-nightly">Rustup y el papel de Rust Nightly</a></h2>
<p>Rustup facilita el cambio entre diferentes canales de lanzamiento de Rust, a
nivel global o por proyecto. Por defecto, tendrá instalado Rust estable. Para
instalar nightly, por ejemplo:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>También puede ver todas las <em>herramientas</em> (versiones de Rust y componentes
asociados) que tiene instaladas con <code>rustup</code>. Aquí hay un ejemplo en uno de los
autores de Windows:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Como puede ver, la herramienta estable es la predeterminada. La mayoría de los
usuarios de Rust utilizan estable la mayor parte del tiempo. Es posible que
desee utilizar estable la mayor parte del tiempo, pero utilizar nightly en un
proyecto específico, porque le importa una característica de vanguardia. Para
hacerlo, puede utilizar <code>rustup override</code> en el directorio del proyecto para
establecer la herramienta nightly como la que <code>rustup</code> debe utilizar cuando
esté en ese directorio:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Ahora, cada vez que llame a <code>rustc</code> o <code>cargo</code> dentro de
<em>~/projects/needs-nightly</em>, <code>rustup</code> se asegurará de que esté utilizando Rust
nocturno, en lugar de su estable predeterminado. ¡Esto es útil cuando tienes
muchos proyectos de Rust!</p>
<h2 id="el-proceso-rfc-y-los-equipos"><a class="header" href="#el-proceso-rfc-y-los-equipos">El proceso RFC y los equipos</a></h2>
<p>Entonces, ¿cómo se aprende sobre estas nuevas características? El modelo de
desarrollo de Rust sigue un proceso de <em>Solicitud de comentarios (RFC)</em>. Si
desea una mejora en Rust, puede escribir una propuesta, llamada RFC.</p>
<p>Cualquiera puede escribir RFC para mejorar Rust, y las propuestas son revisadas
y discutidas por el equipo de Rust, que está compuesto por muchos subequipos de
temas. Hay una lista completa de los equipos <a href="https://www.rust-lang.org/governance">en el sitio web de
Rust</a>, que incluye equipos para cada área
del proyecto: diseño de lenguaje, implementación de compilador, infraestructura,
documentación y más. El equipo apropiado lee la propuesta y los comentarios,
escribe algunos comentarios propios y, finalmente, hay consenso para aceptar o
rechazar la característica.</p>
<p>Si la característica es aceptada, se abre un problema en el repositorio de
Rust, y alguien puede implementarla. ¡La persona que lo implementa muy bien no
tiene por qué ser la persona que propuso la característica en primer lugar!
Cuando la implementación está lista, aterriza en la rama <code>master</code> detrás de una
puerta de características, como discutimos en la sección <a href="appendix-07-nightly-rust.html#caracteristicas-inestables">“Características
inestables”</a><!-- ignore -->.</p>
<p>Después de algún tiempo, una vez que los desarrolladores de Rust que utilizan
las versiones nightly han podido probar la nueva característica, los
miembros del equipo discutirán la característica, cómo ha funcionado en
nightly, y decidirán si debe o no hacerlo en Rust estable. Si la decisión es
seguir adelante, la puerta de la característica se elimina, ¡y la característica
ahora se considera estable! Monta los trenes en una nueva versión estable de
Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
