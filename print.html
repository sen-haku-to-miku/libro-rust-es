<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>El Lenguaje de Programaci√≥n Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
            <link rel="canonical" href="https://book.rustlang-es.org/" />


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="El libro oficial para aprender el lenguaje de programaci√≥n Rust, con tutoriales y gu√≠as.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta property="og:url" content="https://book.rustlang-es.org">
        <meta property="og:type" content="book">
        <meta property="og:title" content="El Lenguaje de Programaci√≥n Rust">
        <meta property="og:description" content="El libro oficial para aprender el lenguaje de programaci√≥n Rust, con tutoriales y gu√≠as.">
        <meta property="og:image" content="https://rustlang-es.org/rust-book-es/img/open-graph.png">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">El Lenguaje de Programaci√≥n Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducci√≥n</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Empezando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalaci√≥n</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ¬°Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ¬°Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un juego de adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programaci√≥n</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Flujo de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Entendiendo el Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ¬øQu√© es el Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Prestamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> El Tipo Slice</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa de Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintaxis de M√©todos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El operador de control de flujo match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Flujo de Control Conciso con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Administrando Proyectos en Crecimiento con Paquetes, Crates y M√≥dulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paquetes y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo m√≥dulos para controlar el scope y la privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths para referirse a un item en el √°rbol de m√≥dulos</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Incluyendo rutas al Scope con la palabra clave use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separando M√≥dulos en Diferentes Archivos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenando listas de valores con vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenando texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Almacenar Claves con Valores Asociados en HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! o no panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos Gen√©ricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Gen√©ricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definiendo Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Escribiendo Tests Automatizados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> C√≥mo Escribir Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlando C√≥mo Los Tests Son Ejecutados</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organizaci√≥n De Los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un proyecto de I/O: Construyendo un programa de l√≠nea de comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando argumentos de l√≠nea de comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la modularidad y el manejo de errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la funcionalidad de la biblioteca con T.D.D.</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo mensajes de error est√°ndar en lugar del output est√°ndar</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Caracter√≠sticas De Lenguajes Funcionales: Iteradores y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones an√≥nimas que capturan su entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una serie de elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando nuestro proyecto I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparando Performance: Bucles vs. Iteradores</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> M√°s sobre Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate a Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extendiendo Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Usando Box&lt;T&gt; para Apuntar a Datos en el Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratando los Smart Pointers como Referencias Regulares con el Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Ejecutando C√≥digo al Limpiar con el Trait Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, el Smart Pointer de Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patr√≥n de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referencias Circulares Pueden Fugar Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia Sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Usando Threads para Ejecutar C√≥digo Simult√°neamente</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Usando el Pasaje de Mensajes para Transferir Datos entre Hilos</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Concurrencia con Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible con los Traits Sync y Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust como un Lenguaje de Programaci√≥n Orientado a Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Caracter√≠sticas de Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Usando Trait Objects que Permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementando un Patr√≥n de Dise√±o Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los lugares donde se pueden usar Patterns</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: Si un Pattern Puede Fallar al Hacer Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Sintaxis de los Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Caracter√≠sticas Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Ap√©ndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y S√≠mbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - C√≥mo se hace Rust y ‚ÄúRust Nightly‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Lenguaje de Programaci√≥n Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustLangES/rust-book-es" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="el-lenguaje-de-programaci√≥n-rust"><a class="header" href="#el-lenguaje-de-programaci√≥n-rust">El Lenguaje de Programaci√≥n Rust</a></h1>
<p><em>por Steve Klabnik y Carol Nichols, con contribuciones de la Comunidad Rust</em></p>
<p>Esta versi√≥n del texto asume que est√°s usando Rust 1.78.0 (lanzado 2024-05-02)
o posterior. Vea la <a href="ch01-01-installation.html">secci√≥n ‚ÄúInstalaci√≥n‚Äù del Cap√≠tulo 1</a><!-- ignore -->
para instalar o actualizar Rust.</p>
<p>El formato HTML est√° disponible en l√≠nea en
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
y offline con instalaciones de Rust realizadas con <code>rustup</code>; ejecute <code>rustup doc --book</code> para abrir.</p>
<p>Tambi√©n est√°n disponibles varias <a href="appendix-06-translation.html">traducciones</a> de la comunidad.</p>
<p>Este texto est√° disponible en <a href="https://nostarch.com/rust-programming-language-2nd-edition">formato de libro impreso y ebook de No Starch
Press</a>.</p>
<blockquote>
<p><strong>üö® ¬øQuieres una experiencia de aprendizaje m√°s interactiva? Prueba una
versi√≥n diferente del Libro de Rust, con: cuestionarios, resaltado,
visualizaciones y m√°s</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a> (en ingl√©s)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefacio"><a class="header" href="#prefacio">Prefacio</a></h1>
<p>No siempre fue tan claro, pero el lenguaje de programaci√≥n Rust es 
fundamentalmente sobre <em>empoderamiento</em>: no importa qu√© tipo de c√≥digo est√°s 
escribiendo ahora, Rust te empodera para llegar m√°s lejos, para programar con 
confianza en una mayor variedad de dominios de lo que lo hiciste antes.</p>
<p>Tomemos, por ejemplo, el trabajo de ‚Äúsistemas‚Äù que se ocupa de los detalles de 
bajo nivel de la administraci√≥n de la memoria, la representaci√≥n de datos y la 
concurrencia. Tradicionalmente, este reino de la programaci√≥n se ve como arcano,
accesible s√≥lo a unos pocos que han dedicado los a√±os necesarios para aprender 
a evitar sus infames trampas. Y aunque aquellos que lo practican lo hacen con 
precauci√≥n, para que su c√≥digo no est√© abierto a vulnerabilidades que puedan ser
explotadas, ca√≠das o corrupci√≥n.</p>
<p>Rust rompe estas barreras al eliminar las antiguas trampas y proporciona un
conjunto amigable y pulido de herramientas para ayudarte en el camino.
Los programadores que necesitan ‚Äúsumergirse‚Äù en un control de bajo nivel pueden 
hacerlo con Rust, sin asumir el riesgo habitual de ca√≠das o agujeros de 
seguridad, y sin tener que aprender los puntos finos de una cadena de 
herramientas caprichosa. Lo mejor de todo, el lenguaje est√° dise√±ado para 
guiarte naturalmente hacia un c√≥digo confiable que es eficiente en t√©rminos 
de velocidad y uso de memoria.</p>
<p>Los programadores que ya est√°n trabajando con c√≥digo de bajo nivel pueden usar
Rust para elevar sus ambiciones. Por ejemplo, introducir la paralelizaci√≥n en
Rust es una operaci√≥n relativamente de bajo riesgo: el compilador lo detectar√°
por ti. As√≠ puedes abordar optimizaciones m√°s agresivas en tu c√≥digo con la
confianza de que no introducir√°s accidentalmente ca√≠das o vulnerabilidades.</p>
<p>Pero Rust no se limita a la programaci√≥n de sistemas de bajo nivel. Es lo
suficientemente expresivo y ergon√≥mico para hacer que las aplicaciones CLI,
servidores web y muchos otros tipos de c√≥digo sean bastante agradables de
escribir - encontrar√°s ejemplos simples de ambos m√°s adelante en el libro.
Trabajar con Rust te permite desarrollar habilidades que se transfieren de un
dominio a otro; puedes aprender Rust escribiendo una aplicaci√≥n web, y luego
aplicar esas mismas habilidades para dirigir tu Raspberry Pi.</p>
<p>Este libro abraza plenamente el potencial de Rust para empoderar a tus usuarios.
Es un texto amigable y accesible que tiene como objetivo ayudarte a mejorar no
s√≥lo tu conocimiento de Rust, sino tambi√©n tu alcance y confianza como
programador en general. As√≠ que sum√©rgete, prep√°rate para aprender y ¬°bienvenido
a la comunidad Rust!</p>
<p>‚Äî Nicholas Matsakis y Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducci√≥n"><a class="header" href="#introducci√≥n">Introducci√≥n</a></h1>
<blockquote>
<p>Nota: Esta edici√≥n del libro es la misma que <a href="https://nostarch.com/rust-programming-language-2nd-edition">The Rust Programming
Language</a> disponible en formato impreso y ebook de <a href="https://nostarch.com/">No Starch
Press</a>.</p>
</blockquote>
<p>Bienvenido a <em>El Lenguaje de Programaci√≥n Rust</em>, un libro introductorio sobre Rust.
El lenguaje de programaci√≥n Rust te ayuda a escribir software m√°s r√°pido y
confiable. La ergonom√≠a de alto nivel y el control de bajo nivel a menudo est√°n
en conflicto en el dise√±o de lenguajes de programaci√≥n; Rust desaf√≠a ese
conflicto. A trav√©s del equilibrio entre una capacidad t√©cnica poderosa y una gran
experiencia de desarrollo, Rust te da la opci√≥n de controlar los detalles de
bajo nivel (como el uso de memoria) sin todo el problema tradicionalmente
asociado con tal control.</p>
<h2 id="para-qui√©n-es-rust"><a class="header" href="#para-qui√©n-es-rust">Para Qui√©n Es Rust</a></h2>
<p>Rust es ideal para muchas personas por una variedad de razones. Veamos algunos
de los grupos m√°s importantes.</p>
<h3 id="equipos-de-desarrolladores"><a class="header" href="#equipos-de-desarrolladores">Equipos de Desarrolladores</a></h3>
<p>Rust est√° demostrando ser una herramienta productiva para colaborar entre
equipos grandes de desarrolladores con diferentes niveles de conocimiento de
programaci√≥n de sistemas. El c√≥digo de bajo nivel tiende a tener varios
sutiles errores, que en la mayor√≠a de otros lenguajes solo pueden ser
detectados a trav√©s de pruebas extensivas y una revisi√≥n cuidadosa del c√≥digo
por parte de desarrolladores experimentados. En Rust, el compilador juega un
rol de guardi√°n al negarse a compilar c√≥digo con estos errores elusivos,
incluidos los errores de concurrencia. Trabajando junto al compilador, el
equipo puede dedicar su tiempo a enfocarse en la l√≥gica del programa en lugar
de perseguir errores.</p>
<p>Rust tambi√©n trae herramientas de desarrollo contempor√°neas al mundo de la
programaci√≥n de sistemas:</p>
<ul>
<li>Cargo, el administrador de dependencias y herramienta de compilaci√≥n
incluido, hace que agregar, compilar y administrar dependencias sea f√°cil y
consistente en todo el ecosistema de Rust.</li>
<li>La herramienta de formateo Rustfmt garantiza un estilo de codificaci√≥n
consistente entre los desarrolladores.</li>
<li>El servidor de lenguaje Rust proporciona integraci√≥n con entornos de
desarrollo integrado (IDE) para la finalizaci√≥n del c√≥digo y los mensajes de
error en l√≠nea.</li>
</ul>
<p>Al usar estas y otras herramientas en el ecosistema de Rust, los desarrolladores
pueden ser productivos mientras escriben c√≥digo de nivel de sistemas.</p>
<h3 id="estudiantes"><a class="header" href="#estudiantes">Estudiantes</a></h3>
<p>Rust es para estudiantes y quienes est√©n interesados en aprender sobre conceptos
de sistemas. Usando Rust, muchas personas han aprendido sobre temas como el
desarrollo de sistemas operativos. La comunidad es muy acogedora y feliz de
responder preguntas de estudiantes. A trav√©s de esfuerzos como este libro, los
equipos de Rust quieren hacer que los conceptos de sistemas sean m√°s
accesibles para m√°s personas, especialmente para quienes son nuevos en la
programaci√≥n.</p>
<h3 id="empresas"><a class="header" href="#empresas">Empresas</a></h3>
<p>Cientos de empresas, grandes y peque√±as, usan Rust en producci√≥n para una
variedad de tareas, incluidas herramientas de l√≠nea de comandos, servicios web,
herramientas de DevOps, dispositivos incrustados, an√°lisis y transcodificaci√≥n
de audio y video, criptomonedas, bioinform√°tica, motores de b√∫squeda, aplicaciones
de Internet de las cosas, aprendizaje autom√°tico e incluso partes importantes del
navegador web Firefox.</p>
<h3 id="desarrolladores-de-c√≥digo-abierto"><a class="header" href="#desarrolladores-de-c√≥digo-abierto">Desarrolladores de C√≥digo Abierto</a></h3>
<p>Rust es para personas que quieren construir el lenguaje de programaci√≥n Rust,
la comunidad, las herramientas de desarrollo y las bibliotecas. Nos encantar√≠a
que contribuyeras al lenguaje Rust.</p>
<h3 id="personas-que-valoran-la-velocidad-y-la-estabilidad"><a class="header" href="#personas-que-valoran-la-velocidad-y-la-estabilidad">Personas que Valoran la Velocidad y la Estabilidad</a></h3>
<p>Rust es para personas que anhelan velocidad y estabilidad en un lenguaje. Por
velocidad, nos referimos tanto a la rapidez con que el c√≥digo Rust puede
ejecutarse como a la velocidad con que Rust te permite escribir programas. Las
verificaciones del compilador de Rust garantizan la estabilidad a trav√©s de
adiciones de funcionalidades y refactorizaciones. Esto contrasta con el c√≥digo
heredado quebradizo en lenguajes sin estas verificaciones, que los desarrolladores
a menudo tienen miedo de modificar. Al esforzarse por lograr abstracciones de
costo cero, caracter√≠sticas de alto nivel que se compilan en c√≥digo de bajo
nivel tan r√°pido como el c√≥digo escrito manualmente, Rust se esfuerza por hacer
que el c√≥digo seguro sea tambi√©n c√≥digo r√°pido.</p>
<p>El lenguaje Rust tambi√©n espera apoyar a muchos otros usuarios; los mencionados
aqu√≠ son solo algunos de los principales interesados. En general, la mayor
ambici√≥n de Rust es eliminar los compromisos que los programadores han
aceptado durante d√©cadas al proporcionar seguridad <em>y</em> productividad, velocidad
<em>y</em> ergonom√≠a. Pru√©balo y ve si sus elecciones funcionan para ti.</p>
<h2 id="para-qui√©n-es-este-libro"><a class="header" href="#para-qui√©n-es-este-libro">Para Qui√©n Es Este Libro</a></h2>
<p>Este libro asume que has escrito c√≥digo en otro lenguaje de programaci√≥n, pero
no hace ninguna suposici√≥n sobre cu√°l es. Hemos intentado hacer que el material
sea ampliamente accesible para aquellos de una amplia variedad de antecedentes
en programaci√≥n. No pasamos mucho tiempo hablando de lo que <em>es</em> la 
programaci√≥n o c√≥mo pensar sobre ella. Si eres completamente nuevo en la 
programaci√≥n, ser√≠a mejor leer un libro que brinde una introducci√≥n espec√≠fica a
la programaci√≥n.</p>
<h2 id="c√≥mo-usar-este-libro"><a class="header" href="#c√≥mo-usar-este-libro">C√≥mo Usar Este Libro</a></h2>
<p>En general, este libro asume que lo est√°s leyendo en secuencia, de principio a
fin. Los cap√≠tulos posteriores se basan en conceptos de los cap√≠tulos
anteriores, y los cap√≠tulos anteriores pueden no profundizar en detalles sobre
un tema en particular, pero volver√°n al tema en un cap√≠tulo posterior.</p>
<p>Encontrar√°s dos tipos de cap√≠tulos en este libro: cap√≠tulos de conceptos y
cap√≠tulos de proyectos. En los cap√≠tulos de conceptos, aprender√°s sobre un
aspecto de Rust. En los cap√≠tulos de proyectos, construiremos programas
peque√±os juntos, aplicando lo que has aprendido hasta ahora. Los cap√≠tulos 2, 12
y 20 son cap√≠tulos de proyectos; el resto son cap√≠tulos de conceptos.</p>
<p>El cap√≠tulo 1 explica c√≥mo instalar Rust, c√≥mo escribir un programa ‚ÄúHola,
mundo!‚Äù Y c√≥mo usar Cargo, el administrador de paquetes y herramienta de
compilaci√≥n de Rust. El cap√≠tulo 2 es una introducci√≥n pr√°ctica a la escritura
de un programa en Rust, teniendo que construir un juego de adivinanzas. Aqu√≠
tratamos los conceptos a un nivel alto, y cap√≠tulos posteriores proporcionar√°n
detalles adicionales. Si quieres ponerte manos a la obra de inmediato, el
cap√≠tulo 2 es el lugar para eso. El cap√≠tulo 3 cubre las caracter√≠sticas de
Rust que son similares a las de otros lenguajes de programaci√≥n, y en el
cap√≠tulo 4 aprender√°s sobre el sistema de propiedad de Rust. Si eres un
aprendiz particularmente meticuloso que prefiere aprender todos los detalles
antes de pasar al siguiente, es posible que desees omitir el cap√≠tulo 2 y
dirigirte directamente al cap√≠tulo 3, regresando al cap√≠tulo 2 cuando gustes
trabajar en un proyecto aplicando los detalles que has aprendido.</p>
<p>El cap√≠tulo 5 discute las estructuras y los m√©todos, y el cap√≠tulo 6 cubre las
enumeraciones, las expresiones <code>match</code>, y la construcci√≥n de flujo de control
<code>if let</code>. Usar√°s estructuras y enumeraciones para crear tipos personalizados en
Rust.</p>
<p>En el cap√≠tulo 7, aprender√°s sobre el sistema de m√≥dulos de Rust y sobre las
reglas de privacidad para organizar tu c√≥digo y su interfaz de programaci√≥n de
aplicaciones (API) p√∫blica. El cap√≠tulo 8 discute algunas estructuras de datos
de colecci√≥n comunes que proporciona la biblioteca est√°ndar, como vectores,
cadenas y mapas hash. El cap√≠tulo 9 explora la filosof√≠a y t√©cnicas de
manejo de errores de Rust.</p>
<p>El cap√≠tulo 10 se adentra en los gen√©ricos, los traits y los lifetimes, que te
dan el poder de definir c√≥digo que se aplique a varios tipos. El cap√≠tulo 11 trata
sobre las pruebas, que incluso con las garant√≠as de seguridad de Rust, son
necesarias para asegurar que la l√≥gica de tu programa sea correcta. En el cap√≠tulo
12, construiremos nuestra propia implementaci√≥n de un subconjunto de la
funcionalidad del comando de l√≠nea de comandos <code>grep</code> que busca texto dentro de
archivos. Para esto, usaremos muchos de los conceptos que discutimos en los
cap√≠tulos anteriores.</p>
<p>El cap√≠tulo 13 explora las closures y los iteradores: caracter√≠sticas de Rust
que provienen de los lenguajes de programaci√≥n funcional. En el cap√≠tulo 14,
examinaremos Cargo en m√°s profundidad y hablaremos sobre las mejores pr√°cticas
para compartir tus bibliotecas con otros. El cap√≠tulo 15 discute los punteros
inteligentes que proporciona la biblioteca est√°ndar y las caracter√≠sticas que
habilitan su funcionalidad.</p>
<p>En el cap√≠tulo 16, recorreremos diferentes modelos de programaci√≥n concurrente
y hablaremos sobre c√≥mo Rust te ayuda a programar en m√∫ltiples hilos sin
temor. El cap√≠tulo 17 examina c√≥mo los modismos de Rust se comparan con los
principios de programaci√≥n orientada a objetos con los que podr√≠as estar
familiarizado.</p>
<p>El cap√≠tulo 18 es una referencia a los patrones y el emparejamiento de patrones,
que son formas poderosas de expresar ideas en todo programa de Rust. El cap√≠tulo
19 contiene un banquete de temas avanzados de inter√©s, incluyendo Rust inseguro,
macros y m√°s sobre lifetimes, traits, tipos, funciones y closures.</p>
<p>En el cap√≠tulo 20, ¬°completaremos un proyecto en el que implementaremos un
servidor web de m√∫ltiples hilos de bajo nivel!</p>
<p>Finalmente, algunos ap√©ndices contienen informaci√≥n √∫til sobre el lenguaje en
un formato m√°s de referencia. El ap√©ndice A cubre las palabras clave de Rust,
el ap√©ndice B cubre los operadores y s√≠mbolos de Rust, el ap√©ndice C cubre los
traits derivables proporcionados por la biblioteca est√°ndar, el ap√©ndice D cubre
algunas herramientas de desarrollo √∫tiles, y el ap√©ndice E explica las ediciones
de Rust. En el ap√©ndice F, puede encontrar traducciones del libro, y en el
ap√©ndice G cubriremos c√≥mo se hace Rust y qu√© es Rust nightly.</p>
<p>No hay una forma incorrecta de leer este libro: ¬°si quieres adelantarte, hazlo!
Es posible que debas volver a los cap√≠tulos anteriores si experimentas
alguna confusi√≥n. Pero haz lo que funcione para ti.</p>
<p><span id="ferris"></span></p>
<p>Una parte importante del proceso de aprendizaje de Rust es aprender a leer los
mensajes de error que muestra el compilador: estos te guiar√°n hacia el c√≥digo
funcional. Por lo tanto, proporcionaremos muchos ejemplos que no se compilan
junto con el mensaje de error que mostrar√° el compilador en cada situaci√≥n.
Ten en cuenta que si ingresas y ejecutas un ejemplo aleatorio, ¬°es posible que
no se compile! Aseg√∫rate de leer el texto circundante para ver si el ejemplo
que est√°s intentando ejecutar est√° destinado a error. Ferris tambi√©n te ayudar√°
a distinguir el c√≥digo que no est√° destinado a funcionar:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Significado</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/></td><td>¬°Este c√≥digo no compila!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/></td><td>¬°Este c√≥digo provoca un p√°nico!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/></td><td>Este c√≥digo no produce el comportamiento deseado.</td></tr>
</tbody></table>
</div>
<p>En la mayor√≠a de las situaciones, te guiaremos a la versi√≥n correcta de cualquier
c√≥digo que no se compile.</p>
<h2 id="c√≥digo-fuente"><a class="header" href="#c√≥digo-fuente">C√≥digo fuente</a></h2>
<p>Los archivos de origen de los que se genera este libro se pueden encontrar en
<a href="https://github.com/RustLangES/rust-book-es/tree/main/src">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empezando"><a class="header" href="#empezando">Empezando</a></h1>
<p>¬°Empecemos tu viaje con Rust! Hay mucho que aprender, pero todo viaje comienza
en alg√∫n lugar. En este cap√≠tulo, discutiremos:</p>
<ul>
<li>Instalaci√≥n de Rust en Linux, macOS y Windows</li>
<li>Escribir un programa que imprima <code>Hola, mundo!</code></li>
<li>Uso de <code>cargo</code>, el administrador de paquetes y sistema de compilaci√≥n de Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><a id="instalacion"></a></p>
<h2 id="instalaci√≥n"><a class="header" href="#instalaci√≥n">Instalaci√≥n</a></h2>
<p>El primer paso es instalar Rust. Descargaremos Rust a trav√©s de <code>rustup</code>, una
herramienta de l√≠nea de comandos para administrar las versiones de Rust y las
herramientas asociadas. Necesitar√°s una conexi√≥n a Internet para la descarga.</p>
<blockquote>
<p>Nota: Si prefieres no usar <code>rustup</code> por alguna raz√≥n, consulta la p√°gina
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Otros m√©todos de instalaci√≥n de Rust</a> para obtener m√°s opciones.</p>
</blockquote>
<p>Los siguientes pasos instalan la √∫ltima versi√≥n estable del compilador de Rust.
Las garant√≠as de estabilidad de Rust aseguran que todos los ejemplos del libro
que se compilan seguir√°n compilando con versiones m√°s nuevas de Rust. La salida
puede diferir ligeramente entre versiones porque Rust a menudo mejora los
mensajes de error y las advertencias. En otras palabras, cualquier versi√≥n m√°s
nueva, estable de Rust que instales usando estos pasos deber√≠a funcionar como se
espera con el contenido de este libro.</p>
<blockquote>
<h3 id="notaci√≥n-de-l√≠nea-de-comandos"><a class="header" href="#notaci√≥n-de-l√≠nea-de-comandos">Notaci√≥n de l√≠nea de comandos</a></h3>
<p>En este cap√≠tulo y en todo el libro, mostraremos algunos comandos utilizados
en la terminal. Las l√≠neas que debes ingresar en una terminal comienzan con <code>$</code>.
No necesitas escribir el car√°cter <code>$</code>; es el indicador de l√≠nea de comandos
mostrado para indicar el comienzo de cada comando. Las l√≠neas que no comienzan
con <code>$</code> generalmente muestran la salida del comando anterior. Adem√°s, los
ejemplos espec√≠ficos de PowerShell usar√°n <code>&gt;</code> en lugar de <code>$</code>.</p>
</blockquote>
<h3 id="instalaci√≥n-de-rustup-en-linux-o-macos"><a class="header" href="#instalaci√≥n-de-rustup-en-linux-o-macos">Instalaci√≥n de <code>rustup</code> en Linux o macOS</a></h3>
<p>Si est√°s utilizando Linux o macOS, abre una terminal y escribe lo siguiente</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>El comando descarga un script y comienza la instalaci√≥n de la herramienta
<code>rustup</code>, que instala la √∫ltima versi√≥n estable de Rust. Es posible que se te
solicite tu contrase√±a. Si la instalaci√≥n es exitosa, aparecer√° la siguiente
l√≠nea:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Tambi√©n necesitar√°s un <em>enlazador</em>, que es un programa que Rust utiliza para
unir sus salidas compiladas en un solo archivo. Es probable que ya lo tengas.
Si obtienes errores de enlace, debes instalar un compilador C, que generalmente
incluye un enlazador. Un compilador C tambi√©n es √∫til porque algunos paquetes
comunes de Rust dependen de c√≥digo C y necesitar√°n un compilador C.</p>
<p>En macOS, puedes obtener un compilador C ejecutando:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Los usuarios de Linux deben instalar generalmente GCC o Clang, seg√∫n la
documentaci√≥n de su distribuci√≥n. Por ejemplo, si usas Ubuntu, puede instalar el
paquete <code>build-essential</code>.</p>
<h3 id="instalaci√≥n-de-rustup-en-windows"><a class="header" href="#instalaci√≥n-de-rustup-en-windows">Instalaci√≥n de <code>rustup</code> en Windows</a></h3>
<p>En Windows, ve a <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> y sigue las
instrucciones para instalar Rust. En alg√∫n momento de la instalaci√≥n, recibir√°s
un mensaje para instalar Visual Studio. Este provee un linker y las bibliotecas
nativas necesarias para compilar programas. </p>
<p>Para obtener las herramientas de compilaci√≥n, deber√°s instalar 
<a href="https://visualstudio.microsoft.com/downloads/">Visual Studio</a>. Cuando se te pregunte qu√© paquetes de trabajo 
instalar, incluye:</p>
<ul>
<li>‚ÄúDesarrollo de escritorio con C ++‚Äù</li>
<li>El SDK de Windows 10 o 11</li>
<li>El componente de paquete de idioma ingl√©s, junto con cualquier otro paquete de
idioma de tu elecci√≥n</li>
</ul>
<p>El resto de este libro usa comandos que funcionan tanto en <em>cmd.exe</em> como en
PowerShell. Si hay diferencias espec√≠ficas, explicaremos cu√°l usar.</p>
<p>Si tu necesitas m√°s ayuda con este 
paso, mira <a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html">MSVC prerequisites</a> o escr√≠benos en nuestro <a href="https://discord.rustlang-es.org">discord</a></p>
<p><a id="solucion-de-problemas"></a></p>
<h3 id="soluci√≥n-de-problemas"><a class="header" href="#soluci√≥n-de-problemas">Soluci√≥n de problemas</a></h3>
<p>Para verificar si has instalado Rust correctamente, abra una shell y escribe esta
l√≠nea:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Deber√≠as ver el n√∫mero de versi√≥n, el hash de confirmaci√≥n y la fecha de
confirmaci√≥n de la √∫ltima versi√≥n estable que se ha publicado, en el siguiente
formato:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Si ves esta informaci√≥n, ¬°has instalado Rust correctamente! Si no ves esta
informaci√≥n, verifica que Rust est√© en la variable de sistema <code>%PATH%</code> de la
siguiente manera.</p>
<p>En Windows CMD, usa:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>En PowerShell, usa:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>En Linux y macOS, usa:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>Si todo est√° correcto y Rust a√∫n no funciona, hay varios lugares donde puedes
obtener ayuda. Obten informaci√≥n sobre c√≥mo comunicarte con otros Rustaceans
(un apodo tonto que nos llamamos a nosotros mismos) en <a href="https://www.rust-lang.org/community">la p√°gina de la
comunidad</a>.</p>
<h3 id="actualizaci√≥n-y-desinstalaci√≥n"><a class="header" href="#actualizaci√≥n-y-desinstalaci√≥n">Actualizaci√≥n y desinstalaci√≥n</a></h3>
<p>Una vez que Rust se instala a trav√©s de <code>rustup</code>, actualizar a una versi√≥n
reci√©n lanzada es f√°cil. Desde tu shell, ejecuta el siguiente script de
actualizaci√≥n:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Para desinstalar Rust y <code>rustup</code>, ejecuta el siguiente script de desinstalaci√≥n
desde tu shell:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="documentaci√≥n-local"><a class="header" href="#documentaci√≥n-local">Documentaci√≥n local</a></h3>
<p>La instalaci√≥n de Rust tambi√©n incluye una copia local de la documentaci√≥n para
que puedas leerla sin conexi√≥n. Ejecuta <code>rustup doc</code> para abrir la documentaci√≥n
local en tu navegador.</p>
<p>En cualquier momento en que se proporcione un tipo o una funci√≥n de la biblioteca
est√°ndar y no est√©s seguro de lo que hace o c√≥mo usarlo, usa la documentaci√≥n de
la interfaz de programaci√≥n de aplicaciones (API) para averiguarlo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hola-mundo"><a class="header" href="#hola-mundo">¬°Hola, mundo!</a></h2>
<p>Ahora que has instalado Rust, es hora de escribir tu primer programa en Rust.
Es tradicional cuando se aprende un nuevo lenguaje escribir un peque√±o programa
que imprima el texto <code>¬°Hola, mundo!</code> en la pantalla, ¬°as√≠ que haremos lo mismo
aqu√≠!</p>
<blockquote>
<p>Nota: Este libro asume una familiaridad b√°sica con la l√≠nea de comandos. Rust
no asume cosas espec√≠ficas sobre tu editor o herramientas o d√≥nde vive tu
c√≥digo, por lo que si prefieres usar un entorno de desarrollo integrado (IDE)
en lugar de la l√≠nea de comandos, si√©ntete libre de usar tu IDE favorito. 
Muchos IDEs ahora tienen alg√∫n grado de soporte para Rust; consulta la
documentaci√≥n del IDE para obtener m√°s detalles. El equipo de Rust se ha
centrado en habilitar un gran soporte a IDEs a trav√©s de <code>rust-analyzer</code>.
Consulta <a href="appendix-04-useful-development-tools.html">Ap√©ndice D</a><!-- ignore --> para obtener m√°s detalles.</p>
</blockquote>
<h3 id="creando-un-directorio-de-proyecto"><a class="header" href="#creando-un-directorio-de-proyecto">Creando un directorio de proyecto</a></h3>
<p>Comenzar√°s creando un directorio para almacenar tu c√≥digo Rust. A Rust no le
importa d√≥nde vive tu c√≥digo, pero para los ejercicios y proyectos de este libro,
sugerimos que hagas un directorio <em>proyectos</em> en tu directorio de inicio y
mantengas todos tus proyectos all√≠.</p>
<p>Abre una terminal y escribe los siguientes comandos para crear un directorio
<em>proyectos</em> y un directorio para el proyecto ‚Äú¬°Hola, mundo!‚Äù dentro del
directorio <em>proyectos</em>.</p>
<p>Para Linux, macOS y PowerShell en Windows, escribe esto:</p>
<pre><code class="language-console">$ mkdir ~/proyectos
$ cd ~/proyectos
$ mkdir hola_mundo
$ cd hola_mundo
</code></pre>
<p>Para Windows CMD, escribe esto:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\proyectos&quot;
&gt; cd /d &quot;%USERPROFILE%\proyectos&quot;
&gt; mkdir hola_mundo
&gt; cd hola_mundo
</code></pre>
<h3 id="escribir-y-ejecutar-un-programa-en-rust"><a class="header" href="#escribir-y-ejecutar-un-programa-en-rust">Escribir y ejecutar un programa en Rust</a></h3>
<p>A continuaci√≥n, crea un nuevo archivo de texto y ll√°malo <em>main.rs</em>. Los archivos
Rust siempre terminan con la extensi√≥n <em>.rs</em>. Si est√°s usando m√°s de una palabra
en tu nombre de archivo, la convenci√≥n es usar un gui√≥n bajo para separarlos.
Por ejemplo, usa <em>hola_mundo.rs</em> en lugar de <em>holamundo.rs</em>.</p>
<p>Ahora abre el archivo <em>main.rs</em> que acabas de crear y escribe el c√≥digo en el
Listado 1-1.</p>
<Listing number="1-1" file-name="main.rs" caption="Un programa que imprime `¬°Hola, mundo!`">
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¬°Hola, mundo!&quot;);
}</code></pre></pre>
</Listing>
<p>Guarda el archivo y vuelve a la ventana de la terminal en el directorio
<em>~/proyectos/hola_mundo</em>. En Linux o macOS, escribe los siguientes comandos para
compilar y ejecutar el archivo:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
¬°Hola, mundo!
</code></pre>
<p>En Windows, escribe el comando <code>.\main.exe</code> en lugar de <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
¬°Hola, mundo!
</code></pre>
<p>Independientemente de tu sistema operativo, la cadena <code>¬°Hola, mundo!</code> debe
imprimirse en la terminal. Si no ves esta salida, consulta la parte
<a href="ch01-01-installation.html#solucion-de-problemas">‚ÄúSoluci√≥n de problemas‚Äù</a><!-- ignore --> de la secci√≥n de
Instalaci√≥n para obtener formas de obtener ayuda.</p>
<p>Si <code>¬°Hola, mundo!</code> se imprimi√≥, ¬°felicidades! Acabas de escribir oficialmente un
programa en Rust. Eso te convierte en un programador de Rust, ¬°bienvenido!</p>
<h3 id="anatom√≠a-de-un-programa-en-rust"><a class="header" href="#anatom√≠a-de-un-programa-en-rust">Anatom√≠a de un programa en Rust</a></h3>
<p>Revisemos este programa ‚Äú¬°Hola, mundo!‚Äù en detalle. Aqu√≠ est√° la primera
parte del rompecabezas:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}</code></pre></pre>
<p>Estas l√≠neas definen una funci√≥n llamada <code>main</code>. La funci√≥n <code>main</code> es especial:
siempre es el primer c√≥digo que se ejecuta en cada programa ejecutable de Rust.
Aqu√≠, la primera l√≠nea declara una funci√≥n llamada <code>main</code> que no tiene
par√°metros y no devuelve nada. Si hubiera par√°metros, ir√≠an dentro de los
par√©ntesis <code>()</code>.</p>
<p>El cuerpo de la funci√≥n est√° envuelto en <code>{}</code>. Rust requiere llaves alrededor de
todos los cuerpos de funci√≥n. Es buena costumbre colocar la llave de apertura en
la misma l√≠nea que la declaraci√≥n de la funci√≥n, agregando un espacio entre
ambos.</p>
<blockquote>
<p>Nota: Si deseas mantener un estilo est√°ndar en todos los proyectos de Rust, 
puedes usar una herramienta de formateo autom√°tico llamada <code>rustfmt</code> para
formatear tu c√≥digo en un estilo particular (m√°s sobre <code>rustfmt</code> en
<a href="appendix-04-useful-development-tools.html">Ap√©ndice D</a><!-- ignore -->). El equipo de Rust ha incluido esta
herramienta con la distribuci√≥n est√°ndar de Rust, como <code>rustc</code>, por lo que
deber√≠a estar instalado en tu computadora.</p>
</blockquote>
<p>El cuerpo de la funci√≥n <code>main</code> contiene el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;¬°Hola, mundo!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Esta l√≠nea hace todo el trabajo en este peque√±o programa: imprime texto en la
pantalla. Hay cuatro detalles importantes que hay que notar aqu√≠.</p>
<p>Primero, el estilo de Rust es indentar con cuatro espacios, no con una tabulaci√≥n.</p>
<p>Segundo, <code>println!</code> llamamos a una macro de Rust. Si hubi√©ramos llamado a una
funci√≥n en su lugar, habr√≠amos ingresado <code>println</code> (sin el <code>!</code>). Discutiremos las
macros de Rust en m√°s detalle en el Cap√≠tulo 19. Por ahora, solo necesitas saber
que usar un <code>!</code> significa que estamos llamando a una macro en lugar de una funci√≥n
normal y que las macros no siempre siguen las mismas reglas que las funciones.</p>
<p>Tercero, ve la cadena <code>&quot;¬°Hola, mundo!&quot;</code>. Pasamos esta cadena como argumento a
<code>println!</code>, y la cadena se imprime en la pantalla.</p>
<p>Cuarto, terminamos la l√≠nea con un punto y coma (<code>;</code>), lo que indica que esta
expresi√≥n ha terminado y la siguiente est√° lista para comenzar. La mayor√≠a de
las l√≠neas de c√≥digo de Rust terminan con un punto y coma.</p>
<h3 id="compilar-y-ejecutar-son-pasos-separados"><a class="header" href="#compilar-y-ejecutar-son-pasos-separados">Compilar y ejecutar son pasos separados</a></h3>
<p>Acabas de ejecutar un programa reci√©n creado, as√≠ que examinemos cada paso en el
proceso.</p>
<p>Antes de ejecutar un programa de Rust, debes compilarlo usando el compilador de
Rust ingresando el comando <code>rustc</code> y pas√°ndole el nombre de tu archivo de
c√≥digo fuente, as√≠:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Si tienes un trasfondo en C o C ++, notar√°s que esto es similar a <code>gcc</code> o
<code>clang</code>. Despu√©s de compilar con √©xito, Rust genera un ejecutable binario.</p>
<p>En Linux, macOS y PowerShell en Windows, puedes ver el ejecutable ingresando el
comando <code>ls</code> en tu shell:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>En Linux y macOS, ver√°s dos archivos. Con PowerShell en Windows, ver√°s los mismos
tres archivos que ver√≠as con CMD. Con CMD en Windows, ingresar√≠as lo siguiente:</p>
<pre><code class="language-cmd">&gt; dir /B %= la /B significa que solo mostrara los nombres de los archivos =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Esto muestra el archivo de c√≥digo fuente con la extensi√≥n <em>.rs</em>, el archivo
ejecutable (<em>main.exe</em> en Windows, pero <em>main</em> en todas las otras plataformas),
y, cuando se usa Windows, un archivo que contiene informaci√≥n de depuraci√≥n con
la extensi√≥n <em>.pdb</em>. Desde aqu√≠, ejecuta el archivo <em>main</em> o <em>main.exe</em>, as√≠:</p>
<pre><code class="language-console">$ ./main # o .\main.exe en Windows
</code></pre>
<p>Si tu <em>main.rs</em> es tu programa &quot;¬°Hola, mundo!&quot;, Esta l√≠nea imprime <code>¬°Hola, mundo!</code> en tu terminal.</p>
<p>Si est√°s m√°s familiarizado con un lenguaje din√°mico, como Ruby, Python o
JavaScript, puede que no est√©s acostumbrado a compilar y ejecutar un programa
como pasos separados. Rust es un lenguaje <em>compilado de antemano</em>, lo que
significa que puedes compilar un programa y dar el ejecutable a otra persona, y
pueden ejecutarlo incluso sin tener Rust instalado. Si le das a alguien un
archivo <em>.rb</em>, <em>.py</em> o <em>.js</em>, necesitan tener una implementaci√≥n de Ruby,
Python o JavaScript instalada (respectivamente). Pero en esos lenguajes, s√≥lo
necesitas un comando para compilar y ejecutar tu programa. Todo depende de las
concesiones hechas al momento de dise√±ar un lenguaje.</p>
<p>Solo compilar con <code>rustc</code> est√° bien para programas simples, pero a medida que
tu proyecto crece, querr√°s administrar todas las opciones y facilitar el 
compartir tu c√≥digo. A continuaci√≥n, te presentaremos la herramienta
Cargo, que te ayudar√° a escribir programas de Rust reales.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hola-cargo"><a class="header" href="#hola-cargo">¬°Hola, Cargo!</a></h2>
<p>Cargo es el sistema de compilaci√≥n y administrador de paquetes de Rust. La
mayor√≠a de los Rustaceans usan esta herramienta para administrar sus proyectos
Rust porque Cargo maneja muchas tareas para ti, como compilar tu c√≥digo,
descargar las bibliotecas de las que depende tu c√≥digo y compilar esas
bibliotecas. (Llamamos <em>dependencias</em> a las bibliotecas de las que depende tu
c√≥digo).</p>
<p>Los programas Rust m√°s simples, como el que hemos escrito hasta ahora, no
tienen dependencias. Si hubi√©ramos construido el proyecto ‚Äú¬°Hola, mundo!‚Äù con
Cargo, s√≥lo usar√≠a la parte de Cargo que maneja la compilaci√≥n de tu c√≥digo. A
medida que escribas programas Rust m√°s complejos, agregar√°s dependencias, y si
comienzas un proyecto usando Cargo, agregar dependencias ser√° mucho m√°s f√°cil
de hacer.</p>
<p>Debido a que la gran mayor√≠a de los proyectos Rust usan Cargo, el resto de este
libro asume que tambi√©n est√°s usando Cargo. Cargo viene instalado con Rust si
usaste los instaladores oficiales que se discuten en la secci√≥n
<a href="ch01-01-installation.html#instalacion">‚ÄúInstallation‚Äù</a><!-- ignore -->. Si instalaste Rust a trav√©s de
algunos otros medios, verifica si Cargo est√° instalado ingresando lo siguiente
en tu terminal:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Si ves un n√∫mero de versi√≥n, ¬°lo tienes! Si ves un error, como <code>command not found</code>,
consulta la documentaci√≥n de tu m√©todo de instalaci√≥n para determinar c√≥mo
instalar Cargo por separado.</p>
<h3 id="creaci√≥n-de-un-proyecto-con-cargo"><a class="header" href="#creaci√≥n-de-un-proyecto-con-cargo">Creaci√≥n de un proyecto con Cargo</a></h3>
<p>Vamos a crear un nuevo proyecto usando Cargo y ver c√≥mo difiere de nuestro
proyecto original ‚Äú¬°Hola, mundo!‚Äù. Navega de vuelta a tu directorio
<em>proyectos</em> (o dondequiera que hayas decidido almacenar tu c√≥digo). Luego, en
cualquier sistema operativo, ejecuta lo siguiente:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>El primer comando crea un nuevo directorio y proyecto llamado <em>hello_cargo</em>.
Hemos nombrado a nuestro proyecto <em>hello_cargo</em>, y Cargo crea sus archivos en
un directorio con el mismo nombre.</p>
<p>Ve al directorio <em>hello_cargo</em> y lista los archivos. Ver√°s que Cargo ha
generado dos archivos y un directorio para nosotros: un archivo <em>Cargo.toml</em> y
un directorio <em>src</em> con un archivo <em>main.rs</em> dentro.</p>
<p>Tambi√©n ha inicializado un nuevo repositorio Git junto con un archivo
<em>.gitignore</em>. Los archivos Git no se generar√°n si ejecutas <code>cargo new</code> dentro
de un repositorio Git existente; puedes anular este comportamiento usando
<code>cargo new --vcs=git</code>.</p>
<blockquote>
<p>Nota: Git es un sistema de control de versiones com√∫n. Puedes cambiar <code>cargo new</code> para usar un sistema de control de versiones diferente o ning√∫n sistema
de control de versiones usando la bandera <code>--vcs</code>. Ejecuta <code>cargo new --help</code>
para ver las opciones disponibles.</p>
</blockquote>
<p>Abre <em>Cargo.toml</em> en tu editor de texto de elecci√≥n. Deber√≠a verse similar al
c√≥digo del Listado 1-2.</p>
<Listing number="1-2" file-name="Cargo.toml" caption="Contenido de *Cargo.toml* generado por `cargo new`">
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
</Listing>
<p>Este archivo est√° en el formato <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tom‚Äôs Obvious,
Minimal Language</em>), que es el formato de configuraci√≥n de Cargo.</p>
<p>La primera l√≠nea, <code>[package]</code>, es un encabezado de secci√≥n que indica que las
siguientes declaraciones est√°n configurando un paquete. A medida que agreguemos
m√°s informaci√≥n a este archivo, agregaremos otras secciones.</p>
<p>Las pr√≥ximas tres l√≠neas establecen la informaci√≥n de configuraci√≥n que Cargo
necesita para compilar tu programa: el nombre, la versi√≥n y la edici√≥n de Rust
que se usar√°. Hablaremos sobre la entrada <code>edition</code> en <a href="appendix-05-editions.html">Ap√©ndice E</a></p>
<!-- ignore -->.
<p>La √∫ltima l√≠nea, <code>[dependencies]</code>, es el comienzo de una secci√≥n para que
enumere cualquier dependencia de tu proyecto. En Rust, los paquetes de c√≥digo
se denominan <em>crates</em>. No necesitaremos otros crates para este proyecto, pero
lo haremos en el primer proyecto del Cap√≠tulo 2, por lo que usaremos esta
secci√≥n de dependencias hasta entonces.</p>
<p>Ahora abre <em>src/main.rs</em> y echa un vistazo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>¬°Cargo ha generado un programa ‚ÄúHello, world!‚Äù/‚Äú¬°Hola, mundo!‚Äù para ti, 
¬°igual que el que escribimos enl Listado 1-1! Hasta ahora, las diferencias 
entre nuestro proyecto y el proyecto generado por Cargo son que Cargo 
coloc√≥ el c√≥digo en el directorio <em>src</em> y tenemos un archivo de 
configuraci√≥n <em>Cargo.toml</em> en el directorio superior.</p>
<p>Cargo espera que tus archivos de origen vivan dentro del directorio <em>src</em>. El
directorio del proyecto de nivel superior es solo para archivos README, 
informaci√≥n de licencia, archivos de configuraci√≥n y cualquier otra cosa 
que no est√© relacionada con tu c√≥digo. Usar Cargo te ayuda a organizar 
tus proyectos. Hay un lugar para todo, y todo est√° en su lugar.</p>
<p>Si comenzaste un proyecto que no usa Cargo, como hicimos con el proyecto
‚Äú¬°Hola, mundo!‚Äù, puedes convertirlo en un proyecto que s√≠ use Cargo. Mueve el
c√≥digo del proyecto al directorio <em>src</em> y crea un archivo <em>Cargo.toml</em>
adecuado.</p>
<h3 id="construir-y-ejecutar-un-proyecto-de-cargo"><a class="header" href="#construir-y-ejecutar-un-proyecto-de-cargo">Construir y ejecutar un proyecto de Cargo</a></h3>
<p>Ahora veamos qu√© es diferente cuando construimos y ejecutamos el programa
‚Äú¬°Hola, mundo!‚Äù con Cargo. ¬°Desde tu directorio <em>hello_cargo</em>, construye tu
proyecto ingresando el siguiente comando:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Este comando crea un archivo ejecutable en <em>target/debug/hello_cargo</em> (o
<em>target\debug\hello_cargo.exe</em> en Windows) en lugar de en tu directorio
actual. Debido a que la compilaci√≥n predeterminada es una compilaci√≥n de
depuraci√≥n, Cargo coloca el binario en un directorio llamado <em>debug</em>. Puedes
llamar al ejecutable con este comando:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # o .\target\debug\hello_cargo.exe en Windows
Hello, world!
</code></pre>
<p>Si todo va bien, <code>Hello, world!</code> deber√≠a imprimirse en la terminal. Ejecutar
<code>cargo build</code> por primera vez tambi√©n hace que Cargo cree un nuevo archivo en
el nivel superior: <em>Cargo.lock</em>. Este archivo rastrea las versiones exactas de
las dependencias de tu proyecto. Este proyecto no tiene dependencias, por lo
que el archivo es un poco escaso. Nunca necesitar√°s cambiar este archivo
manualmente; Cargo administra su contenido para ti.</p>
<p>Acabamos de construir un proyecto con <code>cargo build</code> y ejecutarlo con
<code>./target/debug/hello_cargo</code>, pero tambi√©n podemos usar <code>cargo run</code> para
compilar el c√≥digo y luego llamar al ejecutable resultante en un solo
comando:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Usar <code>cargo run</code> es m√°s conveniente que tener que recordar ejecutar <code>cargo build</code> y luego usar la ruta completa al binario, por lo que la mayor√≠a de los
desarrolladores usan <code>cargo run</code>.</p>
<p>Ten en cuenta que esta vez no vimos salida que indicara que Cargo estaba
compilando <code>hello_cargo</code>. Cargo supo que los archivos no hab√≠an cambiado, por
lo que no volvi√≥ a construir, sino que solo ejecut√≥ el binario. Si hubieras
modificado tu c√≥digo fuente, Cargo habr√≠a reconstruido el proyecto antes de
ejecutarlo, y habr√≠as visto esta salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo tambi√©n proporciona un comando llamado <code>cargo check</code>. Este comando
comprueba r√°pidamente tu c√≥digo para asegurarse de que compila, pero no
produce un ejecutable:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>¬øPor qu√© no querr√≠as un ejecutable? A menudo, <code>cargo check</code> es mucho m√°s r√°pido
que <code>cargo build</code> porque omite el paso de producir un ejecutable. Si est√°s
verificando continuamente tu trabajo mientras escribes el c√≥digo, usar
<code>cargo check</code> acelerar√° el proceso de informarte si tu proyecto todav√≠a a√∫n est√°
compilando. ¬°Por lo tanto, muchos Rustaceans ejecutan <code>cargo check</code>
peri√≥dicamente mientras escriben su programa para asegurarse de que compila!
Luego ejecutan <code>cargo build</code> cuando est√°n listos para usar el ejecutable.</p>
<p>Resumamos lo que hemos aprendido hasta ahora sobre Cargo:</p>
<ul>
<li>Podemos crear un proyecto usando <code>cargo new</code>.</li>
<li>Podemos construir un proyecto usando <code>cargo build</code>.</li>
<li>Podemos construir y ejecutar un proyecto en un solo paso usando <code>cargo run</code>.</li>
<li>Podemos construir un proyecto sin producir un binario para verificar errores
usando <code>cargo check</code>.</li>
<li>En lugar de guardar el resultado de la compilaci√≥n en el mismo directorio que
nuestro c√≥digo, Cargo lo almacena en el directorio <em>target/debug</em>.</li>
</ul>
<p>Una ventaja adicional de usar Cargo es que los comandos son los mismos sin
importar en qu√© sistema operativo est√©s trabajando. Por lo tanto, en este
punto, ya no proporcionaremos instrucciones espec√≠ficas para Linux y macOS
versus Windows.</p>
<h3 id="construyendo-una-versi√≥n-de-lanzamiento"><a class="header" href="#construyendo-una-versi√≥n-de-lanzamiento">Construyendo una versi√≥n de lanzamiento</a></h3>
<p>Cuando tu proyecto finalmente est√© listo para su lanzamiento, puedes usar <code>cargo build --release</code> para compilarlo con optimizaciones. Este comando crear√° un
ejecutable en <em>target/release</em> en lugar de <em>target/debug</em>. Las optimizaciones
hacen que tu c√≥digo Rust se ejecute m√°s r√°pido, pero al activarlos se alarga el
tiempo que tarda tu programa en compilarse. Es por eso que hay dos perfiles
diferentes: uno para el desarrollo, cuando deseas reconstruir r√°pidamente y
con frecuencia, y otro para construir el programa final que le dar√°s al usuario,
que no se reconstruir√° repetidamente y que se ejecutar√° lo m√°s r√°pido posible.
Si est√°s midiendo el tiempo de ejecuci√≥n de tu c√≥digo, aseg√∫rate de ejecutar
<code>cargo build --release</code> y realizar la prueba de rendimiento con el ejecutable
en <em>target/release</em>.</p>
<h3 id="cargo-como-convenci√≥n"><a class="header" href="#cargo-como-convenci√≥n">Cargo como convenci√≥n</a></h3>
<p>Con proyectos simples, Cargo no proporciona mucho valor por sobre s√≥lo usar
<code>rustc</code>, pero demostrar√° su valor a medida que tus programas se vuelvan m√°s
intrincados. Una vez que los programas crecen a m√∫ltiples archivos o necesitan
una dependencia, es mucho m√°s f√°cil dejar que Cargo coordine la construcci√≥n.</p>
<p>Aunque el proyecto <code>hello_cargo</code> es simple, ahora usas muchas de las herramientas
reales que usar√°s en el resto de tu carrera en Rust. De hecho, para trabajar en
cualquier proyecto existente, puedes usar los siguientes comandos para verificar
el c√≥digo usando Git, cambiar al directorio del proyecto y construir:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Para obtener m√°s informaci√≥n sobre Cargo, consulta <a href="https://doc.rust-lang.org/cargo/">su documentaci√≥n</a>.</p>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>¬°Ya est√°s en un gran comienzo en tu viaje de Rust! En este cap√≠tulo, has
aprendido c√≥mo:</p>
<ul>
<li>Instalar la √∫ltima versi√≥n estable de Rust usando <code>rustup</code></li>
<li>Actualizar a una versi√≥n m√°s reciente de Rust</li>
<li>Abrir documentaci√≥n instalada localmente</li>
<li>Escribir y ejecutar un programa &quot;¬°Hola, mundo!&quot; usando <code>rustc</code> directamente</li>
<li>Crear y ejecutar un nuevo proyecto usando las convenciones de Cargo</li>
</ul>
<p>Es un buen momento para construir un programa m√°s sustancial para acostumbrarse
a leer y escribir c√≥digo Rust. Entonces, en el cap√≠tulo 2, construiremos un
programa de juego de adivinanzas. Si prefieres comenzar aprendiendo c√≥mo
funcionan los conceptos de programaci√≥n comunes en Rust, consulta el cap√≠tulo 3
y luego regresa al cap√≠tulo 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programando-un-juego-de-adivinanzas"><a class="header" href="#programando-un-juego-de-adivinanzas">Programando un juego de adivinanzas</a></h1>
<p>¬°Vamos a empezar con Rust trabajando en un proyecto pr√°ctico! Este cap√≠tulo te
introduce a algunos conceptos comunes de Rust mostr√°ndote c√≥mo usarlos en un
programa real. ¬°Aprender√°s sobre <code>let</code>, <code>match</code>, m√©todos, funciones asociadas,
paquetes externos y m√°s! En los cap√≠tulos siguientes, exploraremos estos
conceptos en m√°s detalle. En este cap√≠tulo, solo practicar√°s los fundamentos.</p>
<p>Implementaremos un cl√°sico problema de programaci√≥n para principiantes: un
juego de adivinanzas. As√≠ es como funciona: el programa generar√° un n√∫mero
entero aleatorio entre 1 y 100. Luego le pedir√° al jugador que ingrese una
adivinanza. Despu√©s de ingresar una adivinanza, el programa indicar√° si la
adivinanza es demasiado baja o demasiado alta. Si la adivinanza es correcta, el
juego imprimir√° un mensaje de felicitaci√≥n y saldr√°.</p>
<h2 id="configurando-un-nuevo-proyecto"><a class="header" href="#configurando-un-nuevo-proyecto">Configurando un nuevo proyecto</a></h2>
<p>Para configurar un nuevo proyecto, vaya al directorio <em>proyectos</em> que cre√≥ en
el Cap√≠tulo 1 y cree un nuevo proyecto usando Cargo, as√≠:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>El primer comando, <code>cargo new</code>, toma el nombre del proyecto (<code>guessing_game</code>)
como el primer argumento. El segundo comando cambia al directorio del nuevo
proyecto.</p>
<p>Mira el archivo <em>Cargo.toml</em> generado:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Como viste en el Cap√≠tulo 1, <code>cargo new</code> genera un programa ‚ÄúHola, mundo!‚Äù para
ti. Mira el archivo <em>src/main.rs</em>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Ahora compilemos este programa ‚ÄúHola, mundo!‚Äù y ejecut√©moslo en el mismo paso
usando el comando <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>El comando <code>run</code> es √∫til cuando necesitas iterar r√°pidamente en un proyecto,
como haremos en este juego, probando r√°pidamente cada iteraci√≥n antes de
pasar a la siguiente.</p>
<p>Vuelve a abrir el archivo <em>src/main.rs</em>. Escribir√°s todo el c√≥digo en este</p>
<h2 id="procesando-una-adivinanza"><a class="header" href="#procesando-una-adivinanza">Procesando una adivinanza</a></h2>
<p>La primera parte del programa del juego de adivinanzas pedir√° al usuario que
ingrese un valor, procesar√° ese valor y verificar√° que el valor est√© en el
formato esperado. Para comenzar, permitiremos al jugador ingresar una adivinanza.
Ingresa el c√≥digo de la Lista 2-1 en <em>src/main.rs</em>.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}</code></pre>
<p><span class="caption">Lista 2-1: C√≥digo que obtiene una adivinanza del usuario
y la imprime</span></p>
<p>Este c√≥digo contiene mucha informaci√≥n, as√≠ que repas√©moslo l√≠nea por l√≠nea.
Para obtener la entrada del usuario y luego imprimir el resultado como salida,
necesitamos traer la biblioteca de entrada/salida <code>io</code> al alcance. La biblioteca
<code>io</code> viene de la biblioteca est√°ndar, conocida como <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="prelude-meaning"></a></p>
<p>Por defecto, Rust tiene un conjunto de elementos definidos en la biblioteca
est√°ndar que trae al alcance de cada programa. Este conjunto se llama
<em>prelude</em>, y puedes ver todo lo que contiene <a href="https://doc.rust-lang.org/std/prelude/index.html">en la documentaci√≥n de la
biblioteca est√°ndar</a>.</p>
<p>Si un tipo que quieres usar no est√° en el prelude, tienes que traer ese tipo
al alcance expl√≠citamente con una declaraci√≥n <code>use</code>. Usar la biblioteca <code>std::io</code>
te proporciona una serie de caracter√≠sticas √∫tiles, incluyendo la capacidad de
aceptar la entrada del usuario.</p>
<p>Como viste en el Cap√≠tulo 1, la funci√≥n <code>main</code> es el punto de entrada al
programa:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>La sintaxis <code>fn</code> declara una nueva funci√≥n; los par√©ntesis, <code>()</code>, indican que
no hay par√°metros; y la llave, <code>{</code>, inicia el cuerpo de la funci√≥n.</p>
<p>Como tambi√©n aprendiste en el Cap√≠tulo 1, <code>println!</code> es una macro que imprime
una cadena en la pantalla:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Este c√≥digo est√° imprimiendo una solicitud que indica qu√© es el juego y est√°
solicitando la entrada del usuario.</p>
<h3 id="almacenando-valores-con-variables"><a class="header" href="#almacenando-valores-con-variables">Almacenando valores con variables</a></h3>
<p>A continuaci√≥n, crearemos una <em>variable</em> para almacenar la entrada del usuario,
como esto:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>¬°Ahora el programa est√° interesante! Hay mucho que est√° pasando en esta peque√±a
l√≠nea. Usamos la declaraci√≥n <code>let</code> para crear la variable. Aqu√≠ hay otro
ejemplo:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Esta l√≠nea crea una nueva variable llamada <code>apples</code> y la enlaza con el valor 5.
En Rust, las variables son inmutables por defecto, lo que significa que una vez
que le damos a la variable un valor, el valor no cambiar√°. Vamos a discutir
este concepto en detalle en la secci√≥n <a href="ch03-01-variables-and-mutability.html#variables-y-mutabilidad">‚ÄúVariables y Mutabilidad‚Äù</a><!-- ignore -->
del Cap√≠tulo 3. Para hacer una variable mutable, agregamos <code>mut</code> antes del
nombre de la variable:</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable</code></pre>
<blockquote>
<p>Nota: La sintaxis <code>//</code> inicia un comentario que contin√∫a hasta el final de la
l√≠nea. Rust ignora todo lo que est√° en los comentarios. Vamos a discutir los
comentarios en m√°s detalle en el <a href="ch03-04-comments.html">Cap√≠tulo 3</a><!-- ignore -->.</p>
</blockquote>
<p>Regresando al programa del juego de adivinanzas, ahora sabes que <code>let mut guess</code>
introducir√° una variable mutable llamada <code>guess</code>. El signo igual (<code>=</code>) le dice
a Rust que queremos enlazar algo a la variable ahora. A la derecha del signo
igual est√° el valor al que <code>guess</code> est√° enlazado, que es el resultado de llamar
a <code>String::new</code>, una funci√≥n que devuelve una nueva instancia de un <code>String</code>.
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> es un tipo de cadena proporcionado por la
biblioteca est√°ndar que es una parte de texto codificada en UTF-8 que puede
crecer.</p>
<p>La sintaxis <code>::</code> en la l√≠nea <code>::new</code> indica que <code>new</code> es una funci√≥n asociada
del tipo <code>String</code>. Una <em>funci√≥n asociada</em> es una funci√≥n que est√° implementada
en un tipo, en este caso <code>String</code>. Esta funci√≥n <code>new</code> crea una nueva cadena
vac√≠a. Encontrar√°s una funci√≥n <code>new</code> en muchos tipos porque es un nombre
com√∫n para una funci√≥n que crea un nuevo valor de alg√∫n tipo.</p>
<p>En total, la l√≠nea <code>let mut guess = String::new();</code> ha creado una variable
mutable que est√° actualmente enlazada a una nueva instancia vac√≠a de un
<code>String</code>. ¬°Uf!</p>
<h3 id="recibiendo-la-entrada-del-usuario"><a class="header" href="#recibiendo-la-entrada-del-usuario">Recibiendo la entrada del usuario</a></h3>
<p>Recuerda que incluimos la funcionalidad de entrada/salida de la biblioteca
est√°ndar con <code>use std::io;</code> en la primera l√≠nea del programa. Ahora llamaremos
a la funci√≥n <code>stdin</code> del m√≥dulo <code>io</code>, que nos permitir√° manejar la entrada del
usuario:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Si no hubi√©ramos importado la biblioteca <code>io</code> con <code>use std::io;</code> al comienzo del
programa, a√∫n podr√≠amos usar la funci√≥n escribiendo esta llamada de funci√≥n
como <code>std::io::stdin</code>. La funci√≥n <code>stdin</code> devuelve una instancia de
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, que es un tipo que representa un
manejador de la entrada est√°ndar para tu terminal.</p>
<p>A continuaci√≥n, la l√≠nea <code>.read_line(&amp;mut guess)</code> llama al m√©todo
<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> en el manejador de entrada est√°ndar para
obtener la entrada del usuario. Tambi√©n estamos pasando <code>&amp;mut guess</code> como
argumento a <code>read_line</code> para decirle qu√© cadena almacenar la entrada del
usuario. El trabajo completo de <code>read_line</code> es tomar lo que el usuario escribe
en la entrada est√°ndar y agregar eso a una cadena (sin sobrescribir su
contenido), por lo que, por lo tanto, pasamos esa cadena como argumento. La
cadena de argumentos debe ser mutable para que el m√©todo pueda cambiar el
contenido de la cadena.</p>
<p>El <code>&amp;</code> indica que este argumento es una <em>referencia</em>, que te da una forma de
permitir que varias partes de tu c√≥digo accedan a una pieza de datos sin
necesidad de copiar esos datos en la memoria varias veces. Las referencias son
una caracter√≠stica compleja, y una de las principales ventajas de Rust es lo
seguro y f√°cil que es usar referencias. No necesitas saber mucho de esos
detalles para terminar este programa. Por ahora, todo lo que necesitas saber es
que, como las variables, las referencias son inmutables por defecto. Por lo
tanto, necesitas escribir <code>&amp;mut guess</code> en lugar de <code>&amp;guess</code> para hacerlo
mutable. (El cap√≠tulo 4 explicar√° las referencias con m√°s detalle.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="manejando-el-posible-fallo-con-result"><a class="header" href="#manejando-el-posible-fallo-con-result">Manejando el posible fallo con <code>Result</code></a></h3>
<p>Todav√≠a estamos trabajando en esta l√≠nea de c√≥digo. Ahora estamos discutiendo
una tercera l√≠nea de texto, pero ten en cuenta que a√∫n es parte de una sola
l√≠nea l√≥gica de c√≥digo. La siguiente parte es este m√©todo:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}</span></code></pre>
<p>Podr√≠amos haber escrito este c√≥digo como:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);</code></pre>
<p>Sin embargo, una l√≠nea larga es dif√≠cil de leer, por lo que es mejor dividirla.
A menudo es sabio introducir un salto de l√≠nea y otros espacios en blanco para
ayudar a dividir l√≠neas largas cuando llamas a un m√©todo con la sintaxis
<code>.method_name()</code>. Ahora discutamos lo que hace esta l√≠nea.</p>
<p>Como se mencion√≥ anteriormente, <code>read_line</code> coloca lo que el usuario ingresa en
la cadena que le pasamos, pero tambi√©n devuelve un valor <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> es una <a href="ch06-00-enums.html"><em>enumeraci√≥n</em></a><!-- ignore -->, a menudo
llamada <em>enum</em>, que es un tipo que puede estar en uno de varios estados
posibles. Llamamos a cada estado posible a una <em>variante</em>.</p>
<p>El <a href="ch06-00-enums.html">Cap√≠tulo 6</a><!-- ignore --> cubrir√° las enumeraciones con m√°s
detalles. El prop√≥sito de estos tipos <code>Result</code> es codificar informaci√≥n de
manejo de errores.</p>
<p>Las variantes de <code>Result</code> son <code>Ok</code> y <code>Err</code>. La variante <code>Ok</code> indica que la
operaci√≥n fue exitosa, y dentro de <code>Ok</code> est√° el valor generado con √©xito. La
variante <code>Err</code> significa que la operaci√≥n fall√≥, y <code>Err</code> contiene informaci√≥n
sobre c√≥mo o por qu√© la operaci√≥n fall√≥.</p>
<p>Los valores del tipo <code>Result</code>, como los valores de cualquier tipo, tienen
m√©todos definidos en ellos. Una instancia de <code>Result</code> tiene un m√©todo
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a><!-- ignore --> que puedes llamar. Si esta instancia de
<code>Result</code> es un valor <code>Err</code>, <code>expect</code> har√° que el programa se bloquee y muestre
el mensaje que pasaste como argumento a <code>expect</code>. Si el m√©todo <code>read_line</code>
devuelve un <code>Err</code>, probablemente sea el resultado de un error proveniente del
sistema operativo subyacente. Si esta instancia de <code>Result</code> es un valor <code>Ok</code>,
<code>expect</code> tomar√° el valor de retorno que <code>Ok</code> est√° sosteniendo y devolver√° solo
ese valor para que lo puedas usar. En este caso, ese valor es el n√∫mero de
bytes en la entrada del usuario.</p>
<p>Si no llamas a <code>expect</code>, el programa se compilar√°, pero obtendr√°s una advertencia:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust advierte que no has usado el valor <code>Result</code> devuelto por <code>read_line</code>,
indicando que el programa no ha manejado un posible error.</p>
<p>La forma correcta de suprimir la advertencia es escribir realmente c√≥digo de
manejo de errores, pero en nuestro caso solo queremos bloquear este programa
cuando ocurra un problema, por lo que podemos usar <code>expect</code>. Aprender√°s a
recuperarte de los errores en el <a href="ch09-02-recoverable-errors-with-result.html">Cap√≠tulo 9</a><!-- ignore -->.</p>
<h3 id="imprimiendo-valores-con-marcadores-de-posici√≥n-println"><a class="header" href="#imprimiendo-valores-con-marcadores-de-posici√≥n-println">Imprimiendo valores con marcadores de posici√≥n <code>println!</code></a></h3>
<p>Adem√°s del corchete de cierre, solo hay una l√≠nea m√°s que discutir en el c√≥digo
hasta ahora:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>    println!(&quot;You guessed: {}&quot;, guess);
<span class="boring">}</span></code></pre>
<p>Esta l√≠nea imprime la cadena que ahora contiene la entrada del usuario. El
conjunto de llaves <code>{}</code> es un marcador de posici√≥n: piensa en <code>{}</code> como peque√±as
pinzas de cangrejo que mantienen un valor en su lugar. Al imprimir el valor de
una variable, el nombre de la variable puede ir dentro de las llaves
curvas. Al imprimir el resultado de evaluar una expresi√≥n, coloca llaves
curvas vac√≠as en la cadena de formato, luego sigue la cadena de formato con una
lista separada por comas de expresiones para imprimir en cada marcador de
posici√≥n vac√≠o de llaves curvas en el mismo orden. Imprimir una variable y el
resultado de una expresi√≥n en una llamada a <code>println!</code> se ver√≠a as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {x} and y + 2 = {}&quot;, y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo imprimir√≠a <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="probando-la-primera-parte"><a class="header" href="#probando-la-primera-parte">Probando la primera parte</a></h3>
<p>Probemos la primera parte del juego de adivinanzas. Ejec√∫talo usando <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>En este punto, la primera parte del juego est√° terminada: estamos obteniendo
entrada del teclado y luego la imprimimos.</p>
<h2 id="generando-un-n√∫mero-secreto"><a class="header" href="#generando-un-n√∫mero-secreto">Generando un n√∫mero secreto</a></h2>
<p>A continuaci√≥n, necesitamos generar un n√∫mero secreto que el usuario intentar√°
adivinar. El n√∫mero secreto debe ser diferente cada vez para que el juego sea
divertido de jugar m√°s de una vez. Usaremos un n√∫mero aleatorio entre 1 y 100
para que el juego no sea demasiado dif√≠cil. Rust a√∫n no incluye la
funcionalidad de n√∫meros aleatorios en su biblioteca est√°ndar. Sin embargo, el
equipo de Rust proporciona un <a href="https://crates.io/crates/rand"><code>rand</code> crate</a> con dicha
funcionalidad.</p>
<h3 id="usando-un-crate-para-obtener-m√°s-funcionalidad"><a class="header" href="#usando-un-crate-para-obtener-m√°s-funcionalidad">Usando un Crate para obtener m√°s funcionalidad</a></h3>
<p>Recuerda que un crate es una colecci√≥n de archivos de c√≥digo fuente de Rust. El
proyecto que hemos estado construyendo es un <em>binary crate</em>, que es un
ejecutable. El crate <code>rand</code> es un <em>library crate</em>, que contiene c√≥digo que se
pretende usar en otros programas y no se puede ejecutar por s√≠ solo.</p>
<p>La coordinaci√≥n de los crates externos de Cargo es donde realmente brilla
Cargo. Antes de poder escribir c√≥digo que use <code>rand</code>, necesitamos modificar el
archivo <em>Cargo.toml</em> para incluir el crate <code>rand</code> como una dependencia. Abre ese
archivo ahora y agrega la siguiente l√≠nea al final, debajo del encabezado de la
secci√≥n <code>[dependencies]</code> que Cargo cre√≥ para ti. Aseg√∫rate de especificar <code>rand</code>
exactamente como lo tenemos aqu√≠, con este n√∫mero de versi√≥n, o los ejemplos de
c√≥digo en este tutorial pueden no funcionar:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>En el archivo <em>Cargo.toml</em>, todo lo que sigue a un encabezado es parte de esa
secci√≥n que contin√∫a hasta que comienza otra secci√≥n. En <code>[dependencies]</code> le
dices a Cargo qu√© crates externos depende tu proyecto y qu√© versiones de esos
crates requieres. En este caso, especificamos el crate <code>rand</code> con el
especificador de versi√≥n sem√°ntica <code>0.8.5</code>. Cargo entiende <a href="http://semver.org">Semantic
Versioning</a><!-- ignore --> (a veces llamado <em>SemVer</em>), que es un
est√°ndar para escribir n√∫meros de versi√≥n. El especificador <code>0.8.5</code> es
realmente un atajo para <code>^0.8.5</code>, lo que significa cualquier versi√≥n que sea
al menos 0.8.5 pero inferior a 0.9.0.</p>
<p>Cargo considera que estas versiones tienen APIs p√∫blicas compatibles con la
versi√≥n 0.8.5, y esta especificaci√≥n asegura que obtendr√° la √∫ltima versi√≥n de
correcci√≥n que a√∫n se compilar√° con el c√≥digo de este cap√≠tulo. Cualquier
versi√≥n 0.9.0 o superior no est√° garantizada de tener la misma API que lo que
usar√°n los siguientes ejemplos.</p>
<p>Ahora, sin cambiar ning√∫n c√≥digo, construyamos el proyecto, como se muestra en
el Listado 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Listado 2-2: La salida de ejecutar <code>cargo build</code> despu√©s
de agregar el crate rand como una dependencia</span></p>
<p>Es posible que veas n√∫meros de versi√≥n diferentes (¬°pero todos ser√°n
compatibles con el c√≥digo, gracias a SemVer!) y l√≠neas diferentes (dependiendo
del sistema operativo), y las l√≠neas pueden estar en un orden diferente.</p>
<p>Cuando incluimos una dependencia externa, Cargo obtiene las √∫ltimas versiones de
todo lo que la dependencia necesita del <em>registro</em>, que es una copia de datos
de <a href="https://crates.io/">Crates.io</a>. Crates.io es donde las personas en el ecosistema de
Rust publican sus proyectos de Rust de c√≥digo abierto para que otros los
utilicen.</p>
<p>Despu√©s de actualizar el registro, Cargo verifica la secci√≥n <code>[dependencies]</code>
y descarga cualquier crate que se haya enumerado que a√∫n no se haya
descargado. En este caso, aunque solo enumeramos <code>rand</code> como una dependencia,
Cargo tambi√©n tom√≥ otros crates que <code>rand</code> depende para funcionar. Despu√©s de
descargar los crates, Rust los compila y luego compila el proyecto con las
dependencias disponibles.</p>
<p>Si ejecuta <code>cargo build</code> nuevamente sin hacer ning√∫n cambio, no obtendr√°
ninguna salida aparte de la l√≠nea <code>Finished</code>. Cargo sabe que ya ha descargado y
compilado las dependencias, y no ha cambiado nada sobre ellas en su archivo
<em>Cargo.toml</em>. Cargo tambi√©n sabe que no ha cambiado nada sobre su c√≥digo, por
lo que tampoco lo vuelve a compilar. Sin nada que hacer, simplemente sale.</p>
<p>Si abre el archivo <em>src/main.rs</em>, realiza un cambio trivial y luego lo guarda y
vuelve a construir, solo ver√° dos l√≠neas de salida:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Estas l√≠neas muestran que Cargo solo actualiza la compilaci√≥n con su peque√±o
cambio en el archivo <em>src/main.rs</em>. Sus dependencias no han cambiado, por lo
que Cargo sabe que puede reutilizar lo que ya ha descargado y compilado para
esas.</p>
<h4 id="garantizar-compilaciones-reproducibles-con-el-archivo-cargolock"><a class="header" href="#garantizar-compilaciones-reproducibles-con-el-archivo-cargolock">Garantizar compilaciones reproducibles con el archivo <em>Cargo.lock</em></a></h4>
<p>Cargo tiene un mecanismo que le garantiza que puede reconstruir el mismo
artefacto cada vez que usted o cualquier otra persona construye su c√≥digo:
Cargo solo usar√° las versiones de las dependencias que haya especificado hasta
que indique lo contrario. Por ejemplo, digamos que la semana que viene sale la
versi√≥n 0.8.6 del crate <code>rand</code>, y que esa versi√≥n contiene una correcci√≥n de
error importante, pero tambi√©n contiene una regresi√≥n que romper√° su c√≥digo.
Para manejar esto, Rust crea el archivo <em>Cargo.lock</em> la primera vez que ejecuta
<code>cargo build</code>, por lo que ahora tenemos esto en el directorio <em>guessing_game</em></p>
<p>Cuando construye un proyecto por primera vez, Cargo determina todas las
versiones de las dependencias que cumplen con los criterios y luego las escribe
en el archivo <em>Cargo.lock</em>. Cuando construye su proyecto en el futuro, Cargo
ver√° que el archivo <em>Cargo.lock</em> existe y usar√° las versiones especificadas
all√≠ en lugar de hacer todo el trabajo de averiguar las versiones nuevamente.
Esto le permite tener una compilaci√≥n reproducible de forma autom√°tica. En
otras palabras, su proyecto permanecer√° en 0.8.5 hasta que actualice
expl√≠citamente, gracias al archivo <em>Cargo.lock</em>. Debido a que el archivo
<em>Cargo.lock</em> es importante para las compilaciones reproducibles, a menudo se
verifica en el control de versiones con el resto del c√≥digo en su proyecto.</p>
<h4 id="actualizar-un-crate-para-obtener-una-nueva-versi√≥n"><a class="header" href="#actualizar-un-crate-para-obtener-una-nueva-versi√≥n">Actualizar un crate para obtener una nueva versi√≥n</a></h4>
<p>Cuando <em>quiera</em> actualizar un crate, Cargo proporciona el comando <code>update</code>,
que ignorar√° el archivo <em>Cargo.lock</em> y determinar√° todas las √∫ltimas versiones
que cumplan con sus especificaciones en <em>Cargo.toml</em>. Cargo luego escribir√°
esas versiones en el archivo <em>Cargo.lock</em>. En este caso, Cargo solo buscar√° 
versiones mayores que 0.8.5 y menores que 0.9.0. Si el crate <code>rand</code> ha lanzado 
las dos nuevas versiones 0.8.6 y 0.9.0, ver√≠a lo siguiente si ejecutara 
<code>cargo update</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo ignora el lanzamiento 0.9.0. En este punto, tambi√©n notar√≠a un cambio en
su archivo <em>Cargo.lock</em> que indica que la versi√≥n del crate <code>rand</code> que ahora
est√° usando es 0.8.6. Para usar la versi√≥n 0.9.0 o cualquier versi√≥n en la
serie 0.9.<em>x</em>, tendr√≠a que actualizar el archivo <em>Cargo.toml</em> para que se
vea as√≠:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>La pr√≥xima vez que ejecute <code>cargo build</code>, Cargo actualizar√° el registro de
crates disponibles y volver√° a evaluar sus requisitos de <code>rand</code> de acuerdo con
la nueva versi√≥n que ha especificado.</p>
<p>Hay mucho m√°s que decir sobre <a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore --> y <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">su
ecosistema</a><!-- ignore -->, que discutiremos en el Cap√≠tulo 14, pero
por ahora, eso es todo lo que necesita saber. Cargo hace muy f√°cil reutilizar
bibliotecas, por lo que los Rustaceans pueden escribir proyectos m√°s peque√±os
que se ensamblan a partir de un n√∫mero de paquetes.</p>
<h3 id="generar-un-numero-aleatorio"><a class="header" href="#generar-un-numero-aleatorio">Generar un numero aleatorio</a></h3>
<p>Comencemos a usar <code>rand</code> para generar un n√∫mero para adivinar. El siguiente
paso es actualizar <em>src/main.rs</em>, como se muestra en el Listado 2-3.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;The secret number is: {secret_number}&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}</code></pre>
<p><span class="caption">Listado 2-3: Agregando c√≥digo para generar un n√∫mero
aleatorio</span></p>
<p>Primero agregamos la l√≠nea <code>use rand::Rng;</code>. El trait <code>Rng</code> define m√©todos que
los generadores de n√∫meros aleatorios implementan, y este trait debe estar en
el alcance para que podamos usar esos m√©todos. El Cap√≠tulo 10 cubrir√° los
traits en detalle.</p>
<p>A continuaci√≥n, estamos agregando dos l√≠neas en el medio. En la primera l√≠nea,
llamamos a la funci√≥n <code>rand::thread_rng</code> que nos da el generador de n√∫meros
aleatorios particular que vamos a usar: uno que es local al hilo de ejecuci√≥n
actual y est√° sembrado por el sistema operativo. Luego llamamos al m√©todo
<code>gen_range</code> en el generador de n√∫meros aleatorios. Este m√©todo est√° definido
por el trait <code>Rng</code> que traemos al alcance con la declaraci√≥n <code>use rand::Rng;</code>.
El m√©todo <code>gen_range</code> toma una expresi√≥n de rango como argumento y genera un
n√∫mero aleatorio en el rango. El tipo de expresi√≥n de rango que estamos
utilizando aqu√≠ toma la forma <code>start..=end</code> y es inclusivo en los l√≠mites
inferior y superior, por lo que necesitamos especificar <code>1..=100</code> para solicitar
un n√∫mero entre 1 y 100.</p>
<blockquote>
<p>Nota: No sabr√° solo qu√© traits usar y qu√© m√©todos y funciones llamar desde un
crate, por lo que cada crate tiene documentaci√≥n con instrucciones para
usarlo. Otra caracter√≠stica interesante de Cargo es que ejecutar el comando
<code>cargo doc --open</code> construir√° la documentaci√≥n proporcionada por todas sus
dependencias localmente y la abrir√° en su navegador. Si est√° interesado en
otra funcionalidad en el crate <code>rand</code>, por ejemplo, ejecute <code>cargo doc --open</code> y haga clic en <code>rand</code> en la barra lateral a la izquierda.</p>
</blockquote>
<p>La segunda l√≠nea nueva imprime el n√∫mero secreto. Esto es √∫til mientras
desarrollamos el programa para poder probarlo, pero lo eliminaremos de la
versi√≥n final. ¬°No es mucho un juego si el programa imprime la respuesta tan
pronto como comienza!</p>
<p>Intente ejecutar el programa varias veces:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Deber√≠a obtener n√∫meros aleatorios diferentes, y todos deber√≠an ser n√∫meros
entre 1 y 100. ¬°Gran trabajo!</p>
<p><a id="comparando-la-adivinanza-con-el-numero-secreto"></a></p>
<h2 id="comparando-la-adivinanza-con-el-n√∫mero-secreto"><a class="header" href="#comparando-la-adivinanza-con-el-n√∫mero-secreto">Comparando la Adivinanza con el N√∫mero Secreto</a></h2>
<p>Ahora que tenemos la entrada del usuario y un n√∫mero aleatorio, podemos
compararlos. Ese paso se muestra en el Listado 2-4. Tenga en cuenta que este
c√≥digo a√∫n no se compilar√°, como explicaremos.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}</code></pre>
<p><span class="caption">Listado 2-4: Manejo de los posibles valores de retorno
de la comparaci√≥n de dos n√∫meros</span></p>
<p>Primero agregamos otra declaraci√≥n <code>use</code>, que trae un tipo llamado
<code>std::cmp::Ordering</code> al alcance de la biblioteca est√°ndar. El tipo <code>Ordering</code>
es otro enum y tiene las variantes <code>Less</code>, <code>Greater</code> y <code>Equal</code>. Estos son los
tres resultados posibles cuando compara dos valores.</p>
<p>Luego agregamos cinco nuevas l√≠neas al final que usan el tipo <code>Ordering</code>. El
m√©todo <code>cmp</code> compara dos valores y se puede llamar en cualquier cosa que se
pueda comparar. Toma una referencia a lo que quiera comparar: aqu√≠ est√°
comparando <code>guess</code> con <code>secret_number</code>. Luego devuelve una variante del enum
<code>Ordering</code> que importamos al alcance con la declaraci√≥n <code>use</code>. Usamos una
expresi√≥n <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> para decidir qu√© hacer a continuaci√≥n
bas√°ndonos en qu√© variante de <code>Ordering</code> se devolvi√≥ de la llamada a <code>cmp</code> con
los valores en <code>guess</code> y <code>secret_number</code>.</p>
<p>Una expresi√≥n <code>match</code> est√° compuesta por <em>brazos</em>. Un brazo consta de un
<em>patr√≥n</em> para coincidir y el c√≥digo que se debe ejecutar si el valor dado a
<code>match</code> se ajusta al patr√≥n del brazo. Rust toma el valor dado a <code>match</code> y
busca cada patr√≥n de brazo en orden. Los patrones y la construcci√≥n <code>match</code> son
potentes caracter√≠sticas de Rust: le permiten expresar una variedad de
situaciones que su c√≥digo puede encontrar y se aseguran de que los maneje
todos. Estas caracter√≠sticas se cubrir√°n en detalle en el Cap√≠tulo 6 y el
Cap√≠tulo 18, respectivamente.</p>
<p>Vamos a repasar un ejemplo con la expresi√≥n <code>match</code> que usamos aqu√≠. Digamos
que el usuario ha adivinado 50 y el n√∫mero secreto generado aleatoriamente
esta vez es 38.</p>
<p>Cuando el c√≥digo compara 50 con 38, el m√©todo <code>cmp</code> devolver√°
<code>Ordering::Greater</code> porque 50 es mayor que 38. La expresi√≥n <code>match</code> obtiene el
valor <code>Ordering::Greater</code> y comienza a verificar el patr√≥n de cada brazo. Mira
el patr√≥n del primer brazo, <code>Ordering::Less</code>, y ve que el valor
<code>Ordering::Greater</code> no coincide con <code>Ordering::Less</code>, ¬°as√≠ que ignora el c√≥digo
en ese brazo y se mueve al siguiente brazo! El patr√≥n del siguiente brazo es
<code>Ordering::Greater</code>, ¬°que <em>s√≠</em> coincide con <code>Ordering::Greater</code>! El c√≥digo
asociado en ese brazo se ejecutar√° y mostrar√° <code>Too big!</code> en la pantalla. La
expresi√≥n <code>match</code> termina despu√©s de la primera coincidencia exitosa, ¬°as√≠ que
no mirar√° el √∫ltimo brazo en este escenario.</p>
<p>Sin embargo, el c√≥digo del Listado 2-4 a√∫n no se compilar√°. Vamos a intentarlo:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/cmp.rs:836:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin &quot;guessing_game&quot;) due to 1 previous error
</code></pre>
<p>El n√∫cleo del error indica que hay <em>tipos no coincidentes</em>. Rust tiene un
sistema de tipos fuerte y est√°tico. Sin embargo, tambi√©n tiene inferencia de
tipo. Cuando escribimos <code>let mut guess = String::new()</code>, Rust pudo inferir que
<code>guess</code> deber√≠a ser un <code>String</code> y no nos oblig√≥ a escribir el tipo. El
<code>secret_number</code>, por otro lado, es un tipo de n√∫mero. Algunos de los tipos de
n√∫meros de Rust pueden tener un valor entre 1 y 100: <code>i32</code>, un n√∫mero de 32 bits;
<code>u32</code>, un n√∫mero sin signo de 32 bits; <code>i64</code>, un n√∫mero de 64 bits; as√≠ como
otros. A menos que se especifique lo contrario, Rust predetermina un <code>i32</code>, que
es el tipo de <code>secret_number</code> a menos que agregue informaci√≥n de tipo en otro
lugar que haga que Rust infiera un tipo num√©rico diferente. La raz√≥n del error
es que Rust no puede comparar una cadena y un tipo num√©rico.</p>
<p>Finalmente, queremos convertir la <code>String</code> que el programa lee como entrada en
un tipo de n√∫mero real para que podamos compararlo num√©ricamente con el n√∫mero
secreto. Lo hacemos agregando esta l√≠nea al cuerpo de la funci√≥n <code>main</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
<span class="boring">}</span></code></pre>
<p>La l√≠nea es:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);</code></pre>
<p>Creamos una variable llamada <code>guess</code>. Pero espera, ¬øno tiene el programa ya una
variable llamada <code>guess</code>? Lo hace, pero Rust nos permite redefinir el valor
anterior de <code>guess</code> con uno nuevo. Este concepto en Rust se le conoce como
<em>Shadowing</em>, nos permite volver a usar el nombre de la variable <code>guess</code>
en lugar de obligarnos a crear dos variables √∫nicas, como <code>guess_str</code>
y <code>guess</code>, por ejemplo. Lo cubriremos con m√°s detalle en el
<a href="ch03-01-variables-and-mutability.html#shadowing">Cap√≠tulo 3</a><!-- ignore -->, pero por ahora, s√© que esta
caracter√≠stica se usa a menudo cuando desea convertir un valor de un tipo a
otro tipo.</p>
<p>Enlazamos esta nueva variable a la expresi√≥n <code>guess.trim().parse()</code>. La <code>guess</code>
en la expresi√≥n se refiere a la variable <code>guess</code> original que conten√≠a la
entrada como una cadena. El m√©todo <code>trim</code> en una instancia <code>String</code> eliminar√°
cualquier espacio en blanco al principio y al final, lo que debemos hacer para
poder comparar la cadena con el <code>u32</code>, que solo puede contener datos num√©ricos.
El usuario debe presionar <span class="keystroke">enter</span> para satisfacer
<code>read_line</code> e ingresar su conjetura, lo que agrega un car√°cter de nueva l√≠nea
a la cadena. Por ejemplo, si el usuario escribe <span class="keystroke">5</span>
y presiona <span class="keystroke">enter</span>, <code>guess</code> se ve as√≠: <code>5\n</code>. El
<code>\n</code> representa &quot;nueva l√≠nea&quot;. (En Windows, presionar <span
class="keystroke">enter</span> resulta en un retorno de carro y una nueva
l√≠nea, <code>\r\n</code>). El m√©todo <code>trim</code> elimina <code>\n</code> o <code>\r\n</code>, lo que resulta en solo
<code>5</code>.</p>
<p>El <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">m√©todo <code>parse</code> en las cadenas</a><!-- ignore --> convierte una cadena
en otro tipo. Aqu√≠, lo usamos para convertir de una cadena a un n√∫mero. Debemos
decirle a Rust el tipo de n√∫mero exacto que queremos usando <code>let guess: u32</code>.
Los dos puntos (<code>:</code>) despu√©s de <code>guess</code> le dicen a Rust que anotaremos el tipo
de variable. Rust tiene algunos tipos de n√∫mero integrados; el <code>u32</code> visto
aqu√≠ es un entero sin signo de 32 bits. Es una buena opci√≥n predeterminada para
un n√∫mero positivo peque√±o. Aprender√° sobre otros tipos de n√∫meros en el
<a href="ch03-02-data-types.html#tipos-de-enteros">Cap√≠tulo 3</a><!-- ignore -->.</p>
<p>Adem√°s, la anotaci√≥n <code>u32</code> en este programa de ejemplo y la comparaci√≥n con
<code>secret_number</code> significa que Rust inferir√° que <code>secret_number</code> tambi√©n
deber√≠a ser <code>u32</code>. ¬°Entonces la comparaci√≥n ser√° entre dos valores del mismo
tipo!</p>
<p>El m√©todo <code>parse</code> solo funcionar√° en caracteres que se puedan convertir
l√≥gicamente en n√∫meros y, por lo tanto, pueden causar f√°cilmente errores. Si,
por ejemplo, la cadena contiene <code>Aüëç%</code>, no habr√≠a manera de convertir eso en un
n√∫mero. Debido a que podr√≠a fallar, el m√©todo <code>parse</code> devuelve un tipo <code>Result</code>,
tal como lo hace el m√©todo <code>read_line</code> (discutido anteriormente en
<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">‚ÄúManejo de posibles fallas con <code>Result</code>‚Äù</a><!-- ignore-->).
Trataremos este <code>Result</code> de la misma manera usando el m√©todo <code>expect</code> de nuevo.
Si <code>parse</code> devuelve una variante <code>Err</code> del tipo <code>Result</code> porque no pudo crear
un n√∫mero a partir de la cadena, la llamada <code>expect</code> har√° que el juego se
bloquee y muestre el mensaje que le damos. Si <code>parse</code> puede convertir
exitosamente la cadena en un n√∫mero, devolver√° la variante <code>Ok</code> del tipo
<code>Result</code>, y <code>expect</code> devolver√° el n√∫mero que queremos del valor <code>Ok</code>.</p>
<p>¬°Corramos el programa ahora!</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>¬°Bien! Aunque se agregaron espacios antes de la adivinanza, el programa a√∫n
sab√≠a que el usuario adivin√≥ 76. Ejecute el programa varias veces para
verificar el comportamiento diferente con diferentes tipos de entrada: adivine
el n√∫mero correctamente, adivine un n√∫mero que sea demasiado alto y adivine un
n√∫mero que sea demasiado bajo.</p>
<p>Tenemos la mayor√≠a del juego funcionando ahora, pero el usuario solo puede
adivinar una vez. ¬°Cambiamos eso agregando un bucle!</p>
<h2 id="permitir-m√∫ltiples-adivinanzas-con-bucles"><a class="header" href="#permitir-m√∫ltiples-adivinanzas-con-bucles">Permitir m√∫ltiples adivinanzas con bucles</a></h2>
<p>La palabra clave <code>loop</code> crea un bucle infinito. Agregaremos un bucle para darle
a los usuarios m√°s oportunidades para adivinar el n√∫mero:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;The secret number is: {secret_number}&quot;);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}</code></pre>
<p>Como puede ver, hemos movido todo desde la solicitud de entrada de adivinanzas
hacia adelante en un bucle. Aseg√∫rese de indentar las l√≠neas dentro del bucle
otras cuatro veces y ejecute el programa nuevamente. ¬°El programa ahora pedir√°
otra adivinanza para siempre, lo que introduce un nuevo problema! ¬°Parece que el
usuario no puede salir!</p>
<p>El usuario siempre podr√≠a interrumpir el programa usando el atajo de teclado
<span class="keystroke">ctrl-c</span>. Pero hay otra forma de escapar de este
monstruo insaciable, como se mencion√≥ en la discusi√≥n de <code>parse</code> en
<a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">‚ÄúComparando la adivinanza con el n√∫mero secreto‚Äù</a><!--
ignore -->: si el usuario ingresa una respuesta que no es un n√∫mero, el
programa se bloquear√°. Podemos aprovechar eso para permitir que el usuario
salga, como se muestra aqu√≠:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Al escribir <code>quit</code> se cerrar√° el juego, pero como notar√°, tambi√©n lo har√° al
ingresar cualquier otra entrada que no sea un n√∫mero. Esto es lo menos
√≥ptimo, para decir lo menos; queremos que el juego tambi√©n se detenga cuando se
adivine el n√∫mero correcto.</p>
<p><a id="salir-despues-de-una-adivinanza-correcta"></a></p>
<h3 id="salir-despu√©s-de-una-adivinanza-correcta"><a class="header" href="#salir-despu√©s-de-una-adivinanza-correcta">Salir despu√©s de una adivinanza correcta</a></h3>
<p>Programemos el juego para que se cierre cuando el usuario gane agregando una
declaraci√≥n <code>break</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p>Agregando la l√≠nea <code>break</code> despu√©s de <code>You win!</code> hace que el programa salga del
bucle cuando el usuario adivina el n√∫mero secreto correctamente. Salir del
bucle tambi√©n significa salir del programa, porque el bucle es la √∫ltima parte
de <code>main</code>.</p>
<h3 id="manejo-de-entrada-no-v√°lida"><a class="header" href="#manejo-de-entrada-no-v√°lida">Manejo de entrada no v√°lida</a></h3>
<p>Para mejorar a√∫n m√°s el comportamiento del juego, en lugar de bloquear el
programa cuando el usuario ingresa un n√∫mero no v√°lido, hagamos que el juego
ignore un n√∫mero no v√°lido para que el usuario pueda seguir adivinando. Podemos
hacer eso alterando la l√≠nea donde <code>guess</code> se convierte de un <code>String</code> a un
<code>u32</code>, como se muestra en el Listado 2-5.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 2-5: Ignorar una adivinanza que no es un n√∫mero
y pedir otra adivinanza en lugar de bloquear el programa</span></p>
<p>Cambiamos de una llamada <code>expect</code> a una expresi√≥n <code>match</code> para pasar de
bloquear el programa en un error a manejar el error. Recuerde que <code>parse</code>
devuelve un tipo <code>Result</code> y <code>Result</code> es un enum que tiene las variantes <code>Ok</code> y
<code>Err</code>. Aqu√≠ estamos usando una expresi√≥n <code>match</code>, como hicimos con el resultado
<code>Ordering</code> del m√©todo <code>cmp</code>.</p>
<p>Si <code>parse</code> es capaz de convertir exitosamente la cadena en un n√∫mero, devolver√°
un valor <code>Ok</code> que contiene el n√∫mero resultante. Ese valor <code>Ok</code> coincidir√° con
el patr√≥n de la primera rama y la expresi√≥n <code>match</code> devolver√° el valor <code>num</code>
que <code>parse</code> produjo y puso dentro del valor <code>Ok</code>. Ese n√∫mero terminar√° en el
lugar correcto en la nueva variable <code>guess</code> que estamos creando.</p>
<p>Si <code>parse</code> <em>no</em> es capaz de convertir la cadena en un n√∫mero, devolver√° un
valor <code>Err</code> que contiene m√°s informaci√≥n sobre el error. El valor <code>Err</code> no
coincide con el patr√≥n <code>Ok(num)</code> en la primera rama de <code>match</code>, pero s√≠
coincide con el patr√≥n <code>Err(_)</code> en la segunda rama. El gui√≥n bajo, <code>_</code>, es un
valor de captura; en este ejemplo, estamos diciendo que queremos coincidir con
todos los valores <code>Err</code>, sin importar qu√© informaci√≥n tengan dentro. ¬°As√≠ que
el programa ejecutar√° el c√≥digo de la segunda rama, <code>continue</code>, que le dice al
programa que vaya a la siguiente iteraci√≥n del <code>loop</code> y pida otra adivinanza.
¬°As√≠ que, efectivamente, el programa ignora todos los errores que <code>parse</code> puede
encontrar!</p>
<p>Ahora todo en el programa deber√≠a funcionar como se espera. Vamos a probarlo:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>¬°Genial! Con un peque√±o ajuste final, terminaremos el juego de adivinanzas.
Recuerde que el programa todav√≠a est√° imprimiendo el n√∫mero secreto. Eso
funcion√≥ bien para las pruebas, pero arruina el juego. Vamos a eliminar el
<code>println!</code> que muestra el n√∫mero secreto. El listado 2-6 muestra el c√≥digo
final.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p><span class="caption">Listado 2-6: C√≥digo completo del juego de adivinanzas</span></p>
<p>En este punto, ha construido exitosamente el juego de adivinanzas. ¬°Felicidades!</p>
<h2 id="resumen-1"><a class="header" href="#resumen-1">Resumen</a></h2>
<p>Este proyecto fue una manera pr√°ctica de introducirle a muchos nuevos conceptos
de Rust: <code>let</code>, <code>match</code>, funciones, el uso de paquetes externos, y m√°s. En los
pr√≥ximos cap√≠tulos, aprender√° sobre estos conceptos en m√°s detalle. El cap√≠tulo
3 cubre conceptos que la mayor√≠a de los lenguajes de programaci√≥n tienen, como
variables, tipos de datos y funciones, y muestra c√≥mo usarlos en Rust. El
cap√≠tulo 4 explora la propiedad, una caracter√≠stica que hace que Rust sea
diferente de otros lenguajes. El cap√≠tulo 5 discute las estructuras y la
sintaxis de los m√©todos, y el cap√≠tulo 6 explica c√≥mo funcionan los enums.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conceptos-comunes-de-programaci√≥n"><a class="header" href="#conceptos-comunes-de-programaci√≥n">Conceptos Comunes de Programaci√≥n</a></h1>
<p>Este cap√≠tulo cubre conceptos que aparecen en casi todos los lenguajes de
programaci√≥n y c√≥mo funcionan en Rust. Muchos lenguajes de programaci√≥n tienen
mucho en com√∫n en su n√∫cleo. Ninguno de los conceptos presentados en este
cap√≠tulo son √∫nicos de Rust, pero los discutiremos en el contexto de Rust y
explicaremos las convenciones alrededor de su uso.</p>
<p>Espec√≠ficamente, aprender√°s sobre variables, tipos b√°sicos, funciones,
comentarios y flujo de control. Estas bases estar√°n en todos los programas de
Rust, y aprenderlas temprano te dar√° un n√∫cleo fuerte para comenzar.</p>
<blockquote>
<h4 id="palabras-clave"><a class="header" href="#palabras-clave">Palabras clave</a></h4>
<p>El lenguaje Rust tiene un conjunto de <em>palabras clave</em> que est√°n reservadas
para su uso exclusivo por el lenguaje, al igual que en otros lenguajes. Tenga
en cuenta que no puede usar estas palabras como nombres de variables o
funciones. La mayor√≠a de las palabras clave tienen significados especiales,
y las usar√° para realizar varias tareas en sus programas de Rust; algunas no
tienen ninguna funcionalidad actual asociada con ellas, pero se han reservado
para funcionalidad que podr√≠a agregarse a Rust en el futuro. Puede encontrar
una lista de las palabras clave en <a href="appendix-01-keywords.html">Ap√©ndice A</a><!-- ignore -->.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variables-y-mutabilidad"><a class="header" href="#variables-y-mutabilidad">Variables y Mutabilidad</a></h2>
<p>Como se mencion√≥ en la secci√≥n
<a href="ch02-00-guessing-game-tutorial.html#almacenando-valores-con-variables">‚ÄúAlmacenando valores con variables‚Äù</a><!-- ignore -->
, por defecto, las variables
son inmutables. Este es uno de los muchos empujes que Rust le da para que
escriba su c√≥digo de una manera que aproveche la seguridad y la f√°cil
concurrencia que ofrece Rust. Sin embargo, todav√≠a tiene la opci√≥n de hacer
sus variables mutables. Exploremos c√≥mo y por qu√© Rust le anima a favorecer
la inmutabilidad y por qu√© a veces podr√≠a querer optar por no hacerlo.</p>
<p>Cuando una variable es inmutable, una vez que un valor est√° vinculado a un
nombre, no puede cambiar ese valor. Para ilustrar esto, genere un nuevo
proyecto llamado <em>variables</em> en su directorio <em>proyectos</em> usando <code>cargo new variables</code>.</p>
<p>Luego, en su nuevo directorio <em>variables</em>, abra <em>src/main.rs</em> y reemplace su
c√≥digo con el siguiente c√≥digo, que a√∫n no se compilar√°:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}</code></pre>
<p>Guarde y ejecute el programa usando <code>cargo run</code>. Deber√≠a recibir un mensaje de
error relacionado con un error de inmutabilidad, como se muestra en esta
salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {x}&quot;);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error
</code></pre>
<p>Este ejemplo muestra c√≥mo el compilador le ayuda a encontrar errores en sus
programas. Los errores de compilaci√≥n pueden ser frustrantes, pero realmente
solo significa que su programa a√∫n no est√° realizando de manera segura lo que
desea que haga; <em>no</em> significa que no es un buen programador! Los Rustaceans
experimentados a√∫n reciben errores de compilaci√≥n.</p>
<p>Recibi√≥ el mensaje de error <code>cannot assign twice to immutable variable `x`</code> porque intent√≥ asignar un segundo valor a la variable inmutable <code>x</code>.</p>
<p>Es importante que obtengamos errores en tiempo de compilaci√≥n cuando intentamos
cambiar un valor que est√° designado como inmutable, porque esta situaci√≥n
puede conducir a errores. Si una parte de nuestro c√≥digo opera bajo la
suposici√≥n de que un valor nunca cambiar√° y otra parte de nuestro c√≥digo
cambia ese valor, es posible que la primera parte del c√≥digo no haga lo que
estaba dise√±ado para hacer. La causa de este tipo de error puede ser dif√≠cil
de rastrear despu√©s del hecho, especialmente cuando la segunda pieza de c√≥digo
cambia el valor solo <em>algunas veces</em>. El compilador de Rust garantiza que
cuando afirma que un valor no cambiar√°, realmente no cambiar√°, por lo que no
tiene que rastrearlo usted mismo. Su c√≥digo es, por lo tanto, m√°s f√°cil de
razonar.</p>
<p>Pero la mutabilidad puede ser muy √∫til y puede hacer que el c√≥digo sea m√°s
conveniente de escribir. Aunque las variables son inmutables por defecto, puede
hacerlas mutables agregando <code>mut</code> delante del nombre de la variable como lo
hizo en el <a href="ch02-00-guessing-game-tutorial.html#almacenando-valores-con-variables">Capitulo 2</a><!-- ignore -->.
Agregando <code>mut</code> tambi√©n comunica la intenci√≥n a los lectores futuros del c√≥digo
indicando que otras partes del c√≥digo cambiar√°n el valor de esta variable.</p>
<p>Por ejemplo, cambiemos <em>src/main.rs</em> a lo siguiente:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<p>Cuando ejecutamos el programa ahora, obtenemos esto:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Se nos permite cambiar el valor vinculado a <code>x</code> de <code>5</code> a <code>6</code> cuando se usa
<code>mut</code>. En √∫ltima instancia, decidir si usar o no la mutabilidad depende de
usted y depende de lo que crea que es m√°s claro en esa situaci√≥n particular.</p>
<h3 id="constantes"><a class="header" href="#constantes">Constantes</a></h3>
<p>Al igual que las variables inmutables, las <em>constantes</em> son valores que est√°n
vinculados a un nombre y no se les permite cambiar, pero hay algunas
diferencias entre las constantes y las variables.</p>
<p>Primero, no se le permite usar <code>mut</code> con constantes. Las constantes no son solo
inmutables por defecto, siempre son inmutables. Declara constantes usando la
palabra clave <code>const</code> en lugar de la palabra clave <code>let</code>, y el tipo del valor
<em>debe</em> estar anotado. Cubriremos los tipos y las anotaciones de tipo en la
siguiente secci√≥n, <a href="ch03-02-data-types.html#tipos-de-datos">‚ÄúTipos de datos‚Äù</a><!-- ignore -->, por lo que no se
preocupe por los detalles ahora. Solo sepa que siempre debe anotar el tipo.</p>
<p>Las constantes se pueden declarar en cualquier √°mbito, incluido el √°mbito
global, lo que las hace √∫tiles para valores que muchas partes del c√≥digo
necesitan conocer.</p>
<p>La √∫ltima diferencia es que las constantes solo se pueden establecer en una
expresi√≥n constante, no en el resultado de un valor que solo se podr√≠a calcular
en tiempo de ejecuci√≥n.</p>
<p>Aqu√≠ hay un ejemplo de una declaraci√≥n constante:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>El nombre de la constante es <code>THREE_HOURS_IN_SECONDS</code> y su valor se establece
en el resultado de multiplicar 60 (el n√∫mero de segundos en un minuto) por 60
(el n√∫mero de minutos en una hora) por 3 (el n√∫mero de horas que queremos
contar en este programa). La convenci√≥n de nombramiento de Rust para constantes
es usar may√∫sculas con guiones bajos entre palabras. El compilador es capaz de
evaluar un conjunto limitado de operaciones en tiempo de compilaci√≥n, lo que
nos permite elegir escribir este valor de una manera que sea m√°s f√°cil de
entender y verificar, en lugar de establecer esta constante en el valor 10,800.
Vea la <a href="https://doc.rust-lang.org/reference/const_eval.html">&quot;secci√≥n de la Referencia de Rust sobre la evaluaci√≥n constante&quot;</a>
para m√°s informaci√≥n sobre qu√© operaciones se pueden usar al declarar constantes.</p>
<p>Las constantes son v√°lidas durante todo el tiempo que se ejecuta un programa,
dentro del √°mbito en el que se declararon. Esta propiedad hace que las
constantes sean √∫tiles para los valores en el dominio de su aplicaci√≥n que
varias partes del programa podr√≠an necesitar conocer, como el n√∫mero m√°ximo de
puntos que cualquier jugador de un juego puede obtener o la velocidad de la
luz.</p>
<p>Nombrar valores codificados en su programa como constantes es √∫til para
transmitir el significado de ese valor a los futuros mantenedores del c√≥digo.
Tambi√©n ayuda a tener solo un lugar en su c√≥digo en el que necesitar√≠a cambiar
si el valor codificado tuviera que actualizarse en el futuro.</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>Como vio en el tutorial del juego de adivinanzas en <a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">Cap√≠tulo
2</a><!-- ignore -->, puede declarar una
nueva variable con el mismo nombre que una variable anterior. Los Rustaceans
dicen que la primera variable es <em>ocultada</em> por la segunda, lo que significa
que la segunda variable es lo que el compilador ver√° cuando use el nombre de la
variable. En efecto, la segunda variable oculta la primera, tomando
cualquier uso del nombre de la variable para s√≠ misma hasta que se haga
<em>shadowing</em> sobre la misma variable o el √°mbito finalice.
Podemos ocultar una variable usando el mismo nombre de variable y repitiendo
el uso de la palabra clave <code>let</code> de la siguiente manera:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {x}&quot;);
    }

    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<p>Este programa primero vincula a <code>x</code> el valor de <code>5</code>. Luego crea una nueva
variable <code>x</code> repitiendo <code>let x =</code>, tomando el valor original y agregando <code>1</code>
para que el valor de <code>x</code> sea entonces <code>6</code>. Luego, dentro de un √°mbito interno
creado con las llaves, la tercera declaraci√≥n <code>let</code> tambi√©n proyecta <code>x</code> y
crea una nueva variable, multiplicando el valor anterior por <code>2</code> para darle a
<code>x</code> un valor de <code>12</code>. Cuando ese √°mbito finaliza, la proyecci√≥n interna finaliza
y <code>x</code> vuelve a ser <code>6</code>. Cuando ejecutamos este programa, se mostrar√° lo
siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>El <em>Shadowing</em> es diferente de marcar una variable como <code>mut</code> porque obtendremos
un error de tiempo de compilaci√≥n si accidentalmente intentamos volver a
asignar esta variable sin usar la palabra clave <code>let</code>. Al usar <code>let</code>, podemos
realizar algunas transformaciones en un valor, pero la variable debe ser
inmutable despu√©s de que se hayan completado esas transformaciones.</p>
<p>La otra diferencia entre <code>mut</code> y el <em>shadowing</em> es que, debido a que
efectivamente estamos creando una nueva variable cuando usamos la palabra clave
<code>let</code> nuevamente, podemos cambiar el tipo de valor pero reutilizar el mismo
nombre. Por ejemplo, digamos que nuestro programa le pide al usuario que muestre
cu√°ntos espacios desea entre alg√∫n texto ingresando caracteres de espacio, y
luego queremos almacenar esa entrada como un n√∫mero:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>La primera variable <code>spaces</code> es de tipo <em>string</em> y la segunda variable <code>spaces</code>
es de tipo <em>num√©rico</em>. El <em>shadowing</em> nos ahorra tener que pensar en nombres
diferentes, como <code>spaces_str</code> y <code>spaces_num</code>; en su lugar, podemos reutilizar
el nombre m√°s simple <code>spaces</code>. Sin embargo, si intentamos usar <code>mut</code> para esto,
como se muestra aqu√≠, obtendremos un error de tiempo de compilaci√≥n:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>El error dice que no se permite mutar el tipo de una variable:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin &quot;variables&quot;) due to 1 previous error
</code></pre>
<p>Ahora que hemos explorado c√≥mo funcionan las variables, veamos m√°s tipos de
datos que pueden tener.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-de-datos"><a class="header" href="#tipos-de-datos">Tipos de datos</a></h2>
<p>Cada valor en Rust es de un cierto <em>tipo de dato</em>, que le dice a Rust qu√© tipo
de dato se est√° especificando para que sepa c√≥mo trabajar con ese dato. Veremos 
dos subconjuntos de tipos de datos: escalares y compuestos.</p>
<p>Tenga en cuenta que Rust es un lenguaje <em>est√°ticamente tipado</em>, lo que significa
que debe conocer los tipos de todas las variables en tiempo de compilaci√≥n. El
compilador generalmente puede inferir qu√© tipo queremos usar en funci√≥n del
valor y c√≥mo lo usamos. En los casos en que muchos tipos son posibles, como
cuando convertimos un <code>String</code> en un tipo num√©rico usando <code>parse</code> en la secci√≥n
<a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">‚ÄúComparando la Adivinanza con el N√∫mero Secreto‚Äù</a>
del cap√≠tulo 2, debemos agregar una anotaci√≥n de tipo, como
esta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Si no agregamos la anotaci√≥n de tipo <code>: u32</code> mostrada en el c√≥digo anterior,
Rust mostrar√° el siguiente error, lo que significa que el compilador necesita
m√°s informaci√≥n de nosotros para saber qu√© tipo queremos usar:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin &quot;no_type_annotations&quot;) due to 1 previous error
</code></pre>
<p>Ver√° diferentes anotaciones de tipo para otros tipos de datos.</p>
<h3 id="tipos-escalares"><a class="header" href="#tipos-escalares">Tipos Escalares</a></h3>
<p>Un tipo <em>escalar</em> representa un solo valor. Rust tiene cuatro tipos escalares
principales: enteros, n√∫meros de punto flotante, booleanos y caracteres. Puede
reconocerlos de otros lenguajes de programaci√≥n. Vamos a ver c√≥mo funcionan en
Rust.</p>
<h4 id="tipos-de-enteros"><a class="header" href="#tipos-de-enteros">Tipos de Enteros</a></h4>
<p>Un <em>entero</em> es un n√∫mero sin componente fraccionario. Usamos un tipo de entero
en el cap√≠tulo 2, el tipo <code>u32</code>. Esta declaraci√≥n de tipo indica que el valor
con el que est√° asociado debe ser un entero sin signo (los tipos de enteros con
signo comienzan con <code>i</code> en lugar de <code>u</code>) que ocupa 32 bits de espacio. La tabla
3-1 muestra los tipos de enteros integrados en Rust. Podemos usar cualquiera de
estas variantes para declarar el tipo de un valor entero.</p>
<p><span class="caption">Tabla 3-1: Tipos Enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Tama√±o</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Cada variante puede ser <em>signed</em> (con signo) o <em>unsigned</em> (sin signo) y tiene
un tama√±o expl√≠cito. <em>Signed</em> y <em>unsigned</em> se refieren a si es posible que el
n√∫mero sea negativo, es decir, si el n√∫mero necesita tener un signo con √©l
(signed) o si solo ser√° positivo y por lo tanto puede representarse sin signo
(unsigned). Es como escribir n√∫meros en papel: cuando el signo importa,
un n√∫mero se muestra con un signo m√°s o un signo menos; sin embargo, cuando es
seguro suponer que el n√∫mero es positivo, se muestra sin signo.
Los n√∫meros con signo se almacenan usando la
representaci√≥n de <a href="https://es.wikipedia.org/wiki/Complemento_a_dos">complemento a dos</a>.</p>
<p>Cada variante con signo puede almacenar n√∫meros de -(2<sup>n - 1</sup>)
a 2<sup>n - 1</sup> - 1, donde <em>n</em> es el n√∫mero de bits que usa la variante.
As√≠, un <code>i8</code> puede almacenar n√∫meros de -(2<sup>7</sup>) a 2<sup>7</sup> - 1,
lo que equivale a -128 a 127. Las variantes sin signo pueden almacenar n√∫meros
de 0 a 2<sup>n</sup> - 1, por lo que un <code>u8</code> puede almacenar n√∫meros de 0 a 2<sup>8</sup> - 1,
lo que equivale a 0 a 255.</p>
<p>Adem√°s, los tipos <code>isize</code> y <code>usize</code> dependen de la arquitectura de la
computadora en la que se ejecuta su programa, que se denota en la tabla como
‚Äúarch‚Äù: 64 bits si est√° en una arquitectura de 64 bits y 32 bits si est√° en una
arquitectura de 32 bits.</p>
<p>Puede escribir literales enteros en cualquiera de las formas que se muestran en
la Tabla 3-2. Tenga en cuenta que los literales num√©ricos que pueden ser
m√∫ltiples tipos num√©ricos permiten un sufijo de tipo, como <code>57u8</code>, para
designar el tipo. Los literales num√©ricos tambi√©n pueden usar <code>_</code> como un
separador visual para facilitar la lectura del n√∫mero, como <code>1_000</code>, que tendr√°
el mismo valor que si hubiera especificado <code>1000</code>.</p>
<p><span class="caption">Tabla 3-2: Literales enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Literales num√©ricos</th><th>Ejemplo</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binario</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> solamente)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Entonces, ¬øc√≥mo sabe qu√© tipo de entero usar? Si no est√° seguro, los valores
predeterminados de Rust son generalmente buenos lugares para comenzar: los
tipos enteros se configuran predeterminadamente en <code>i32</code>. La situaci√≥n
principal en la que usar√≠a <code>isize</code> o <code>usize</code> es cuando indexa alg√∫n tipo de
colecci√≥n.</p>
<blockquote>
<h5 id="desbordamiento-de-enteros"><a class="header" href="#desbordamiento-de-enteros">Desbordamiento de enteros</a></h5>
<p>Digamos que tiene una variable de tipo <code>u8</code> que puede contener valores entre 0
y 255. Si intenta cambiar la variable a un valor fuera de ese rango, como 256,
<em>se producir√° un desbordamiento de enteros</em>, que puede resultar en uno de dos
comportamientos. Cuando est√° compilando en modo de depuraci√≥n, Rust incluye
comprobaciones para el desbordamiento de enteros que hacen que su programa
<em>se desborde</em> en tiempo de ejecuci√≥n si ocurre este comportamiento.
Rust usa el t√©rmino <em>desbordamiento</em> cuando un programa sale con un error;
discutiremos los desbordamientos con m√°s profundidad en la secci√≥n <a href="ch09-01-unrecoverable-errors-with-panic.html">‚ÄúErrores
irrecuperables con <code>panic!</code>‚Äù</a><!-- ignore -->
del Cap√≠tulo 9.</p>
<p>Cuando est√° compilando en modo de lanzamiento con la bandera <code>--release</code>,
Rust <em>no</em> incluye comprobaciones para el desbordamiento de enteros que
provocan desbordamientos. En su lugar, si ocurre un desbordamiento, Rust
realiza una <em>envoltura de complemento a dos</em>. En resumen, los valores mayores que
el valor m√°ximo que el tipo puede contener ‚Äúse envuelven‚Äù al m√≠nimo de los
valores que el tipo puede contener. En el caso de un <code>u8</code>, el valor 256 se
convierte en 0, el valor 257 se convierte en 1, y as√≠ sucesivamente. El
programa no se desbordar√°, pero la variable tendr√° un valor que probablemente
no sea el que esperaba que tuviera. Depender del comportamiento de la envoltura
del desbordamiento de enteros se considera un error.</p>
<p>Para manejar expl√≠citamente la posibilidad de desbordamiento, puede usar estas
familias de m√©todos proporcionados por la biblioteca est√°ndar para tipos
num√©ricos primitivos:</p>
<ul>
<li>Envolver en todos los modos con los m√©todos <code>wrapping_*</code>, como
<code>wrapping_add</code>.</li>
<li>Devolver el valor <code>None</code> si hay desbordamiento con los m√©todos <code>checked_*</code>.</li>
<li>Devolver el valor y un booleano que indica si hubo desbordamiento con los
m√©todos <code>overflowing_*</code>.</li>
<li>Saturar en los valores m√≠nimos o m√°ximos del valor con los m√©todos
<code>saturating_*</code>.</li>
</ul>
</blockquote>
<h4 id="tipos-de-punto-flotante"><a class="header" href="#tipos-de-punto-flotante">Tipos de punto flotante</a></h4>
<p>Rust tambi√©n tiene dos tipos primitivos para <em>n√∫meros de punto flotante</em>, que
son n√∫meros con puntos decimales. Los tipos de punto flotante de Rust son <code>f32</code>
y <code>f64</code>, que tienen 32 bits y 64 bits de tama√±o, respectivamente. El tipo
predeterminado es <code>f64</code> porque en CPUs modernas, es aproximadamente la misma
velocidad que <code>f32</code> pero es capaz de m√°s precisi√≥n. Todos los tipos de punto
flotante son con signo.</p>
<p>Aqu√≠ hay un ejemplo que muestra n√∫meros de punto flotante en acci√≥n:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Los n√∫meros de punto flotante se representan de acuerdo con el est√°ndar
IEEE-754. El tipo <code>f32</code> es un punto flotante de precisi√≥n simple, y <code>f64</code> tiene
doble precisi√≥n.</p>
<h4 id="operaciones-num√©ricas"><a class="header" href="#operaciones-num√©ricas">Operaciones num√©ricas</a></h4>
<p>Rust admite las operaciones matem√°ticas b√°sicas que esperar√≠a para todos los
tipos de n√∫meros: adici√≥n, sustracci√≥n, multiplicaci√≥n, divisi√≥n y resto.
La divisi√≥n entera se trunca hacia cero al entero m√°s cercano. El siguiente
c√≥digo muestra c√≥mo usar√≠a cada operaci√≥n num√©rica en una declaraci√≥n <code>let</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<p>Cada expresi√≥n en estas instrucciones usa un operador matem√°tico y se eval√∫a a
un solo valor, que luego se vincula a una variable. El <a href="appendix-02-operators.html">Ap√©ndice
B</a> contiene una lista de todos los operadores que
Rust proporciona.</p>
<h4 id="el-tipo-booleano"><a class="header" href="#el-tipo-booleano">El tipo booleano</a></h4>
<p>Como en la mayor√≠a de los otros lenguajes de programaci√≥n, un tipo booleano en
Rust tiene dos posibles valores: <code>true</code> y <code>false</code>. Los booleanos tienen un
byte de tama√±o. El tipo booleano en Rust se especifica usando <code>bool</code>. Por
ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre></pre>
<p>La forma principal de usar valores booleanos es a trav√©s de condicionales, como
una expresi√≥n <code>if</code>. Cubriremos c√≥mo funcionan las expresiones <code>if</code> en Rust en
la secci√≥n <a href="ch03-05-control-flow.html#flujo-de-control">‚ÄúControl de flujo‚Äù</a><!-- ignore -->.</p>
<h4 id="el-tipo-de-car√°cter"><a class="header" href="#el-tipo-de-car√°cter">El tipo de car√°cter</a></h4>
<p>El tipo <code>char</code> de Rust es el tipo alfab√©tico m√°s primitivo del lenguaje. Estos son algunos ejemplos de declaraci√≥n de valores <code>char</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = '‚Ñ§'; // with explicit type annotation
    let heart_eyed_cat = 'üòª';
}</code></pre></pre>
<p>Tenga en cuenta que especificamos literales <code>char</code> con comillas simples, en
oposici√≥n a literales de cadena, que usan comillas dobles. El tipo <code>char</code> de 
Rust tiene un tama√±o de cuatro bytes y representa un valor escalar Unicode, lo 
que significa que puede representar mucho m√°s que ASCII. Letras
acentuadas; Caracteres chinos, japoneses y coreanos; Emojis; y espacios de ancho
cero son todos valores <code>char</code> v√°lidos en Rust. Los valores escalar de Unicode
van desde <code>U+0000</code> a <code>U+D7FF</code> y <code>U+E000</code> a <code>U+10FFFF</code> inclusive. Sin embargo,
un &quot;car√°cter&quot; no es realmente un concepto en Unicode, por lo que su intuici√≥n
humana sobre lo que es un &quot;car√°cter&quot; puede no coincidir con lo que es un <code>char</code>
en Rust. Discutiremos este tema en detalle en <a href="ch08-02-strings.html#almacenando-texto-codificado-en-utf-8-con-strings">‚ÄúAlmacenar texto codificado en
UTF-8 con cadenas‚Äù</a><!-- ignore --> en el cap√≠tulo 8.</p>
<h3 id="tipos-compuestos"><a class="header" href="#tipos-compuestos">Tipos compuestos</a></h3>
<p><em>Tipos compuestos</em> pueden agrupar m√∫ltiples valores en un solo tipo. Rust
tiene dos tipos compuestos primitivos: tuplas y arreglos.</p>
<h4 id="el-tipo-tupla"><a class="header" href="#el-tipo-tupla">El Tipo Tupla</a></h4>
<p>Una <em>tupla</em> es una forma general de agrupar varios valores de distintos tipos en 
un tipo compuesto. Las tuplas tienen una longitud fija: una vez declaradas, su 
tama√±o no puede aumentar ni disminuir.</p>
<p>Creamos una tupla escribiendo una lista de valores separados por comas dentro de
par√©ntesis. Cada posici√≥n de la tupla tiene un tipo, y los tipos de los 
distintos valores de la tupla no tienen por qu√© ser iguales. En este ejemplo 
hemos a√±adido anotaciones de tipo opcionales:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>La variable <code>tup</code> se vincula a toda la tupla porque una tupla se considera un 
√∫nico elemento compuesto. Para obtener los valores individuales de una tupla, 
podemos utilizar la concordancia de patrones para desestructurar un valor de 
tupla, as√≠:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {y}&quot;);
}</code></pre></pre>
<p>Este programa primero crea una tupla y la vincula a la variable <code>tup</code>. Luego
usa un patr√≥n con <code>let</code> para tomar <code>tup</code> y convertirla en tres variables
separadas, <code>x</code>, <code>y</code> y <code>z</code>. Esto se llama <em>desestructuraci√≥n</em> porque rompe la
√∫nica tupla en tres partes. Finalmente, el programa imprime el valor de <code>y</code>,
que es <code>6.4</code>.</p>
<p>Tambi√©n podemos acceder directamente a un elemento de la tupla usando un punto
(<code>.</code>) seguido del √≠ndice del valor que queremos acceder. Por ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>Este programa crea la tupla <code>x</code> y luego accede a cada elemento de la tupla
usando sus respectivos √≠ndices. Al igual que la mayor√≠a de los lenguajes de
programaci√≥n, el primer √≠ndice en una tupla es 0.</p>
<p>La tupla sin ning√∫n valor tiene un nombre especial, <em>unit</em>. Este valor y su
tipo correspondiente est√°n escritos ambos como <code>()</code> y representan un valor
vac√≠o o un tipo de retorno vac√≠o. Las expresiones devuelven impl√≠citamente el
valor unit si no devuelven ning√∫n otro valor.</p>
<h4 id="el-tipo-arreglo"><a class="header" href="#el-tipo-arreglo">El Tipo Arreglo</a></h4>
<p>Otra forma de tener una colecci√≥n de m√∫ltiples valores es con un <em>arreglo</em>.
A diferencia de una tupla, cada elemento de un arreglo debe tener el mismo
tipo. A diferencia de los arreglos en algunos otros lenguajes, los arreglos en
Rust tienen una longitud fija.</p>
<p>Escribimos los valores en un arreglo como una lista separada por comas dentro
de corchetes:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Los arreglos son √∫tiles cuando desea que sus datos se asignen en el stack (pila)
en lugar del heap (mont√≠culo) (hablaremos m√°s sobre el stack y el heap en el
<a href="ch04-01-what-is-ownership.html#el-stack-y-el-heap">Cap√≠tulo 4</a><!-- ignore -->) o cuando desea asegurarse de que
siempre tenga un n√∫mero fijo de elementos. Sin embargo, un arreglo no es tan
flexible como el tipo vector. Un <em>vector</em> es un tipo de colecci√≥n similar
proporcionado por la biblioteca est√°ndar que <em>puede</em> crecer o reducir su tama√±o.
Si no est√° seguro de si debe usar un arreglo o un vector, es probable que deba
usar un vector. El <a href="ch08-01-vectors.html">Cap√≠tulo 8</a><!-- ignore --> discute los vectores en
m√°s detalle.</p>
<p>Sin embargo, los arreglos son m√°s √∫tiles cuando sabe que el n√∫mero de elementos
no cambiar√°. Por ejemplo, si est√° utilizando los nombres del mes en un
programa, probablemente usar√≠a un arreglo en lugar de un vector porque sabe que
siempre contendr√° 12 elementos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}</span></code></pre></pre>
<p>Escribe el tipo de un arreglo usando corchetes con el tipo de cada elemento,
un punto y coma y luego el n√∫mero de elementos en el arreglo, as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Aqu√≠, <code>i32</code> es el tipo de cada elemento. Despu√©s del punto y coma, el n√∫mero
<code>5</code> indica que el arreglo contiene cinco elementos.</p>
<p>Tambi√©n puede inicializar un arreglo para contener el mismo valor para cada
elemento especificando el valor inicial, seguido de un punto y coma y luego la
longitud del arreglo en corchetes, como se muestra aqu√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>El arreglo llamado <code>a</code> contendr√° <code>5</code> elementos que inicialmente se establecer√°n
en el valor <code>3</code>. Esto es lo mismo que escribir <code>let a = [3, 3, 3, 3, 3];</code> pero
de una manera m√°s concisa.</p>
<h5 id="accediendo-a-los-elementos-del-arreglo"><a class="header" href="#accediendo-a-los-elementos-del-arreglo">Accediendo a los Elementos del Arreglo</a></h5>
<p>Un arreglo es un trozo de memoria de tama√±o fijo y conocido que puede asignarse 
a la pila. Se puede acceder a los elementos de una arreglo utilizando la 
indexaci√≥n, de la siguiente manera:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>En este ejemplo, la variable llamada <code>first</code> obtendr√° el valor <code>1</code> porque ese
es el valor en el √≠ndice <code>[0]</code> en el arreglo. La variable llamada <code>second</code>
obtendr√° el valor <code>2</code> del √≠ndice <code>[1]</code> en el arreglo.</p>
<h5 id="acceso-inv√°lido-a-los-elementos-del-arreglo"><a class="header" href="#acceso-inv√°lido-a-los-elementos-del-arreglo">Acceso Inv√°lido a los Elementos del Arreglo</a></h5>
<p>Veamos qu√© sucede si intenta acceder a un elemento de un arreglo que est√° m√°s
all√° del final del arreglo. Digamos que ejecuta este c√≥digo, similar al juego
de adivinanzas del Cap√≠tulo 2, para obtener un √≠ndice de arreglo del usuario:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(&quot;The value of the element at index {index} is: {element}&quot;);
}</code></pre>
<p>Este c√≥digo se compila con √©xito. Si ejecuta este c√≥digo usando <code>cargo run</code> y
ingresa <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> o <code>4</code>, el programa imprimir√° el valor
correspondiente en ese √≠ndice en el arreglo. Si en cambio ingresa un n√∫mero
m√°s all√° del final del arreglo, como <code>10</code>, ver√° una salida como esta:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>El programa dio lugar a un <em>error en tiempo de ejecuci√≥n</em> al momento de utilizar 
un valor no v√°lido en la operaci√≥n de indexaci√≥n. El programa sali√≥ con un 
mensaje de error y no ejecut√≥ la sentencia final <code>println!</code>. Cuando intentas 
acceder a un elemento utilizando la indexaci√≥n, Rust comprobar√° que el √≠ndice 
que has especificado es menor que la longitud del array. Si el √≠ndice es mayor o 
igual que la longitud, Rust entrar√° en p√°nico. Esta comprobaci√≥n tiene que 
ocurrir en tiempo de ejecuci√≥n, especialmente en este caso, porque el compilador 
no puede saber qu√© valor introducir√° el usuario cuando ejecute el c√≥digo m√°s 
tarde.</p>
<p>Este es un ejemplo de los principios de seguridad de memoria de Rust en acci√≥n. 
En muchos lenguajes de bajo nivel, este tipo de comprobaci√≥n no se hace, y 
cuando proporcionas un √≠ndice incorrecto, se puede acceder a memoria inv√°lida. 
Rust te protege contra este tipo de error saliendo inmediatamente en lugar de 
permitir el acceso a la memoria y continuar. El Cap√≠tulo 9 discute m√°s sobre el 
manejo de errores de Rust y c√≥mo puedes escribir c√≥digo legible y seguro que no 
entre en p√°nico ni permita el acceso a memoria inv√°lida.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funciones"><a class="header" href="#funciones">Funciones</a></h2>
<p>Las Funciones son muy comunes en el c√≥digo Rust. Ya has visto una de las
funciones m√°s importantes del lenguaje: la funci√≥n <code>main</code>, que es el punto de
entrada de muchos programas. Tambi√©n has visto la palabra clave <code>fn</code>, que te
permite declarar nuevas funciones.</p>
<p>El c√≥digo en Rust usa <em>snake case</em> como estilo convencional para los nombres
de funciones y variables, en el que todas las letras son min√∫sculas y los
guiones bajos separan las palabras. Aqu√≠ hay un programa que contiene un
ejemplo de definici√≥n de una funci√≥n:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}</code></pre></pre>
<p>Definimos una funci√≥n en Rust escribiendo <code>fn</code> seguido del nombre de la funci√≥n
y un conjunto de par√©ntesis. Las llaves indican al compilador donde comienza y
termina el cuerpo de la funci√≥n.</p>
<p>Podemos llamar a cualquier funci√≥n que hayamos definido escribiendo su nombre
seguido de un conjunto de par√©ntesis. Como <code>another_function</code> est√° definida en
el programa, se puede llamar desde dentro de la funci√≥n <code>main</code>. Ten en cuenta
que definimos <code>another_function</code> <em>despu√©s</em> de la funci√≥n <code>main</code> en el c√≥digo
fuente; tambi√©n podr√≠amos haberla definido antes. A Rust no le importa d√≥nde
definas tus funciones, s√≥lo que est√©n definidas en alg√∫n lugar en un √°mbito que
pueda ser visto por el invocador.</p>
<p>Empecemos un nuevo proyecto binario llamado <em>functions</em> para explorar las
funciones m√°s a fondo. Coloca el ejemplo de <code>another_function</code> en
<em>src/main.rs</em> y ejec√∫talo. Deber√≠as ver la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>Las l√≠neas se ejecutan en el orden en que aparecen en la funci√≥n <code>main</code>. Primero
se imprime el mensaje ‚ÄúHello, world!‚Äù, y luego se llama a <code>another_function</code> y
se imprime su mensaje.</p>
<h3 id="par√°metros"><a class="header" href="#par√°metros">Par√°metros</a></h3>
<p>Podemos definir funciones para que tengan <em>par√°metros</em>, que son variables
especiales que forman parte de la firma de una funci√≥n. Cuando una funci√≥n
tiene par√°metros, puedes proporcionarle valores concretos para esos
par√°metros. T√©cnicamente, los valores concretos se llaman <em>argumentos</em>, pero coloquialmente,
la gente tiende a usar las palabras <em>par√°metro</em> y
<em>argumento</em> indistintamente para las variables en la definici√≥n de una funci√≥n
o los valores concretos que se pasan cuando llamas a una funci√≥n.</p>
<p>En esta versi√≥n de <code>another_function</code> agregamos un par√°metro:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<p>Intenta ejecutar este programa; deber√≠as obtener la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>La declaraci√≥n de <code>another_function</code> tiene un par√°metro llamado <code>x</code>. El tipo de
<code>x</code> se especifica como <code>i32</code>. Cuando pasamos <code>5</code> a <code>another_function</code>, la
macro <code>println!</code> pone <code>5</code> donde estaba el par de llaves que conten√≠a <code>x</code> en la
cadena de formato.</p>
<p>En las firmas de las funciones, <em>debes</em> declarar el tipo de cada par√°metro. Esta
es una decisi√≥n deliberada en el dise√±o de Rust: requerir anotaciones de tipo en
las definiciones de las funciones significa que el compilador casi nunca necesita
que las uses en otro lugar del c√≥digo para averiguar a qu√© tipo te refieres. El
compilador tambi√©n puede dar mensajes de error m√°s √∫tiles si sabe qu√© tipos espera la funci√≥n.</p>
<p>Al definir m√∫ltiples par√°metros, separa las declaraciones de par√°metros con
comas, como esto:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;The measurement is: {value}{unit_label}&quot;);
}</code></pre></pre>
<p>Este ejemplo crea una funci√≥n llamada <code>print_labeled_measurement</code> con dos
par√°metros. El primer par√°metro se llama <code>value</code> y es un <code>i32</code>. El segundo par√°metro se
llama <code>unit_label</code> y es de tipo <code>char</code>. Luego, la funci√≥n imprime texto que
contiene tanto el <code>value</code> como el <code>unit_label</code>.</p>
<p>Intentemos ejecutar este c√≥digo. Reemplaza el programa actual en tu
proyecto <em>functions</em> en el archivo <em>src/main.rs</em> con el ejemplo anterior y
ejec√∫talo usando <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p>Como hemos llamamos a la funci√≥n con <code>5</code> como valor para <code>value</code> y <code>'h'</code> como
valor para <code>unit_label</code>, la salida del programa contiene esos valores.</p>
<h3 id="sentencias-y-expresiones"><a class="header" href="#sentencias-y-expresiones">Sentencias y Expresiones</a></h3>
<p>Los cuerpos de las funciones est√°n compuestos por una serie de sentencias
opcionalmente terminadas en una expresi√≥n. Hasta ahora, las funciones que hemos
visto no incluyen una expresi√≥n final, pero has visto una expresi√≥n como parte
de una sentencia. Debido a que Rust es un lenguaje basado en expresiones, esta
es una distinci√≥n importante de entender. Otros lenguajes no tienen las mismas
distinciones, as√≠ que veamos qu√© son las sentencias y las expresiones y c√≥mo
sus diferencias afectan a los cuerpos de las funciones.</p>
<ul>
<li><strong>Sentencias</strong> son instrucciones que realizan alguna acci√≥n y no devuelven un
valor.</li>
<li><strong>Expresiones</strong> eval√∫an a un valor resultante. Veamos algunos ejemplos.</li>
</ul>
<p>Hemos usado realmente sentencias y expresiones. Crear una variable y asignarle
un valor con la palabra clave <code>let</code> es una sentencia. En el Listado 3-1,
<code>let y = 6;</code> es una sentencia.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}</code></pre></pre>
<p><span class="caption">Listado 3-1: Una declaraci√≥n de la funci√≥n <code>main</code> que contiene una sentencia</span></p>
<p>Las definiciones de las funciones tambi√©n son sentencias; todo el ejemplo
anterior es una sentencia en s√≠ misma.</p>
<p>Las sentencias no devuelven valores. Por lo tanto, no puedes asignar una
sentencia <code>let</code> a otra variable, como intenta hacer el siguiente c√≥digo;
obtendr√°s un error:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>Cuando ejecutes este programa, el error que obtendr√°s se ver√° as√≠:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error; 1 warning emitted
</code></pre>
<p>La sentencia <code>let y = 6</code> no devuelve un valor, por lo que no hay nada a lo
que <code>x</code> se pueda vincular. Esto es diferente a lo que ocurre en otros lenguajes,
como C y Ruby, donde la asignaci√≥n devuelve el valor de la asignaci√≥n. En esos
lenguajes, puedes escribir <code>x = y = 6</code> y hacer que tanto <code>x</code> como <code>y</code> tengan el valor <code>6</code>;
eso no es el caso en Rust.</p>
<p>Las expresiones eval√∫an a un valor y componen la mayor parte del resto del
c√≥digo que escribir√°s en Rust. Considera una operaci√≥n matem√°tica, como <code>5 + 6</code>,
que es una expresi√≥n que eval√∫a al valor <code>11</code>. Las expresiones pueden ser parte
de las sentencias: en el Listado 3-1, el <code>6</code> en la sentencia <code>let y = 6;</code> es
una expresi√≥n que eval√∫a al valor <code>6</code>. Llamar a una funci√≥n es una expresi√≥n.
Llamar a una macro es una expresi√≥n. Un nuevo bloque de √°mbito creado con
llaves es una expresi√≥n, por ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {y}&quot;);
}</code></pre></pre>
<p>Esta expresi√≥n:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>es un bloque que, en este caso, eval√∫a a <code>4</code>. Ese valor se enlaza a <code>y</code> como
parte de la sentencia <code>let</code>. Ten en cuenta que la l√≠nea <code>x + 1</code> no tiene un
punto y coma al final, lo que es diferente a la mayor√≠a de las l√≠neas que has
visto hasta ahora. Las expresiones no incluyen punto y coma al final. Si
agregas un punto y coma al final de una expresi√≥n, la conviertes en una
sentencia, y entonces no devolver√° un valor. Ten esto en cuenta a medida que
exploras los valores de retorno de las funciones y las expresiones a continuaci√≥n.</p>
<h3 id="funciones-con-valores-de-retorno"><a class="header" href="#funciones-con-valores-de-retorno">Funciones con valores de retorno</a></h3>
<p>Las funciones pueden devolver valores al c√≥digo que las llama. No nombramos los
valores de retorno, pero debemos declarar su tipo despu√©s de una flecha (<code>-&gt;</code>).
En Rust, el valor de retorno de la funci√≥n es sin√≥nimo del valor de la √∫ltima
expresi√≥n en el bloque del cuerpo de una funci√≥n. Puedes devolver un valor antes de que la funci√≥n finalice utilizando la palabra clave<code>return</code> y especificando un valor, pero la
mayor√≠a de las funciones devuelven la √∫ltima expresi√≥n impl√≠citamente. Aqu√≠
hay un ejemplo de una funci√≥n que devuelve un valor:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<p>No hay llamadas a funciones, macros, ni siquiera sentencias <code>let</code> en la funci√≥n
<code>five</code> - solo el n√∫mero <code>5</code> por s√≠ solo. Esa es una funci√≥n perfectamente
v√°lida en Rust. Ten en cuenta que tambi√©n se especifica el tipo de retorno de
la funci√≥n, como <code>-&gt; i32</code>. Intenta ejecutar este c√≥digo; la salida deber√≠a
verse as√≠:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>El <code>5</code> en <code>five</code> es el valor de retorno de la funci√≥n, por eso el tipo de
retorno es <code>i32</code>. Veamos esto con m√°s detalle. Hay dos partes importantes:
primero, la l√≠nea <code>let x = five();</code> muestra que estamos usando el valor de
retorno de una funci√≥n para inicializar una variable. Debido a que la funci√≥n
<code>five</code> devuelve un <code>5</code>, esa l√≠nea es la misma que la siguiente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Segundo, la funci√≥n <code>five</code> no tiene par√°metros y define el tipo del valor de
retorno, pero el cuerpo de la funci√≥n es un solitario <code>5</code> sin punto y coma
porque es una expresi√≥n cuyo valor queremos devolver.</p>
<p>Veamos otro ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>La ejecuci√≥n de este c√≥digo imprimir√° <code>The value of x is: 6</code>. Pero si colocamos
un punto y coma al final de la l√≠nea que contiene <code>x + 1</code>, cambi√°ndolo de una
expresi√≥n a una sentencia, obtendremos un error:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>La compilaci√≥n de este c√≥digo produce un error, como sigue:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error
</code></pre>
<p>El mensaje de error principal, <code>mismatched types</code>, revela el problema principal
con este c√≥digo. La definici√≥n de la funci√≥n <code>plus_one</code> dice que devolver√° un
<code>i32</code>, pero las sentencias no eval√∫an un valor, lo que se expresa por <code>()</code>, el
tipo unitario. Por lo tanto, no se devuelve nada, lo que contradice la
definici√≥n de la funci√≥n y da como resultado un error. En esta salida, Rust
proporciona un mensaje para posiblemente ayudar a corregir este problema:
sugiere eliminar el punto y coma, lo que arreglar√≠a el error.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h2>
<p>Todos los programadores se esfuerzan por hacer que su c√≥digo sea f√°cil de
entender, pero a veces se requiere una explicaci√≥n adicional. En estos casos,
los programadores dejan <em>comentarios</em> en su c√≥digo fuente que el compilador
ignorar√° pero que las personas que lean el c√≥digo fuente pueden encontrar
√∫tiles.</p>
<p>Aqu√≠ hay un comentario simple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hola, mundo
<span class="boring">}</span></code></pre></pre>
<p>En Rust, el estilo de comentario idiom√°tico comienza un comentario con dos
barras inclinadas y el comentario contin√∫a hasta el final de la l√≠nea. Para
comentarios que se extienden m√°s all√° de una sola l√≠nea, deber√° incluir <code>//</code> en
cada l√≠nea, as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// As√≠ que estamos haciendo algo complicado aqu√≠, lo suficientemente largo
// como para necesitar varias l√≠neas de comentarios para hacerlo. ¬°Uf!
// ¬°Espero que este comentario explique lo que est√° sucediendo!
<span class="boring">}</span></code></pre></pre>
<p>Los comentarios tambi√©n se pueden colocar al final de las l√≠neas que contienen
c√≥digo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero_de_la_suerte = 7; // Me siento afortunado hoy
}</code></pre></pre>
<p>Pero m√°s a menudo ver√°s que se usan en este formato, con el comentario en una
l√≠nea separada por encima del c√≥digo que est√° anotando:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Me siento afortunado hoy
    let numero_de_la_suerte = 7;
}</code></pre></pre>
<p>Rust tambi√©n tiene otro tipo de comentario, comentarios de documentaci√≥n, que
discutiremos en la secci√≥n 
<a href="ch14-02-publishing-to-crates-io.html">‚ÄúPublicando una Caja en Crates.io‚Äù</a><!-- ignore --> del Cap√≠tulo 14.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flujo-de-control"><a class="header" href="#flujo-de-control">Flujo de Control</a></h2>
<p>La capacidad de ejecutar alg√∫n c√≥digo dependiendo de si una condici√≥n es <code>true</code>
y ejecutar alg√∫n c√≥digo repetidamente mientras una condici√≥n es <code>true</code> son
elementos b√°sicos en la mayor√≠a de los lenguajes de programaci√≥n.
Las construcciones m√°s comunes que le permiten controlar el flujo de ejecuci√≥n
del c√≥digo Rust son las expresiones <code>if</code> y los bucles.</p>
<h3 id="expresiones-if"><a class="header" href="#expresiones-if">Expresiones <code>if</code></a></h3>
<p>Una expresi√≥n <code>if</code> le permite dividir su c√≥digo seg√∫n las condiciones.
Proporciona una condici√≥n y luego dice: ‚ÄúSi se cumple esta condici√≥n, ejecute
este bloque de c√≥digo. Si la condici√≥n no se cumple, no ejecute este bloque de
c√≥digo.‚Äù</p>
<p>Cree un nuevo proyecto llamado <em>branches</em> en su directorio <em>projects</em> para
explorar la expresi√≥n <code>if</code>. En el archivo <em>src/main.rs</em>, ingrese lo siguiente:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}</code></pre></pre>
<p>Todas las expresiones <code>if</code> comienzan con la palabra clave <code>if</code>, seguida de una
condici√≥n. En este caso, la condici√≥n comprueba si la variable <code>number</code> tiene un
valor menor que 5. Colocamos el bloque de c√≥digo para ejecutar si la condici√≥n
es <code>true</code> inmediatamente despu√©s de la condici√≥n dentro de llaves. Los bloques
de c√≥digo asociados con las condiciones en las expresiones <code>if</code> a veces se
llaman <em>brazos</em>, al igual que los brazos en las expresiones <code>match</code> que
discutimos en la secci√≥n
<a href="ch02-00-guessing-game-tutorial.html#comparando-la-adivinanza-con-el-numero-secreto">‚ÄúComparando la Adivinanza
con el N√∫mero Secreto‚Äù</a><!--ignore -->
del Cap√≠tulo 2.</p>
<p>Opcionalmente, tambi√©n podemos incluir una expresi√≥n <code>else</code>, que elegimos
hacer aqu√≠, para dar al programa un bloque de c√≥digo alternativo para ejecutar
si la condici√≥n evaluada es <code>false</code>. Si no proporciona una expresi√≥n <code>else</code>
y la condici√≥n es <code>false</code>, el programa va a ignorar el bloque <code>if</code> y continuar√°
con el siguiente fragmento de c√≥digo.</p>
<p>Intente ejecutar este c√≥digo; Deber√≠a ver la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Vamos a intentar cambiar el valor de <code>number</code> a un valor que haga que la
condici√≥n sea <code>false</code> para ver qu√© sucede:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;condition was true&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;condition was false&quot;);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ejecute el programa nuevamente y observe la salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>Tambi√©n vale la pena se√±alar que la condici√≥n en este c√≥digo <em>debe</em> ser un
<code>bool</code>. Si la condici√≥n no es un <code>bool</code>, obtendremos un error. Por ejemplo,
intente ejecutar el siguiente c√≥digo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}</code></pre>
<p>La condici√≥n <code>if</code> se eval√∫a como un valor de <code>3</code> esta vez, y Rust arroja un
error:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin &quot;branches&quot;) due to 1 previous error
</code></pre>
<p>El error indica que Rust esperaba un <code>bool</code> pero obtuvo un entero. A diferencia
de los lenguajes como Ruby y JavaScript, Rust no intentar√° convertir
autom√°ticamente los tipos no booleanos en un booleano. Debes ser expl√≠cito y
siempre proporcionar a <code>if</code> un booleano como su condici√≥n. Si queremos que el
bloque de c√≥digo <code>if</code> se ejecute solo cuando un n√∫mero no sea igual a <code>0</code>, por
ejemplo, podemos cambiar la expresi√≥n <code>if</code> a lo siguiente:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}</code></pre></pre>
<p>Ejecutando este c√≥digo imprimir√° <code>number was something other than zero</code>.</p>
<h4 id="manejo-de-m√∫ltiples-condiciones-con-else-if"><a class="header" href="#manejo-de-m√∫ltiples-condiciones-con-else-if">Manejo de m√∫ltiples condiciones con <code>else if</code></a></h4>
<p>Puede usar m√∫ltiples condiciones combinando <code>if</code> y <code>else</code> en una expresi√≥n
<code>else if</code>. Por ejemplo:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}</code></pre></pre>
<p>Este programa tiene cuatro posibles caminos que puede tomar. Despu√©s de
ejecutarlo, deber√≠a ver la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>Cuando se ejecuta este programa, verifica cada expresi√≥n <code>if</code> en orden y
ejecuta el primer cuerpo para el cual la condici√≥n se eval√∫a como <code>true</code>. Tenga
en cuenta que incluso si 6 es divisible por 2, no vemos la salida <code>number is divisible by 2</code>, ni vemos el texto <code>number is not divisible by 4, 3, or 2</code> del
bloque <code>else</code>. Esto se debe a que Rust solo ejecuta el bloque para la primera
condici√≥n <code>true</code>, y una vez que encuentra una, ni siquiera verifica el resto.</p>
<p>El uso de demasiadas expresiones <code>else if</code> puede ensuciar su c√≥digo, por lo que
si tiene m√°s de una, es posible que desee refactorizar su c√≥digo. El cap√≠tulo 6
describe una poderosa construcci√≥n de ramificaci√≥n de Rust llamada <code>match</code> para
estos casos.</p>
<h4 id="usando-if-en-una-declaraci√≥n-let"><a class="header" href="#usando-if-en-una-declaraci√≥n-let">Usando <code>if</code> en una declaraci√≥n <code>let</code></a></h4>
<p>Dado que <code>if</code> es una expresi√≥n, podemos usarlo en el lado derecho de una
declaraci√≥n <code>let</code> para asignar el resultado a una variable, como en el Listado
3-2.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {number}&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 3-2: Asignando el resultado de una expresi√≥n
<code>if</code> a una variable</span></p>
<p>La variable <code>number</code> estar√° vinculada a un valor basado en el resultado de la
expresi√≥n <code>if</code>. Ejecute este c√≥digo para ver qu√© sucede:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Recuerde que los bloques de c√≥digo se eval√∫an en la √∫ltima expresi√≥n de ellos y
los n√∫meros por s√≠ mismos tambi√©n son expresiones. En este caso, el valor de
la expresi√≥n <code>if</code> en su conjunto depende de qu√© bloque de c√≥digo se ejecuta.
Esto significa que los valores que tienen el potencial de ser resultados de cada
rama del <code>if</code> deben ser del mismo tipo; en el Listado 3-2, los resultados de
ambas ramas del <code>if</code> y la rama <code>else</code> fueron enteros <code>i32</code>. Si los tipos no
coinciden, como en el siguiente ejemplo, obtendremos un error:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;The value of number is: {number}&quot;);
}</code></pre>
<p>Cuando intentamos compilar este c√≥digo, obtendremos un error. Las ramas <code>if</code> y
<code>else</code> tienen tipos de valor que son incompatibles, y Rust indica exactamente
d√≥nde encontrar el problema en el programa:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin &quot;branches&quot;) due to 1 previous error
</code></pre>
<p>La expresi√≥n en el bloque <code>if</code> se eval√∫a como un entero, y la expresi√≥n en el
bloque <code>else</code> se eval√∫a como una cadena. Esto no funcionar√° porque las
variables deben tener un solo tipo, y Rust necesita saber en tiempo de
compilaci√≥n qu√© tipo tiene la variable <code>number</code>, definitivamente. Conocer el
tipo de <code>number</code> permite al compilador verificar que el tipo sea v√°lido en
cualquier lugar que usemos <code>number</code>. Rust no podr√≠a hacerlo si el tipo de
<code>number</code> solo se determinara en tiempo de ejecuci√≥n; el compilador ser√≠a m√°s
complejo y har√≠a menos garant√≠as sobre el c√≥digo si tuviera que rastrear
diversos tipos hipot√©ticos para cualquier variable.</p>
<h3 id="repetici√≥n-con-bucles"><a class="header" href="#repetici√≥n-con-bucles">Repetici√≥n con bucles</a></h3>
<p>A menudo es √∫til ejecutar un bloque de c√≥digo m√°s de una vez. Para esta tarea,
Rust proporciona varios <em>bucles</em>, que ejecutar√°n el c√≥digo dentro del cuerpo del
bucle hasta el final y luego comenzar√°n de inmediato desde el principio. Para
experimentar con los bucles, hagamos un nuevo proyecto llamado <em>loops</em>.</p>
<p>Rust tiene tres tipos de bucles: <code>loop</code>, <code>while</code> y <code>for</code>. Vamos a probar cada
uno.</p>
<h4 id="repetir-c√≥digo-con-loop"><a class="header" href="#repetir-c√≥digo-con-loop">Repetir c√≥digo con <code>loop</code></a></h4>
<p>La palabra clave <code>loop</code> le dice a Rust que ejecute un bloque de c√≥digo una y
otra vez para siempre o hasta que le indique expl√≠citamente que se detenga.</p>
<p>Como ejemplo, cambie el archivo <em>src/main.rs</em> en su directorio <em>loops</em> para
que se vea as√≠:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}</code></pre>
<p>Cuando ejecutemos este programa, veremos <code>again!</code> impreso una y otra vez
continuamente hasta que detengamos manualmente el programa. La mayor√≠a de los
terminales admiten el atajo de teclado <span class="keystroke">ctrl-c</span>
para interrumpir un programa que est√° atascado en un bucle continuo.
Int√©ntelo:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>El s√≠mbolo <code>^C</code> representa d√≥nde presion√≥ <span
class="keystroke">ctrl-c</span>. Puede que vea o no la palabra <code>again!</code>
impresa despu√©s del <code>^C</code>, dependiendo de d√≥nde estaba el c√≥digo en el bucle
cuando recibi√≥ la se√±al de interrupci√≥n.</p>
<p>Afortunadamente, Rust tambi√©n proporciona una forma de salir de un bucle
utilizando c√≥digo. Puede colocar la palabra clave <code>break</code> dentro del bucle para
decirle al programa cu√°ndo dejar de ejecutar el bucle. Recuerde que hicimos
esto en el juego de adivinanzas en la secci√≥n <a href="ch02-00-guessing-game-tutorial.html#salir-despues-de-una-adivinanza-correcta">‚ÄúSalir despu√©s de una
adivinanza correcta‚Äù</a><!-- ignore --> del
cap√≠tulo 2 para salir del programa cuando el usuario gan√≥ el juego adivinando
el n√∫mero correcto.</p>
<p>Tambi√©n usamos <code>continue</code> en el juego de adivinanzas, que en un bucle le dice
al programa que omita cualquier c√≥digo restante en esta iteraci√≥n del bucle y
pase a la siguiente iteraci√≥n.</p>
<h4 id="devolviendo-valores-de-los-bucles"><a class="header" href="#devolviendo-valores-de-los-bucles">Devolviendo valores de los bucles</a></h4>
<p>Una de las aplicaciones de un <code>loop</code> es volver a intentar una operaci√≥n que
sabe que puede fallar, como verificar si un hilo ha completado su trabajo. Es
posible que tambi√©n necesite pasar el resultado de esa operaci√≥n fuera del
bucle al resto de su c√≥digo. Para hacer esto, puede agregar el valor que desea
devolver despu√©s de la expresi√≥n <code>break</code> que usa para detener el bucle; ese
valor se devolver√° fuera del bucle para que pueda usarlo, como se muestra aqu√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {result}&quot;);
}</code></pre></pre>
<p>Antes del bucle, declaramos una variable llamada <code>counter</code> e inicializamos en
<code>0</code>. Luego declaramos una variable llamada <code>result</code> para contener el valor
devuelto del bucle. En cada iteraci√≥n del bucle, agregamos <code>1</code> a la variable
<code>counter</code>, y luego verificamos si el <code>counter</code> es igual a <code>10</code>. Cuando lo es,
usamos la palabra clave <code>break</code> con el valor <code>counter * 2</code>. Despu√©s del bucle,
usamos un punto y coma para terminar la instrucci√≥n que asigna el valor a
<code>result</code>. Finalmente, imprimimos el valor en <code>result</code>, que en este caso es
<code>20</code>.</p>
<p>Tu puedes tambi√©n usar <code>return</code> dentro de un loop. Mientras <code>break</code> solo existe
para el loop actual, <code>return</code> siempre existe para la funci√≥n actual.</p>
<h4 id="etiquetas-de-bucle-para-distinguir-entre-varios-bucles"><a class="header" href="#etiquetas-de-bucle-para-distinguir-entre-varios-bucles">Etiquetas de bucle para distinguir entre varios bucles</a></h4>
<p>Si tiene bucles dentro de bucles, <code>break</code> y <code>continue</code> se aplican al bucle m√°s
interior en ese punto. Opcionalmente, puede especificar una <em>etiqueta de bucle</em>
en un bucle que luego puede usar con <code>break</code> o <code>continue</code> para especificar que
esas palabras clave se aplican al bucle etiquetado en lugar del bucle m√°s
interior. Las etiquetas de bucle deben comenzar con una comilla simple. Aqu√≠
hay un ejemplo con dos bucles anidados:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
}</code></pre></pre>
<p>El bucle externo tiene la etiqueta <code>'counting_up</code>, y contar√° de 0 a 2. El bucle
interior sin etiqueta cuenta de 10 a 9. El primer <code>break</code> que no especifique
una etiqueta solo saldr√° del bucle interno. La instrucci√≥n <code>break 'counting_up;</code> saldr√° del bucle externo. Este c√≥digo imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="bucles-condicionales-con-while"><a class="header" href="#bucles-condicionales-con-while">Bucles condicionales con <code>while</code></a></h4>
<p>Un programa a menudo necesitar√° evaluar una condici√≥n dentro de un bucle.
Mientras la condici√≥n sea <code>true</code>, el bucle se ejecuta. Cuando la condici√≥n deja
de ser <code>true</code>, el programa llama a <code>break</code>, deteniendo el bucle. Es posible
implementar un comportamiento como este usando una combinaci√≥n de <code>loop</code>, <code>if</code>,
<code>else</code> y <code>break</code>; puede intentarlo ahora en un programa, si lo desea. Sin
embargo, este patr√≥n es tan com√∫n que Rust tiene una construcci√≥n de lenguaje
integrada para ello, llamada <code>while</code> loop. En el Listado 3-3, usamos <code>while</code>
para ejecutar el programa tres veces, contando hacia atr√°s cada vez, y luego,
despu√©s del bucle, imprimir un mensaje y salir.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{number}!&quot;);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 3-3: Usando un bucle <code>while</code> para ejecutar c√≥digo
mientras una condici√≥n es verdadera</span></p>
<p>Esta expresion elimina mucho anidamiento que ser√≠a necesario si usara <code>loop</code>,
<code>if</code>, <code>else</code> y <code>break</code>, y es m√°s claro. Mientras una condici√≥n se eval√∫a como
<code>true</code>, el c√≥digo se ejecuta; de lo contrario, sale del bucle.</p>
<p><a id="bucle-a-traves-de-una-coleccion-con-for"></a></p>
<h4 id="bucle-a-traves-de-una-colecci√≥n-con-for"><a class="header" href="#bucle-a-traves-de-una-colecci√≥n-con-for">Bucle a traves de una colecci√≥n con <code>for</code></a></h4>
<p>Tu puedes tambi√©n puedes usar el <code>while</code> para recorrer los elementos de una 
colecci√≥n, justo como un arreglo. Por ejemplo, el bucle en el Listado 3-4
muestra cada elemento en el arreglo <code>a</code>.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index += 1;
    }
}</code></pre></pre>
<p><span class="caption">Listado 3-4: Bucle a trav√©s de cada elemento de una
colecci√≥n usando un bucle <code>while</code></span></p>
<p>Aqu√≠, el c√≥digo cuenta hacia arriba a trav√©s de los elementos en el arreglo. Se
inicia en el √≠ndice <code>0</code>, y luego se ejecuta hasta que alcanza el √≠ndice final
en el arreglo (es decir, cuando <code>index &lt; 5</code> ya no es <code>true</code>). Ejecutar este
c√≥digo imprimir√° cada elemento en el arreglo:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>Los cinco valores del arreglo aparecen en la terminal, como se esperaba.
Aunque <code>index</code> llegar√° a un valor de <code>5</code> en alg√∫n momento, el bucle deja de
ejecutarse antes de intentar obtener un sexto valor del arreglo.</p>
<p>Sin embargo, este enfoque es propenso a errores; podr√≠amos causar que el
programa se descomponga si el valor del √≠ndice o la condici√≥n de prueba es
incorrecta. Por ejemplo, si cambia la definici√≥n del arreglo <code>a</code> para tener
cuatro elementos, pero olvida actualizar la condici√≥n a <code>while index &lt; 4</code>, el
c√≥digo se descompondr√≠a. Tambi√©n es lento, porque el compilador agrega c√≥digo
de tiempo de ejecuci√≥n para realizar la verificaci√≥n condicional de si el
√≠ndice est√° dentro de los l√≠mites del arreglo en cada iteraci√≥n del bucle.</p>
<p>Como una alternativa m√°s concisa, puede usar un bucle <code>for</code> y ejecutar alg√∫n
c√≥digo para cada elemento en una colecci√≥n. Un bucle <code>for</code> se ve como el c√≥digo
en el Listado 3-5.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;the value is: {element}&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listado 3-5: Bucle a trav√©s de cada elemento de una
colecci√≥n usando un bucle <code>for</code></span></p>
<p>Cuando ejecutamos este c√≥digo, veremos la misma salida que en el Listado 3-4.
Lo m√°s importante es que ahora hemos aumentado la seguridad del c√≥digo y
eliminado la posibilidad de errores que podr√≠an deberse a ir m√°s all√° del final
del arreglo o no ir lo suficientemente lejos y perder algunos elementos.</p>
<p>Usando el bucle <code>for</code>, no necesitar√≠a recordar cambiar cualquier otro c√≥digo si
cambiara el n√∫mero de valores en el arreglo, como lo har√≠a con el m√©todo usado en
el Listado 3-4.</p>
<p>La seguridad y concisi√≥n de los bucles <code>for</code> los convierten en la
estructura de bucle m√°s utilizada en Rust. Incluso en situaciones en las que
quiera ejecutar alg√∫n c√≥digo un cierto n√∫mero de veces, como en el ejemplo de
cuenta regresiva que us√≥ un bucle <code>while</code> en el Listado 3-3, la mayor√≠a de los
Rustaceans usar√≠an un bucle <code>for</code>. La forma de hacerlo ser√≠a usar un <code>Range</code>,
proporcionado por la biblioteca est√°ndar, que genera todos los n√∫meros en
secuencia a partir de un n√∫mero y termina antes de otro n√∫mero.</p>
<p>As√≠ es como se ver√≠a la cuenta regresiva usando un bucle <code>for</code> y otro m√©todo que
a√∫n no hemos hablado, <code>rev</code>, para invertir el rango:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{number}!&quot;);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p>Este c√≥digo es un poco m√°s agradable, ¬øverdad?</p>
<h2 id="resumen-2"><a class="header" href="#resumen-2">Resumen</a></h2>
<p>¬°Lo lograste! Este fue un cap√≠tulo de gran tama√±o: aprendiste sobre variables,
tipos de datos escalares y compuestos, funciones, comentarios, expresiones <code>if</code>
y bucles. Para practicar con los conceptos discutidos en este cap√≠tulo, intente
construir programas para hacer lo siguiente:</p>
<ul>
<li>Convertir temperaturas entre Fahrenheit y Celsius.</li>
<li>Generar el n√∫mero de Fibonacci <em>n</em>.</li>
<li>Imprimir las letras de la canci√≥n navide√±a &quot;Los doce d√≠as de Navidad&quot;,
aprovechando la repetici√≥n en la canci√≥n.</li>
</ul>
<p>Cuando est√© listo para continuar, hablaremos sobre un concepto en Rust que
<em>no</em> existe com√∫nmente en otros lenguajes de programaci√≥n: la propiedad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entendiendo-el-ownership"><a class="header" href="#entendiendo-el-ownership">Entendiendo el Ownership</a></h1>
<p>El Ownership es la caracter√≠stica m√°s √∫nica de Rust y tiene implicaciones
profundas para el resto del lenguaje. Permite a Rust hacer garant√≠as de
seguridad de memoria sin necesidad de un recolector de basura, por lo que es
importante entender c√≥mo funciona el Ownership. En este cap√≠tulo, hablaremos
sobre el Ownership as√≠ como varias caracter√≠sticas relacionadas: pr√©stamo 
(borrowing), slices, y c√≥mo Rust organiza los datos en la memoria.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="qu√©-es-el-ownership"><a class="header" href="#qu√©-es-el-ownership">¬øQu√© es el Ownership?</a></h2>
<p>El <em>ownership</em> es un conjunto de reglas que definen c√≥mo un programa de Rust
administra la memoria. Todos los programas tienen que administrar la forma en
que usan la memoria de un computador mientras se ejecutan. Algunos lenguajes
tienen recolecci√≥n de basura que busca regularmente la memoria que ya no se
usa mientras el programa se ejecuta; en otros lenguajes, el programador debe
asignar y liberar la memoria expl√≠citamente. Rust usa un tercer enfoque: la
memoria se administra a trav√©s de un sistema de ownership con un conjunto de
reglas que el compilador verifica. Si alguna de las reglas se viola, el
programa no se compilar√°. Ninguna de las caracter√≠sticas del ownership
ralentizar√° su programa mientras se ejecuta.</p>
<p>Porque el ownership es un concepto nuevo para muchos programadores, toma un
tiempo acostumbrarse. La buena noticia es que a medida que se vuelva m√°s
experimentado con Rust y las reglas del sistema de ownership, m√°s f√°cil le
resultar√° desarrollar naturalmente c√≥digo que sea seguro y eficiente. ¬°Sigue
intent√°ndolo!</p>
<p>Cuando entienda el ownership, tendr√° una base s√≥lida para comprender las
caracter√≠sticas que hacen que Rust sea √∫nico. En este cap√≠tulo, aprender√°
ownership trabajando en algunos ejemplos que se centran en una estructura de
datos muy com√∫n: las cadenas de caracteres.</p>
<blockquote>
<p>Nota:
La traducci√≥n de Ownership seria &quot;Propiedad&quot;, la mayor parte de la comunidad
habla de este sistema como Ownsership pero tambi√©n es valido este termino.
El motivo es que el sistema de ownership es solo una analog√≠a.</p>
<p>La analog√≠a es que el ownership es como la propiedad de un objeto, por ejemplo
si tienes un libro, el libro es tuyo. Si lo prestas a alguien, el libro sigue
siendo tuyo, pero ahora el libro esta en posesi√≥n de otra persona. Cuando
te devuelven el libro, el libro regresa a tu posesi√≥n.</p>
</blockquote>
<blockquote>
<h3 id="el-stack-y-el-heap"><a class="header" href="#el-stack-y-el-heap">El Stack y el Heap</a></h3>
<p>Muchos lenguajes de programaci√≥n no requieren que piense mucho en el stack y
el heap. Pero en un lenguaje de programaci√≥n de sistemas como Rust, si un
valor est√° en el stack o en el heap afecta c√≥mo el lenguaje se comporta y por
qu√© debe tomar ciertas decisiones. Partes del ownership se describir√°n en
relaci√≥n con el stack y el heap m√°s adelante en este cap√≠tulo, por lo que
aqu√≠ hay una breve explicaci√≥n en preparaci√≥n.</p>
<p>Tanto el stack como el heap son partes de la memoria disponible para su c√≥digo
para usar en tiempo de ejecuci√≥n, pero est√°n estructurados de formas
diferentes. El stack almacena valores en el orden en que los recibe y elimina
los valores en el orden opuesto. Esto se conoce como LIFO que es el acr√≥nimo ingl√©s de <em>Last In, First Out</em> o en espa√±ol <em>El √∫ltimo en entrar, es el primero en salir</em>. Piense en una pila de platos: cuando agrega m√°s platos, los coloca en
la parte superior de la pila, y cuando necesita un plato, toma uno de la
parte superior. Agregar o eliminar platos del medio o de la parte inferior no
funcionar√≠a tan bien! Agregar datos se llama <em>empujar en el stack</em>, y
eliminar datos se llama <em>sacar del stack</em>. Todos los datos almacenados en el
stack deben tener un tama√±o conocido y fijo. Los datos con un tama√±o
desconocido en tiempo de compilaci√≥n o un tama√±o que puede cambiar deben
almacenarse en el heap en su lugar.</p>
<p>El heap es menos organizado: cuando coloca datos en el heap, solicita una
cierta cantidad de espacio. El administrador de memoria encuentra un lugar
vac√≠o en el heap que sea lo suficientemente grande, lo marca como en uso y
devuelve un <em>puntero</em>, que es la direcci√≥n de esa ubicaci√≥n. Este proceso se
llama <em>asignar en el heap</em> y a veces se abrevia como solo <em>asignar</em> (empujar
valores en el stack no se considera asignar). Debido a que el puntero al heap
es un tama√±o conocido y fijo, puede almacenar el puntero en el stack, pero
cuando desea los datos reales, debe seguir el puntero. Piense en estar sentado
en un restaurante. Cuando ingresa, indica la cantidad de personas en su
grupo, y el anfitri√≥n encuentra una mesa vac√≠a que quepa a todos y los lleva
all√≠. Si alguien en su grupo llega tarde, puede preguntar d√≥nde se ha
sentado para encontrarlo.</p>
<p>Empujar en el stack es m√°s r√°pido que asignar en el heap porque el
administrador de memoria nunca tiene que buscar un lugar para almacenar nuevos
datos; esa ubicaci√≥n siempre est√° en la parte superior de la pila. En
comparaci√≥n, asignar espacio en el heap requiere m√°s trabajo porque el
administrador de memoria debe encontrar primero un espacio lo suficientemente
grande para contener los datos y luego realizar tareas administrativas para
prepararse para la siguiente asignaci√≥n.</p>
<p>Acceder a los datos en el heap es m√°s lento que acceder a los datos en el
stack porque debe seguir un puntero para llegar all√≠. Los procesadores
contempor√°neos son m√°s r√°pidos si saltan menos en la memoria. Continuando con
la analog√≠a, considere un servidor en un restaurante que toma pedidos de
muchas mesas. Es m√°s eficiente obtener todos los pedidos de una mesa antes de
pasar a la siguiente mesa. Tomar un pedido de la mesa A, luego un pedido de la
mesa B, luego uno de la A nuevamente y luego uno de la B nuevamente ser√≠a un
proceso mucho m√°s lento. Del mismo modo, un procesador puede hacer su trabajo
mejor si trabaja con datos que est√°n cerca de otros datos (como lo est√°n en
el stack) en lugar de m√°s lejos (como pueden estar en el heap).</p>
<p>Cuando su c√≥digo llama a una funci√≥n, los valores que se pasan a la funci√≥n
(incluidos, posiblemente, punteros a datos en el heap) y las variables locales
de la funci√≥n se empujan en el stack. Cuando la funci√≥n termina, esos valores
se sacan del stack.</p>
<p>Mantener un registro de qu√© partes del c√≥digo est√°n utilizando qu√© datos en
el heap, minimizar la cantidad de datos duplicados en el heap y limpiar los
datos no utilizados en el heap para que no se quede sin espacio son todos
problemas que ownership aborda. Una vez que comprenda ownership, no tendr√°
que pensar mucho en el stack y el heap, pero saber que el principal prop√≥sito
de ownership es administrar datos en el heap puede ayudar a explicar por qu√©
funciona de la manera en que lo hace.</p>
</blockquote>
<h3 id="reglas-de-ownership"><a class="header" href="#reglas-de-ownership">Reglas de Ownership</a></h3>
<p>Primero, echemos un vistazo a las reglas de ownership. Mantenga estas reglas en
mente mientras trabajamos a trav√©s de los ejemplos que las ilustran:</p>
<ul>
<li>Cada valor en Rust tiene un <em>propietario</em>.</li>
<li>Solo puede haber un propietario a la vez.</li>
<li>Cuando el propietario sale del alcance, el valor se descartar√°.</li>
</ul>
<h3 id="√Åmbito-de-las-variables"><a class="header" href="#√Åmbito-de-las-variables">√Åmbito de las Variables</a></h3>
<p>Ahora que hemos pasado la sintaxis b√°sica de Rust, no incluiremos todo el c√≥digo
<code>fn main() {</code> en los ejemplos, por lo que si est√° siguiendo, aseg√∫rese de
colocar los siguientes ejemplos dentro de una funci√≥n <code>main</code> manualmente. Como
resultado, nuestros ejemplos ser√°n un poco m√°s concisos, permiti√©ndonos
centrarnos en los detalles reales en lugar del c√≥digo repetitivo.</p>
<p>Como primer ejemplo de ownership, veremos el <em>contexto de ejecuci√≥n</em> de algunas variables.
Un contexto de ejecuci√≥n es el rango o espacio dentro de un programa para el que un elemento es v√°lido.
Toma la siguiente variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hola&quot;;
<span class="boring">}</span></code></pre></pre>
<p>La variable <code>s</code> se refiere a un literal de cadena, donde el valor de la cadena
est√° codificado en el texto de nuestro programa. La variable es v√°lida desde el
punto en que se declara hasta el final del <em>contexto de ejecuci√≥n</em> actual. El listado 4-1
muestra un programa con comentarios que anotan d√≥nde ser√≠a v√°lida la variable
<code>s</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s no es valido aqu√≠, a√∫n no est√° declarado
        let s = &quot;hola&quot;;   // s es valido desde aqu√≠

        // Hacer algo con s
    }                      // este √°mbito termina aqu√≠, s ya no es valido
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 4-1: Una variable y el contexto de ejecuci√≥n en el que es v√°lida</span></p>
<p>En otras palabras, hay dos puntos importantes en el tiempo aqu√≠:</p>
<ul>
<li>Cuando <code>s</code> est√° el <em>contexto de ejecuci√≥n</em>, es v√°lido.</li>
<li>Permanece v√°lido hasta que sale de <em>contexto de ejecuci√≥n</em>.</li>
</ul>
<p>En este punto, la relaci√≥n entre los contextos de ejecuci√≥n y cu√°ndo las variables son v√°lidas
es similar a la de otros lenguajes de programaci√≥n. Ahora construiremos sobre
este entendimiento al introducir el tipo <code>String</code>.</p>
<h3 id="el-tipo-string"><a class="header" href="#el-tipo-string">El Tipo <code>String</code></a></h3>
<p>Para ilustrar las reglas de ownership, necesitamos un tipo de datos m√°s complejo
que los que cubrimos en la secci√≥n <a href="ch03-02-data-types.html#tipos-de-datos">‚ÄúTipos de Datos‚Äù</a><!-- ignore -->
del Cap√≠tulo 3. Los tipos cubiertos anteriormente son de un tama√±o conocido,
pueden almacenarse en el stack y se pueden sacar del stack cuando su contexto de ejecuci√≥n termina, y se pueden copiar r√°pidamente y trivialmente para crear una nueva
instancia independiente si otra parte del c√≥digo necesita usar el mismo valor
en un contexto de ejecuci√≥n diferente. Pero queremos ver los datos que se almacenan en el heap
y explorar c√≥mo Rust sabe cu√°ndo limpiar esos datos, y el tipo <code>String</code> es un
gran ejemplo.</p>
<p>Nos centraremos en las partes de <code>String</code> que se relacionan con el ownership.
Estos aspectos tambi√©n se aplican a otros tipos de datos complejos, ya sean
suministrados por la biblioteca est√°ndar o creados por usted. Discutiremos
<code>String</code> con m√°s profundidad en el <a href="ch08-02-strings.html">Cap√≠tulo 8</a><!-- ignore -->.</p>
<p>Ya hemos visto literales de cadena, donde un valor de cadena est√° codificado en
nuestro programa. Los literales de cadena son convenientes, pero no son
adecuados para todas las situaciones en las que podr√≠amos querer usar texto.
Una raz√≥n es que son inmutables. Otra es que no todos los valores de cadena se
pueden conocer cuando escribimos nuestro c√≥digo: ¬øy si queremos tomar la
entrada del usuario y almacenarla? Para estas situaciones, Rust tiene un segundo
tipo de cadena, <code>String</code>. Este tipo administra datos asignados en el heap y,
como tal, es capaz de almacenar una cantidad de texto que no conocemos en el
tiempo de compilaci√≥n. Puede crear un <code>String</code> a partir de un literal de cadena
usando la funci√≥n <code>from</code>, as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p>El operador doble dos puntos <code>::</code> nos permite usar el namespace (nombre
de espacio) de esta funci√≥n <code>from</code> particular bajo el tipo <code>String</code> en lugar
de usar alg√∫n tipo de nombre como <code>string_from</code>. Discutiremos esta sintaxis
m√°s en la secci√≥n <a href="ch05-03-method-syntax.html#sintaxis-de-metodos">‚ÄúSintaxis de M√©todo‚Äù</a><!-- ignore --> del
Cap√≠tulo 5, y cuando hablamos sobre el uso de namespaces con m√≥dulos en
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúRutas para Referir a un Elemento en el √Årbol de M√≥dulos‚Äù</a><!-- ignore --></p>
<p>Este tipo de cadena <em>puede</em> ser mutable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hola&quot;);

    s.push_str(&quot;, mundo!&quot;); // push_str() agrega un literal a un String

    println!(&quot;{s}&quot;); // Esto imprime &quot;hola, mundo!&quot;
<span class="boring">}</span></code></pre></pre>
<p>Entonces, ¬øcu√°l es la diferencia aqu√≠? ¬øPor qu√© <code>String</code> puede ser mutable pero
los literales no pueden? La diferencia est√° en c√≥mo estos dos tipos manejan la
memoria.</p>
<h3 id="memoria-y-asignaci√≥n"><a class="header" href="#memoria-y-asignaci√≥n">Memoria y Asignaci√≥n</a></h3>
<p>En el caso de un literal de cadena, conocemos los contenidos en tiempo de
compilaci√≥n, por lo que el texto est√° codificado directamente en el ejecutable
final. Es por eso que los literales de cadena son r√°pidos y eficientes. Pero
estas propiedades solo vienen de la inmutabilidad del literal de cadena.
Desafortunadamente, no podemos poner un blob de memoria en el binario para
cada pieza de texto cuyo tama√±o es desconocido en tiempo de compilaci√≥n y cuyo
tama√±o puede cambiar mientras se ejecuta el programa.</p>
<p>Con el tipo <code>String</code>, para poder soportar una pieza mutable y extensible de
texto, necesitamos asignar una cantidad de memoria en el heap, desconocida en
tiempo de compilaci√≥n, para contener el contenido. Esto significa:</p>
<ul>
<li>La memoria debe solicitarse al administrador de memoria en tiempo de ejecuci√≥n.</li>
<li>Necesitamos una forma de devolver esta memoria al administrador cuando
terminemos con nuestro <code>String</code>.</li>
</ul>
<p>Esa primera parte la hacemos nosotros: cuando llamamos a <code>String::from</code>, su
implementaci√≥n solicita la memoria que necesita. Esto es pr√°cticamente
universal en los lenguajes de programaci√≥n.</p>
<p>Sin embargo, la segunda parte es diferente. En los lenguajes con un <em>recolector
de basura (Garbage Collector)</em>, el recolector de basura rastrea y limpia la
memoria que ya no se est√° usando y no necesitamos pensar en ello. En la mayor√≠a
de los lenguajes sin un recolector de basura, es nuestra responsabilidad identificar cu√°ndo la
memoria ya no se est√° usando y llamar al c√≥digo para liberarla expl√≠citamente,
tal como lo hicimos para solicitarla. Hacer esto correctamente ha sido
hist√≥ricamente un problema dif√≠cil de programaci√≥n. Si lo olvidamos,
desperdiciaremos memoria. Si lo hacemos demasiado pronto, tendremos una variable
inv√°lida. Si lo hacemos dos veces, eso tambi√©n es un error. Necesitamos
emparejar exactamente una <code>asignaci√≥n</code> con exactamente una <code>liberaci√≥n</code>.</p>
<p>Rust toma un camino diferente: la memoria se devuelve autom√°ticamente una vez
que la variable que la posee sale del contexto de ejecuci√≥n. Aqu√≠ hay una versi√≥n de nuestro
ejemplo de alcance de la Lista 4-1 usando un <code>String</code> en lugar de un literal
de cadena:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hola&quot;); // s es valido desde aqu√≠

        // Hacer algo con s
    }                                  // este √°mbito termina aqu√≠, 
                                       // s ya no es valido
<span class="boring">}</span></code></pre></pre>
<p>Hay un punto natural en el que podemos devolver la memoria que necesita nuestro
<code>String</code> al administrador: cuando <code>s</code> sale del alcance. Cuando una variable
sale del contexto de ejecuci√≥n, Rust llama a una funci√≥n especial para nosotros. Esta
funci√≥n se llama <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, y es donde el autor de <code>String</code>
puede poner el c√≥digo para devolver la memoria. Rust llama a <code>drop</code>
autom√°ticamente en la llave de cierre.</p>
<blockquote>
<p>Nota: En C++, este patr√≥n de desasignaci√≥n de recursos al final de la vida
√∫til de un elemento a veces se denomina <em>Resource Acquisition Is
Initialization (RAII)</em>. La funci√≥n <code>drop</code> en Rust ser√° familiar para usted si
ha utilizado patrones RAII.</p>
</blockquote>
<p>Este patr√≥n tiene un profundo impacto en la forma en que se escribe el c√≥digo
Rust. Puede parecer simple ahora, pero el comportamiento del c√≥digo puede ser
inesperado en situaciones m√°s complejas cuando queremos que varias variables
usen los datos que hemos asignado en el heap. Exploremos algunas de esas
situaciones ahora.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="variables-y-datos-interactuando-con-move"><a class="header" href="#variables-y-datos-interactuando-con-move">Variables y datos interactuando con Move</a></h4>
<p>Varias variables pueden interactuar con los mismos datos de diferentes formas
en Rust. Veamos un ejemplo usando un entero en la Lista 4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Lista 4-2: Asignando el valor entero de la variable <code>x</code>
a <code>y</code></span></p>
<p>Podemos adivinar lo que est√° haciendo: &quot;vincular el valor <code>5</code> a <code>x</code>; luego
hacer una copia del valor en <code>x</code> y vincularlo a <code>y</code>&quot;. Ahora tenemos dos
variables, <code>x</code> y <code>y</code>, y ambos son <code>5</code>. Esto es lo que est√° sucediendo, porque
los enteros son valores simples con un tama√±o conocido y fijo, y estos dos
valores <code>5</code> se empujan en la pila.</p>
<p>Ahora veamos la versi√≥n <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hola&quot;);
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>Esto se ve muy similar, por lo que podr√≠amos suponer que la forma en que
funciona ser√≠a la misma: es decir, la segunda l√≠nea har√≠a una copia del valor en
<code>s1</code> y lo vincular√≠a a <code>s2</code>. Pero esto no es exactamente lo que sucede.</p>
<p>Mire la Figura 4-1 para ver lo que est√° sucediendo en realidad con el <code>String</code>.
Un <code>String</code> est√° compuesto por tres partes, mostradas a la izquierda:
un puntero a la memoria que contiene el contenido de la cadena, una longitud y
una capacidad. Este grupo de datos se almacena en la pila. A la derecha est√° la
memoria en el heap que contiene el contenido.</p>
<div style="width:50%; max-width: 100%;">
<svg class="center" role="img" aria-labelledby="desc" 
 viewBox="0.00 400.00 1000.00 500.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 238)">
<title>Dos tablas: la primera tabla contiene la representaci√≥n de s1 en la pila, que consta de su longitud (5), capacidad (5) y un puntero al primer valor en la segunda tabla. La segunda tabla contiene la representaci√≥n de los datos en el heap, byte por byte.</title>
<desc >Dos tablas: la primera tabla contiene la representaci√≥n de s1 en la pila, que consta de su longitud (5), capacidad (5) y un puntero al primer valor en la segunda tabla. La segunda tabla contiene la representaci√≥n de los datos en el heap, byte por byte.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-152 233,-152 233,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-124 96,-124 "/>
<text text-anchor="start" x="45.7759" y="-129.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="0,-104 0,-124 60,-124 60,-104 8,-104"/>
<text text-anchor="start" x="2.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="currentColor">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-104 60,-124 96,-124 96,-104 60,-104"/>
<text text-anchor="start" x="62.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-84 0,-104 60,-104 60,-84 8,-84"/>
<text text-anchor="start" x="2.2241" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">ptr</text>
<polygon fill="none" stroke="var(--fg)" points="60,-84 60,-104 96,-104 96,-84 60,-84"/>
<polygon fill="none" stroke="var(--fg)" points="0,-64 0,-84 60,-84 60,-64 8,-64"/>
<text text-anchor="start" x="2.4482" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-64 60,-84 96,-84 96,-64 60,-64"/>
<text text-anchor="start" x="74.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-44 0,-64 60,-64 60,-44 8,-44"/>
<text text-anchor="start" x="2.6826" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-44 60,-64 96,-64 96,-44 60,-44"/>
<text text-anchor="start" x="74.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table1 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="140.5,-104 140.5,-124 185.5,-124 185.5,-104 148.5,-104"/>
<text text-anchor="start" x="143.4482" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-104 185.5,-124 221.5,-124 221.5,-104 185.5,-104"/>
<text text-anchor="start" x="188.3413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-84 140.5,-104 185.5,-104 185.5,-84 148.5,-84"/>
<text text-anchor="start" x="155.5" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-84 185.5,-104 221.5,-104 221.5,-84 185.5,-84"/>
<text text-anchor="start" x="200" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-64 140.5,-84 185.5,-84 185.5,-64 148.5,-64"/>
<text text-anchor="start" x="155.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-64 185.5,-84 221.5,-84 221.5,-64 185.5,-64"/>
<text text-anchor="start" x="200.3931" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-44 140.5,-64 185.5,-64 185.5,-44 148.5,-44"/>
<text text-anchor="start" x="155.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-44 185.5,-64 221.5,-64 221.5,-44 185.5,-44"/>
<text text-anchor="start" x="201.5552" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-24 140.5,-44 185.5,-44 185.5,-24 148.5,-24"/>
<text text-anchor="start" x="155.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-24 185.5,-44 221.5,-44 221.5,-24 185.5,-24"/>
<text text-anchor="start" x="201.5552" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-94C78,-94 109.3406,-94 130.3797,-94"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.5,-97.5001 140.5,-94 130.5,-90.5001 130.5,-97.5001"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-1: Representaci√≥n en memoria de un <code>String</code>
que contiene el valor <code>&quot;hola&quot;</code> vinculado a <code>s1</code></span></p>
<p>La longitud es cu√°nta memoria, en bytes, los contenidos del <code>String</code> est√°n
utilizando actualmente. La capacidad es la cantidad total de memoria, en bytes,
que el <code>String</code> ha recibido del administrador. La diferencia entre longitud y
capacidad importa, pero no en este contexto, por lo que por ahora est√° bien
ignorar la capacidad.</p>
<p>Cuando asignamos <code>s1</code> a <code>s2</code>, los datos de <code>String</code> se copian, lo que significa
que copiamos el puntero, la longitud y la capacidad que est√°n en la pila. No
copiamos los datos en el heap al que hace referencia el puntero. En otras
palabras, la representaci√≥n de datos en memoria se ve como la Figura 4-2.</p>
<div style="width:50%; max-width: 100%;">
<svg class="center" role="img" aria-labelledby="desc" 
 viewBox="0.00 0.00 1000.00 1000.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 238)">
<title>Tres tablas: tablas s1 y s2 que representan esas cadenas en la
pila, respectivamente, y ambas apuntando a los mismos datos de cadena en el
heap.</title>
<desc >Tres tablas: tablas s1 y s2 que representan esas cadenas en la
pila, respectivamente, y ambas apuntando a los mismos datos de cadena en el
heap.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-238 233,-238 233,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<title>table0</title>
<polyline fill="none" stroke="var(--fg)" points="0,-210 96,-210 "/>
<text text-anchor="start" x="45.7759" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="0,-190 0,-210 60,-210 60,-190 8,-190"/>
<text text-anchor="start" x="8.8413" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-190 60,-210 96,-210 96,-190 60,-190"/>
<text text-anchor="start" x="62.8413" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-170 0,-190 60,-190 60,-170 8,-170"/>
<text text-anchor="start" x="2.2241" y="-175.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-170 60,-190 96,-190 96,-170 60,-170"/>
<polygon fill="none" stroke="var(--fg)" points="0,-150 0,-170 60,-170 60,-150 8,-150"/>
<text text-anchor="start" x="2.4482" y="-155.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-150 60,-170 96,-170 96,-150 60,-150"/>
<text text-anchor="start" x="74.5" y="-155.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-130 0,-150 60,-150 60,-130 8,-130"/>
<text text-anchor="start" x="2.6826" y="-135.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-130 60,-150 96,-150 96,-130 60,-130"/>
<text text-anchor="start" x="74.5" y="-135.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table1 -->
<g  class="node">
<title>table1</title>
<polygon fill="none" stroke="currentColor" points="140.5,-127 140.5,-147 185.5,-147 185.5,-127 148.5,-127"/>
<text text-anchor="start" x="145.4482" y="-132.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-127 185.5,-147 221.5,-147 221.5,-127 185.5,-127"/>
<text text-anchor="start" x="188.3413" y="-132.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-107 140.5,-127 185.5,-127 185.5,-107 148.5,-107"/>
<text text-anchor="start" x="158.5" y="-112.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-107 185.5,-127 221.5,-127 221.5,-107 185.5,-107"/>
<text text-anchor="start" x="200" y="-112.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-87 140.5,-107 185.5,-107 185.5,-87 148.5,-87"/>
<text text-anchor="start" x="158.5" y="-92.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-87 185.5,-107 221.5,-107 221.5,-87 185.5,-87"/>
<text text-anchor="start" x="200.3931" y="-92.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-67 140.5,-87 185.5,-87 185.5,-67 148.5,-67"/>
<text text-anchor="start" x="158.5" y="-72.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-67 185.5,-87 221.5,-87 221.5,-67 185.5,-67"/>
<text text-anchor="start" x="201.5552" y="-72.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-47 140.5,-67 185.5,-67 185.5,-47 148.5,-47"/>
<text text-anchor="start" x="158.5" y="-52.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-47 185.5,-67 221.5,-67 221.5,-47 185.5,-47"/>
<text text-anchor="start" x="201.5552" y="-52.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<title>table0:c&#45;&gt;table1:pointee</title>
<path fill="none" stroke="var(--fg)" d="M78,-180C78,-180 101.9982,-126.912 130.4405,-118.2023"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.986,-121.6621 140.5,-117 130.1553,-114.7115 130.986,-121.6621"/>
</g>
<!-- table3 -->
<g  class="node">
<title>table3</title>
<polyline fill="none" stroke="var(--fg)" points="0,-84 96,-84 "/>
<text text-anchor="start" x="45.7759" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s2</text>
<polygon fill="none" stroke="var(--fg)" points="0,-64 0,-84 60,-84 60,-64 8,-64"/>
<text text-anchor="start" x="8.8413" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-64 60,-84 96,-84 96,-64 60,-64"/>
<text text-anchor="start" x="62.8413" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-44 0,-64 60,-64 60,-44 8,-44"/>
<text text-anchor="start" x="2.2241" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-44 60,-64 96,-64 96,-44 60,-44"/>
<polygon fill="none" stroke="var(--fg)" points="0,-24 0,-44 60,-44 60,-24 8,-24"/>
<text text-anchor="start" x="2.4482" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-24 60,-44 96,-44 96,-24 60,-24"/>
<text text-anchor="start" x="74.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-4 0,-24 60,-24 60,-4 8,-4"/>
<text text-anchor="start" x="2.6826" y="-9.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-4 60,-24 96,-24 96,-4 60,-4"/>
<text text-anchor="start" x="74.5" y="-9.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table3&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-54C78,-54 101.9982,-107.088 130.4405,-115.7977"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.1553,-119.2885 140.5,-117 130.986,-112.3379 130.1553,-119.2885"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-2: Representaci√≥n en memoria de la variable
<code>s2</code> que tiene una copia del puntero, la longitud y la capacidad de <code>s1</code>.</span></p>
<p>La representaci√≥n <em>no</em> se ve como la Figura 4-3, que es lo que la memoria
parecer√≠a si Rust copiara adem√°s los datos del heap. Si Rust hiciera esto, la
operaci√≥n <code>s2 = s1</code> podr√≠a ser muy costosa en t√©rminos de rendimiento de tiempo
de ejecuci√≥n si los datos en el heap fueran grandes.</p>
<div style="width:50%; max-width: 100%;">
<svg
 viewBox="0.00 0.00 1000.00 1200.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 298)">
<title>Cuatro tablas: dos tablas que representan los datos de la pila para s1 y s2, y cada una apunta a su propia copia de datos de cadena en el heap.</title>
<desc >Cuatro tablas: dos tablas que representan los datos de la pila para s1 y s2, y cada una apunta a su propia copia de datos de cadena en el heap.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-298 233,-298 233,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-124 96,-124 "/>
<text text-anchor="start" x="45.7759" y="-129.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s2</text>
<polygon fill="none" stroke="var(--fg)" points="0,-104 0,-124 60,-124 60,-104 8,-104"/>
<text text-anchor="start" x="8.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-104 60,-124 96,-124 96,-104 60,-104"/>
<text text-anchor="start" x="62.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-84 0,-104 60,-104 60,-84 8,-84"/>
<text text-anchor="start" x="2.2241" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-84 60,-104 96,-104 96,-84 60,-84"/>
<polygon fill="none" stroke="var(--fg)" points="0,-64 0,-84 60,-84 60,-64 8,-64"/>
<text text-anchor="start" x="2.4482" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-64 60,-84 96,-84 96,-64 60,-64"/>
<text text-anchor="start" x="74.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-44 0,-64 60,-64 60,-44 8,-44"/>
<text text-anchor="start" x="2.6826" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-44 60,-64 96,-64 96,-44 60,-44"/>
<text text-anchor="start" x="74.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table1 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="140.5,-104 140.5,-124 185.5,-124 185.5,-104 148.5,-104"/>
<text text-anchor="start" x="145.4482" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-104 185.5,-124 221.5,-124 221.5,-104 185.5,-104"/>
<text text-anchor="start" x="188.3413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-84 140.5,-104 185.5,-104 185.5,-84 148.5,-84"/>
<text text-anchor="start" x="158.5" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-84 185.5,-104 221.5,-104 221.5,-84 185.5,-84"/>
<text text-anchor="start" x="200" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-64 140.5,-84 185.5,-84 185.5,-64 148.5,-64"/>
<text text-anchor="start" x="158.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-64 185.5,-84 221.5,-84 221.5,-64 185.5,-64"/>
<text text-anchor="start" x="200.3931" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-44 140.5,-64 185.5,-64 185.5,-44 148.5,-44"/>
<text text-anchor="start" x="158.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-44 185.5,-64 221.5,-64 221.5,-44 185.5,-44"/>
<text text-anchor="start" x="201.5552" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-24 140.5,-44 185.5,-44 185.5,-24 148.5,-24"/>
<text text-anchor="start" x="158.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-24 185.5,-44 221.5,-44 221.5,-24 185.5,-24"/>
<text text-anchor="start" x="201.5552" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-94C78,-94 109.3406,-94 130.3797,-94"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.5,-97.5001 140.5,-94 130.5,-90.5001 130.5,-97.5001"/>
</g>
<!-- table3 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-270 96,-270 "/>
<text text-anchor="start" x="45.7759" y="-275.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="0,-250 0,-270 60,-270 60,-250 8,-250"/>
<text text-anchor="start" x="8.8413" y="-255.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-250 60,-270 96,-270 96,-250 60,-250"/>
<text text-anchor="start" x="62.8413" y="-255.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-230 0,-250 60,-250 60,-230 8,-230"/>
<text text-anchor="start" x="2.2241" y="-235.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-230 60,-250 96,-250 96,-230 60,-230"/>
<polygon fill="none" stroke="var(--fg)" points="0,-210 0,-230 60,-230 60,-210 8,-210"/>
<text text-anchor="start" x="2.4482" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-210 60,-230 96,-230 96,-210 60,-210"/>
<text text-anchor="start" x="74.5" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-190 0,-210 60,-210 60,-190 8,-190"/>
<text text-anchor="start" x="2.6826" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-190 60,-210 96,-210 96,-190 60,-190"/>
<text text-anchor="start" x="74.5" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table4 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="140.5,-250 140.5,-270 185.5,-270 185.5,-250 148.5,-250"/>
<text text-anchor="start" x="145.4482" y="-255.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-250 185.5,-270 221.5,-270 221.5,-250 185.5,-250"/>
<text text-anchor="start" x="188.3413" y="-255.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-230 140.5,-250 185.5,-250 185.5,-230 148.5,-230"/>
<text text-anchor="start" x="158.5" y="-235.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-230 185.5,-250 221.5,-250 221.5,-230 185.5,-230"/>
<text text-anchor="start" x="200" y="-235.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-210 140.5,-230 185.5,-230 185.5,-210 148.5,-210"/>
<text text-anchor="start" x="158.5" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-210 185.5,-230 221.5,-230 221.5,-210 185.5,-210"/>
<text text-anchor="start" x="200.3931" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-190 140.5,-210 185.5,-210 185.5,-190 148.5,-190"/>
<text text-anchor="start" x="158.5" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-190 185.5,-210 221.5,-210 221.5,-190 185.5,-190"/>
<text text-anchor="start" x="201.5552" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-170 140.5,-190 185.5,-190 185.5,-170 148.5,-170"/>
<text text-anchor="start" x="158.5" y="-175.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-170 185.5,-190 221.5,-190 221.5,-170 185.5,-170"/>
<text text-anchor="start" x="201.5552" y="-175.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table3&#45;&gt;table4 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-240C78,-240 109.3406,-240 130.3797,-240"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.5,-243.5001 140.5,-240 130.5,-236.5001 130.5,-243.5001"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-3: Otra posibilidad de lo que <code>s2 = s1</code> podr√≠a
hacer si Rust copiara tambi√©n los datos del heap</span></p>
<p>Anteriormente, dijimos que cuando una variable sale de contexto de ejecuci√≥n, Rust llama
autom√°ticamente a la funci√≥n <code>drop</code> y limpia la memoria del heap para esa
variable. Pero la Figura 4-2 muestra que ambos punteros de datos apuntan al
mismo lugar. Esto es un problema: cuando <code>s2</code> y <code>s1</code> salen de contexto de ejecuci√≥n, ambos
intentar√°n liberar la misma memoria. Esto se conoce como un error de <em>doble
liberaci√≥n</em> y es uno de los errores de seguridad de la memoria que mencionamos
anteriormente. Liberar la memoria dos veces puede conducir a la corrupci√≥n de
memoria, lo que puede conducir a vulnerabilidades de seguridad.</p>
<p>Para garantizar la seguridad de la memoria, despu√©s de la l√≠nea <code>let s2 = s1;</code>,
Rust considera a <code>s1</code> como no v√°lida. Por lo tanto, Rust no necesita liberar
nada cuando <code>s1</code> sale de √°mbito. Echa un vistazo a lo que sucede cuando intentas
usar <code>s1</code> despu√©s de que se crea <code>s2</code>; no funcionar√°:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hola&quot;);
    let s2 = s1;

    println!(&quot;{s1}, mundo!&quot;);
<span class="boring">}</span></code></pre>
<p>Obtendr√°s un error como este porque Rust te impide usar la referencia
invalidada:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from(&quot;hola&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!(&quot;{s1}, mundo!&quot;);
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>Si has escuchado los t√©rminos <em>copia superficial</em> y <em>copia profunda</em> mientras
trabajabas con otros lenguajes, el concepto de copiar el puntero, la longitud y
la capacidad sin copiar los datos probablemente suene a hacer una copia
superficial. Pero debido a que Rust tambi√©n invalida la primera variable, en
vez de llamarse una copia superficial, se conoce como un <em>movimiento</em>. En este
ejemplo, dir√≠amos que <code>s1</code> fue <em>movido</em> a <code>s2</code>. Entonces, lo que realmente
sucede se muestra en la Figura 4-4.</p>
<div style="width:50%; max-width: 100%;">
<svg
 viewBox="0.00 0.00 1000.00 1000.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 238)">
<title>Tres tablas: las tablas s1 y s2 que representan esas cadenas en la pila, respectivamente, y ambas apuntando a la misma cadena de datos en el heap. La tabla s1 est√° desactivada porque s1 ya no es v√°lida; solo s2 se puede usar para acceder a los datos del heap.</title>
<desc >Tres tablas: las tablas s1 y s2 que representan esas cadenas en la pila, respectivamente, y ambas apuntando a la misma cadena de datos en el heap. La tabla s1 est√° desactivada porque s1 ya no es v√°lida; solo s2 se puede usar para acceder a los datos del heap.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-238 233,-238 233,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<polygon class="opacity-background" stroke="transparent" points="0,-130 0,-230 96,-230 96,-130 8,-130"/>
<polyline fill="none" stroke="var(--fg)" points="0,-210 96,-210 "/>
<text text-anchor="start" x="45.7759" y="-215.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="0,-190 0,-210 60,-210 60,-190 8,-190"/>
<text text-anchor="start" x="8.8413" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-190 60,-210 96,-210 96,-190 60,-190"/>
<text text-anchor="start" x="62.8413" y="-195.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-170 0,-190 60,-190 60,-170 8,-170"/>
<text text-anchor="start" x="2.2241" y="-175.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-170 60,-190 96,-190 96,-170 60,-170"/>
<polygon fill="none" stroke="var(--fg)" points="0,-150 0,-170 60,-170 60,-150 8,-150"/>
<text text-anchor="start" x="2.4482" y="-155.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-150 60,-170 96,-170 96,-150 60,-150"/>
<text text-anchor="start" x="74.5" y="-155.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-130 0,-150 60,-150 60,-130 8,-130"/>
<text text-anchor="start" x="2.6826" y="-135.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-130 60,-150 96,-150 96,-130 60,-130"/>
<text text-anchor="start" x="74.5" y="-135.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table1 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="140.5,-127 140.5,-147 185.5,-147 185.5,-127 148.5,-127"/>
<text text-anchor="start" x="145.4482" y="-132.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-127 185.5,-147 221.5,-147 221.5,-127 185.5,-127"/>
<text text-anchor="start" x="188.3413" y="-132.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-107 140.5,-127 185.5,-127 185.5,-107 148.5,-107"/>
<text text-anchor="start" x="158.5" y="-112.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-107 185.5,-127 221.5,-127 221.5,-107 185.5,-107"/>
<text text-anchor="start" x="200" y="-112.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-87 140.5,-107 185.5,-107 185.5,-87 148.5,-87"/>
<text text-anchor="start" x="158.5" y="-92.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-87 185.5,-107 221.5,-107 221.5,-87 185.5,-87"/>
<text text-anchor="start" x="200.3931" y="-92.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-67 140.5,-87 185.5,-87 185.5,-67 148.5,-67"/>
<text text-anchor="start" x="158.5" y="-72.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-67 185.5,-87 221.5,-87 221.5,-67 185.5,-67"/>
<text text-anchor="start" x="201.5552" y="-72.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="140.5,-47 140.5,-67 185.5,-67 185.5,-47 148.5,-47"/>
<text text-anchor="start" x="158.5" y="-52.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="185.5,-47 185.5,-67 221.5,-67 221.5,-47 185.5,-47"/>
<text text-anchor="start" x="201.5552" y="-52.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-180C78,-180 101.9982,-126.912 130.4405,-118.2023"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.986,-121.6621 140.5,-117 130.1553,-114.7115 130.986,-121.6621"/>
</g>
<!-- table3 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-84 96,-84 "/>
<text text-anchor="start" x="45.7759" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s2</text>
<polygon fill="none" stroke="var(--fg)" points="0,-64 0,-84 60,-84 60,-64 8,-64"/>
<text text-anchor="start" x="8.8413" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="60,-64 60,-84 96,-84 96,-64 60,-64"/>
<text text-anchor="start" x="62.8413" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-44 0,-64 60,-64 60,-44 8,-44"/>
<text text-anchor="start" x="2.2241" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="60,-44 60,-64 96,-64 96,-44 60,-44"/>
<polygon fill="none" stroke="var(--fg)" points="0,-24 0,-44 60,-44 60,-24 8,-24"/>
<text text-anchor="start" x="2.4482" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="60,-24 60,-44 96,-44 96,-24 60,-24"/>
<text text-anchor="start" x="74.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="0,-4 0,-24 60,-24 60,-4 8,-4"/>
<text text-anchor="start" x="2.6826" y="-9.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="60,-4 60,-24 96,-24 96,-4 60,-4"/>
<text text-anchor="start" x="74.5" y="-9.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table3&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M78,-54C78,-54 101.9982,-107.088 130.4405,-115.7977"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="130.1553,-119.2885 140.5,-117 130.986,-112.3379 130.1553,-119.2885"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-4: Representaci√≥n en memoria despu√©s de que
<code>s1</code> se haya invalidado</span></p>
<p>¬°Eso resuelve nuestro problema! Con solo <code>s2</code> v√°lido, cuando sale de √°mbito
solo √©l liberar√° la memoria, y ya est√°.</p>
<p>Adem√°s, hay una elecci√≥n de dise√±o que se infiere de esto: Rust nunca
crear√° autom√°ticamente &quot;copias profundas&quot; de tus datos. Por lo tanto, cualquier
copia <em>autom√°tica</em> se puede asumir que es econ√≥mica en t√©rminos de rendimiento
en tiempo de ejecuci√≥n.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="variables-y-datos-interactuando-con-clone"><a class="header" href="#variables-y-datos-interactuando-con-clone">Variables y datos interactuando con Clone</a></h4>
<p>Si <em>queremos</em> copiar profundamente los datos del heap de la <code>String</code>, no solo
los datos de la pila, podemos usar un m√©todo com√∫n llamado <code>clone</code>. Discutiremos
la sintaxis del m√©todo en el Cap√≠tulo 5, pero debido a que los m√©todos son una
caracter√≠stica com√∫n en muchos lenguajes de programaci√≥n, probablemente los
hayas visto antes.</p>
<p>Aqu√≠ hay un ejemplo del m√©todo <code>clone</code> en acci√≥n:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hola&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {s1}, s2 = {s2}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Esto funciona bien y produce expl√≠citamente el comportamiento mostrado en la
Figura 4-3, donde los datos del heap <em>se copian</em>.</p>
<p>Cuando veas una llamada a <code>clone</code>, sabr√°s que se est√° ejecutando alg√∫n c√≥digo
arbitrario y que ese c√≥digo puede ser costoso. Es un indicador visual de que
algo diferente est√° sucediendo.</p>
<h4 id="solo-datos-del-stack-copiar"><a class="header" href="#solo-datos-del-stack-copiar">Solo datos del stack: Copiar</a></h4>
<p>Hay otro problema que a√∫n no hemos hablado. Este c√≥digo usando enteros - parte
de lo que se mostr√≥ en el Listado 4-2 - funciona y es v√°lido:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {x}, y = {y}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Pero este c√≥digo parece contradecir lo que acabamos de aprender: no tenemos una
llamada a <code>clone</code>, pero <code>x</code> sigue siendo v√°lido y no se movi√≥ a <code>y</code>.</p>
<p>La raz√≥n es que los tipos como los enteros que tienen un tama√±o conocido en el
momento de la compilaci√≥n se almacenan completamente en la pila, por lo que
copiar los valores reales es r√°pido. Eso significa que no hay raz√≥n para que
queramos evitar que <code>x</code> sea v√°lido despu√©s de crear la variable <code>y</code>. En otras
palabras, no hay diferencia entre copiar superficial y profunda aqu√≠, por lo que
llamar a <code>clone</code> no har√≠a nada diferente de la copia superficial habitual, y
podemos dejarlo fuera.</p>
<p>Rust tiene una anotaci√≥n especial llamada <code>Copy</code> que podemos colocar en tipos
que se almacenan en la pila, como los enteros (hablaremos m√°s sobre los
<em>traits</em> en el <a href="ch10-02-traits.html">Cap√≠tulo 10</a><!-- ignore -->). Si un tipo implementa el
<code>Copy</code> <em>trait</em>, las variables que lo usan no se mueven, sino que se copian
trivialmente, haciendo que sigan siendo v√°lidas despu√©s de asignarlas a otra
variable.</p>
<p>Rust no nos permitir√° anotar un tipo con <code>Copy</code> si el tipo, o cualquiera de sus
partes, ha implementado el <em>trait</em> <code>Drop</code>. Si el tipo necesita que algo
especial suceda cuando el valor sale del alcance y agregamos la anotaci√≥n <code>Copy</code>
a ese tipo, obtendremos un error de tiempo de compilaci√≥n. Para aprender c√≥mo
agregar la anotaci√≥n <code>Copy</code> a tu tipo para implementar el <em>trait</em>, consulta
<a href="appendix-03-derivable-traits.html">‚ÄúTraits derivables‚Äù</a><!-- ignore --> en el Ap√©ndice C.</p>
<p>Entonces, ¬øqu√© tipos implementan el <em>trait</em> <code>Copy</code>? Puedes consultar la
documentaci√≥n del tipo dado para asegurarte, pero como regla general, cualquier
grupo de valores escalares simples puede implementar <code>Copy</code>, y nada que
requiera asignaci√≥n o sea alguna forma de recurso puede implementar <code>Copy</code>.
Aqu√≠ hay algunos de los tipos que implementan <code>Copy</code>:</p>
<ul>
<li>Todos los tipos enteros, como <code>u32</code>.</li>
<li>El tipo booleano, <code>bool</code>, con valores <code>true</code> y <code>false</code>.</li>
<li>Todos los tipos de punto flotante, como <code>f64</code>.</li>
<li>El tipo de car√°cter, <code>char</code>.</li>
<li>Tuplas, si solo contienen tipos que tambi√©n implementan <code>Copy</code>. Por ejemplo,
<code>(i32, i32)</code> implementa <code>Copy</code>, pero <code>(i32, String)</code> no lo hace.</li>
</ul>
<h3 id="propiedad-y-funciones"><a class="header" href="#propiedad-y-funciones">Propiedad y funciones</a></h3>
<p>Las mec√°nicas de pasar un valor a una funci√≥n son similares a las de asignar un
valor a una variable. Pasar una variable a una funci√≥n mover√° o copiar√°, como
hace la asignaci√≥n. La Lista 4-3 tiene un ejemplo con algunas anotaciones que
muestran d√≥nde entran y salen las variables del alcance.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hola&quot;);  // s aparece en el √°mbito

    tomar_ownership(s);             // El valor de s se mueve a la funci√≥n...
                                    // ... y ya no es valido aqu√≠

    let x = 5;                      // x aparece en el √°mbito

    hacer_una_copia(x);                  // x deberia moverse a la funci√≥n,
                                    // pero i32 implementa Copy, entonces es
                                    // valido a√∫n despues de llamar a la funci√≥n

} // Aqu√≠ termina el √°mbito, x es destruido con drop. La memoria es liberada.
  // s ya no existia porque habia sido movido a la funci√≥n.
  // Nada especial ocurre.

fn tomar_ownership(un_string: String) { // un_string aparece en el √°mbito
    println!(&quot;{un_string}&quot;);
} // Aqu√≠ termina el √°mbito, un_string es destruido con drop. 
  // La memoria es liberada.

fn hacer_una_copia(un_entero: i32) { // un_entero aparece en el √°mbito
    println!(&quot;{un_entero}&quot;);
} // Aqu√≠ termina el √°mbito, un_entero es destruido. Nada especial ocurre.</code></pre></pre>
<p><span class="caption">Lista 4-3: Funciones con propiedad y alcance
anotados</span></p>
<p>Si intentamos usar <code>s</code> despu√©s de llamar a <code>tomar_ownership</code>, Rust lanzar√≠a un
error de tiempo de compilaci√≥n. Estas comprobaciones est√°ticas nos protegen de
errores. Intenta agregar c√≥digo a <code>main</code> que use <code>s</code> y <code>x</code> para ver d√≥nde puedes
usarlos y d√≥nde las reglas de propiedad te impiden hacerlo.</p>
<h3 id="valores-de-retorno-y-alcance"><a class="header" href="#valores-de-retorno-y-alcance">Valores de retorno y alcance</a></h3>
<p>Los valores de retorno tambi√©n pueden transferir la propiedad. La Lista 4-4
muestra un ejemplo de una funci√≥n que devuelve alg√∫n valor, con anotaciones
similares a las de la Lista 4-3.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = da_un_ownership();         // da_un_ownership es llamado y
                                        // devuelve el valor de retorno
                                        // a s1

    let s2 = String::from(&quot;hola&quot;);     // s2 aparece en el √°mbito

    let s3 = toma_y_devuelve(s2);  // s2 es movido a la funci√≥n
                                        // toma_y_devuelve, que tambi√©n
                                        // retorna el valor de s2 a s3
} // Fin el √°mbito, s3 es destruido con drop y se libera la memoria. 
  // s2 fue movido previamente, entonces no pasa nada. 
  // s1 es destruido con drop y se libera la memoria.

fn da_un_ownership() -&gt; String {             // da_un_ownership mueve su
                                             // retorno a la funci√≥n que la
                                             // llama

    let un_string = String::from(&quot;tuyo&quot;);    // un_string aparece en el √°mbito

    un_string                                // un_string es retornado y
                                             // mueve su valor
}

// Esta funci√≥n toma un String y devuelve uno
fn toma_y_devuelve(un_string: String) -&gt; String { // un_string aparece 
                                                  // en el √°mbito

    un_string  // un_string es retornado y mueve su valor
}</code></pre></pre>
<p><span class="caption">Lista 4-4: Transferencia de propiedad de los valores
de retorno</span></p>
<p>La propiedad (ownership) de una variable sigue el mismo patr√≥n cada vez:
asignar un valor a otra variable lo mueve. Cuando una variable que incluye datos
en el heap sale del contexto de ejecuci√≥n, el valor se limpiar√° por <code>drop</code> a menos que la
propiedad de los datos se haya movido a otra variable.</p>
<p>Aunque esto funciona, tomar la propiedad y luego devolver la propiedad con cada
funci√≥n es un poco tedioso. ¬øQu√© pasa si queremos que una funci√≥n use un valor
pero no tome la propiedad? Es bastante molesto que todo lo que pasamos tambi√©n
necesite volver a pasar si queremos usarlo de nuevo, adem√°s de cualquier dato
que resulte del cuerpo de la funci√≥n que tambi√©n podr√≠amos querer devolver.</p>
<p>Rust nos permite devolver m√∫ltiples valores usando una tupla, como se muestra
en la Lista 4-5.</p>
<p><span class="filename">Nombre del archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hola&quot;);

    let (s2, len) = calcular_longitud(s1);

    println!(&quot;La longitud de '{s2}' es {len}.&quot;);
}

fn calcular_longitud(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() retorna la longitud de un String

    (s, length)
}</code></pre></pre>
<p><span class="caption">Lista 4-5: Devoluci√≥n de la propiedad de los
par√°metros</span></p>
<p>Pero esto es demasiado ceremonioso y mucho trabajo para un concepto que deber√≠a
ser com√∫n. Afortunadamente para nosotros, Rust tiene una caracter√≠stica para
usar un valor sin transferir la propiedad, llamada <em>referencias</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referencias-y-prestamos"><a class="header" href="#referencias-y-prestamos">Referencias y Prestamos</a></h2>
<p>El problema con la tupla de c√≥digo en el Listado 4-5 es que tenemos que devolver
el <code>String</code> a la funci√≥n que lo llama para que podamos seguir usando el
<code>String</code> despu√©s de la llamada a <code>calcular_longitud</code>, porque el <code>String</code> se
movi√≥ a <code>calcular_longitud</code>. En lugar de eso, podemos proporcionar una
referencia al valor <code>String</code>. Una <em>referencia</em> es como un puntero en que es una
direcci√≥n que podemos seguir para acceder a los datos almacenados en esa
direcci√≥n; esos datos son propiedad de otra variable. A diferencia de un
puntero, una referencia garantiza que apunte a un valor v√°lido de un tipo
particular para la vida de esa referencia.</p>
<p>Aqu√≠ est√° c√≥mo definir√≠as y usar√≠as una funci√≥n <code>calcular_longitud</code> que tiene
una referencia a un objeto como par√°metro en lugar de tomar la propiedad del valor.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hola&quot;);

    let len = calcular_longitud(&amp;s1);

    println!(&quot;La longitud de '{s1}' es {len}.&quot;);
}

fn calcular_longitud(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>Primero, ten en cuenta que todo el c√≥digo de la tupla en la declaraci√≥n de la
variable y el valor de retorno de la funci√≥n ha desaparecido. En segundo
lugar, observe que pasamos <code>&amp;s1</code> a <code>calcular_longitud</code> y, en su definici√≥n,
tomamos <code>&amp;String</code> en lugar de <code>String</code>. Este signo ampersands (&amp;) representa
<em>referencia</em>, y te permiten referirte a alg√∫n valor sin tomar la propiedad de
√©l. La Figura 4-5 representa este concepto.</p>
<div class="center">
<svg
 viewBox="0.00 0.00 1500.00 650.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g  class="graph" transform="scale(4.1667 4.1667) rotate(0) translate(4 152)">
<title>Tres tablas: la tabla para s contiene solo un puntero a la tabla para s1. La tabla para s1 contiene los datos de la pila para s1 y apunta a los datos de la cadena en la pila.</title>
<desc >Tres tablas: la tabla para s contiene solo un puntero a la tabla para s1. La tabla para s1 contiene los datos de la pila para s1 y apunta a los datos de la cadena en la pila.</desc>
<polygon fill="transparent" stroke="transparent" points="-4,4 -4,-152 357,-152 357,4 -4,4"/>
<!-- table0 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="0,-124 90,-124 "/>
<text text-anchor="start" x="41.2759" y="-129.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s</text>
<polygon fill="none" stroke="var(--fg)" points="0,-104 0,-124 54,-124 54,-104 8,-104"/>
<text text-anchor="start" x="2.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="54,-104 54,-124 90,-124 90,-104 54,-104"/>
<text text-anchor="start" x="56.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="0,-84 0,-104 54,-104 54,-84 8,-84"/>
<text text-anchor="start" x="2.2241" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="54,-84 54,-104 90,-104 90,-84 54,-84"/>
</g>
<!-- table1 -->
<g  class="node">
<polyline fill="none" stroke="var(--fg)" points="122,-124 220,-124 "/>
<text text-anchor="start" x="169.7759" y="-129.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">s1</text>
<polygon fill="none" stroke="var(--fg)" points="122,-104 122,-124 184,-124 184,-104 122,-104"/>
<text text-anchor="start" x="132.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">nombre</text>
<polygon fill="none" stroke="var(--fg)" points="184,-104 184,-124 220,-124 220,-104 184,-104"/>
<text text-anchor="start" x="186.8413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="122,-84 122,-104 184,-104 184,-84 122,-84"/>
<text text-anchor="start" x="124.2241" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">puntero</text>
<polygon fill="none" stroke="var(--fg)" points="184,-84 184,-104 220,-104 220,-84 184,-84"/>
<polygon fill="none" stroke="var(--fg)" points="122,-64 122,-84 184,-84 184,-64 122,-64"/>
<text text-anchor="start" x="124.4482" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">longitud</text>
<polygon fill="none" stroke="var(--fg)" points="184,-64 184,-84 220,-84 220,-64 184,-64"/>
<text text-anchor="start" x="198.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
<polygon fill="none" stroke="var(--fg)" points="122,-44 122,-64 184,-64 184,-44 122,-44"/>
<text text-anchor="start" x="124.6826" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">capacidad</text>
<polygon fill="none" stroke="var(--fg)" points="184,-44 184,-64 220,-64 220,-44 184,-44"/>
<text text-anchor="start" x="198.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">4</text>
</g>
<!-- table0&#45;&gt;table1 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M62,-94C62,-94 93.1184,-94 121.9514,-94"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="112,-97.5001 122,-94 112,-90.5001 112,-97.5001"/>
</g>
<!-- table2 -->
<g  class="node">
<polygon fill="none" stroke="var(--fg)" points="272.5,-104 272.5,-124 309.5,-124 309.5,-104 272.5,-104"/>
<text text-anchor="start" x="275.4482" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">indice</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-104 309.5,-124 345.5,-124 345.5,-104 309.5,-104"/>
<text text-anchor="start" x="312.3413" y="-109.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">valor</text>
<polygon fill="none" stroke="var(--fg)" points="272.5,-84 272.5,-104 309.5,-104 309.5,-84 272.5,-84"/>
<text text-anchor="start" x="287.5" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">0</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-84 309.5,-104 345.5,-104 345.5,-84 309.5,-84"/>
<text text-anchor="start" x="324" y="-89.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">h</text>
<polygon fill="none" stroke="var(--fg)" points="272.5,-64 272.5,-84 309.5,-84 309.5,-64 272.5,-64"/>
<text text-anchor="start" x="287.5" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">1</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-64 309.5,-84 345.5,-84 345.5,-64 309.5,-64"/>
<text text-anchor="start" x="324.3931" y="-69.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">o</text>
<polygon fill="none" stroke="var(--fg)" points="272.5,-44 272.5,-64 309.5,-64 309.5,-44 272.5,-44"/>
<text text-anchor="start" x="287.5" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">2</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-44 309.5,-64 345.5,-64 345.5,-44 309.5,-44"/>
<text text-anchor="start" x="325.5552" y="-49.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">l</text>
<polygon fill="none" stroke="var(--fg)" points="272.5,-24 272.5,-44 309.5,-44 309.5,-24 272.5,-24"/>
<text text-anchor="start" x="287.5" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">3</text>
<polygon fill="none" stroke="var(--fg)" points="309.5,-24 309.5,-44 345.5,-44 345.5,-24 309.5,-24"/>
<text text-anchor="start" x="325.5552" y="-29.8" font-family="Times,serif" font-size="14.00" fill="var(--fg)">a</text>
</g>
<!-- table1&#45;&gt;table2 -->
<g  class="edge">
<path fill="none" stroke="var(--fg)" d="M202,-94C202,-94 233.3406,-94 262.3797,-94"/>
<polygon fill="var(--fg)" stroke="var(--fg)" points="262.5,-97.5001 272.5,-94 262.5,-90.5001 262.5,-97.5001"/>
</g>
</g>
</svg>
</div>
<p><span class="caption">Figura 4-5: Un diagrama de <code>&amp;String s</code> apuntando a <code>String s1</code></span></p>
<blockquote>
<p>Nota: Lo opuesto a la referencia usando <code>&amp;</code> es <em>desreferenciar</em>, que se
logra con el operador de desreferencia, <code>*</code>. Veremos algunos usos del
operador de desreferencia en el Cap√≠tulo 8 y discutiremos detalles de la
desreferenciaci√≥n en el Cap√≠tulo 15.</p>
</blockquote>
<p>Vamos a echar un vistazo m√°s de cerca a la llamada de funci√≥n aqu√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hola&quot;);

    let len = calcular_longitud(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;La longitud de '{s1}' es {len}.&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calcular_longitud(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p>La sintaxis <code>&amp;s1</code> nos permite crear una referencia que <em>se refiere</em> al valor de
<code>s1</code> pero sin ser el propietario. Por este motivo, el valor al que apunta no se
descartar√° cuando la referencia deje de usarse.</p>
<p>Del mismo modo, la firma de la funci√≥n usa <code>&amp;</code> para indicar que el tipo del
par√°metro <code>s</code> es una referencia. Vamos a agregar algunas anotaciones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hola&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calcular_longitud(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;La longitud de '{s1}' es {len}.&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn calcular_longitud(s: &amp;String) -&gt; usize { // es una referencia a un String
    s.len()
} // Aqu√≠, s sale de √°mbito. Pero como no tiene el ownership/la propiedad sino 
  // que s es solo un prestamo, no se destruye, se regresa al propietario, s1.</code></pre></pre>
<p>El contexto de ejecuci√≥n en el que la variable <code>s</code> es v√°lida es el mismo que el contexto de ejecuci√≥n de
cualquier par√°metro de funci√≥n, pero el valor al que apunta la referencia no se
descarta cuando <code>s</code> deja de usarse, porque <code>s</code> no tiene la propiedad. Cuando
las funciones tienen referencias como par√°metros en lugar de los valores
reales, no necesitaremos devolver los valores para devolver la propiedad,
porque nunca tuvimos la propiedad.</p>
<p>Llamamos a la acci√≥n de crear una referencia <em>prestar</em> (borrowing en ingles).
Como en la vida real, si una persona posee algo, puedes pedir prestado.
Cuando termines, tienes que devolverlo. No lo posees.</p>
<p>Entonces, ¬øqu√© pasa si intentamos modificar algo que estamos prestando? Prueba
el c√≥digo en el Listado 4-6. Spoiler alert: ¬°no funciona!</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hola&quot;);

    modificar(&amp;s);
}

fn modificar(un_string: &amp;String) {
    un_string.push_str(&quot;, mundo&quot;);
}</code></pre>
<p><span class="caption">Listado 4-6: Intentando modificar un valor prestado</span></p>
<p>Aqu√≠ est√° el error:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*un_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     un_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ `un_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn modificar(un_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>Al igual que las variables son inmutables por defecto, tambi√©n lo son las
referencias. No se nos permite modificar algo al que tenemos una referencia.</p>
<h3 id="referencias-mutables"><a class="header" href="#referencias-mutables">Referencias Mutables</a></h3>
<p>Podemos arreglar el c√≥digo del Listado 4-6 para permitirnos modificar un valor
prestado con solo unos peque√±os cambios que usen, en su lugar, una
<em>referencia mutable</em>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hola&quot;);

    modificar(&amp;mut s);
}

fn modificar(un_string: &amp;mut String) {
    un_string.push_str(&quot;, mundo&quot;);
}</code></pre></pre>
<p>Primero cambiamos <code>s</code> a <code>mut</code>. Luego creamos una referencia mutable con <code>&amp;mut s</code> donde llamamos a la funci√≥n <code>modificar</code>, y actualizamos la firma de la funci√≥n
para aceptar una referencia mutable con <code>un_string: &amp;mut String</code>. Esto hace
muy claro que la funci√≥n <code>modificar</code> mutar√° el valor que presta.</p>
<p>Las referencias mutables tienen una gran restricci√≥n: si tienes una referencia
mutable a un valor, no puedes tener otras referencias a ese valor. Este c√≥digo
que intenta crear dos referencias mutables a <code>s</code> fallar√°:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hola&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}</span></code></pre>
<p>Aqu√≠ est√° el error:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>Este error dice que este c√≥digo es inv√°lido porque no podemos prestar <code>s</code> como
mutable m√°s de una vez. El primer pr√©stamo mutable est√° en <code>r1</code> y debe
durar hasta que se use en el <code>println!</code>, pero entre la creaci√≥n de esa
referencia mutable y su uso, intentamos crear otra referencia mutable en <code>r2</code>
que presta los mismos datos que <code>r1</code>.</p>
<p>La restricci√≥n que impide m√∫ltiples referencias mutables a los mismos datos al
mismo tiempo permite la mutaci√≥n pero de una manera muy controlada. Es algo
con lo que los nuevos Rustaceans luchan porque la mayor√≠a de los lenguajes te
permiten mutar cuando quieras. El beneficio de tener esta restricci√≥n es que
Rust puede prevenir las carreras de datos en tiempo de compilaci√≥n. Una
<em>carrera de datos</em> es similar a una condici√≥n de carrera y ocurre cuando
ocurren estos tres comportamientos:</p>
<ul>
<li>Dos o m√°s punteros acceden a los mismos datos al mismo tiempo.</li>
<li>Al menos uno de los punteros se est√° utilizando para escribir en los datos.</li>
<li>No hay ning√∫n mecanismo que se est√© utilizando para sincronizar el acceso a
los datos.</li>
</ul>
<p>Las carreras de datos causan un comportamiento indefinido y pueden ser
dif√≠ciles de diagnosticar y corregir cuando intentas rastrearlas en tiempo de
ejecuci√≥n; ¬°Rust evita este problema al negarse a compilar c√≥digo con carreras
de datos!</p>
<p>Como siempre, podemos usar llaves para crear un nuevo contexto de ejecuci√≥n, permitiendo
m√∫ltiples referencias mutables, solo no <em>simult√°neas</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hola&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 se sale de su √°mbito aqu√≠, por lo que no hay problema 
      // si creamos otra referencia mutable

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>Rust impone una regla similar para combinar referencias mutables e inmutables.
Este c√≥digo da como resultado un error:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hola&quot;);

    let r1 = &amp;s; // no hay problema
    let r2 = &amp;s; // no hay problema
    let r3 = &amp;mut s; // ¬° UN GRAN PROBLEMA !

    println!(&quot;{}, {}, y {}&quot;, r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>Aqu√≠ est√° el error:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no hay problema
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no hay problema
6 |     let r3 = &amp;mut s; // ¬° UN GRAN PROBLEMA !
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, y {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>¬°Uf! <em>Tambi√©n</em> no podemos tener una referencia mutable mientras tenemos una
inmutable al mismo valor.</p>
<p>¬°Los usuarios de una referencia inmutable no esperan que el valor cambie
repentinamente debajo de ellos! Sin embargo, se permiten m√∫ltiples referencias
inmutables porque nadie que solo est√° leyendo los datos tiene la capacidad de
afectar la lectura de los datos de nadie m√°s.</p>
<p>Tenga en cuenta que el contexto de ejecuci√≥n de una referencia comienza desde donde se
introduce y contin√∫a hasta la √∫ltima vez que se usa la referencia. Por
ejemplo, este c√≥digo se compilar√° porque el √∫ltimo uso de las referencias
inmutables, el <code>println!</code>, ocurre antes de que se introduzca la referencia
mutable:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no hay problema
    let r2 = &amp;s; // no hay problema
    println!(&quot;{r1} y {r2}&quot;);
    // variables r1 y r2 no se usaran m√°s a partir de aqu√≠

    let r3 = &amp;mut s; // no hay problema
    println!(&quot;{r3}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Los contextos de ejecuci√≥n de las referencias inmutables <code>r1</code> y <code>r2</code> terminan despu√©s del
<code>println!</code> donde se usan por √∫ltima vez, que es antes de que se cree la
referencia mutable <code>r3</code>. Estos contextos de ejecuci√≥n no se superponen, por lo que este c√≥digo
est√° permitido: ¬°el compilador puede decir que la referencia ya no se est√°
utilizando en un punto antes del final del √°mbito!</p>
<p>Aunque los errores de pr√©stamo a veces pueden ser frustrantes, recuerda que
es el compilador de Rust que se√±ala un error potencial temprano (en tiempo de
compilaci√≥n en lugar de en tiempo de ejecuci√≥n) y te muestra exactamente d√≥nde
est√° el problema. Entonces no tienes que rastrear por qu√© tus datos no son lo
que pensabas que eran.</p>
<h3 id="referencias-colgantes"><a class="header" href="#referencias-colgantes">Referencias colgantes</a></h3>
<p>En lenguajes con punteros, es f√°cil crear accidentalmente un <em>puntero colgante</em>:
un puntero que hace referencia a una ubicaci√≥n en la memoria que puede haber
sido otorgada a otra persona, al liberar algo de memoria mientras se preserva
un puntero a esa memoria. En Rust, por el contrario, el compilador garantiza
que las referencias nunca ser√°n referencias colgantes: si tiene una referencia
a alg√∫n dato, el compilador asegurar√° que los datos no salgan de contexto de ejecuci√≥n antes
de que la referencia a los datos lo haga.</p>
<p>Intentemos crear una referencia colgante para ver c√≥mo Rust los previene con un
error de tiempo de compilaci√≥n:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let referencia_a_la_nada = colgar();
}

fn colgar() -&gt; &amp;String {
    let s = String::from(&quot;hola&quot;);

    &amp;s
}</code></pre>
<p>Aqu√≠ est√° el error:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn colgar() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn colgar() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 2 previous errors
</code></pre>
<p>Este mensaje de error se refiere a una caracter√≠stica que a√∫n no hemos cubierto:
los tiempos de vida. Discutiremos los tiempos de vida en detalle en el Cap√≠tulo 
10. Pero, si ignora las partes sobre los tiempos de vida, el mensaje contiene la
clave para saber por qu√© este c√≥digo es un problema:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Se traducir√≠a algo as√≠ como:</p>
<pre><code class="language-text">el tipo de retorno de la funci√≥n contiene un valor prestado, pero no hay ning√∫n 
valor que pueda ser prestado
```

&lt;span class=&quot;filename&quot;&gt;Nombre de archivo: src/main.rs&lt;/span&gt;

```rust,ignore,does_not_compile
# fn main() {
#     let referencia_a_la_nada = colgar();
# }
# 
fn colgar() -&gt; &amp;String { // colgar retorna una referencia a un String

    let s = String::from(&quot;hola&quot;); // s es un nuevo String

    &amp;s // retornamos una referencia a la String, s
} // Aqu√≠, s sale de √°mbito y se libera su memoria. 
  // ¬°Pero retornamos una referencia a ella!
  // ¬°Peligro! ¬°Esta referencia apunta a memoria que ya no existe!
</code></pre>
<p>Porque <code>s</code> se crea dentro de <code>colgar</code>, cuando el c√≥digo de <code>colgar</code> finaliza,
<code>s</code> se desalocar√°. Pero intentamos devolver una referencia a √©l. Eso significa
que esta referencia estar√≠a apuntando a una <code>String</code> inv√°lida. ¬°Eso no est√°
bien! Rust no nos dejar√° hacer esto.</p>
<p>La soluci√≥n aqu√≠ es devolver la <code>String</code> directamente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_colgante();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_colgante() -&gt; String {
    let s = String::from(&quot;hola&quot;);

    s
}</code></pre></pre>
<p>Esto funciona sin problemas. La propiedad se mueve fuera y nada se desaloca.</p>
<h3 id="las-reglas-de-las-referencias"><a class="header" href="#las-reglas-de-las-referencias">Las reglas de las referencias</a></h3>
<p>Repasemos lo que hemos discutido sobre las referencias:</p>
<ul>
<li>En cualquier momento dado, puedes tener <em>o bien</em> una referencia mutable <em>o</em>
cualquier n√∫mero de referencias inmutables.</li>
<li>Las referencias deben ser siempre v√°lidas.</li>
</ul>
<p>A continuaci√≥n, veremos un tipo diferente de referencia: los slices.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="el-tipo-slice"><a class="header" href="#el-tipo-slice">El Tipo Slice</a></h2>
<p>Los <em>Slices</em> te permiten referenciar a una secuencia contigua de elementos
en una <a href="ch08-00-common-collections.html">colecci√≥n</a> en lugar de la colecci√≥n completa. Un slice es una especie de
referencia, por lo que no tiene ownership.</p>
<p>Aqu√≠ hay un peque√±o problema de programaci√≥n: escribe una funci√≥n que tome un
string de palabras separadas por espacios y retorne la primera palabra que
encuentre en ese string.
Si la funci√≥n no encuentra ning√∫n espacio en el string, todo el string debe ser
una sola palabra, por lo que se debe retornar todo el string.</p>
<p>Trabajemos en c√≥mo escribir√≠amos la firma de esta funci√≥n sin usar slices,
para entender el problema que los slices resolver√°n:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>La funci√≥n <code>first_word</code> tiene un <code>&amp;String</code> como par√°metro. No queremos el
ownership, as√≠ que esto est√° bien. Pero ¬øQue deber√≠amos retornar? Realmente no
tenemos una forma de hablar sobre &quot;una <em>porci√≥n</em> de un string&quot;. Sin embargo,
podr√≠amos retornar el √≠ndice del final de la palabra, indicado por un espacio.
Probemos eso, como se muestra en Listing 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 4-7: La funci√≥n <code>first_word</code> retorna un
valor de √≠ndice en bytes dentro de un par√°metro <code>String</code></span></p>
<p>Dado que necesitamos recorrer el <code>String</code> elemento por elemento y comprobar si
un valor es un espacio, convertiremos nuestro <code>String</code> a un array de bytes
usando el m√©todo <code>as_bytes</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>A continuaci√≥n, creamos un iterator sobre el array de bytes utilizando el m√©todo
<code>iter</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Hablaremos m√°s detalladamente sobre los iterators en <a href="ch13-02-iterators.html">Procesando una serie de
elementos con Iteradores</a><!-- ignore -->. Por ahora, sabemos que <code>iter</code> es
un m√©todo que retorna cada elemento en una colecci√≥n y que <code>enumerate</code> envuelve
el resultado de <code>iter</code> y retorna cada elemento como parte de una tupla. El
primer elemento de la tupla que retorna <code>enumerate</code> es el √≠ndice, y el segundo
elemento es una referencia al elemento.
Esto es un poco m√°s conveniente que calcular el √≠ndice nosotros mismos.</p>
<p>Debido a que el m√©todo <code>enumerate</code> retorna una tupla, podemos usar patrones para
desestructurar esa tupla. Hablaremos m√°s sobre los patrones en
<a href="ch06-02-match.html#patrones-que-vinculan-valores">Patrones que vinculan valores</a><!-- ignore -->. En el ciclo <code>for</code>,
especificamos un patr√≥n que tiene <code>i</code> para el √≠ndice de la tupla e <code>&amp;item</code> para
el byte √∫nico en la tupla. Debido a que tomamos una referencia al elemento de
<code>.iter().enumerate()</code>, podemos usar<code>&amp;</code> en el patr√≥n.</p>
<p>Dentro del ciclo <code>for</code>, buscamos el byte que representa el espacio usando
la sintaxis literal del byte. Si encontramos un espacio, retornamos su posici√≥n.
De lo contrario, retornamos la longitud del string usando <code>s.len()</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Ahora tenemos una forma de averiguar el √≠ndice del final de la primera palabra
en el string, pero tenemos un problema. Estamos retornando un <code>usize</code> por si
solo, pero es solo un n√∫mero significativo en el contexto de √©l <code>&amp;String</code>.
En otras palabras, debido a que es un valor separado del <code>String</code>, no hay
garant√≠a de que siga siendo v√°lido en el futuro. Considera el programa en
Listing 4-8 que usa la funci√≥n <code>first_word</code> del Listing 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word obtendr√° el valor 5

    s.clear(); // esto &quot;vac√≠a&quot; el String, dejando s igual a &quot;&quot;

    // word a√∫n tiene el valor 5 aqu√≠, pero ya no hay un string para que
    // usar el valor 5 tenga sentido, ¬°word es totalmente invalida!
}</code></pre></pre>
<p><span class="caption">Listing 4-8: Almacenando el resultado de llamar a
la funci√≥n <code>first_word</code> y luego cambiar el contenido del <code>String</code></span></p>
<p>Este programa compila sin errores y tambi√©n lo har√° si us√°ramos <code>word</code> despu√©s
de llamar a <code>s.clear()</code>. Debido a que <code>word</code> no est√° conectado al estado de <code>s</code>
en absoluto, <code>word</code> a√∫n contiene el valor <code>5</code>. Podr√≠amos usar el valor <code>5</code> con
la variable <code>s</code> para intentar extraer la primera palabra, pero esto ser√≠a un
error porque el contenido de <code>s</code> ha cambiado desde que guardamos <code>5</code> en <code>word</code>.</p>
<p>¬°Tener que preocuparse de que el √≠ndice de <code>word</code> no est√© sincronizado con los
datos en <code>s</code> es tedioso y propenso a errores! El manejo de estos √≠ndices es a√∫n
m√°s fr√°gil si escribimos una segunda funci√≥n llamada <code>second_word</code>.
Su firma deber√≠a ser algo como esto:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Ahora que estamos rastreando tanto el √≠ndice de inicio como el de fin, <em>y</em>
tenemos a√∫n m√°s que se calcularon a partir de los datos en un estado particular,
pero que no est√°n vinculados a ese estado en absoluto. Tenemos tres variables no
relacionados flotando por ahi que necesitan mantenerse sincronizadas.</p>
<p>Afortunadamente, Rust tiene una soluci√≥n a este problema: los string slices.</p>
<h3 id="string-slices"><a class="header" href="#string-slices">String Slices</a></h3>
<p>Un <em>string slice</em> es una referencia de parte de un <code>String</code>, y se ve algo como
esto:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>En lugar de referenciar todo el <code>String</code>, <code>hello</code> es una referencia a una
porci√≥n del <code>String</code>, especificada en el segmento adicional <code>[0..5]</code>. Creamos
slices usando un rango dentro de corchetes, especificando
<code>[starting_index..ending_index]</code>, donde <code>starting_index</code> es la primera posici√≥n
en el slice y <code>ending_index</code> es una posici√≥n m√°s que la √∫ltima posici√≥n en el
slice. Internamente, la estructura de datos del slice almacena la posici√≥n
inicial y la longitud del slice, lo que corresponde a <code>ending_index</code> menos
<code>starting_index</code>. Por lo tanto, en el caso de <code>let world = &amp;s[6..11];</code>, <code>world</code>
ser√≠a un slice que contiene un puntero al byte en el √≠ndice 6 de <code>s</code> con un
valor de longitud de <code>5</code>.</p>
<p>Figure 4-6 muestra esto en el diagrama.</p>
<p><img alt="Three tables: a table representing the stack data of s, which points
to the byte at index 0 in a table of the string data &quot;hello world&quot; on
the heap. The third table rep-resents the stack data of the slice world, which
has a length value of 5 and points to byte 6 of the heap data table."
src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-6: String slice referencia una parte de un
<code>String</code></span></p>
<p>Con la sintaxis de rango <code>..</code> de Rust, si queremos comenzar en el √≠ndice 0,
podemos dejar el valor antes de los dos puntos. En otras palabras, estos son
iguales:</p>
<pre><code class="language-rut">let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
</code></pre>
<p>Del mismo modo, si el slice incluye el √∫ltimo byte del <code>String</code>, podemos
eliminar el n√∫mero final. Esto significa que son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>Tambi√©n podemos omitir ambos valores para tomar un slice de todo el string.
Entonces estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Nota: Los √≠ndices del rango del string slice deben ocurrir en l√≠mites v√°lidos
de caracteres UTF-8. Si intentamos crear un string slice en medio de un
caracter multibyte, tu programa saldr√° con un error. Para fines de
introducci√≥n a los string slices, estamos asumiendo solo ASCII en esta
secci√≥n; una discusi√≥n m√°s completa sobre el manejo de UTF-8 se encuentra
en la secci√≥n <a href="ch08-02-strings.html#almacenando-texto-codificado-en-utf-8-con-strings">Almacenando texto codificado en UTF-8 con Strings</a><!-- ignore --> del
Cap√≠tulo 8.</p>
</blockquote>
<p>Con toda esta informaci√≥n en mente, reescribamos <code>first_word</code> para retornar un
slice. El tipo que significa ‚Äústring slice‚Äù se escribe como <code>&amp;str</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Obtenemos el √≠ndice para el final de la palabra de la misma manera que lo
hicimos en el Listing 4-7, buscando la primera aparici√≥n de un espacio. Cuando
encontramos un espacio, retornamos un string slice usando el inicio del string
y el √≠ndice del espacio como √≠ndices de inicio y final.</p>
<p>Ahora cuando llamamos a <code>first_word</code>, obtenemos un √∫nico valor que est√°
vinculado a los datos subyacentes. El valor se compone de una referencia al
punto de inicio del slice y el n√∫mero de elementos en el slice.</p>
<p>Retornando el slice tambi√©n funcionar√≠a para la funci√≥n <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Ahora tenemos una API sencilla que es mucho m√°s dif√≠cil de estropear porque el
compilador se asegurar√° de que las referencias dentro del <code>String</code> sigan siendo
v√°lidas. ¬øRecuerdas el error en el programa en Listing 4-8, cuando obtuvimos
el √≠ndice para el final de la primera palabra, pero luego limpiamos el string
de modo que nuestro √≠ndice era inv√°lido? Ese c√≥digo era l√≥gicamente incorrecto,
pero no mostraba errores inmediatos. Los problemas aparecer√≠an m√°s tarde si
seguimos intentando usar el √≠ndice de la primera palabra con un string vac√≠o.
Los Slices hacen que este error sea imposible y nos permiten saber que tenemos
un problema en nuestro c√≥digo mucho antes. El uso de la versi√≥n slice de
<code>first_word</code> arrojar√° un error en tiempo de compilaci√≥n:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {word}&quot;);
}</code></pre>
<p>Aqu√≠ est√° el error del compilador:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!(&quot;the first word is: {word}&quot;);
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin &quot;ownership&quot;) due to 1 previous error
</code></pre>
<p>Recordemos que las reglas del borrowing si tenemos una referencia immutable a
algo, no podemos tomar tambi√©n una referencia mutable. Debido a que <code>clear</code>
necesita truncar el <code>String</code>, necesita obtener una referencia mutable.
El <code>println!</code> despu√©s de la llamada a <code>clear</code> usa la referencia en <code>word</code>,
por lo que la referencia inmutable debe seguir activa en ese punto. Rust
impide que la referencia mutable en <code>clear</code> y la referencia inmutable en <code>word</code>
existan al mismo tiempo, y la compilaci√≥n falla. No solo Rust ha hecho m√°s f√°cil
nuestra API, sino que tambi√©n ha eliminado una clase entera de errores en tiempo
de compilaci√≥n.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="string-literales-como-slices"><a class="header" href="#string-literales-como-slices">String Literales como Slices</a></h4>
<p>Recordemos que hablamos sobre que los string literales se almacenan dentro
del binario. Ahora que sabemos sobre los slices, podemos entender correctamente
los string literales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}</span></code></pre></pre>
<p>El tipo de <code>s</code> aqu√≠ es <code>&amp;str</code>: es un slice apuntando a ese punto espec√≠fico
del binario. Esto tambi√©n es por qu√© los literales de string son inmutables;
<code>&amp;str</code> es una referencia inmutable.</p>
<h4 id="string-slices-as-parameters"><a class="header" href="#string-slices-as-parameters">String Slices as Parameters</a></h4>
<p>Conociendo que puedes tomar slices de literales y valores <code>String</code> nos lleva
a una mejora m√°s en <code>first_word</code>, y es su firma:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Un Rustacean m√°s experimentado escribir√≠a la firma mostrada en el Listing 4-9
en su lugar porque nos permite usar la misma funci√≥n en ambos valores <code>&amp;String</code>
y <code>&amp;str</code>.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `first_word` funciona con slices de un string, sean parciales o completos.
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` tambi√©n funciona con referencias de un string, que son equivalentes
</span><span class="boring">    // a un slice completo de un String
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `first_word` funciona con slices de string literales, sean parciales o completos
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Por que los strings literales son slices de strings,esto tambi√©n funciona,
</span><span class="boring">    // sin necesidad de usar la sintaxis de slices.
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 4-9:
Mejorando la funci√≥n <code>first_word</code> usando un string slice como par√°metro
para el tipo del par√°metro de<code>s</code></span></p>
<p>Si tenemos un string slice, podemos pasar directamente ese valor. Si tenemos
un <code>String</code>, podemos pasar un slice del <code>String</code> o una referencia al <code>String</code>.
Esta flexibilidad aprovecha las <em>deref coercions</em>, una caracter√≠stica que
veremos en la secci√≥n
<a href="ch15-02-deref.html#coerciones-implicitas-de-deref-con-funciones-y-metodos">&quot;Tratando los Smart Pointers como Referencias Regulares con el Trait Deref&quot;</a><!--ignore-->
del Cap√≠tulo 15.</p>
<p>Definir una funci√≥n para tomar un string slice en lugar de una referencia a un
<code>String</code> hace que nuestra API sea m√°s general y √∫til sin perder ninguna
funcionalidad:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // `first_word` funciona con slices de un string, sean parciales o completos.
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` tambi√©n funciona con referencias de un string, que son equivalentes
    // a un slice completo de un String
    let word = first_word(&amp;my_string);

    let my_string_literal = &quot;hello world&quot;;

    // `first_word` funciona con slices de string literales, sean parciales o completos
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Por que los strings literales son slices de strings,esto tambi√©n funciona,
    // sin necesidad de usar la sintaxis de slices.
    let word = first_word(my_string_literal);
}</code></pre></pre>
<h3 id="otros-slices"><a class="header" href="#otros-slices">Otros Slices</a></h3>
<p>Los string slices, como puedes imaginar, son espec√≠ficos para strings. Pero
hay un tipo de slice m√°s general. Considera este array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>As√≠ como podemos querer referirnos a parte de un string, tambi√©n podemos querer
referirnos a parte de un array. Lo har√≠amos de esta manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>Este slice tiene el tipo <code>&amp;[i32]</code>. Funciona de la misma manera que los slices
de string, almacenando una referencia al primer elemento y una longitud. Usar√°s
este tipo de slice para todo tipo de colecciones. Hablaremos de estas
colecciones en detalle cuando veamos vectores en el Cap√≠tulo 8.</p>
<h2 id="resumen-3"><a class="header" href="#resumen-3">Resumen</a></h2>
<p>Los conceptos de ownership, borrowing, y slices aseguran la seguridad de la
memoria en los programas Rust en tiempo de compilaci√≥n. El lenguaje Rust te
da control sobre el uso de la memoria de la misma manera que otros lenguajes
de programaci√≥n de sistemas, pero el hecho de que el propietario de los datos
limpie autom√°ticamente esos datos cuando salen del scope significa que no tienes
que escribir y depurar c√≥digo extra para obtener este control.</p>
<p>El ownership afecta a c√≥mo funcionan otras partes de Rust, as√≠ que hablaremos
de estos conceptos m√°s adelante en el libro. Vamos a pasar al Cap√≠tulo 5 y
ver c√≥mo agrupar piezas de datos en un <code>struct</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usando-structs-para-estructurar-datos-relacionados"><a class="header" href="#usando-structs-para-estructurar-datos-relacionados">Usando Structs para Estructurar Datos Relacionados</a></h1>
<p>Un <em>struct</em>, o <em>estructura</em>, es un tipo de dato personalizado que te permite 
empaquetar y nombrar m√∫ltiples valores relacionados que forman un grupo
significativo. Si est√°s familiarizado con un lenguaje orientado a objetos, 
un <em>struct</em> es como los atributos de un objeto. En este cap√≠tulo, 
compararemos y contrastaremos tuplas con structs para desarrollar lo que ya
sabes y demostrar cuando los structs son una mejor manera de agrupar datos.</p>
<p>Demostraremos c√≥mo definir e instanciar structs. Discutiremos como definir
funciones asociadas, especialmente, el tipo de funciones asociadas llamadas
<em>m√©todos</em>, para especificar el comportamiento asociado con un tipo de struct. 
Los structs y enums (discutidos en el cap√≠tulo 6) son los bloques de 
construcci√≥n para crear nuevos tipos en el dominio de tu programa para
aprovechar al m√°ximo la comprobaci√≥n de tipos en tiempo de compilaci√≥n de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definiendo-e-instanciando-structs"><a class="header" href="#definiendo-e-instanciando-structs">Definiendo e Instanciando Structs</a></h2>
<p>Los Structs son similares a las tuplas, discutido en la secci√≥n
<a href="ch03-02-data-types.html#el-tipo-tupla">‚ÄúThe Tuple Type‚Äù</a><!--ignore --> en ambos casos mantenemos m√∫ltiples
valores relativos. Como en las tuplas, las partes de un struct pueden ser de
diferentes tipos. A diferencia de las tuplas, en un struct t√∫ nombras a cada
pieza de datos para que quede claro, que significan estos valores.
Agregando estos nombres significa que los structs son m√°s flexibles
que las tuplas: no tienes que confiar en el orden de los datos para especificar o
acceder a los valores de una instancia.</p>
<p>Para definir un struct, debemos usar la palabra clave <code>struct</code> y el nombre del struct completo.
El nombre del struct debe describir el significado de los datos que se agrupan.
Entonces, entre llaves, definimos los nombres y tipos de datos, que llamaremos
<em>campos</em>. Por ejemplo, en el Listing 5-1 mostramos una definici√≥n de un struct
que almacena informaci√≥n sobre una cuenta de usuario.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 5-1: Una definici√≥n de struct <code>User</code></span></p>
<p>Para usar un struct despu√©s de haberlo definido, creamos una <em>instancia</em> de ese
struct especificando valores concretos para cada uno de los campos. Creamos una
instancia al declarar el nombre del struct y luego agregar llaves que contienen
<em>clave: valor</em> pares, donde las claves son los nombres de los campos y los
valores son los datos que queremos almacenar en esos campos. No tenemos que
especificar los campos en el mismo orden en el que los declaramos en el struct.
En otras palabras, la definici√≥n del struct es como una plantilla general para
el tipo, y las instancias llenan esa plantilla con datos particulares para
crear valores del tipo. Por ejemplo, podemos declarar un usuario en particular
como se muestra en el Listing 5-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from(&quot;someusername123&quot;),
        email: String::from(&quot;someone@example.com&quot;),
        sign_in_count: 1,
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-2: Creando una instancia del struct <code>User</code>
</span></p>
<p>Para acceder a un valor espec√≠fico de un struct, usamos la notaci√≥n de punto.
Por ejemplo, para acceder a la direcci√≥n de correo electr√≥nico de este usuario,
usamos <code>user1.email</code>. Si la instancia es mutable, podemos cambiar un valor
asignando en un campo particular. El Listing 5-3 muestra c√≥mo cambiar el valor
en el campo <code>email</code> de una instancia mutable de <code>User</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from(&quot;someusername123&quot;),
        email: String::from(&quot;someone@example.com&quot;),
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 5-3: Cambiando el valor en el campo <code>email</code> de una
instancia <code>User</code></span></p>
<p>Nota que toda la instancia debe ser mutable; Rust no nos permite marcar solo
ciertos campos como mutables. Como cualquier expresi√≥n, podemos construir una
nueva instancia del struct como la √∫ltima expresi√≥n en el cuerpo de la funci√≥n
para devolver impl√≠citamente esa nueva instancia.</p>
<p>Listing 5-4 muestra una funci√≥n <code>build_user</code> que devuelve una instancia de
<code>User</code> con el correo electr√≥nico y el nombre de usuario dados. El campo
<code>active</code> obtiene el valor de <code>true</code>, y el campo <code>sign_in_count</code> obtiene el
valor de <code>1</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-4: Una funci√≥n <code>build_user</code> que toma un email
y username y devuelve una instancia <code>User</code></span></p>
<p>Tiene sentido nombrar los par√°metros de la funci√≥n con el mismo nombre que los
campos del struct, pero tener que repetir los nombres de los campos y
variables <code>email</code> y <code>username</code> es un poco tedioso. Si el struct tuviera m√°s
campos, repetir cada nombre ser√≠a a√∫n m√°s molesto. Afortunadamente, hay una
conveniente forma abreviada.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="usando-la-abreviatura-field-init"><a class="header" href="#usando-la-abreviatura-field-init">Usando la abreviatura Field Init</a></h3>
<p>Debido a que los nombres de los par√°metros y los nombres de los campos del
struct son exactamente los mismos en el Listing 5-4, podemos usar la <em>abreviatura
Field Init</em> para reescribir <code>build_user</code> para que se comporte exactamente igual
pero no tenga la repetici√≥n de <code>username</code> y <code>email</code>, como se muestra en el
Listing 5-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-5: Una funci√≥n <code>build_user</code> que usa field init
abreviado porque los par√°metros <code>username</code> e <code>email</code> tienen el mismo nombre que
los campos del struct</span></p>
<p>Aqu√≠, estamos creando una nueva instancia del struct <code>User</code>, que tiene un
campo llamado <code>email</code>. Queremos establecer el valor del campo <code>email</code> en el
valor del par√°metro <code>email</code> de la funci√≥n <code>build_user</code>. Debido a que el campo
<code>email</code> y el par√°metro <code>email</code> tienen el mismo nombre, solo necesitamos escribir
<code>email</code> en lugar de <code>email: email</code>.</p>
<h3 id="creando-instancias-de-otras-instancias-con-sintaxis-de-struct-update"><a class="header" href="#creando-instancias-de-otras-instancias-con-sintaxis-de-struct-update">Creando Instancias de Otras Instancias con Sintaxis de Struct Update</a></h3>
<p>Suele ser √∫til crear una nueva instancia de un struct que incluya la mayor√≠a de
los valores de otra instancia, pero cambie algunos. Puede hacer esto usando la
<em>sintaxis de struct update</em>.</p>
<p>Primero, en el Listing 5-6 mostramos c√≥mo crear una nueva instancia de <code>User</code>
regularmente, sin la sintaxis de actualizaci√≥n. Establecemos un nuevo valor para
<code>email</code>, pero de lo contrario usamos los mismos valores de <code>user1</code> que creamos
en el Listing 5-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-6: Creando una nueva instancia <code>User</code> usando uno
de los valores de <code>user1</code></span></p>
<p>Usando la sintaxis de struct update, podemos lograr el mismo efecto con menos
c√≥digo, como se muestra en el Listing 5-7. La sintaxis <code>..</code> especifica que los
campos restantes que no se establecen expl√≠citamente deben tener el mismo valor
que los campos en la instancia dada.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
}</code></pre></pre>
<p><span class="caption">Listing 5-7: Usando una sintaxis de struct update para
introducir un nuevo valor <code>email</code> para una instancia <code>User</code> pero para usar el
resto de los valores de <code>user1</code></span></p>
<p>El c√≥digo en el Listing 5-7 tambi√©n crea una instancia en <code>user2</code> que tiene un
valor diferente para <code>email</code> pero tiene los mismos valores para los campos
<code>username</code>, <code>active</code> y <code>sign_in_count</code> de <code>user1</code>. √âl <code>..user1</code> debe ir al
final para especificar que cualquier campo restante debe obtener sus valores
del campo correspondiente en <code>user1</code>, pero podemos elegir especificar valores
para tantos campos como queramos en cualquier orden, independientemente del
orden de los campos en la definici√≥n del struct.</p>
<p>Nota que la sintaxis de update struct usa <code>=</code> como una asignaci√≥n; esto es
porque mueve los datos, como vimos en la secci√≥n <a href="ch04-01-what-is-ownership.html#variables-y-datos-interactuando-con-move">‚ÄúVariables y datos
interactuando con Move‚Äù</a><!-- ignore -->. En este ejemplo, ya no podemos
usar <code>user1</code> como un todo despu√©s de crear <code>user2</code> porque el <code>String</code> en el
campo <code>username</code> de <code>user1</code> se movi√≥ a <code>user2</code>. Si hubi√©ramos dado a <code>user2</code>
nuevos valores <code>String</code> para <code>email</code> y <code>username</code>, y por lo tanto solo usamos
los valores de <code>active</code> y <code>sign_in_count</code> de <code>user1</code>, entonces <code>user1</code> todav√≠a
ser√≠a v√°lido despu√©s de crear <code>user2</code>. Tanto <code>active</code> como <code>sign_in_count</code> son
tipos que implementan la trait <code>Copy</code>, por lo que el comportamiento que
discutimos en la secci√≥n <a href="ch04-01-what-is-ownership.html#solo-datos-del-stack-copiar">‚ÄúDatos de pila: Copy‚Äù</a><!-- ignore --> se
aplicar√≠a.</p>
<h3 id="usando-structs-de-tuplas-sin-campos-nombrados-para-crear-diferentes-tipos"><a class="header" href="#usando-structs-de-tuplas-sin-campos-nombrados-para-crear-diferentes-tipos">Usando Structs de Tuplas sin Campos Nombrados para Crear Diferentes Tipos</a></h3>
<p>Rust tambi√©n admite structs que se parecen a tuplas, llamados <em>structs de
tuplas</em>. Los structs de tuplas tienen el significado adicional que proporciona
el nombre del struct, pero no tienen nombres asociados a sus campos; en su
lugar, solo tienen los tipos de los campos. Los structs de tuplas son √∫tiles
cuando desea darle un nombre al conjunto completo y hacer que el conjunto sea
un tipo diferente de otros conjuntos, y cuando nombrar cada campo como en un
struct regular ser√≠a verboso o redundante.</p>
<p>Para definir un struct de tupla, comience con la palabra clave <code>struct</code> y el
nombre del struct seguido por los tipos en la tupla. Por ejemplo, aqu√≠
definimos y usamos dos structs de tupla llamados <code>Color</code> y <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
<p>Nota que los valores <code>black</code> y <code>origin</code> son diferentes tipos porque son
instancias de diferentes structs de tupla. Cada struct que defina es su propio
tipo, incluso si los campos dentro del struct tienen los mismos tipos. Por
ejemplo, una funci√≥n que toma un par√°metro de tipo <code>Color</code> no puede tomar un
<code>Point</code> como argumento, incluso si ambos tipos est√°n compuestos por tres
valores <code>i32</code>. De lo contrario, las instancias de structs de tupla son
similares a las tuplas en que puede descomponerlas en sus piezas individuales,
y puede usar un <code>.</code> seguido por el √≠ndice para acceder a un valor individual.</p>
<h3 id="structs-de-unidad-sin-campos"><a class="header" href="#structs-de-unidad-sin-campos">Structs de Unidad sin Campos</a></h3>
<p>Tambi√©n puede definir structs que no tienen ning√∫n campo. Estos se llaman
<em>structs de unidad</em> porque se comportan de manera similar a <code>()</code>, el tipo de
unidad que mencionamos en la secci√≥n <a href="ch03-02-data-types.html#el-tipo-tupla">‚ÄúEl tipo de tupla‚Äù</a><!-- ignore
-->. Los structs de unidad pueden ser √∫tiles cuando necesita implementar un
trait en alg√∫n tipo, pero no tiene datos que desea almacenar en el tipo
propio. Discutiremos los traits en el Cap√≠tulo 10. Aqu√≠ hay un ejemplo de
declarar e instanciar un struct de unidad llamado <code>AlwaysEqual</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<p>Para definir <code>AlwaysEqual</code>, usamos la palabra clave <code>struct</code>, el nombre que
queremos y luego un punto y coma. ¬°No se necesitan llaves ni par√©ntesis! Luego
podemos obtener una instancia de <code>AlwaysEqual</code> en la variable <code>subject</code> de la
misma manera: usando el nombre que definimos, sin llaves ni par√©ntesis.
Imagina que m√°s tarde implementaremos un comportamiento para este tipo de tal
manera que cada instancia de <code>AlwaysEqual</code> siempre sea igual a cada instancia
de cualquier otro tipo, tal vez para tener un resultado conocido para fines de
prueba. No necesitar√≠amos ning√∫n dato para implementar ese comportamiento.
Ver√°s en el Cap√≠tulo 10 c√≥mo definir traits e implementarlos en cualquier
tipo, incluidos los structs de unidad.</p>
<blockquote>
<h3 id="ownership-de-los-datos-de-struct"><a class="header" href="#ownership-de-los-datos-de-struct">Ownership de los datos de Struct</a></h3>
<p>En el struct <code>User</code> de la definici√≥n en el Listing 5-1, usamos el tipo
<code>String</code> en lugar del tipo <code>&amp;str</code> de la cadena de caracteres. Esta es una
elecci√≥n deliberada porque queremos que cada instancia de este struct tenga
todos sus datos y que esos datos sean v√°lidos durante todo el tiempo que el
struct sea v√°lido.</p>
<p>Tambi√©n es posible para los structs almacenar referencias a datos que son
propiedad de algo m√°s, pero para hacerlo requiere el uso de <em>lifetimes</em>, una
caracter√≠stica de Rust que discutiremos en el Cap√≠tulo 10. Los lifetimes
garantizan que los datos referenciados por un struct sean v√°lidos durante el
tiempo que el struct sea v√°lido. Digamos que intentas almacenar una
referencia en un struct sin especificar lifetimes, como el siguiente; esto
no funcionar√°:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: &quot;someusername123&quot;,
        email: &quot;someone@example.com&quot;,
        sign_in_count: 1,
    };
}</code></pre>
<p>El compilador se quejar√° de que necesita especificadores de lifetime:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin &quot;structs&quot;) due to 2 previous errors
</code></pre>
<p>En el Cap√≠tulo 10, discutiremos como solucionar estos errores para que puedas
almacenar referencias en structs, pero por ahora, solucionaremos los errores
usando tipos propios como <code>String</code> en lugar de referencias como <code>&amp;str</code>.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="un-programa-de-ejemplo-usando-structs"><a class="header" href="#un-programa-de-ejemplo-usando-structs">Un Programa de Ejemplo Usando Structs</a></h2>
<p>Para entender cu√°ndo podr√≠amos querer usar structs, vamos a escribir un
programa que calcule el √°rea de un rect√°ngulo. Empezaremos usando variables
individuales, y luego refactorizaremos el programa hasta que estemos usando
structs.</p>
<p>Hagamos un nuevo proyecto binario con Cargo llamado <em>rectangles</em> que tomar√°
el ancho y el alto de un rect√°ngulo especificado en p√≠xeles y calcular√° el √°rea
del rect√°ngulo. La lista 5-8 muestra un programa corto con una forma de hacer
exactamente eso en el <em>src/main.rs</em> de nuestro proyecto.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<p><span class="caption">Listing 5-8: Calculando el √°rea de un rect√°ngulo
especificado por separado en variables ancho y alto</span></p>
<p>Ahora, ejecuta este programa usando <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>Este c√≥digo logra calcular el √°rea del rect√°ngulo llamando a la funci√≥n <code>area</code>
con cada dimensi√≥n, pero podemos hacer m√°s para hacer este c√≥digo claro y
legible.</p>
<p>El problema con este c√≥digo es evidente en la firma de <code>area</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>La funci√≥n <code>area</code> est√° supuestamente para calcular el √°rea de un rect√°ngulo, pero
la funci√≥n que escribimos tiene dos par√°metros, y no est√° claro en ning√∫n
lugar de nuestro programa que los par√°metros est√°n relacionados. Ser√≠a m√°s
legible y m√°s manejable agrupar el ancho y el alto juntos. Ya hemos discutido
una forma de hacerlo en la secci√≥n <a href="ch03-02-data-types.html#el-tipo-tupla">‚ÄúEl Tipo Tupla‚Äù</a><!-- ignore
--> del Cap√≠tulo 3: usando tuplas.</p>
<h3 id="refactorizando-con-tuplas"><a class="header" href="#refactorizando-con-tuplas">Refactorizando con Tuplas</a></h3>
<p>Listings 5-9 muestra otra versi√≥n de nuestro programa que usa tuplas.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<p><span class="caption">Listing 5-9: Especificando el ancho y alto del
rect√°ngulo con una tupla</span></p>
<p>En un sentido, este programa es mejor. Las tuplas nos permiten agregar un poco
de estructura, y ahora estamos pasando solo un argumento. Pero en otro sentido,
esta versi√≥n es menos clara: las tuplas no nombran sus elementos, por lo que
tenemos que indexar los componentes de la tupla, haciendo que nuestro
c√°lculo sea menos obvio.</p>
<p>Mezclar el ancho y el alto no importar√≠a para el c√°lculo del √°rea, pero si
queremos dibujar el rect√°ngulo en la pantalla, ¬°importar√≠a! Tendr√≠amos que
tener en cuenta que <code>width</code> es el √≠ndice de la tupla <code>0</code> y <code>height</code> es el √≠ndice
de la tupla <code>1</code>. ¬°Esto ser√≠a a√∫n m√°s dif√≠cil para que otra persona lo
descubriera y lo tuviera en cuenta si usara nuestro c√≥digo! Debido a que no
hemos transmitido el significado de nuestros datos en nuestro c√≥digo, ahora es
m√°s f√°cil introducir errores.</p>
<h3 id="refactorizando-con-structs-a√±adiendo-m√°s-significado"><a class="header" href="#refactorizando-con-structs-a√±adiendo-m√°s-significado">Refactorizando con Structs: A√±adiendo M√°s Significado</a></h3>
<p>Hemos usado structs para agregar significado al etiquetar los datos. Podemos
transformar la tupla que estamos usando en un struct con un nombre para la estructura y nombres para los campos, como se muestra en la lista 5-10.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<p><span class="caption">Listing 5-10: Definiendo un struct <code>Rectangle</code></span></p>
<p>Hemos definido un struct y lo hemos llamado <code>Rectangle</code>. Dentro de las llaves,
hemos definido los campos como <code>width</code> y <code>height</code>, ambos de los cuales tienen
el tipo <code>u32</code>. Luego, en <code>main</code>, hemos creado una instancia particular de
<code>Rectangle</code> que tiene un ancho de <code>30</code> y un alto de <code>50</code>.</p>
<p>Nuestra funci√≥n <code>area</code> ahora toma un argumento que es una referencia a una
instancia de <code>Rectangle</code> en lugar de dos par√°metros num√©ricos. En la funci√≥n,
usamos el punto para acceder a los campos de la instancia de <code>Rectangle</code> que
recibimos como argumento. En <code>main</code>, creamos una instancia de <code>Rectangle</code> y
llamamos a la funci√≥n <code>area</code> con la instancia de <code>Rectangle</code> como argumento.</p>
<p>La funci√≥n <code>area</code> accede a los campos de <code>width</code> y <code>height</code> de la instancia de
<code>Rectangle</code> (tenga en cuenta que acceder a los campos de una instancia de
estructura prestada no mueve los valores de los campos, por lo que a menudo
ve pr√©stamos de estructuras). Nuestra firma de funci√≥n para <code>area</code> ahora dice
exactamente lo que queremos: calcular el √°rea de <code>Rectangle</code>, usando sus
campos <code>width</code> y <code>height</code>. Esto conduce a que el ancho y el alto est√©n
relacionados entre s√≠, y da nombres descriptivos a los valores en lugar de
usar los valores de √≠ndice de tupla de <code>0</code> y <code>1</code>. ¬°Esto es una victoria para
la claridad!</p>
<h3 id="a√±adiendo-funcionalidad-√ötil-con-traits-derivados"><a class="header" href="#a√±adiendo-funcionalidad-√ötil-con-traits-derivados">A√±adiendo Funcionalidad √ötil con Traits Derivados</a></h3>
<p>Ser√≠a √∫til poder imprimir una instancia de <code>Rectangle</code> mientras estamos
depurando nuestro programa y ver los valores de todos sus campos. La lista 5-11
intenta usar la macro <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a><!-- ignore --> como hemos usado en
cap√≠tulos anteriores. Sin embargo, esto no funcionar√°.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {}&quot;, rect1);
}</code></pre>
<p><span class="caption">Listing 5-11: Intentando imprimir una instancia de
<code>Rectangle</code></span></p>
<p>Cuando compilamos este c√≥digo, obtenemos un error con este mensaje principal:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>La macro <code>println!</code> puede hacer muchos tipos de formateo, y por defecto, las
llaves curvas le dicen a <code>println!</code> que use el formateo conocido como
<code>Display</code>: salida destinada al consumo directo del usuario final. Los tipos
primitivos que hemos visto hasta ahora implementan <code>Display</code> por defecto
porque solo hay una forma en que querr√≠as mostrar un <code>1</code> u otro tipo
primitivo a un usuario. Pero con las estructuras, la forma en que <code>println!</code>
debe formatear la salida es menos clara porque hay m√°s posibilidades de
visualizaci√≥n: ¬øQuieres comas o no? ¬øQuieres imprimir las llaves curvas? ¬øDeben
mostrarse todos los campos? Debido a esta ambig√ºedad, Rust no intenta adivinar
lo que queremos, y las estructuras no tienen una implementaci√≥n proporcionada
de <code>Display</code> para usar con <code>println!</code> y el marcador de posici√≥n <code>{}</code>.</p>
<p>Si seguimos leyendo los errores, encontraremos esta nota √∫til:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Intentemos eso. La llamada a la macro <code>println!</code> ahora se ver√° as√≠:
<code>println!(&quot;rect1 es {rect1:?}&quot;);</code>. Poner el especificador <code>:?</code> dentro de
los corchetes curvos le dice a <code>println!</code> que queremos usar un formato de
salida llamado <code>Debug</code>. El rasgo <code>Debug</code> nos permite imprimir nuestra estructura
de una manera que sea √∫til para los desarrolladores para que podamos ver su
valor mientras depuramos nuestro c√≥digo.</p>
<p>Compilamos el c√≥digo con este cambio. ¬°Oh, no! Todav√≠a obtenemos un error:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Pero otra vez, el compilador nos da una nota √∫til:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>si</em> incluye la funcionalidad para imprimir informaci√≥n de depuraci√≥n,
pero tenemos que optar expl√≠citamente para hacer que esa funcionalidad est√©
disponible para nuestra estructura. Para hacer eso, agregamos el atributo
externo <code>#[derive(Debug)]</code> justo antes de la definici√≥n de la estructura, como
se muestra en la lista 5-12.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {rect1:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 5-12: Agregando el atributo para derivar el trait
<code>Debug</code> e imprimiendo la instancia <code>Rectangle</code> usando el formato debug</span></p>
<p>Ahora, cuando compilamos el c√≥digo, no obtendremos ning√∫n error, y veremos la
siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>¬°Bien! No es la salida m√°s bonita, pero muestra los valores de todos los
campos de esta instancia, lo que definitivamente ayudar√≠a durante la
depuraci√≥n. Cuando tenemos estructuras m√°s grandes, es √∫til tener una salida
que sea un poco m√°s f√°cil de leer; en esos casos, podemos usar <code>{:#?}</code> en
lugar de <code>{:?}</code> en el string <code>println!</code>. En este ejemplo, el uso del estilo
<code>{:#?}</code> producir√° la siguiente salida:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Otra forma de imprimir un valor usando el formato <code>Debug</code> es usar la macro
<a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code></a><!-- ignore -->, que toma el ownership de una expresi√≥n (en
oposici√≥n a <code>println!</code>, que toma una referencia), imprime el archivo y el
n√∫mero de l√≠nea donde se produce esa llamada a la macro <code>dbg!</code> en su c√≥digo
junto con el valor resultante de esa expresi√≥n, y devuelve el ownership del
valor.</p>
<blockquote>
<p>Nota: Llamar a la macro <code>dbg!</code> imprime en el flujo de consola de error
est√°ndar (<code>stderr</code>), en oposici√≥n a <code>println!</code>, que imprime en el flujo de
consola de salida est√°ndar (<code>stdout</code>). Hablaremos m√°s sobre <code>stderr</code> y
<code>stdout</code> en la <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">secci√≥n ‚ÄúEscribiendo mensajes de error en el error est√°ndar
en lugar de la salida est√°ndar‚Äù del cap√≠tulo 12</a><!-- ignore -->.</p>
</blockquote>
<p>Aqu√≠ hay un ejemplo en el que estamos interesados en el valor que se asigna al
campo <code>width</code>, as√≠ como el valor de todo el struct en <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>Podemos poner <code>dbg!</code> alrededor de la expresi√≥n <code>30 * scale</code> y, porque <code>dbg!</code>
devuelve el ownership del valor de la expresi√≥n, el campo <code>width</code> tendr√° el
mismo valor que si no tuvi√©ramos la llamada <code>dbg!</code> all√≠. No queremos que <code>dbg!</code>
tome el ownership de <code>rect1</code>, as√≠ que usamos una referencia a <code>rect1</code> en la
siguiente llamada. Aqu√≠ est√° el output de este ejemplo:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Podemos ver que el primer bit de salida proviene de la linea 10 de <em>src/main.rs</em> donde estamos depurando la expresi√≥n <code>30 * scale</code>, y su valor resultante es
<code>60</code> (el formato de <code>Debug</code> implementado para enteros es imprimir s√≥lo su valor).
La llamada a <code>dbg!</code> en la l√≠nea 14 de <em>src/main.rs</em> produce el valor de <code>&amp;rect1</code>,
que es la estructura de <code>Rectangle</code>. Esta salida usa el formato <code>Debug</code> de la
estructura <code>Rectangle</code>. La macro <code>dbg!</code> puede ser realmente √∫til cuando est√°
tratando de averiguar qu√© est√° haciendo su c√≥digo.</p>
<p>Adem√°s del trait <code>Debug</code>, Rust nos ha proporcionado un n√∫mero de traits para
que podamos usar con el atributo <code>derive</code> que pueden agregar un comportamiento
√∫til a nuestros tipos personalizados. Esos traits y sus comportamientos se
enumeran en <a href="appendix-03-derivable-traits.html">el Ap√©ndice C</a><!-- ignore -->. Cubriremos c√≥mo implementar
estos traits con un comportamiento personalizado, as√≠ como c√≥mo crear sus
propios traits en el Cap√≠tulo 10. Tambi√©n hay muchos atributos m√°s all√° de
<code>derive</code>; para obtener m√°s informaci√≥n, consulte <a href="https://doc.rust-lang.org/reference/attributes.html">la secci√≥n ‚ÄúAtributos‚Äù de la
Referencia de Rust</a>.</p>
<p>Nuestra funci√≥n <code>area</code> es muy espec√≠fica: solo calcula el √°rea de
rect√°ngulos. Ser√≠a √∫til vincular este comportamiento m√°s estrechamente a nuestra
estructura <code>Rectangle</code> porque no funcionar√° con ning√∫n otro tipo. Veamos c√≥mo
podemos continuar refactorizando este c√≥digo al convertir la funci√≥n <code>area</code> en
un <em>m√©todo</em> <code>area</code> definido en nuestro tipo <code>Rectangle</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p><a id="sintaxis-de-metodos"></a></p>
<h2 id="sintaxis-de-m√©todos"><a class="header" href="#sintaxis-de-m√©todos">Sintaxis de M√©todos</a></h2>
<p>Los m√©todos son similares a las funciones: los declaramos con la palabra clave
<code>fn</code> y un nombre, pueden tener par√°metros y un valor de retorno, y contienen
alguno c√≥digo que se ejecuta cuando el m√©todo es llamado desde otro lugar.
A diferencia de las funciones, los m√©todos se definen dentro del contexto de
una estructura (o un enum o un objeto de tipo trait, que cubriremos en el
<a href="ch06-00-enums.html">Cap√≠tulo 6</a><!-- ignore --> y el <a href="ch17-02-trait-objects.html">Cap√≠tulo 17</a><!-- ignore
-->, respectivamente), y su primer par√°metro siempre es <code>self</code>, que representa
la instancia de la estructura en la que se est√° llamando al m√©todo.</p>
<h3 id="definiendo-metodos"><a class="header" href="#definiendo-metodos">Definiendo Metodos</a></h3>
<p>Vamos a cambiar la funci√≥n <code>area</code> que tiene una instancia de <code>Rectangle</code> como
par√°metro y en vez de eso definamos un m√©todo <code>area</code> en el struct <code>Rectangle</code>,
como se muestra en el Listado 5-13.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}</code></pre></pre>
<p><span class="caption">Listing 5-13: Definici√≥n de un m√©todo <code>area</code> en el struct
<code>Rectangle</code> </span></p>
<p>Para definir la funci√≥n dentro del contexto de <code>Rectangle</code>, iniciamos un bloque
<code>impl</code> (implementaci√≥n). Todo lo que est√© dentro de este bloque <code>impl</code> estar√°
asociado al tipo <code>Rectangle</code>. Luego movemos la funci√≥n <code>area</code> dentro de las
llaves del bloque <code>impl</code> y cambiamos el primer (y en este caso, √∫nico) par√°metro para
ser <code>self</code> en la firma y en todas partes dentro del cuerpo. En <code>main</code>, donde
llamamos a la funci√≥n <code>area</code> y pasamos <code>rect1</code> como argumento, podemos en vez
de eso usar la <em>sintaxis de m√©todo</em> para llamar al m√©todo <code>area</code> en nuestra
instancia de <code>Rectangle</code>. La sintaxis de m√©todo va despu√©s de una instancia: se
agrega un punto seguido del nombre del m√©todo, par√©ntesis y cualquier argumento.</p>
<p>En la firma para <code>area</code>, usamos <code>&amp;self</code> en vez de <code>rectangle: &amp;Rectangle</code>. El
<code>&amp;self</code> es en realidad una abreviatura para <code>self: &amp;Self</code>. Dentro de un bloque
<code>impl</code>, el tipo <code>Self</code> es un alias para el tipo al que pertenece el bloque
<code>impl</code>. Los m√©todos deben tener un par√°metro llamado <code>self</code> de tipo <code>Self</code> para
su primer par√°metro, por lo que Rust nos permite abreviar esto con solo el
nombre <code>self</code> en el primer par√°metro. Ten en cuenta que a√∫n necesitamos usar el
<code>&amp;</code> antes de la abreviatura <code>self</code> para indicar que este m√©todo toma prestada la
instancia <code>Self</code>, al igual que hicimos en <code>rectangle: &amp;Rectangle</code>. Los m√©todos
pueden tomar la propiedad de <code>self</code>, tomarlo prestado de forma inmutable, como
hemos hecho aqu√≠, o tomarlo prestado de forma mutable, al igual que pueden hacerlo con
cualquier otro par√°metro.</p>
<p>Elegimos <code>&amp;self</code> aqu√≠ por la misma raz√≥n que usamos <code>&amp;Rectangle</code> en la versi√≥n
de la funci√≥n: no queremos tomar la propiedad, y solo queremos leer los datos
en la estructura, no escribir en ella. Si quisi√©ramos cambiar la instancia en
la que hemos llamado al m√©todo como parte de lo que el m√©todo hace, usar√≠amos
<code>&amp;mut self</code> como primer par√°metro. Tener un m√©todo que tome la propiedad de la
instancia usando solo <code>self</code> como primer par√°metro es raro; esta t√©cnica se
usa normalmente cuando el m√©todo transforma <code>self</code> en otra cosa y quieres
evitar que el que llama al m√©todo use la instancia original despu√©s de la
transformaci√≥n.</p>
<p>La raz√≥n principal para usar m√©todos en vez de funciones, adem√°s de proveer la
sintaxis de m√©todo y no tener que repetir el tipo de <code>self</code> en cada firma de
m√©todo, es para la organizaci√≥n. Hemos puesto todas las cosas que podemos hacer
con una instancia de un tipo en un bloque <code>impl</code> en vez de hacer que los
usuarios futuros de nuestro c√≥digo busquen las capacidades de <code>Rectangle</code> en
varios lugares en la biblioteca que proveemos.</p>
<p>Nota que podemos elegir darle al m√©todo el mismo nombre que uno de los campos
del struct. Por ejemplo, podemos definir un m√©todo en <code>Rectangle</code> que se llame
<code>width</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}</code></pre></pre>
<p>Aqu√≠, estamos eligiendo que el m√©todo <code>width</code> retorne <code>true</code> si el valor en el
campo <code>width</code> de la instancia es mayor que <code>0</code> y <code>false</code> si el valor es <code>0</code>:
podemos usar un campo dentro de un m√©todo del mismo nombre para cualquier
prop√≥sito. En <code>main</code>, cuando seguimos <code>rect1.width</code> con par√©ntesis, Rust sabe
que queremos decir el m√©todo <code>width</code>. Cuando no usamos par√©ntesis, Rust sabe
que queremos decir el campo <code>width</code>.</p>
<p>A veces, pero no siempre, cuando damos un m√©todo el mismo nombre que un campo
queremos que solo retorne el valor en el campo y no haga nada m√°s. Los m√©todos
como este se llaman <em>getters</em>, y Rust no los implementa autom√°ticamente para
los campos de un struct como lo hacen otros lenguajes. Los getters son √∫tiles
porque puedes hacer que el campo sea privado, pero el m√©todo sea p√∫blico, y as√≠
permitir acceso de solo lectura a ese campo como parte de la API p√∫blica del
tipo. Hablaremos de qu√© es p√∫blico y privado y c√≥mo designar un campo o m√©todo
como p√∫blico o privado en el <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exponiendo-rutas-con-la-palabra-clave-pub">Cap√≠tulo 7</a><!-- ignore -->.</p>
<blockquote>
<h3 id="donde-esta-el-operador--"><a class="header" href="#donde-esta-el-operador--">¬øDonde esta el Operador <code>-&gt;</code>?</a></h3>
<p>En C y C++, se usan dos operadores diferentes para llamar a m√©todos: se usa
<code>.</code> si se est√° llamando a un m√©todo en el objeto directamente y <code>-&gt;</code> si se
est√° llamando al m√©todo en un puntero al objeto y se necesita desreferenciar
el puntero primero. En otras palabras, si <code>object</code> es un puntero,
<code>object-&gt;something()</code> es similar a <code>(*object).something()</code>.</p>
<p>Rust no tiene un equivalente al operador <code>-&gt;</code>; en su lugar, Rust tiene una
caracter√≠stica llamada <em>referenciaci√≥n y desreferenciaci√≥n autom√°ticas</em>.
Llamar a m√©todos es uno de los pocos lugares en Rust donde se tiene este
comportamiento.</p>
<p>As√≠ es como funciona: cuando llamas a un m√©todo con <code>object.something()</code>,
Rust autom√°ticamente agrega <code>&amp;</code>, <code>&amp;mut</code>, o <code>*</code> para que <code>object</code> coincida
con la firma del m√©todo. En otras palabras, lo siguiente es lo mismo:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>El primer ejemplo es m√°s limpio. Este comportamiento de referencia y
desreferenciaci√≥n autom√°tica funciona porque los m√©todos tienen un receptor
claro: el tipo de <code>self</code>. Dado el receptor y el nombre de un m√©todo, Rust
puede determinar con certeza si el m√©todo est√° leyendo (<code>&amp;self</code>), mutando
(<code>&amp;mut self</code>), o consumiendo (<code>self</code>). El hecho de que Rust haga que el
pr√©stamo sea impl√≠cito para los receptores de m√©todo es una gran parte de
hacer que la propiedad sea ergon√≥mica en la pr√°ctica.</p>
</blockquote>
<h3 id="m√©todos-con-m√°s-par√°metros"><a class="header" href="#m√©todos-con-m√°s-par√°metros">M√©todos con m√°s par√°metros</a></h3>
<p>Practiquemos usando m√©todos implementando un segundo m√©todo en la estructura
<code>Rectangle</code>. Esta vez queremos que una instancia de <code>Rectangle</code> tome otra
instancia de <code>Rectangle</code> y retorne <code>true</code> si el segundo <code>Rectangle</code> puede
completamente caber dentro de <code>self</code> (el primer <code>Rectangle</code>); de lo
contrario, deber√≠a retornar <code>false</code>. Es decir, una vez que hayamos definido el
m√©todo <code>can_hold</code>, queremos poder escribir el programa mostrado en el
Listing 5-14.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}</code></pre>
<p><span class="caption">Listing 5-14: Uso del m√©todo <code>can_hold</code> a√∫n no escrito
</span></p>
<p>La salida esperada se ver√≠a como la siguiente porque ambas dimensiones de
<code>rect2</code> son m√°s peque√±as que las dimensiones de <code>rect1</code>, pero <code>rect3</code> es m√°s
ancha que <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Sabemos que queremos definir un m√©todo, por lo que estar√° dentro del bloque
<code>impl Rectangle</code>. El nombre del m√©todo ser√° <code>can_hold</code>, y tomar√° un pr√©stamo
inmutable de otro <code>Rectangle</code> como par√°metro. Podemos decir cu√°l ser√° el tipo
del par√°metro mirando el c√≥digo que llama al m√©todo: <code>rect1.can_hold(&amp;rect2)</code>
pasa <code>&amp;rect2</code>, que es un pr√©stamo inmutable a <code>rect2</code>, una instancia de
<code>Rectangle</code>. Esto tiene sentido porque solo necesitamos leer <code>rect2</code> (en lugar
de escribir, lo que significar√≠a que necesitar√≠amos un pr√©stamo mutable), y
queremos que <code>main</code> conserve la propiedad de <code>rect2</code> para que podamos usarlo
nuevamente despu√©s de llamar al m√©todo <code>can_hold</code>. El valor de retorno de
<code>can_hold</code> ser√° un Booleano, y la implementaci√≥n verificar√° si el ancho y
alto de <code>self</code> son mayores que el ancho y alto del otro <code>Rectangle</code>,
respectivamente. Agreguemos el nuevo m√©todo <code>can_hold</code> al bloque <code>impl</code> del
Listing 5-13 que se muestra en el Listing 5-15.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-15: Implementando el m√©todo <code>can_hold</code> en
<code>Rectangle</code> que toma otra instancia de <code>Rectangle</code> como un par√°metro</span></p>
<p>Cuando ejecutamos este c√≥digo con la funci√≥n <code>main</code> en el Listing 5-14,
obtendremos el resultado deseado. Los m√©todos pueden tomar m√∫ltiples par√°metros
que agregamos a la firma despu√©s del par√°metro <code>self</code>, y esos par√°metros
funcionan igual que los par√°metros en las funciones.</p>
<h3 id="funciones-asociadas"><a class="header" href="#funciones-asociadas">Funciones asociadas</a></h3>
<p>Todas las funciones definidas dentro de un bloque <code>impl</code> se llaman <em>funciones
asociadas</em> porque est√°n asociadas con el tipo nombrado despu√©s del <code>impl</code>.
Podemos definir funciones asociadas que no tengan <code>self</code> como su primer
par√°metro (y, por lo tanto, no sean m√©todos) porque no necesitan una instancia del
tipo con el que trabajar. Ya hemos usado una funci√≥n como esta: la funci√≥n
<code>String::from</code> que est√° definida en el tipo <code>String</code>.</p>
<p>Las funciones asociadas que no son m√©todos son a menudo utilizadas para
constructores que devolver√°n una nueva instancia de la estructura. Est√°s
a menudo se llaman <code>new</code>, pero <code>new</code> no es un nombre especial y no est√°
incorporado en el lenguaje. Por ejemplo, podr√≠amos elegir proporcionar una
funci√≥n asociada llamada <code>square</code> que tendr√≠a un par√°metro de dimensi√≥n y lo
usar√≠a como ancho y alto, de modo que sea m√°s f√°cil crear un <code>Rectangle</code>
cuadrado en lugar de tener que especificar el mismo valor dos veces:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>La palabra clave <code>Self</code> en el tipo de retorno y en el cuerpo de la funci√≥n es
un alias para el tipo que aparece despu√©s de la palabra clave <code>impl</code>, que en
este caso es <code>Rectangle</code>.</p>
<p>Para llamar a esa funci√≥n asociada, usamos la sintaxis <code>::</code> con el nombre de
la estructura; <code>let sq = Rectangle::square(3);</code> es un ejemplo. Esta funci√≥n
est√° dentro del namespace de la estructura. La sintaxis <code>::</code> se usa tanto
para las funciones asociadas como para los namespaces creados por los
m√≥dulos. Discutiremos los m√≥dulos en el <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">Cap√≠tulo 7</a><!-- ignore -->.</p>
<h3 id="bloques-impl-m√∫ltiples"><a class="header" href="#bloques-impl-m√∫ltiples">Bloques <code>impl</code> m√∫ltiples</a></h3>
<p>Cada struct es permitido tener m√∫ltiples bloques <code>impl</code>. Por ejemplo, el
Listing 5-15 es equivalente al c√≥digo mostrado en el Listing 5-16, que tiene
cada m√©todo en su propio bloque <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 5-16: Reescribiendo Listing 5-15 usando m√∫ltiples
bloques <code>impl</code></span></p>
<p>No hay raz√≥n para separar estos m√©todos en m√∫ltiples bloques <code>impl</code> aqu√≠, pero
esta es una sintaxis v√°lida. Veremos un caso en el que los m√∫ltiples bloques
<code>impl</code> son √∫tiles en el Cap√≠tulo 10, donde discutiremos los tipos gen√©ricos y
los traits.</p>
<h2 id="resumen-4"><a class="header" href="#resumen-4">Resumen</a></h2>
<p>Los structs te permiten crear tipos personalizados que son significativos para
su dominio. Al usar structs, puede mantener piezas de datos asociadas entre s√≠
y nombrar cada pieza para hacer que su c√≥digo sea claro. En los bloques <code>impl</code>,
puede definir funciones que est√°n asociadas con su tipo, y los m√©todos son un
tipo de funci√≥n asociada que le permite especificar el comportamiento que
tienen las instancias de sus structs.</p>
<p>Pero los structs no son la √∫nica forma de crear tipos personalizados: pasemos
a la funci√≥n enum de Rust para agregar otra herramienta a su toolbox.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-y-pattern-matching"><a class="header" href="#enums-y-pattern-matching">Enums y Pattern Matching</a></h1>
<p>En este cap√≠tulo, vamos a ver las <em>enumeraciones</em>, tambi√©n conocidos como
<em>enums</em>. Los enums te permiten definir un tipo enumerando sus posibles
<em>variantes</em>. Primero definiremos y usaremos un enum para mostrar c√≥mo un
enum puede codificar el significado junto con datos. A continuaci√≥n,
exploraremos un enum particularmente √∫til, llamado <code>Option</code>, que
expresa que un valor puede ser algo o nada. Luego veremos c√≥mo el
patr√≥n de coincidencia en la expresi√≥n <code>match</code> hace que sea f√°cil
ejecutar un c√≥digo diferente para diferentes valores de un enum.
Finalmente, veremos c√≥mo la construcci√≥n <code>if let</code> es otra expresi√≥n
conveniente y concisa disponible para manejar enums en su c√≥digo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definiendo-un-enum"><a class="header" href="#definiendo-un-enum">Definiendo un Enum</a></h2>
<p>Los <code>struct</code> te permiten agrupar campos relacionados y datos, como un <code>Rect√°ngulo</code>
con su <code>ancho</code> y <code>largo</code>. Por otro lado, los enums te permiten decir que
un valor es uno de un conjunto de posibles valores. Por ejemplo, podr√≠amos querer
decir que <code>Rect√°ngulo</code> es uno de un conjunto de posibles formas que tambi√©n
incluye <code>Circulo</code> y <code>Triangulo</code>. Para hacer esto, Rust nos permite codificar estas
posibilidades como un <code>enum</code>.</p>
<p>Vamos a ver una situaci√≥n que podemos expresar en c√≥digo y veremos por qu√©
los enums son √∫tiles y m√°s apropiados que los structs en este caso. Digamos
que tenemos que trabajar con direcciones IP. Actualmente, existen dos est√°ndares
que se usan para direcciones IP: la versi√≥n cuatro y la versi√≥n seis.
Como estos son los √∫nicos posibles tipos de direcciones IP que nuestro
programa encontrar√°, podemos <em>enumerar</em> todas las variantes posibles, de
donde viene el nombre de <code>enum</code>.</p>
<p>Cualquier direcci√≥n IP puede ser una direcci√≥n de la versi√≥n cuatro o la versi√≥n
seis, pero no ambas al mismo tiempo. Esa propiedad de las direcciones IP hace
que la estructura de datos <code>enum</code> sea apropiada porque un valor <code>enum</code> puede ser
s√≥lo una de sus variantes. Tanto las direcciones de la versi√≥n cuatro como la versi√≥n seis
siguen siendo fundamentalmente direcciones IP, por lo que deben ser
tratadas como el mismo tipo cuando el c√≥digo est√° manejando situaciones que se
aplican a cualquier tipo de direcci√≥n IP.</p>
<p>Podemos expresar este concepto en c√≥digo definiendo el enum <code>IpAddrKind</code>
y enumerando los posibles tipos de direcciones IP, <code>V4</code> y <code>V6</code>. Estas son las
variantes del <code>enum</code>:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> ahora es un tipo de datos personalizado que podemos usar en otras
partes de nuestro c√≥digo.</p>
<h3 id="valores-enum"><a class="header" href="#valores-enum">Valores Enum</a></h3>
<p>Podemos crear instancias de cada una de las dos variantes de <code>IpAddrKind</code> de
esta manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Nota que las variantes del <code>enum</code> est√°n en el mismo espacio de nombres bajo su
identificador, y usamos dos puntos para separar los dos. Esto es √∫til porque
ahora ambos valores <code>IpAddrKind::V4</code> e <code>IpAddrKind::V6</code> son del mismo tipo:
<code>IpAddrKind</code>. Podemos entonces, por ejemplo, definir una funci√≥n que tome
cualquier <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>Y podemos llamar a esta funci√≥n con cualquiera de las variantes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Usando <code>enum</code> tiene a√∫n m√°s ventajas. Pensando m√°s en nuestro tipo de direcci√≥n
IP, en este momento no tenemos una forma de almacenar los datos reales de la
direcci√≥n IP; solo sabemos qu√© tipo es. Dado que acabas de aprender sobre los
structs en el Cap√≠tulo 5, podr√≠as estar tentado a abordar este problema con
structs como se muestra en el Listing 6-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 6-1: Almacenando los datos y la variante
<code>IpAddrKind</code> de una direcci√≥n IP usando un <code>struct</code></span></p>
<p>Aqu√≠, hemos definido un struct <code>IpAddr</code> que tiene dos campos: un campo <code>kind</code>
que es de tipo <code>IpAddrKind</code> (el <code>enum</code> que definimos anteriormente) y un campo
<code>address</code> de tipo <code>String</code>. Tenemos dos instancias de este struct. La primera
es <code>home</code>, y tiene el valor <code>IpAddrKind::V4</code> como su <code>kind</code> como datos de
direcci√≥n asociados de <code>127.0.0.1</code>. La segunda instancia es <code>loopback</code>. Tiene
la otra variante de <code>IpAddrKind</code> como su valor <code>kind</code>, <code>V6</code>, y tiene la
direcci√≥n <code>::1</code> asociada con ella. Hemos usado un struct para agrupar los
valores <code>kind</code> y <code>address</code> juntos, as√≠ que ahora la variante est√° asociada con
el valor.</p>
<p>Sin embargo, representar el mismo concepto usando s√≥lo un <code>enum</code> es m√°s conciso:
en lugar de un <code>enum</code> dentro de un struct, podemos poner datos directamente en
cada variante de <code>enum</code>. Esta nueva definici√≥n del enum <code>IpAddr</code> dice que tanto
las variantes <code>V4</code> como <code>V6</code> tendr√°n valores <code>String</code> asociados:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Adjuntamos datos a cada variante del <code>enum</code> directamente, por lo que no hay
necesidad de un struct extra. Aqu√≠, tambi√©n es m√°s f√°cil ver otro detalle
de c√≥mo funcionan los enums: el nombre de cada variante de <code>enum</code> que definimos
tambi√©n se convierte en una funci√≥n que construye una instancia del tipo <code>enum</code>.
Es decir, <code>IpAddr::V4()</code> es una llamada a funci√≥n que toma un argumento
<code>String</code> y devuelve una instancia del tipo <code>IpAddr</code>. Obtenemos autom√°ticamente
esta funci√≥n constructora definida como resultado de definir el <code>enum</code>.</p>
<p>Hay otra ventaja de usar un <code>enum</code> en lugar de un struct: cada variante puede
tener diferentes tipos y cantidades de datos asociados con ella. La versi√≥n
cuatro de las direcciones IP siempre tendr√° cuatro componentes num√©ricos que
tendr√°n valores entre 0 y 255. Si quisi√©ramos almacenar las direcciones <code>V4</code>
como cuatro valores <code>u8</code> pero aun as√≠ expresar las direcciones <code>V6</code> como un
valor <code>String</code>, no podr√≠amos hacerlo con un struct. Los enums manejan este caso
con facilidad:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Hemos mostrado varias formas diferentes de definir estructuras de datos para
almacenar direcciones IP de la versi√≥n cuatro y de la versi√≥n seis. Sin embargo,
resulta que querer almacenar direcciones IP y codificar de que tipo son es tan com√∫n
que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la biblioteca est√°ndar tiene una definici√≥n que podemos usar!</a><!-- ignore -->
Veamos c√≥mo define la biblioteca est√°ndar <code>IpAddr</code>: tiene el <code>enum</code> exacto y las
variantes que hemos definido y usado, pero incrusta los datos de direcci√≥n
dentro de las variantes en forma de dos structs diferentes, que se definen de
manera diferente para cada variante:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo ilustra que puedes poner cualquier tipo de datos dentro de una
variante de <code>enum</code>: strings, tipos num√©ricos o structs, por ejemplo. ¬°Incluso
puedes incluir otro <code>enum</code>! Adem√°s, los tipos de biblioteca est√°ndar a menudo no
son mucho m√°s complicados de lo que podr√≠as idear.</p>
<p>Ten en cuenta que aunque la biblioteca est√°ndar contiene una definici√≥n para
<code>IpAddr</code>, a√∫n podemos crear y usar nuestra propia definici√≥n sin conflicto
porque no hemos tra√≠do la definici√≥n de la biblioteca est√°ndar a nuestro
contexto de ejecuci√≥n. Hablaremos m√°s sobre c√≥mo traer tipos al contexto de ejecuci√≥n en el Cap√≠tulo 7.</p>
<p>Veamos otro ejemplo de una enumeraci√≥n en el Listing 6-2: este tiene una amplia
variedad de tipos incrustados en sus variantes.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 6-2: Un enum <code>Message</code> cuyas variantes almacenan
diferentes cantidades y tipos de valores</span></p>
<p>Este <code>enum</code> tiene cuatro variantes con diferentes tipos:</p>
<ul>
<li><code>Quit</code> no tiene ning√∫n dato asociado.</li>
<li><code>Move</code> tiene campos nombrados, como lo har√≠a un struct.</li>
<li><code>Write</code> incluye un solo <code>String</code>.</li>
<li><code>ChangeColor</code> incluye tres valores <code>i32</code>.</li>
</ul>
<p>Definiendo un <code>enum</code> con variantes como las del Listing 6-2 es similar a
definir diferentes tipos de definiciones de struct, excepto que el <code>enum</code> no
use la palabra clave <code>struct</code> y todas las variantes est√°n agrupadas juntas
bajo el tipo <code>Message</code>. Los siguientes structs podr√≠an contener los mismos
datos que las variantes de <code>enum</code> anteriores:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Pero si usamos los diferentes structs, cada uno de los cuales tiene su propio
tipo, no podr√≠amos definir tan f√°cilmente una funci√≥n para tomar cualquiera
de estos tipos de mensajes como podr√≠amos con el enum <code>Message</code> definido en
el Listing 6-2, que es un solo tipo.</p>
<p>Hay una similitud entre enums y structs que puede ser √∫til de recordar: al
igual que puedes definir m√©todos en structs usando <code>impl</code>, puedes definir
m√©todos en enums. Aqu√≠ hay un m√©todo llamado <code>call</code> que podemos definir en
nuestro enum <code>Message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>El cuerpo del m√©todo usar√≠a <code>self</code> para obtener el valor en el que llamamos
el m√©todo. En este ejemplo, hemos creado una variable <code>m</code> que tiene el valor
<code>Message::Write(String::from(&quot;hello&quot;))</code>, y eso es lo que ser√° <code>self</code> en el
cuerpo del m√©todo <code>call</code> cuando se ejecute <code>m.call()</code>.</p>
<p>Veamos otro <code>enum</code> en la librer√≠a est√°ndar que es muy com√∫n y √∫til: <code>Option</code>.</p>
<h3 id="el-enum-option-y-sus-ventajas-sobre-los-valores-null"><a class="header" href="#el-enum-option-y-sus-ventajas-sobre-los-valores-null">El Enum <code>Option</code> y Sus Ventajas Sobre los Valores Null</a></h3>
<p>Esta secci√≥n explora un caso de estudio de <code>Option</code>, que es otro <code>enum</code> definido
por la biblioteca est√°ndar. El tipo <code>Option</code> codifica el escenario muy com√∫n en
el que un valor podr√≠a ser algo o podr√≠a ser nada.</p>
<p>Por ejemplo, si solicita el primer elemento de una lista no vac√≠a, obtendr√≠a un
valor. Si solicita el primer elemento de una lista vac√≠a, no obtendr√≠a nada.
Expresar este concepto en t√©rminos del sistema de tipos significa que el
compilador puede verificar si ha manejado todos los casos que deber√≠a estar
manejando; esta funcionalidad puede prevenir errores que son extremadamente
comunes en otros lenguajes de programaci√≥n.</p>
<p>El dise√±o del lenguaje de programaci√≥n a menudo se piensa en t√©rminos de qu√©
caracter√≠sticas se incluyen, pero las caracter√≠sticas que se excluyen son
importantes tambi√©n. Rust no tiene la caracter√≠stica de null que muchos otros
lenguajes tienen. <em>Null</em> es un valor que significa que no hay ning√∫n valor
all√≠. En los lenguajes con null, las variables siempre pueden estar en uno de
dos estados: null o no null.</p>
<p>En su presentaci√≥n del 2009 ‚ÄúNull References: The Billion Dollar Mistake‚Äù,
Tony Hoare, el inventor de null, tiene esto que decir:</p>
<blockquote>
<p>Ll√°malo mi error de un bill√≥n de d√≥lares. En ese momento, estaba dise√±ando el
primer sistema de tipos completo para referencias en un lenguaje de
programaci√≥n orientado a objetos. Mi objetivo era asegurarme de que todo el
uso de referencias fuera absolutamente seguro, con verificaci√≥n realizada
autom√°ticamente por el compilador. Pero no pude resistir la tentaci√≥n de
poner un valor null, simplemente porque era tan f√°cil de implementar. Esto a
dado lugar a innumerables errores, vulnerabilidades y bloqueos del sistema,
que probablemente han causado un bill√≥n de d√≥lares de dolor y da√±os en los
√∫ltimos cuarenta a√±os.</p>
</blockquote>
<p>El problema con los valores null es que si intentas utilizar un valor null como
un valor no null, obtendr√°s un error de alg√∫n tipo. Debido a que esta propiedad
nula o no nula es omnipresente, es extremadamente f√°cil cometer este tipo de error.</p>
<p>Sin embargo, el concepto que null est√° tratando de expresar sigue siendo
√∫til: un null es un valor que es actualmente inv√°lido o ausente por alguna
raz√≥n.</p>
<p>El problema no es realmente con el concepto, sino con la implementaci√≥n
particular. Como tal, Rust no tiene null, pero tiene un <code>enum</code> que puede
codificar el concepto de un valor presente o ausente. Este <code>enum</code> es
<code>Option&lt;T&gt;</code>, y est√° <a href="https://doc.rust-lang.org/std/option/enum.Option.html">definido por la biblioteca est√°ndar</a><!-- ignore -->
de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>El enum <code>Option&lt;T&gt;</code> es tan √∫til que incluso est√° incluido en el <a href="ch02-00-guessing-game-tutorial.html#prelude-meaning">prelude</a>; no
necesitas traerlo al contexto de ejecuci√≥n expl√≠citamente. Sus variantes tambi√©n est√°n
incluidas en el prelude: puedes usar <code>Some</code> y <code>None</code> directamente sin el
prefijo <code>Option::</code>. El enum <code>Option&lt;T&gt;</code> es a√∫n un <code>enum</code> regular, y <code>Some(T)</code>
y <code>None</code> son a√∫n variantes de tipo <code>Option&lt;T&gt;</code>.</p>
<p>La sintaxis <code>&lt;T&gt;</code> es una caracter√≠stica de Rust que a√∫n no hemos hablado. Es
un par√°metro de tipo gen√©rico, y cubriremos los gen√©ricos en m√°s detalle en
el Cap√≠tulo 10. Por ahora, todo lo que necesitas saber es que <code>&lt;T&gt;</code> significa
que la variante <code>Some</code> del enum <code>Option</code> puede contener una pieza de datos de
cualquier tipo, y que cada tipo concreto que se usa en lugar de <code>T</code> hace que
el tipo <code>Option&lt;T&gt;</code> general sea un tipo diferente. Aqu√≠ hay algunos ejemplos
de usar valores <code>Option</code> para contener tipos de n√∫meros y tipos de strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>El tipo de <code>some_number</code> es <code>Option&lt;i32&gt;</code>. El tipo de <code>some_string</code> es
<code>Option&lt;String&gt;</code>, que es un tipo diferente. Rust puede inferir estos tipos
porque hemos especificado un valor dentro de la variante <code>Some</code>. Para
<code>absent_number</code>, Rust requiere que anotemos el tipo general <code>Option</code>: el
compilador no puede inferir el tipo que tendr√° la variante <code>Some</code> correspondiente
mirando s√≥lo un valor <code>None</code>. Aqu√≠, le decimos a Rust que queremos
que <code>absent_number</code> sea del tipo <code>Option&lt;i32&gt;</code>.</p>
<p>Cuando tenemos un valor <code>Some</code>, sabemos que un valor est√° presente y el valor
se mantiene dentro del <code>Some</code>. Cuando tenemos un valor <code>None</code>, en cierto
sentido significa lo mismo que null: no tenemos un valor v√°lido. Entonces,
¬øpor qu√© tener <code>Option&lt;T&gt;</code> es mejor que tener null?</p>
<p>En resumen, porque <code>Option&lt;T&gt;</code> y <code>T</code> (donde <code>T</code> puede ser cualquier tipo) son
tipos diferentes, el compilador no nos permitir√° usar un valor <code>Option&lt;T&gt;</code> como
si fuera definitivamente un valor v√°lido. Por ejemplo, este c√≥digo no se
compilar√°, porque est√° tratando de agregar un <code>i8</code> a un <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>Si ejecutamos este c√≥digo, obtenemos un mensaje de error como este:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            &lt;i8 as Add&gt;
            &lt;i8 as Add&lt;&amp;i8&gt;&gt;
            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;
            &lt;&amp;i8 as Add&lt;&amp;i8&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error
</code></pre>
<p>¬°Intenso! En efecto, este mensaje de error significa que Rust no entiende c√≥mo
agregar un <code>i8</code> y un <code>Option&lt;i8&gt;</code>, porque son tipos diferentes. Cuando tenemos
un valor de un tipo como <code>i8</code> en Rust, el compilador se asegurar√° de que
siempre tengamos un valor v√°lido. Podemos proceder con confianza sin tener que
comprobar si es null antes de usar ese valor. Solo cuando tenemos un
<code>Option&lt;i8&gt;</code> (o el tipo de valor que estemos trabajando) tenemos que preocuparnos
por posiblemente no tener un valor, y el compilador se asegurar√° de que
manejemos ese caso antes de usar el valor.</p>
<p>En otras palabras, tienes que convertir un <code>Option&lt;T&gt;</code> a un <code>T</code> antes de que
puedas realizar operaciones <code>T</code> con √©l. Generalmente, esto ayuda a detectar uno
de los errores m√°s comunes con null: asumiendo que algo no es null cuando
realmente lo es.</p>
<p>Eliminar el riesgo de asumir incorrectamente un valor no null
ayuda a tener m√°s confianza en su c√≥digo. Para tener un valor que
posiblemente pueda ser null, debe optar expl√≠citamente por hacer que el tipo de ese
valor sea <code>Option&lt;T&gt;</code>. Entonces, cuando use ese valor, se le requerir√°
expresar expl√≠citamente el caso cuando el valor es null. Siempre que un valor tenga un tipo que no sea <code>Option&lt;T&gt;</code>, se <em>puede</em>
asumir con seguridad que el valor no es null. Esta fue una decisi√≥n
deliberada del dise√±o de Rust para limitar la omnipresencia de nulls y
aumentar la seguridad del c√≥digo de Rust.</p>
<p>Entonces ¬øc√≥mo obtienes el valor <code>T</code> de un <code>Some</code> cuando tienes un valor de
tipo <code>Option&lt;T&gt;</code> para que puedas usar ese valor? El enum <code>Option&lt;T&gt;</code> tiene una
gran cantidad de m√©todos que son √∫tiles en una variedad de situaciones; puedes
verlos en <a href="https://doc.rust-lang.org/std/option/enum.Option.html">su documentaci√≥n</a><!-- ignore -->. Familiarizarse con los
m√©todos en <code>Option&lt;T&gt;</code> ser√° extremadamente √∫til en su viaje con Rust.</p>
<p>En general, para usar un valor <code>Option&lt;T&gt;</code>, querr√°s tener c√≥digo que maneje
cada variante. Quieres tener alg√∫n c√≥digo que se ejecute solo cuando tienes un
valor <code>Some(T)</code>, y este c√≥digo est√° permitido de usar el <code>T</code> interno. Quieres
tener alg√∫n otro c√≥digo que se ejecute solo si tienes un valor <code>None</code>, y ese
c√≥digo no tiene un valor <code>T</code> disponible. La expresi√≥n <code>match</code> es una
construcci√≥n de flujo de control que hace exactamente esto cuando se usa con
enums: ejecutar√° diferente c√≥digo dependiendo de la variante del <code>enum</code> que
tenga, y ese c√≥digo puede usar los datos dentro del valor que coincida.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="el-operador-de-control-de-flujo-match"><a class="header" href="#el-operador-de-control-de-flujo-match">El operador de control de flujo <code>match</code></a></h2>
<p>Rust tiene una construcci√≥n de flujo de control extremadamente poderosa llamada
<code>match</code> que te permite comparar un valor contra una serie de patrones y luego
ejecutar c√≥digo basado en qu√© patr√≥n coincide. Los patrones pueden estar
compuestos de valores literales, nombres de variables, comodines y muchas otras
cosas; El <a href="ch18-00-patterns.html">Cap√≠tulo 18</a><!-- ignore --> cubre todos los
diferentes tipos de patrones y lo que hacen. El poder de <code>match</code> viene de la
expresividad de los patrones y el hecho de que el compilador confirma que se
tratan todos los casos posibles.</p>
<p>Piensa en una expresi√≥n <code>match</code> como una m√°quina de clasificaci√≥n de monedas:
las monedas deslizan a lo largo de una pista con orificios de diversos tama√±os
a lo largo de ella, y cada moneda cae a trav√©s del primer orificio que encuentra
que se ajusta a ella. De la misma manera, los valores pasan a trav√©s de cada
patr√≥n en un <code>match</code>, y en el primer patr√≥n en el que el valor ‚Äúse ajusta‚Äù, el
valor cae en el bloque de c√≥digo asociado para ser utilizado durante la
ejecuci√≥n.</p>
<p>Hablando de monedas, ¬°us√©moslas como un ejemplo usando <code>match</code>! Podemos escribir
una funci√≥n que tome una moneda desconocida de los Estados Unidos y, de una
manera similar a la m√°quina de conteo, determine qu√© moneda es y devuelva su
valor en centavos, como se muestra en el Listing 6-3.</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 6-3: Una expresi√≥n <code>enum</code> y <code>match</code> que tiene
las variantes del enum como sus patrones</span></p>
<p>Desglosemos el uso de <code>match</code> en la funci√≥n <code>value_in_cents</code>.
Primero listamos la palabra clave <code>match</code> seguida de una expresi√≥n,
que en este caso es el valor <code>coin</code>. Esto parece muy similar a una expresi√≥n
condicional utilizada con <code>if</code>, pero hay una gran diferencia: con <code>if</code>,
la condici√≥n debe evaluar a un valor Booleano, pero aqu√≠ puede ser cualquier
tipo. El tipo de <code>coin</code> en este ejemplo es el enum <code>Coin</code> que definimos en la
primera l√≠nea.</p>
<p>A continuaci√≥n, dentro de las llaves de <code>match</code>, hay un n√∫mero de Opciones.
Una Opci√≥n tiene dos partes: un patr√≥n y alg√∫n c√≥digo. La primera Opci√≥n aqu√≠
tiene un patr√≥n que es el valor <code>Coin::Penny</code> y luego el operador <code>=&gt;</code> que
separa el patr√≥n y el c√≥digo a ejecutar. El c√≥digo en este caso es solo el valor
<code>1</code>. Cada Opci√≥n est√° separado del siguiente con una coma.</p>
<p>Cuando la expresi√≥n <code>match</code> se ejecuta, compara el valor resultante contra el
patr√≥n de cada Opci√≥n, en orden. Si un patr√≥n coincide con el valor, se ejecuta
el c√≥digo asociado con ese patr√≥n. Si ese patr√≥n no coincide con el valor,
la ejecuci√≥n contin√∫a en la siguiente Opci√≥n, como en una m√°quina de
clasificaci√≥n de monedas. Podemos tener tantas Opciones como necesitemos:
en el Listado 6-3, nuestro <code>match</code> tiene cuatro Opciones.</p>
<p>El c√≥digo asociado con cada Opci√≥n es una expresi√≥n, y el valor resultante de
la expresi√≥n en la Opci√≥n coincidente es el valor que se devuelve para la
expresi√≥n <code>match</code> completa.</p>
<p>Por lo general, no usamos llaves si el c√≥digo de la Opci√≥n de match es
corto, como lo es en el Listado 6-3, donde cada Opci√≥n solo devuelve un valor.
Si desea ejecutar varias l√≠neas de c√≥digo en una Opci√≥n de match, debe
usar llaves, y la coma que sigue a la Opci√≥n es opcional. Por ejemplo,
el siguiente c√≥digo imprime ‚Äú¬°Moneda de la suerte!‚Äù cada vez que el m√©todo
se llama con un <code>Coin::Penny</code>, pero a√∫n devuelve el √∫ltimo valor del bloque,
<code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="patrones-que-vinculan-valores"><a class="header" href="#patrones-que-vinculan-valores">Patrones que vinculan valores</a></h3>
<p>Otra caracter√≠stica √∫til de las Opciones de match es que pueden vincularse
a las partes del valor que coinciden con el patr√≥n. Esto es c√≥mo podemos extraer
valores de las variantes de enum.</p>
<p>Como ejemplo, podemos cambiar el c√≥digo de la funci√≥n <code>value_in_cents</code> para
que, en lugar de devolver un valor, imprima el valor que tiene. Esto nos
permite ver qu√© moneda tenemos y cu√°nto vale. Para hacer esto, necesitamos
convertir el c√≥digo de cada Opci√≥n en una expresi√≥n, y luego usar una
expresi√≥n <code>println!</code> en lugar de un valor de retorno. Tambi√©n necesitamos
cambiar el tipo de <code>value_in_cents</code> a <code>()</code>, ya que no estamos devolviendo un
valor entero, sino que estamos ejecutando c√≥digo. El c√≥digo completo se muestra
en el Listing 6-4.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 6-4: Un enum <code>Coin</code> en el cual la variante
<code>Quarter</code> tambi√©n contiene un valor <code>UsState</code></span></p>
<p>Imaginemos que tenemos un amigo que est√° tratando de coleccionar todas las
monedas de 50 estados. Mientras clasificamos nuestra moneda suelta por tipo de
moneda, tambi√©n llamaremos al nombre del estado asociado con cada moneda de
50 centavos para que si es uno que no tiene, pueda agregarlo a su colecci√≥n.</p>
<p>En la expresi√≥n <code>match</code> en el Listado 6-4, podemos agregar <code>UsState::Alaska</code> a
la variante <code>Coin::Quarter</code> para crear una nueva variante de <code>Coin</code>. Cuando
hacemos esto, el estado de Alaska se adjunta a la moneda. Luego, cuando
ejecutamos el c√≥digo, podemos ver el valor del estado almacenado en la
moneda de 50 centavos al imprimirlo. El c√≥digo completo se muestra en el
Listing 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {state:?}!&quot;);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>Si llam√°ramos a <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code> ser√≠a
<code>Coin::Quarter(UsState::Alaska)</code>. Cuando comparamos ese valor con cada una de
las Opciones de match, ninguno coincide hasta que llegamos a
<code>Coin::Quarter(state)</code>. En ese punto, el enlace para <code>state</code> ser√° el valor
<code>UsState::Alaska</code>. Luego podemos usar ese enlace en la expresi√≥n <code>println!</code>,
obteniendo as√≠ el valor del estado interno de la variante de <code>Coin</code> para
<code>Quarter</code>.</p>
<h3 id="match-con-optiont"><a class="header" href="#match-con-optiont">Match con <code>Option&lt;T&gt;</code></a></h3>
<p>En la secci√≥n anterior, quer√≠amos obtener el valor interno <code>T</code> de la variante
<code>Some</code> cuando se usaba <code>Option&lt;T&gt;</code>; tambi√©n podemos manejar <code>Option&lt;T&gt;</code> usando
<code>match</code>, como lo hicimos con el enum <code>Coin</code>! En lugar de comparar monedas,
compararemos las variantes de <code>Option&lt;T&gt;</code>, pero la forma en que funciona la
expresi√≥n <code>match</code> sigue siendo la misma.</p>
<p>Digamos que queremos escribir una funci√≥n que tome un <code>Option&lt;i32&gt;</code> y, si
hay un valor dentro, agregue 1 a ese valor. Si no hay un valor dentro, la
funci√≥n debe devolver el valor <code>None</code> y no intentar realizar ninguna
operaci√≥n.</p>
<p>Esta funci√≥n es muy f√°cil de escribir, gracias a <code>match</code>, y se ver√° como el
Listing 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 6-5: Una funci√≥n que usa una expresi√≥n <code>match</code> en
un <code>Option&lt;i32&gt;</code></span></p>
<p>Examinemos la primera ejecuci√≥n de <code>plus_one</code> en m√°s detalle. Cuando llamamos
a <code>plus_one(five)</code>, la variable <code>x</code> en el cuerpo de <code>plus_one</code> tendr√° el
valor <code>Some(5)</code>. Luego comparamos eso contra cada Opci√≥n de match:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>El valor <code>Some(5)</code> no coincide con el patr√≥n <code>None</code>, por lo que seguimos a la
siguiente Opci√≥n:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>¬øCoincide <code>Some(5)</code> con <code>Some(i)</code>? ¬°Lo hace! Tenemos la misma variante. √âl
<code>i</code> se vincula al valor contenido en <code>Some</code>, por lo que <code>i</code> toma el valor <code>5</code>.
Luego se ejecuta el c√≥digo en la Opci√≥n de match, por lo que agregamos 1
al valor de <code>i</code> y creamos un nuevo valor <code>Some</code> con nuestro total <code>6</code> dentro.</p>
<p>Ahora consideremos la segunda llamada a <code>plus_one</code> en el Listing 6-5, donde
<code>x</code> es <code>None</code>. Entramos en el <code>match</code> y comparamos con la primera Opci√≥n:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>¬°Coincide! No hay valor para agregar, por lo que el programa se detiene y
devuelve el valor <code>None</code> en el lado derecho de <code>=&gt;</code>. Debido a que la primera
Opci√≥n coincidi√≥, no se comparan otras Opciones.</p>
<p>Combinando <code>match</code> y enums es √∫til en muchas situaciones. Ver√°s este patr√≥n
mucho en el c√≥digo Rust: <code>match</code> contra un enum, vincula una variable a los
datos internos y luego ejecuta el c√≥digo en funci√≥n de √©l. Es un poco
complicado al principio, pero una vez que te acostumbras, desear√°s tenerlo en
todos los lenguajes. Es consistentemente un favorito de los usuarios.</p>
<h3 id="los-matches-son-exhaustivos"><a class="header" href="#los-matches-son-exhaustivos">Los matches son exhaustivos</a></h3>
<p>Hay otro aspecto de <code>match</code> que debemos discutir: los patrones de las Opciones
deben cubrir todas las posibilidades. Considera esta versi√≥n de nuestra
funci√≥n <code>plus_one</code>, que tiene un error y no se compila:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>No manejamos el caso <code>None</code>, por lo que este c√≥digo causar√° un error.
Afortunadamente, es un error que Rust sabe c√≥mo detectar. Si intentamos
compilar este c√≥digo, obtendremos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:572:1
 ::: /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:576:5
  |
  = note: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error
</code></pre>
<p>Rust sabe que no cubrimos todos los casos posibles, e incluso sabe qu√©
patr√≥n olvidamos! Los matches en Rust son <em>exhaustivos</em>: debemos agotar
todas las posibilidades para que el c√≥digo sea v√°lido. Especialmente en el
caso de <code>Option&lt;T&gt;</code>, cuando Rust nos impide olvidar manejar el caso <code>None</code>,
nos protege de asumir que tenemos un valor cuando podr√≠amos tener nulo,
haciendo as√≠ imposible el error de mil millones de d√≥lares discutido
anteriormente.</p>
<h3 id="patrones-de-captura-y-el-placeholder-_"><a class="header" href="#patrones-de-captura-y-el-placeholder-_">Patrones de captura y el Placeholder <code>_</code></a></h3>
<p>Usando enums, tambi√©n podemos tomar acciones especiales para algunos valores
particulares, pero para todos los dem√°s valores, tomar una acci√≥n
predeterminada. Imagina que estamos implementando un juego donde, si sacas un
3 en un lanzamiento de dados, tu jugador no se mueve, sino que obtiene un nuevo
sombrero elegante. Si sacas un 7, tu jugador pierde un sombrero elegante.
Para todos los dem√°s valores, tu jugador se mueve esa cantidad de espacios
en el tablero de juego. Aqu√≠ hay un <code>match</code> que implementa esa l√≥gica, con el
resultado del lanzamiento de dados codificado en lugar de un valor aleatorio,
y toda la l√≥gica representada por funciones sin cuerpos porque implementarlas
realmente est√° fuera del alcance de este ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>Para las primeras dos Opciones, los patrones son los valores literales <code>3</code> y
<code>7</code>. Para la √∫ltima Opci√≥n que cubre cualquier otro valor posible, el patr√≥n
es la variable que hemos elegido para nombrar <code>other</code>. El c√≥digo que se
ejecuta para la Opci√≥n <code>other</code> usa la variable pas√°ndola a la funci√≥n
<code>move_player</code>.</p>
<p>Este c√≥digo compila, aunque no hemos enumerado todos los posibles valores que
puede tener un <code>u8</code>, porque el √∫ltimo patr√≥n coincidir√° con todos los valores
no especificados espec√≠ficamente. Este patr√≥n de captura cumple con el
requisito de que <code>match</code> debe ser exhaustivo. Ten en cuenta que tenemos que
poner la Opci√≥n de captura al final porque los patrones se eval√∫an en orden. Si
ponemos la Opci√≥n de captura antes, las otras Opciones nunca se ejecutar√≠an, por
lo que Rust nos advertir√° si agregamos Opciones despu√©s de un catch-all!</p>
<p>Rust tambi√©n tiene un patr√≥n que podemos usar cuando queremos un catch-all,
pero no queremos <em>usar</em> el valor en el patr√≥n catch-all: <code>_</code> es un patr√≥n
especial que coincide con cualquier valor y no se vincula a ese valor. Esto le
dice a Rust que no vamos a usar el valor, por lo que Rust no nos advertir√°
sobre una variable no utilizada.</p>
<p>Vamos a cambiar las reglas del juego. Ahora, si sacas un n√∫mero diferente de un 3 o un 7 debes tirar
de nuevo. Ya no necesitamos usar el valor general, por lo que puede cambiar
nuestro c√≥digo para usar <code>_</code> en lugar de la variable llamada <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>Este ejemplo tambi√©n cumple con el requisito de exhaustividad porque estamos
expl√≠citamente ignorando todos los dem√°s valores en la √∫ltima Opci√≥n; no hemos
olvidado nada.</p>
<p>Finalmente, cambiaremos las reglas del juego una vez m√°s para que nada m√°s
ocurra en tu turno si sacas algo que no sea un 3 o un 7. Podemos expresar eso
usando el valor de unidad (el tipo de tupla vac√≠a que mencionamos en <a href="ch03-02-data-types.html#el-tipo-tupla">‚ÄúEl tipo
de tupla‚Äù</a><!-- ignore --> secci√≥n) como el c√≥digo que va con la Opci√≥n
<code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>Aqu√≠, le decimos a Rust expl√≠citamente que no vamos a usar ning√∫n otro valor
que no coincida con un patr√≥n en una Opci√≥n anterior, y no queremos ejecutar
ning√∫n c√≥digo en este caso.</p>
<p>Hay m√°s sobre patrones y coincidencias que cubriremos en el <a href="ch18-00-patterns.html">Cap√≠tulo
18</a><!-- ignore -->. Por ahora, vamos a pasar a la sintaxis
<code>if let</code> que puede ser √∫til en situaciones en las que la expresi√≥n <code>match</code> es
un poco larga.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flujo-de-control-conciso-con-if-let"><a class="header" href="#flujo-de-control-conciso-con-if-let">Flujo de Control Conciso con <code>if let</code></a></h2>
<p>La sintaxis <code>if let</code> te permite combinar <code>if</code> y <code>let</code> en una forma menos
verbosa de manejar valores que coinciden con un patr√≥n mientras se ignoran el
resto. Considera el programa en el Listado 6-6 que coincide con un valor
<code>Option&lt;u8&gt;</code> en la variable <code>config_max</code> pero solo quiere ejecutar el c√≥digo si
el valor es la variante <code>Some</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!(&quot;The maximum is configured to be {max}&quot;),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 6-6: Un <code>match</code> que solo se preocupa por ejecutar
c√≥digo cuando el valor es <code>Some</code></span></p>
<p>Si el valor es <code>Some</code>, imprimimos el valor en la variante <code>Some</code> vinculando el
valor a la variable <code>max</code> en el patr√≥n. No queremos hacer nada con el valor
<code>None</code>. Para satisfacer la expresi√≥n <code>match</code>, tenemos que agregar <code>_ =&gt; ()</code>
despu√©s de procesar solo una variante, lo cual es un c√≥digo de plantilla
molesto para agregar.</p>
<p>En su lugar, podr√≠amos escribir esto de una manera m√°s corta usando <code>if let</code>.
El siguiente c√≥digo se comporta de la misma manera que el <code>match</code> en el Listado
6-6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!(&quot;The maximum is configured to be {max}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>La sintaxis <code>if let</code> toma un patr√≥n y una expresi√≥n separados por un signo
igual. Funciona de la misma manera que un <code>match</code>, donde la expresi√≥n se da al
<code>match</code> y el patr√≥n es su primer brazo. En este caso, el patr√≥n es <code>Some(max)</code>,
y el <code>max</code> se vincula al valor dentro del <code>Some</code>. Luego podemos usar <code>max</code> en
el cuerpo del bloque <code>if let</code> de la misma manera que usamos <code>max</code> en el brazo
<code>match</code> correspondiente. El c√≥digo en el bloque <code>if let</code> no se ejecuta si el
valor no coincide con el patr√≥n.</p>
<p>Usar <code>if let</code> significa menos escritura, menos indentaci√≥n y menos c√≥digo repetitivo. Sin embargo, pierdes la verificaci√≥n exhaustiva que hace cumplir
<code>match</code>. Elegir entre <code>match</code> e <code>if let</code> depende de lo que est√©s haciendo en tu
situaci√≥n particular y de si ser m√°s conciso a cambio de la verificaci√≥n exhaustiva es un intercambio adecuado.</p>
<p>En otras palabras, puedes pensar en <code>if let</code> como una sintaxis dulce para un
<code>match</code> que ejecuta c√≥digo cuando el valor coincide con un patr√≥n y luego
ignora todos los dem√°s valores.</p>
<p>Podemos incluir un <code>else</code> con un <code>if let</code>. El bloque de c√≥digo que va con el
<code>else</code> es el mismo que el bloque de c√≥digo que ir√≠a con el caso <code>_</code> en la
expresi√≥n <code>match</code> que es equivalente al <code>if let</code> y <code>else</code>. Recuerda la
definici√≥n de <code>Coin</code> en el Listado 6-4, donde la variante <code>Quarter</code> tambi√©n
ten√≠a un valor <code>UsState</code>. Si quisi√©ramos contar todas las monedas que no son
cuartos que vemos mientras tambi√©n anunciamos el estado de los cuartos, podr√≠amos
hacerlo con una expresi√≥n <code>match</code>, como esta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {state:?}!&quot;),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>O podr√≠amos usar un <code>if let</code> y <code>else</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {state:?}!&quot;);
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<p>Si se encuentra en una situaci√≥n en la cual tu programa tiene l√≥gica que es
demasiado verbosa para expresar usando un <code>match</code>, recuerda que <code>if let</code> est√°
en tu caja de herramientas de Rust tambi√©n.</p>
<h2 id="resumen-5"><a class="header" href="#resumen-5">Resumen</a></h2>
<p>Ahora hemos cubierto c√≥mo usar enums para crear tipos personalizados que pueden
ser uno de un conjunto de valores enumerados. Hemos mostrado c√≥mo el tipo
<code>Option&lt;T&gt;</code> de la biblioteca est√°ndar te ayuda a usar el sistema de tipos para
prevenir errores. Cuando los valores de enum tienen datos dentro de ellos,
podemos usar <code>match</code> o <code>if let</code> para extraer y usar esos valores, dependiendo de
cu√°ntos casos necesites manejar.</p>
<p>Tus programas Rust ahora pueden expresar conceptos en tu dominio usando
structs y enums. Crear tipos personalizados para usar en tu API
asegura la seguridad de tipos: el compilador se asegurar√° de que tus funciones
solo obtengan valores del tipo que cada funci√≥n espera.</p>
<p>En orden de proveer una API bien organizada a tus usuarios que sea
sencilla de usar y solo exponga exactamente lo que tus usuarios necesitar√°n,
ahora vamos a ver los m√≥dulos de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="administrando-proyectos-en-crecimiento-con-paquetes-crates-y-m√≥dulos"><a class="header" href="#administrando-proyectos-en-crecimiento-con-paquetes-crates-y-m√≥dulos">Administrando proyectos en crecimiento con paquetes, crates y m√≥dulos</a></h1>
<p>A medida que escribes programas grandes, organizar tu c√≥digo se volver√° cada vez m√°s
importante. Al agrupar funcionalidades relacionadas y separar el c√≥digo con
caracter√≠sticas distintas, tendr√°s m√°s claro d√≥nde encontrar el c√≥digo que implementa
una caracter√≠stica concreta y d√≥nde ir para cambiar el funcionamiento de una
caracter√≠stica.</p>
<p>Los programas que hemos escrito hasta ahora han estado en un m√≥dulo en un
archivo. A medida que un proyecto crece, debes organizar el c√≥digo dividi√©ndolo
en m√∫ltiples m√≥dulos y luego en m√∫ltiples archivos. Un paquete puede contener
m√∫ltiples <em>crates</em> binarios y opcionalmente un <em>crate</em> de biblioteca. A medida
que un paquete crece, puedes extraer partes en <em>crates</em> separados que se
convierten en dependencias externas. Este cap√≠tulo cubre todas estas
t√©cnicas. Para proyectos muy grandes que comprenden un conjunto de paquetes
interrelacionados que evolucionan juntos, Cargo proporciona <em>workspaces</em>, que
cubriremos en la secci√≥n <a href="ch14-03-cargo-workspaces.html">‚ÄúCargo Workspaces‚Äù</a><!-- ignore --> en el
Cap√≠tulo 14.</p>
<p>Tambi√©n discutiremos la encapsulaci√≥n de detalles de implementaci√≥n, que le
permite reutilizar el c√≥digo a un nivel superior: una vez que ha implementado
una operaci√≥n, otro c√≥digo puede llamar a su c√≥digo a trav√©s de su interfaz
p√∫blica sin tener que saber c√≥mo funciona la implementaci√≥n. La forma en que
escribes el c√≥digo define qu√© partes son p√∫blicas para que otro c√≥digo las use
y qu√© partes son detalles de implementaci√≥n privados que te reservas el
derecho de cambiar. Esta es otra forma de limitar la cantidad de detalles que
tienes que mantener en tu cabeza.</p>
<p>Un concepto relacionado es el √°mbito: el contexto anidado en el que se
escribe el c√≥digo tiene un conjunto de nombres que se definen como
&quot;en el √°mbito&quot;. Al leer, escribir y compilar c√≥digo, los programadores y
compiladores necesitan saber si un nombre concreto en un punto determinado
se refiere a una variable, funci√≥n, estructura, enumeraci√≥n, m√≥dulo, constante
u otro elemento, y qu√© significa ese elemento. Se pueden crear √°mbitos y cambiar
los nombres que est√°n dentro o fuera de ellos.
No puede haber dos elementos con el mismo nombre en el mismo √°mbito;
existen herramientas para resolver conflictos de nombres.</p>
<p>Rust tiene una serie de caracter√≠sticas que te permiten administrar la
organizaci√≥n de tu c√≥digo, incluidos los detalles que se exponen, los detalles
que son privados y los nombres que est√°n en cada √°mbito en tus programas. Estas
caracter√≠sticas, a veces denominadas colectivamente <em>sistema de m√≥dulos</em>,
incluyen:</p>
<ul>
<li><strong>Paquetes:</strong> Una caracter√≠stica de Cargo que te permite construir, probar y
compartir <em>crates</em></li>
<li><strong>Crates:</strong> Un √°rbol de m√≥dulos que produce una biblioteca o ejecutable</li>
<li><strong>M√≥dulos</strong> y <strong>use:</strong> Te permiten controlar la organizaci√≥n, el √°mbito y
la privacidad de las rutas</li>
<li><strong>Rutas:</strong> Una forma de nombrar un elemento, como una estructura, funci√≥n o
m√≥dulo</li>
</ul>
<p>En este cap√≠tulo, cubriremos todas estas caracter√≠sticas, discutiremos c√≥mo
interact√∫an y explicaremos c√≥mo usarlas para administrar el √°mbito. Al final,
deber√≠as tener una comprensi√≥n s√≥lida del sistema de m√≥dulos y poder trabajar
con √°mbitos como un profesional!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="paquetes-y-crates"><a class="header" href="#paquetes-y-crates">Paquetes y Crates</a></h2>
<p>Las primeras partes del sistema de m√≥dulos que cubriremos son los paquetes y los
crates.</p>
<p>Un <em>crate</em> es la cantidad m√°s peque√±a de c√≥digo que el compilador Rust considera
a la vez. Incluso si ejecutas <code>rustc</code> en lugar de <code>cargo</code> y pasas un solo
archivo de c√≥digo fuente (como lo hicimos en la secci√≥n ‚ÄúEscribir y Ejecutar un
Programa Rust‚Äù del Cap√≠tulo 1), el compilador considera que ese archivo es un
crate. Los crates pueden contener m√≥dulos, y los m√≥dulos pueden definirse en
otros archivos que se compilan con el crate, como veremos en las pr√≥ximas
secciones.</p>
<p>Un crate puede venir en una de dos formas: un crate binario o un crate de
biblioteca. Los <em>crates binarios</em> son programas que puedes compilar a un
ejecutable que puedes ejecutar, como un programa de l√≠nea de comandos o un
servidor. Cada uno debe tener una funci√≥n llamada <code>main</code> que defina lo que
sucede cuando se ejecuta el ejecutable. Todos los crates que hemos creado hasta
ahora han sido crates binarios.</p>
<p>Los <em>crates de biblioteca</em> no tienen una funci√≥n <code>main</code>, y no se compilan a un
ejecutable. En su lugar, definen funcionalidad destinada a ser compartida con
m√∫ltiples proyectos. Por ejemplo, el crate <code>rand</code> que usamos en el <a href="ch02-00-guessing-game-tutorial.html#generar-un-numero-aleatorio">Cap√≠tulo
2</a><!-- ignore --> proporciona funcionalidad que genera n√∫meros aleatorios.
La mayor parte del tiempo, cuando los Rustaceans dicen ‚Äúcrate‚Äù, se refieren a
crate de biblioteca, y usan ‚Äúcrate‚Äù indistintamente con el concepto general de
programaci√≥n de una ‚Äúbiblioteca‚Äù.</p>
<p>El <em>crate root</em> es un archivo fuente que el compilador Rust comienza y forma el
m√≥dulo ra√≠z de tu crate (explicaremos los m√≥dulos en profundidad en la secci√≥n
<a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">‚ÄúDefinir M√≥dulos para Controlar el Alcance y la Privacidad‚Äù</a><!-- ignore
-->).</p>
<p>Un <em>paquete</em> es un conjunto de uno o m√°s crates que proporciona un conjunto de
funcionalidades. Un paquete contiene un archivo <em>Cargo.toml</em> que describe c√≥mo
compilar esos crates. Cargo es en realidad un paquete que contiene el crate
binario para la herramienta de l√≠nea de comandos que has estado usando para
compilar tu c√≥digo. El paquete Cargo tambi√©n contiene un crate de biblioteca en
el que el crate binario depende. Otros proyectos pueden depender del crate de
biblioteca Cargo para usar la misma l√≥gica que la herramienta de l√≠nea de
comandos Cargo usa.</p>
<p>Un paquete puede venir en dos formas: un paquete binario o un paquete libreria.
Un paquete puede contener tantos crates binarios como desees, pero como m√°ximo
solo un crate de biblioteca. Un paquete debe contener al menos un crate, ya sea
un crate de biblioteca o un crate binario.</p>
<p>Veamos qu√© sucede cuando creamos un paquete. Primero, ingresamos el comando
<code>cargo new</code>:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Despu√©s de ejecutar <code>cargo new my-project</code>, usamos <code>ls</code> para ver lo que crea 
Cargo. En el directorio del proyecto, hay un archivo <em>Cargo.toml</em>, que nos da un
paquete. Tambi√©n hay un directorio <em>src</em> que contiene <em>main.rs</em>. Abre 
<em>Cargo.toml</em> en tu editor de texto, y observa que no hay menci√≥n de 
<em>src/main.rs</em>. Cargo sigue una convenci√≥n de que <em>src/main.rs</em> es la ra√≠z del 
crate de un crate binario con el mismo nombre que el paquete. Del mismo modo, 
Cargo sabe que si el directorio del paquete contiene <em>src/lib.rs</em>, el paquete 
contiene un crate de biblioteca con el mismo nombre que el paquete, y 
<em>src/lib.rs</em> es su ra√≠z del crate. Cargo pasa los archivos ra√≠z del crate a 
<code>rustc</code> para compilar la biblioteca o el binario.</p>
<p>Aqu√≠, tenemos un paquete que solo contiene <em>src/main.rs</em>, lo que significa que
solo contiene un crate binario llamado <code>my-project</code>. Si un paquete contiene
<em>src/main.rs</em> y <em>src/lib.rs</em>, tiene dos crates: un binario y una biblioteca,
ambos con el mismo nombre que el paquete. Un paquete puede tener m√∫ltiples
crates binarios colocando archivos en el directorio <em>src/bin</em>: cada archivo ser√°
un crate binario separado.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definiendo-m√≥dulos-para-controlar-el-alcance-y-la-privacidad"><a class="header" href="#definiendo-m√≥dulos-para-controlar-el-alcance-y-la-privacidad">Definiendo m√≥dulos para controlar el alcance y la privacidad</a></h2>
<p>En esta secci√≥n, hablaremos sobre m√≥dulos y otras partes del sistema de m√≥dulos,
es decir, <em>rutas</em> que permiten nombrar elementos; la palabra clave <code>use</code> que
trae una ruta dentro del √°mbito; y la palabra clave <code>pub</code> para hacer elementos
p√∫blicos. Tambi√©n discutiremos la palabra clave <code>as</code>, los paquetes externos y el
operador <code>glob</code>.</p>
<p>Primero, vamos a empezar con una lista de reglas para tener a mano cuando
est√©s organizando tu c√≥digo en el futuro. Luego explicaremos cada una de las
reglas en detalle.</p>
<h3 id="hoja-de-referencia-de-m√≥dulos"><a class="header" href="#hoja-de-referencia-de-m√≥dulos">Hoja de referencia de m√≥dulos</a></h3>
<p>Antes nosotros debemos obtener los detalles de los m√≥dulos y las rutas, aqu√≠ te 
proporcionamos una referencia r√°pida sobre c√≥mo funcionan los m√≥dulos,
las rutas, la palabra clave <code>use</code> y la palabra clave <code>pub</code> en el compilador, y
c√≥mo la mayor√≠a de los desarrolladores organizan su c√≥digo. Vamos a ir
tratando ejemplos de cada una de estas reglas a lo largo de este cap√≠tulo, pero
esta es una buena referencia para tener a mano cuando necesites recordar c√≥mo
funcionan los m√≥dulos.</p>
<ul>
<li><strong>Empezamos desde la ra√≠z del crate</strong>: Cuando se compila un crate, el
compilador primero busca el c√≥digo en el archivo ra√≠z del crate (usualmente
<em>src/lib.rs</em> para un crate de librer√≠a o <em>src/main.rs</em> para un crate
binario) para compilar.</li>
<li><strong>Declarando m√≥dulos</strong>: En el archivo ra√≠z del crate, puedes declarar nuevos
m√≥dulos; digamos, que declaras un m√≥dulo ‚Äúgarden‚Äù con <code>mod garden;</code>. El
compilador buscar√° el c√≥digo del m√≥dulo en estos lugares:
<ul>
<li>Inline, dentro de llaves que reemplazan el punto y coma que sigue a <code>mod garden</code></li>
<li>En el archivo <em>src/garden.rs</em></li>
<li>En el archivo <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Declarando subm√≥dulos</strong>: En cualquier archivo que no sea la ra√≠z del crate,
puedes declarar subm√≥dulos. Por ejemplo, podr√≠as declarar <code>mod vegetables;</code> en
<em>src/garden.rs</em>. El compilador buscar√° el c√≥digo del subm√≥dulo dentro del
directorio que se llama igual que el m√≥dulo padre en estos lugares:
<ul>
<li>En l√≠nea, directamente despu√©s de <code>mod vegetables</code>, dentro de llaves que
reemplazan el punto y coma que sigue a <code>mod garden</code></li>
<li>En el archivo <em>src/garden/vegetables.rs</em></li>
<li>En el archivo <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>Rutas de acceso a c√≥digo en m√≥dulos</strong>: Una vez que un m√≥dulo es parte de tu crate, puedes
referirte al c√≥digo de ese m√≥dulo desde cualquier otro lugar del mismo crate,
siempre y cuando las reglas de privacidad lo permitan, usando la ruta al
c√≥digo. Por ejemplo, un tipo <code>Asparagus</code> en el m√≥dulo de vegetales del garden
se encontrar√≠a en <code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>Privado vs. p√∫blico</strong>: El c√≥digo dentro de un m√≥dulo es privado por defecto
desde los m√≥dulos padres. Para hacer un m√≥dulo p√∫blico, decl√°ralo con <code>pub mod</code> en vez de <code>mod</code>. Para hacer p√∫blicos los elementos dentro de un m√≥dulo
p√∫blico, usa <code>pub</code> antes de sus declaraciones.</li>
<li><strong>La palabra clave <code>use</code></strong>: Dentro de un alcance, la palabra clave <code>use</code> crea
atajos a elementos para reducir la repetici√≥n de rutas largas. En cualquier
alcance que pueda referirse a <code>crate::garden::vegetables::Asparagus</code>, puedes
crear un atajo con <code>use crate::garden::vegetables::Asparagus;</code> y a partir de
entonces solo necesitar√°s escribir <code>Asparagus</code> para hacer uso de ese tipo en
el alcance.</li>
</ul>
<p>Aqu√≠, crearemos un crate binario llamado <code>backyard</code> que ilustra estas reglas. El
directorio del crate, tambi√©n llamado <code>backyard</code>, contiene estos archivos y
directorios:</p>
<pre><code class="language-text">backyard
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ garden
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ vegetables.rs
    ‚îú‚îÄ‚îÄ garden.rs
    ‚îî‚îÄ‚îÄ main.rs
</code></pre>
<p>El crate ra√≠z es <em>src/main.rs</em>, y contiene:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!(&quot;I'm growing {plant:?}!&quot;);
}</code></pre>
<p>La l√≠nea <code>mod garden;</code> le dice al compilador que incluya el c√≥digo que encuentra
en <em>src/garden.rs</em>, que es:</p>
<p><span class="filename">Filename: src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
<p>Aqu√≠, <code>pub mod vegetables;</code> significa que el c√≥digo en <em>src/garden/vegetables.rs</em>
tambi√©n se incluye. Ese c√≥digo es:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>¬°Ahora entremos en los detalles de estas reglas y demostr√©moslas en acci√≥n!</p>
<h3 id="agrupando-c√≥digo-relacionado-en-m√≥dulos"><a class="header" href="#agrupando-c√≥digo-relacionado-en-m√≥dulos">Agrupando c√≥digo relacionado en m√≥dulos</a></h3>
<p>Los <em>m√≥dulos</em> nos permiten organizar el c√≥digo dentro de un crate para facilitar
su lectura y reutilizaci√≥n. Tambi√©n nos permiten controlar la privacidad de los
elementos, ya que el c√≥digo dentro de un m√≥dulo es privado por defecto. Los
elementos privados son detalles de la implementaci√≥n interna que no est√°n
disponibles para su uso externo. Podemos elegir hacer p√∫blicos los m√≥dulos y los
elementos que contienen para exponerlos y permitir que el c√≥digo externo los
use y dependa de ellos.</p>
<p>Como un ejemplo, vamos a escribir una librer√≠a que provee la funcionalidad de un
restaurante. Vamos a definir las firmas de las funciones, pero dejaremos sus
cuerpos vac√≠os para concentrarnos en la organizaci√≥n del c√≥digo, en vez de la
implementaci√≥n de un restaurante.</p>
<p>En la industria de restaurantes, algunas partes de un restaurante se llaman
<em>front of house</em> y otras <em>back of house</em>. El <em>front of house</em> es donde est√°n
los clientes; esto incluye donde los anfitriones se sientan a los clientes,
los camareros toman los pedidos y el pago, y los bartenders preparan las
bebidas. El <em>back of house</em> es donde los chefs y los cocineros trabajan en la
cocina, los lavaplatos limpian, y los gerentes hacen el trabajo administrativo.</p>
<p>Para estructurar nuestro crate de esta manera, podemos organizar sus funciones
dentro de m√≥dulos anidados. Crea una nueva librer√≠a llamada <code>restaurant</code>
ejecutando <code>cargo new restaurant --lib</code>. Luego ingresa el c√≥digo en el 
Listado 7-1 para definir algunos m√≥dulos y firmas de funciones. Aqu√≠ est√° la
secci√≥n <em>front of house</em>:</p>
<p><span class="filename">Nombre de archivo: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
<p><span class="caption">Listado 7-1: Un m√≥dulo <code>front_of_house</code> que contiene otros
m√≥dulos que luego contienen funciones</span></p>
<p>Definimos un m√≥dulo con la palabra clave <code>mod</code> seguida del nombre del m√≥dulo
(en este caso, <code>front_of_house</code>). El cuerpo del m√≥dulo va dentro de llaves.
Dentro de los m√≥dulos, podemos colocar otros m√≥dulos, como en este caso con los
m√≥dulos <code>hosting</code> y <code>serving</code>. Los m√≥dulos tambi√©n pueden contener definiciones
de otros elementos, como structs, enums, constantes, traits, y como en la Lista
7-1‚Äîfunciones.</p>
<p>Mediante el uso de m√≥dulos, podemos agrupar definiciones relacionadas y nombrar
por qu√© est√°n relacionadas. Los programadores que usen este c√≥digo pueden
navegar el c√≥digo bas√°ndose en los grupos en vez de tener que leer todas las
definiciones, haciendo m√°s f√°cil encontrar las definiciones relevantes para
ellos. Los programadores que agreguen nueva funcionalidad a este c√≥digo sabr√°n
d√≥nde colocar el c√≥digo para mantener el programa organizado.</p>
<p>Anteriormente, mencionamos que <em>src/main.rs</em> y <em>src/lib.rs</em> se llaman ra√≠ces de
crate. La raz√≥n de su nombre es que el contenido de cualquiera de estos dos
archivos forma un m√≥dulo llamado <code>crate</code> en la ra√≠z de la estructura de m√≥dulos
del crate, conocida como el <em>√°rbol de m√≥dulos</em>.</p>
<p>El Listado 7-2 muestra el √°rbol de m√≥dulos para la estructura en el listado 7-1</p>
<pre><code class="language-text">crate
 ‚îî‚îÄ‚îÄ front_of_house
     ‚îú‚îÄ‚îÄ hosting
     ‚îÇ   ‚îú‚îÄ‚îÄ add_to_waitlist
     ‚îÇ   ‚îî‚îÄ‚îÄ seat_at_table
     ‚îî‚îÄ‚îÄ serving
         ‚îú‚îÄ‚îÄ take_order
         ‚îú‚îÄ‚îÄ serve_order
         ‚îî‚îÄ‚îÄ take_payment
</code></pre>
<p><span class="caption">Listado 7-2: El √°rbol de m√≥dulos para el c√≥digo del
listado 7-1</span></p>
<p>Este √°rbol muestra como algunos de los m√≥dulos se anidan dentro de otros m√≥dulos; 
por ejemplo, <code>hosting</code> se anida dentro de <code>front_of_house</code>. El √°rbol tambi√©n 
muestra que algunos m√≥dulos son <em>hermanos</em> entre s√≠, lo que significa que est√°n
definidos en el mismo m√≥dulo; <code>hosting</code> y <code>serving</code> son hermanos definidos
dentro de <code>front_of_house</code>. Si el m√≥dulo A est√° contenido dentro del m√≥dulo B,
decimos que el m√≥dulo A es el <em>hijo</em> del m√≥dulo B y que el m√≥dulo B es el
<em>padre</em> del m√≥dulo A. Nota que el √°rbol de m√≥dulos completo est√° enraizado bajo
el m√≥dulo impl√≠cito llamado <code>crate</code>.</p>
<p>El √°rbol de m√≥dulos puede recordarte al √°rbol de directorios del sistema de
archivos en tu computadora; ¬°esta es una comparaci√≥n muy apropiada! Al igual que
los directorios en un sistema de archivos, usas m√≥dulos para organizar tu
c√≥digo. Y al igual que los archivos en un directorio, necesitamos una forma de
encontrar nuestros m√≥dulos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rutas-para-referirse-a-un-elemento-en-el-√°rbol-de-m√≥dulos"><a class="header" href="#rutas-para-referirse-a-un-elemento-en-el-√°rbol-de-m√≥dulos">Rutas para referirse a un elemento en el √°rbol de m√≥dulos</a></h2>
<p>Para mostrarle a Rust d√≥nde encontrar un item en el √°rbol de m√≥dulos, usamos una
ruta de la misma manera que usamos una ruta cuando navegamos en un sistema de archivos.
Para llamar a una funci√≥n, necesitamos saber su ruta.</p>
<p>Una ruta puede tomar dos formas:</p>
<ul>
<li>
<p>Una <em>ruta absoluta</em> es la ruta completa que comienza desde la ra√≠z de un <code>crate</code>; para el c√≥digo de un <code>crate</code> externo, la ruta absoluta comienza con el nombre del <code>crate</code>, y para el c√≥digo del crate actual, comienza con el <code>crate</code> literal.</p>
</li>
<li>
<p>Una <em>ruta relativa</em> comienza desde el m√≥dulo actual y utiliza <code>self</code>, <code>super</code>, o un
identificador del m√≥dulo actual.</p>
</li>
</ul>
<p>Tanto las rutas absolutas como las relativas est√°n seguidas por uno o m√°s
identificadores separados por dos puntos dobles (<code>::</code>).</p>
<p>Volviendo al listado 7-1, digamos que queremos llamar a la funci√≥n
<code>add_to_waitlist</code> desde la funci√≥n <code>eat_at_restaurant</code> definida en el crate
root. Este es el mismo que preguntar: ¬øcu√°l es la ruta de la funci√≥n
<code>add_to_waitlist</code>? El listado 7-3 contiene el listado 7-1 con algunos de los
m√≥dulos y funciones removidas.</p>
<p>Mostraremos dos formas de llamar a la funci√≥n <code>add_to_waitlist</code> desde una nueva
funci√≥n, <code>eat_at_restaurant</code>, definida en el crate de la ra√≠z. Estas rutas son
correctas, pero hay otro problema que impide que este ejemplo compile tal cual.
Explicaremos por qu√© en un momento.</p>
<p>La funci√≥n <code>eat_at_restaurant</code> es parte de la API p√∫blica del crate de nuestra
librer√≠a, as√≠ que la marcamos con la palabra clave <code>pub</code>. En la secci√≥n
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exponiendo-rutas-con-la-palabra-clave-pub">‚ÄúExponiendo Rutas con la palabra clave <code>pub</code>‚Äù</a><!-- ignore -->, iremos en
m√°s detalle sobre <code>pub</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-3: Llamando a la funci√≥n <code>add_to_waitlist</code> usando
rutas absolutas y relativas</span></p>
<p>La primera vez que llamamos a la funci√≥n <code>add_to_waitlist</code> en <code>eat_at_restaurant</code>,
usamos una ruta absoluta. La funci√≥n <code>add_to_waitlist</code> est√° definida en el mismo
crate que <code>eat_at_restaurant</code>, lo que significa que podemos usar la palabra
clave <code>crate</code> para comenzar una ruta absoluta. Luego incluimos cada uno de los
m√≥dulos sucesivos hasta que llegamos a <code>add_to_waitlist</code>. Puedes imaginar un
sistema de archivos con la misma estructura: especificar√≠amos la ruta
<code>/front_of_house/hosting/add_to_waitlist</code> para ejecutar el programa
<code>add_to_waitlist</code>; usar el nombre <code>crate</code> para comenzar desde la ra√≠z del crate
es como usar <code>/</code> para comenzar desde la ra√≠z del sistema de archivos en tu
shell.</p>
<p>La segunda vez que llamamos a <code>add_to_waitlist</code> en <code>eat_at_restaurant</code>, usamos
la ruta relativa. La ruta comienza con <code>front_of_house</code>, el nombre del m√≥dulo
definido al mismo nivel del √°rbol de m√≥dulos que <code>eat_at_restaurant</code>. Aqu√≠ el
equivalente en el sistema de archivos ser√≠a usar la ruta
<code>front_of_house/hosting/add_to_waitlist</code>. Comenzar con el nombre del m√≥dulo
significa que la ruta es relativa.</p>
<p>Elegir si usar una ruta relativa o absoluta es una decisi√≥n que tomar√°s basado
en tu proyecto, y depende de si es m√°s probable que muevas la definici√≥n de un
item de c√≥digo separadamente o junto con el c√≥digo que usa el item. Por
ejemplo, si movemos el m√≥dulo <code>front_of_house</code> y la funci√≥n <code>eat_at_restaurant</code>
a un m√≥dulo llamado <code>customer_experience</code>, necesitar√≠amos actualizar la ruta
absoluta a <code>add_to_waitlist</code>, pero la ruta relativa seguir√≠a siendo v√°lida.
Sin embargo, si movemos la funci√≥n <code>eat_at_restaurant</code> separadamente a un
m√≥dulo llamado <code>dining</code>, la ruta absoluta a la llamada de <code>add_to_waitlist</code>
seguir√≠a siendo la misma, pero la ruta relativa necesitar√≠a ser actualizada.
Nuestra preferencia en general es especificar rutas absolutas porque es m√°s
probable que queramos mover definiciones de c√≥digo y llamadas de items
independientemente.</p>
<p>¬°Intentemos compilar el listado 7-3 y averig√ºemos por qu√© a√∫n no compila! Los
errores que obtenemos se muestran en el listado 7-4.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Listado 7-4: Errores de compilaci√≥n al hacer building del
c√≥digo del listado 7-3</span></p>
<p>El mensaje de error dice que el m√≥dulo <code>hosting</code> es privado. En otras palabras,
tenemos las rutas correctas para el m√≥dulo <code>hosting</code> y la funci√≥n
<code>add_to_waitlist</code>, pero Rust no nos deja usarlos porque no tiene acceso a las
secciones privadas. En Rust, todos los items (funciones, m√©todos, structs,
enums, m√≥dulos, y constantes) son privados a los m√≥dulos padres por defecto. Si
quieres hacer un item como una funci√≥n o struct privado, lo pones en un m√≥dulo.</p>
<p>Los elementos en un m√≥dulo privado no pueden ser accedidos por una ruta externa
absoluta, porque el m√≥dulo padre no puede ver dentro de los m√≥dulos privados de
sus hijos. El m√≥dulo padre puede ver el contenido de sus m√≥dulos hijos porque
los m√≥dulos hijos est√°n dentro del m√≥dulo padre. Para continuar con nuestra
met√°fora, piensa en las reglas de privacidad como la oficina de atr√°s de un
restaurante: lo que pasa ah√≠ es privado para los clientes del restaurante, pero
los gerentes de la oficina pueden ver y hacer todo en el restaurante que
operan.</p>
<p>Rust elige tener el sistema de m√≥dulos funcionando de esta forma para que
ocultar detalles de implementaci√≥n internos sea lo predeterminado. De esta
forma, sabes qu√© partes del c√≥digo interno puedes cambiar sin romper el c√≥digo
externo. Sin embargo, Rust te da la opci√≥n de exponer partes internas del c√≥digo
de los m√≥dulos hijos a los m√≥dulos ancestros externos usando la palabra clave
<code>pub</code> para hacer un item p√∫blico.</p>
<h3 id="exponiendo-rutas-con-la-palabra-clave-pub"><a class="header" href="#exponiendo-rutas-con-la-palabra-clave-pub">Exponiendo rutas con la palabra clave <code>pub</code></a></h3>
<p>Volviendo al error en el listado 7-4 que nos dijo que el m√≥dulo <code>hosting</code> es
privado, queremos que la funci√≥n <code>eat_at_restaurant</code> en el m√≥dulo padre tenga
acceso a la funci√≥n <code>add_to_waitlist</code> en el m√≥dulo hijo, as√≠ que marcamos el
m√≥dulo <code>hosting</code> con la palabra clave <code>pub</code>, como se muestra en el listado 7-5.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-5: Declarando el m√≥dulo <code>hosting</code> como <code>pub</code>
para usarlo desde <code>eat_at_restaurant</code></span></p>
<p>Desafortunadamente, el c√≥digo en el listado 7-5 a√∫n resulta en errores de 
compilador, como se muestra en el listado 7-6.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<p><span class="caption">Listado 7-6: Errores de compilaci√≥n al hacer building del
c√≥digo del listado 7-5</span></p>
<p>¬øQu√© pas√≥? Agregar la palabra clave <code>pub</code> al frente del m√≥dulo <code>hosting</code> hace
que el m√≥dulo sea p√∫blico. Con este cambio, si podemos acceder a
<code>front_of_house</code>, podemos acceder a <code>hosting</code>. Pero el <em>contenido</em> de <code>hosting</code>
sigue siendo privado; hacer el m√≥dulo p√∫blico no hace que su contenido sea
p√∫blico. La palabra clave <code>pub</code> en un m√≥dulo solo permite que el c√≥digo en sus
m√≥dulos ancestros se refiera a √©l, no acceder a su c√≥digo interno. Debido a que
los m√≥dulos son contenedores, no hay mucho que podamos hacer solo haciendo que
el m√≥dulo sea p√∫blico; necesitamos ir m√°s all√° y elegir hacer que uno o m√°s de
los items dentro del m√≥dulo sean p√∫blicos tambi√©n.</p>
<p>El error en el listado 7-6 dicen que la funci√≥n <code>add_to_waitlist</code> es privada.
Las reglas de privacidad se aplican a structs, enums, funciones, y m√©todos, as√≠
como a m√≥dulos.</p>
<p>Para hacer que la funci√≥n <code>add_to_waitlist</code> sea p√∫blica, necesitamos agregar la
palabra clave <code>pub</code> antes de su definici√≥n, como se muestra en el listado 7-7.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-7: Agregar la keyword <code>pub</code> a <code>mod hosting</code>
y <code>fn add_to_waitlist</code> nos permite llamar a la funci√≥n desde
<code>eat_at_restaurant</code></span></p>
<p>¬°Ahora el c√≥digo compilar√°! Para ver por qu√© agregar la palabra clave <code>pub</code> nos
permite usar estas rutas en <code>eat_at_restaurant</code> con respecto a las reglas de
privacidad, veamos las rutas absolutas y relativas.</p>
<p>En la ruta absoluta, comenzamos con <code>crate</code>, la ra√≠z del √°rbol de m√≥dulos de nuestro crate.
El m√≥dulo <code>front_of_house</code> est√° definido en la ra√≠z del <code>crate</code>. Si
bien <code>front_of_house</code> no es p√∫blico, porque la funci√≥n <code>eat_at_restaurant</code> est√°
definida en el mismo m√≥dulo que <code>front_of_house</code> (es decir, <code>eat_at_restaurant</code>
y <code>front_of_house</code> son hermanos), podemos referirnos a <code>front_of_house</code> desde
<code>eat_at_restaurant</code>. A continuaci√≥n est√° el m√≥dulo <code>hosting</code> marcado con <code>pub</code>.
Podemos acceder al m√≥dulo padre de <code>hosting</code>, por lo que podemos acceder a
<code>hosting</code>. ¬°Finalmente, la funci√≥n <code>add_to_waitlist</code> est√° marcada con <code>pub</code> y
podemos acceder a su m√≥dulo padre, por lo que est√° llamada a funci√≥n funciona!</p>
<p>En la ruta relativa, la l√≥gica es la misma que la ruta absoluta, excepto por el
primer paso: en lugar de comenzar desde la ra√≠z del <code>crate</code>, la ruta comienza
desde <code>front_of_house</code>. El m√≥dulo <code>front_of_house</code> est√° definido dentro del
mismo m√≥dulo que <code>eat_at_restaurant</code>, por lo que la ruta relativa que comienza
desde el m√≥dulo en el que se define <code>eat_at_restaurant</code> funciona. Luego,
porque <code>hosting</code> y <code>add_to_waitlist</code> est√°n marcados con <code>pub</code>, el resto de la ruta
funciona, ¬°y est√° llamada a funci√≥n es v√°lida!</p>
<p>Si planeas compartir tu biblioteca crate para que otros proyectos puedan usar
tu c√≥digo, tu API p√∫blica es tu contrato con los usuarios de tu crate que
determina c√≥mo pueden interactuar con tu c√≥digo. Hay muchas consideraciones
sobre c√≥mo administrar los cambios en tu API p√∫blica para que sea m√°s f√°cil que
la gente dependa de tu crate. Estas consideraciones est√°n fuera del alcance de
este libro; si est√°s interesado en este tema, consulta <a href="https://rust-lang.github.io/api-guidelines/">The Rust API
Guidelines</a>.</p>
<blockquote>
<h4 id="buenas-pr√°cticas-para-paquetes-con-un-binario-y-una-biblioteca"><a class="header" href="#buenas-pr√°cticas-para-paquetes-con-un-binario-y-una-biblioteca">Buenas pr√°cticas para paquetes con un binario y una biblioteca</a></h4>
<p>Mencionamos que un paquete puede contener tanto un binario <em>src/main.rs</em> como
una biblioteca <em>src/lib.rs</em>, y ambos tendr√°n el nombre del paquete de forma
predeterminada. T√≠picamente, los paquetes con este patr√≥n de contener tanto
una biblioteca como un binario tendr√°n solo el c√≥digo suficiente en el binario
para iniciar un ejecutable que llame al c√≥digo con la biblioteca. Esto permite
que otros proyectos se beneficien de que la mayor funcionalidad que 
proporciona el paquete, porque el c√≥digo de la biblioteca se puede compartir.</p>
<p>El √°rbol de m√≥dulos deber√≠a ser definido en <em>src/lib.rs</em>. Luego, cualquier
item p√∫blico puede ser usado en el binario comenzando las rutas con el nombre
del paquete. El binario se convierte en un usuario de la biblioteca de la
misma forma que un crate completamente externo usar√≠a la biblioteca: solo
puede usar la API p√∫blica. Esto te ayuda a dise√±ar una buena API; no solo eres
el autor, ¬°tambi√©n eres un cliente!</p>
<p>En el <a href="ch12-00-an-io-project.html">Cap√≠tulo 12</a><!-- ignore -->, demostraremos esta pr√°ctica
organizativa con un programa de l√≠nea de comandos que contendr√° tanto un
paquete binario como una biblioteca.</p>
</blockquote>
<h3 id="comenzando-rutas-relativas-con-super"><a class="header" href="#comenzando-rutas-relativas-con-super">Comenzando rutas relativas con <code>super</code></a></h3>
<p>Podemos construir rutas relativas que comiencen en el m√≥dulo padre, en lugar de en el m√≥dulo actual o en la ra√≠z del <code>crate</code>,
usando <code>super</code> al comienzo de la ruta. Esto es
como comenzar una ruta del sistema de archivos con la sintaxis <code>..</code>. Usar <code>super</code>
nos permite hacer referencia a un item que sabemos que est√° en el m√≥dulo padre,
lo que puede facilitar la reorganizaci√≥n del √°rbol de m√≥dulos cuando el m√≥dulo
est√° estrechamente relacionado con el padre, pero el padre podr√≠a moverse a
otro lugar en el √°rbol de m√≥dulos alg√∫n d√≠a.</p>
<p>Considere el c√≥digo en el listado 7-8 que modela la situaci√≥n en la que un chef
arregla un pedido incorrecto y lo trae personalmente al cliente. La funci√≥n
<code>fix_incorrect_order</code> definida en el m√≥dulo <code>back_of_house</code> llama a la funci√≥n
<code>deliver_order</code> definida en el m√≥dulo padre especificando la ruta a
<code>deliver_order</code>, comenzando con <code>super</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<p><span class="caption">Listado 7-8: Llamar a una funci√≥n usando una ruta relativa
que comienza con <code>super</code></span></p>
<p>La funci√≥n <code>fix_incorrect_order</code> est√° en el m√≥dulo <code>back_of_house</code>, por lo que
podemos usar <code>super</code> para ir al m√≥dulo padre de <code>back_of_house</code>, que en este
caso es <code>crate</code>, la ra√≠z. Desde all√≠, buscamos <code>deliver_order</code> y lo encontramos.
¬°√âxito! Pensamos que el m√≥dulo <code>back_of_house</code> y la funci√≥n <code>deliver_order</code>
probablemente permanecer√°n en la misma relaci√≥n entre s√≠ y se mover√°n juntos si
decidimos reorganizar el √°rbol de m√≥dulos del crate. Por lo tanto, usamos
<code>super</code> para tener menos lugares para actualizar el c√≥digo en el futuro si este
c√≥digo se mueve a un m√≥dulo diferente.</p>
<h3 id="haciendo-p√∫blicos-los-structs-y-enums"><a class="header" href="#haciendo-p√∫blicos-los-structs-y-enums">Haciendo p√∫blicos los structs y enums</a></h3>
<p>Tambi√©n podemos usar <code>pub</code> para designar structs y enums como p√∫blicos, pero hay
algunos detalles adicionales para el uso de <code>pub</code> con structs y enums. Si
usamos <code>pub</code> antes de una definici√≥n de struct, hacemos que el struct sea
p√∫blico, pero los campos del struct seguir√°n siendo privados. Podemos hacer que
cada campo sea p√∫blico o no caso por caso. En el listado 7-9, hemos definido un
struct <code>back_of_house::Breakfast</code> p√∫blico con un campo <code>toast</code> p√∫blico pero un
campo <code>seasonal_fruit</code> privado. Esto modela el caso en un restaurante donde el
cliente puede elegir el tipo de pan que viene con una comida, pero el chef
decide qu√© fruta acompa√±a la comida seg√∫n lo que est√° en temporada y en stock.
La fruta disponible cambia r√°pidamente, por lo que los clientes no pueden
elegir la fruta o incluso ver qu√© fruta obtendr√°n.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}</code></pre>
<p><span class="caption">Listado 7-9: Un struct con algunos campos p√∫blicos y
algunos campos privados</span></p>
<p>Debido a que el campo <code>toast</code> es p√∫blico, podemos cambiar el valor de <code>toast</code>
en una instancia de <code>Breakfast</code> en la funci√≥n <code>eat_at_restaurant</code> en el listado
7-10. Ten en cuenta que no podemos usar el campo <code>seasonal_fruit</code> en
<code>eat_at_restaurant</code>, porque <code>seasonal_fruit</code> es privado. ¬°Intenta descomentar la
l√≠nea que modifica el valor del campo <code>seasonal_fruit</code> para ver qu√© error
obtiene!</p>
<p>Adem√°s, ten en cuenta que debido a que <code>back_of_house::Breakfast</code> tiene un
campo privado, el struct debe proporcionar una funci√≥n asociada p√∫blica que
construya una instancia de <code>Breakfast</code> (lo hemos llamado <code>summer</code> aqu√≠). Si
<code>Breakfast</code> no tuviera tal funci√≥n, no podr√≠amos crear una instancia de
<code>Breakfast</code> en <code>eat_at_restaurant</code> porque no podr√≠amos establecer el valor del
campo privado <code>seasonal_fruit</code> en <code>eat_at_restaurant</code>.</p>
<p>Por el contrario, si hacemos un enum p√∫blico, todos sus variantes son p√∫blicas.
Solo necesitamos el <code>pub</code> antes de la palabra clave <code>enum</code>, como se muestra en
el listado 7-10.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<p><span class="caption">Listado 7-10: Designar un enum como p√∫blico hace que todas
sus variantes sean p√∫blicas</span></p>
<p>Debido a que hicimos el enum <code>Appetizer</code> p√∫blico, podemos usar las variantes
<code>Appetizer::Soup</code> y <code>Appetizer::Salad</code> en <code>eat_at_restaurant</code>.</p>
<p>Los Enums no son muy √∫tiles a menos que sus variantes sean p√∫blicas; ser√≠a
molesto tener que anotar todas las variantes de enum con <code>pub</code> en todos los
casos, por lo que el valor predeterminado para las variantes de enum es ser
p√∫blico. Los structs a menudo son √∫tiles sin que sus campos sean p√∫blicos, por
lo que los campos de struct siguen la regla general de que todo es privado por
defecto a menos que se anote con <code>pub</code>.</p>
<p>Hay una situaci√≥n m√°s relacionada con <code>pub</code> que no hemos cubierto, y es
nuestra √∫ltima caracter√≠stica del sistema de m√≥dulos: la palabra clave <code>use</code>.
Cubriremos <code>use</code> por s√≠ solo primero, y luego mostraremos c√≥mo combinar <code>pub</code> y
<code>use</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="incluyendo-rutas-al-√°mbito-con-la-palabra-clave-use"><a class="header" href="#incluyendo-rutas-al-√°mbito-con-la-palabra-clave-use">Incluyendo rutas al √°mbito con la palabra clave <code>use</code></a></h2>
<p>Tener que escribir las rutas para llamar a las funciones puede sentirse
inconveniente y repetitivo. En el Listado 7-7, si elegimos la ruta absoluta o
relativa para la funci√≥n <code>add_to_waitlist</code>, cada vez que quer√≠amos llamar a
<code>add_to_waitlist</code> ten√≠amos que especificar <code>front_of_house</code> y <code>hosting</code> tambi√©n.
Afortunadamente, hay una manera de simplificar este proceso: podemos crear un
atajo a una ruta con la palabra clave <code>use</code> una vez, y luego usar el nombre
m√°s corto en todas partes en el √°mbito.</p>
<p>En el listado 7-11, traemos el m√≥dulo <code>crate::front_of_house::hosting</code> al √°mbito
de la funci√≥n <code>eat_at_restaurant</code> para que solo tengamos que especificar
<code>hosting::add_to_waitlist</code> para llamar a la funci√≥n <code>add_to_waitlist</code> en
<code>eat_at_restaurant</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-11: Introducir un m√≥dulo en el √°mbito de aplicaci√≥n con <code>use</code></span></p>
<p>Agregar <code>use</code> y una ruta en un √°mbito es similar a crear un enlace simb√≥lico
en el sistema de archivos. Al agregar <code>use crate::front_of_house::hosting</code> en
la ra√≠z del crate, hace que <code>hosting</code> sea ahora un nombre v√°lido en ese √°mbito, como si
el m√≥dulo <code>hosting</code> hubiera sido definido en la ra√≠z del crate. Las rutas
tra√≠das al √°mbito con <code>use</code> tambi√©n verifican la privacidad, como cualquier
otra ruta.</p>
<p>Ten en cuenta que <code>use</code> solo crea el atajo para el √°mbito particular en el que
ocurre √©l <code>use</code>. El Listado 7-12 mueve la funci√≥n <code>eat_at_restaurant</code> a un
nuevo m√≥dulo hijo llamado <code>customer</code>, que es entonces un √°mbito diferente al de la sentencia <code>use</code>,
por lo que el cuerpo de la funci√≥n no compilar√°.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<p><span class="caption">Listado 7-12: La sentencia <code>use</code> solo aplica en el
√°mbito donde se encuentra declarado</span></p>
<p>El error del compilador muestra que el acceso directo ya no se aplica dentro del m√≥dulo del
<code>customer</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Observe que tambi√©n hay una advertencia de que √©l <code>use</code> ya no se utiliza en su
√°mbito. Para solucionar este problema, mueva tambi√©n √©l <code>use</code> dentro del m√≥dulo
<code>customer</code>, o haga referencia al acceso directo en el m√≥dulo padre con
<code>super::hosting</code> dentro del m√≥dulo hijo <code>customer</code>.</p>
<h3 id="creando-rutas-de-use-idiomaticas"><a class="header" href="#creando-rutas-de-use-idiomaticas">Creando rutas de <code>use</code> idiomaticas</a></h3>
<p>En el Listado 7-11, podr√≠as haberte preguntado por qu√© especificamos
<code>use crate::front_of_house::hosting</code> y luego llamamos a <code>hosting::add_to_waitlist</code>
en <code>eat_at_restaurant</code>, en lugar de especificar toda la ruta
hasta la funci√≥n <code>add_to_waitlist</code> para lograr el mismo resultado, como en el
Listado 7-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-13: Incorporando la funci√≥n <code>add_to_waitlist</code>
en el √°mbito con <code>use</code>, que no es idiom√°tico</span></p>
<p>Aunque el Listado 7-11 y 7-13 logran la misma tarea, el Listado 7-11 es la
forma idiom√°tica de traer una funci√≥n al √°mbito con <code>use</code>. Traer el m√≥dulo
padre de la funci√≥n al √°mbito con <code>use</code> significa que tenemos que especificar
el m√≥dulo padre cuando llamamos a la funci√≥n. Especificar el m√≥dulo padre
cuando llamamos a la funci√≥n hace que quede claro que la funci√≥n no est√°
definida localmente, al tiempo que minimiza la repetici√≥n de la ruta completa.
El c√≥digo en el Listado 7-13 no es claro en cuanto a d√≥nde se define
<code>add_to_waitlist</code>.</p>
<p>Por otro lado, cuando traemos structs, enums y otros items con <code>use</code>, es
idiom√°tico especificar la ruta completa. El Listado 7-14 muestra la forma
idiom√°tica de traer la struct <code>HashMap</code> de la biblioteca est√°ndar al √°mbito de
un crate binario.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<p><span class="caption">Listado 7-14: Trayendo <code>HashMap</code> al √°mbito de una
manera idiom√°tica</span></p>
<p>No hay una raz√≥n fuerte detr√°s de este idioma: es solo la convenci√≥n que ha
surgido, y la gente se ha acostumbrado a leer y escribir c√≥digo Rust de esta
manera.</p>
<p>La excepci√≥n a este idioma es si estamos trayendo dos elementos con el mismo nombre
al √°mbito con declaraciones <code>use</code>, porque Rust no lo permite. El Listado
7-15 muestra c√≥mo traer dos tipos <code>Result</code> al √°mbito que tienen el mismo nombre
pero m√≥dulos padres diferentes, y c√≥mo referirse a ellos.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Listado 7-15: Incorporando dos tipos con el mismo nombre
en el mismo √°mbito requiere el uso de sus m√≥dulos principales.</span></p>
<p>Como puedes ver, usar los m√≥dulos padres distingue los dos tipos <code>Result</code>. S√≠,
en cambio, especificamos <code>use std::fmt::Result</code> y <code>use std::io::Result</code>,
tendr√≠amos dos tipos <code>Result</code> en el mismo √°mbito, y Rust no sabr√≠a a cu√°l nos
referimos cuando usamos <code>Result</code>.</p>
<h3 id="proporcionando-nuevos-nombres-con-el-keyword-as"><a class="header" href="#proporcionando-nuevos-nombres-con-el-keyword-as">Proporcionando nuevos nombres con el Keyword <code>as</code></a></h3>
<p>Hay otra soluci√≥n a este problema de traer dos elementos con el mismo nombre al
√°mbito con <code>use</code>: despu√©s de la ruta, podemos especificar <code>as</code> y un nuevo
nombre local, o <em>alias</em>, para el tipo. El Listado 7-16 muestra otra forma de
escribir el c√≥digo en el Listado 7-15 renombrando uno de los dos tipos
<code>Result</code> usando <code>as</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Listado 7-16: Cambiando el nombre de un tipo cuando se
introduce en el √°mbito con la keyword <code>as</code></span></p>
<p>En la segunda declaraci√≥n <code>use</code>, elegimos el nuevo nombre <code>IoResult</code> para el
tipo <code>std::io::Result</code>, que no entrar√° en conflicto con el <code>Result</code> de
<code>std::fmt</code> que tambi√©n hemos tra√≠do al √°mbito. El Listado 7-15 y 7-16 se
consideran idiom√°ticos, ¬°as√≠ que la elecci√≥n depende de ti!</p>
<h3 id="re-exportando-nombres-con-pub-use"><a class="header" href="#re-exportando-nombres-con-pub-use">Re-exportando nombres con <code>pub use</code></a></h3>
<p>Cuando traemos un nombre al √°mbito con la keyword <code>use</code>, el nombre est√°
disponible en ese √°mbito de forma privada. Si queremos que el nombre est√©
disponible para que el c√≥digo que llama a nuestro c√≥digo lo use, podemos
combinar <code>pub</code> y <code>use</code>. Esta t√©cnica se llama <em>re-exporting</em> porque estamos
trayendo un elemento al √°mbito, pero tambi√©n haciendo que ese elemento est√© 
disponible para que otros lo traigan a su √°mbito.</p>
<p>El listado 7-17 muestra el c√≥digo del listado 7-11 con <code>use</code> en el m√≥dulo
<code>front_of_house</code> cambiado a <code>pub use</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-17: Hacer que un nombre est√© disponible para que
lo use cualquier c√≥digo desde un nuevo √°mbito con <code>pub use</code></span></p>
<p>Antes de este cambio, el c√≥digo externo tendr√≠a que llamar a la funci√≥n
<code>add_to_waitlist</code> usando la ruta
<code>restaurant::front_of_house::hosting::add_to_waitlist()</code>, el cual tambi√©n 
deber√≠a tener requerido el modulo <code>front_of_house</code> para ser marcado como <code>pub</code>. 
Ahora que este <code>pub use</code> ha reexportado el m√≥dulo <code>hosting</code> desde el m√≥dulo ra√≠z,
el c√≥digo externo puede usar la ruta <code>restaurant::hosting::add_to_waitlist()</code> en
su lugar.</p>
<p>Re-exportar es √∫til cuando la estructura interna de tu c√≥digo es diferente de
c√≥mo los programadores que llaman a tu c√≥digo pensar√≠an sobre el dominio. Por
ejemplo, en esta met√°fora de un restaurante, la gente que dirige el restaurante
piensa en ‚Äúfront of house‚Äù y ‚Äúback of house‚Äù. Pero los clientes que visitan un
restaurante probablemente no pensar√°n en las partes del restaurante en esos
t√©rminos. Con <code>pub use</code>, podemos escribir nuestro c√≥digo con una estructura
pero exponer una estructura diferente. Hacerlo hace que nuestra biblioteca est√©
bien organizada para los programadores que trabajan en la biblioteca y los
programadores que llaman a la biblioteca. Veremos otro ejemplo de <code>pub use</code> y
c√≥mo afecta la documentaci√≥n de tu crate en la secci√≥n <a href="ch14-02-publishing-to-crates-io.html#exportando-una-api-publica-conveniente-con-pub-use">‚ÄúExportando una API
p√∫blica conveniente con <code>pub use</code>‚Äù</a><!-- ignore --> del Cap√≠tulo 14.</p>
<h3 id="usando-paquetes-externos"><a class="header" href="#usando-paquetes-externos">Usando paquetes externos</a></h3>
<p>En el Cap√≠tulo 2, programamos un proyecto de juego de adivinanzas que usaba un
paquete externo llamado <code>rand</code> para obtener n√∫meros aleatorios. Para usar
<code>rand</code> en nuestro proyecto, agregamos esta l√≠nea a <em>Cargo.toml</em>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.5&quot;
</code></pre>
<p>A√±adir <code>rand</code> como dependencia en <em>Cargo.toml</em> le dice a Cargo que descargue el
paquete <code>rand</code> y cualquier dependencia de <a href="https://crates.io/">crates.io</a> y
haga que <code>rand</code> est√© disponible para nuestro proyecto.</p>
<p>Luego, para llevar las definiciones de <code>rand</code> al √°mbito de nuestro paquete,
agregamos una l√≠nea <code>use</code> que comienza con el nombre del paquete, <code>rand</code>, y
enumera los items que queremos traer al √°mbito. Recuerda que en la secci√≥n
<a href="ch02-00-guessing-game-tutorial.html#generar-un-numero-aleatorio">‚ÄúGenerando un n√∫mero aleatorio‚Äù</a><!-- ignore --> del Cap√≠tulo 2,
tra√≠amos el trait <code>Rng</code> al √°mbito y llam√°bamos a la funci√≥n <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span>}</code></pre>
<p>Los miembros de la comunidad de Rust han puesto muchos paquetes disponibles en
<a href="https://crates.io/">crates.io</a>, y traer cualquiera de ellos a tu paquete
involucra estos mismos pasos: listarlos en el archivo <em>Cargo.toml</em> de tu
paquete y usar <code>use</code> para traer items de sus crates al √°mbito.</p>
<p>Ten en cuenta que la biblioteca est√°ndar <code>std</code> tambi√©n es una crate externa a
nuestro paquete. Debido a que la biblioteca est√°ndar se env√≠a con el lenguaje
Rust, no necesitamos cambiar <em>Cargo.toml</em> para incluir <code>std</code>. Pero s√≠
necesitamos referirnos a √©l con <code>use</code> para traer items de all√≠ al √°mbito de
nuestro paquete. Por ejemplo, con <code>HashMap</code> usar√≠amos esta l√≠nea:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Esta es una ruta absoluta que comienza con <code>std</code>, el nombre del crate de la
biblioteca est√°ndar. Tambi√©n podr√≠amos escribir este <code>use</code> como:</p>
<h3 id="usando-rutas-anidadas-para-limpiar-listas-use-grandes"><a class="header" href="#usando-rutas-anidadas-para-limpiar-listas-use-grandes">Usando rutas anidadas para limpiar listas <code>use</code> grandes</a></h3>
<p>Si estamos usando varios elementos definidos en el mismo crate o el mismo m√≥dulo,
enumerar cada elemento en su propia l√≠nea puede ocupar mucho espacio vertical en
nuestros archivos. Por ejemplo, estas dos declaraciones <code>use</code> que ten√≠amos en
el juego de adivinanzas en el Listado 2-4 traen items de <code>std</code> al √°mbito:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>En su lugar, podemos utilizar rutas anidadas para incluir los mismos elementos en una sola l√≠nea.
Hacemos esto especificando la parte com√∫n de la ruta, seguida de
dos puntos y luego entre llaves los elementos, como se muestra en el Listado 7-18.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 7-18: Especificaci√≥n de una ruta anidada para incluir en el √°mbito varios elementos con el mismo prefijo</span></p>
<p>En programas m√°s grandes, traer muchos items al √°mbito desde el mismo crate o
m√≥dulo usando rutas anidadas puede reducir la cantidad de declaraciones <code>use</code>
necesarias en gran medida.</p>
<p>Podemos usar una ruta anidada en cualquier nivel de una ruta, lo que es √∫til cuando
combinamos dos sentencias <code>use</code> que comparten una sub-ruta. Por ejemplo, el Listado
7-19 muestra dos sentencias use: una que trae <code>std::io</code> al √°mbito y
otra que trae <code>std::io::Write</code> al √°mbito.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<p><span class="caption">Listado 7-19: Dos sentencias <code>use</code> donde una es una sub-ruta de la otra</span></p>
<p>La parte com√∫n de estas dos rutas es <code>std::io</code>, as√≠ que podemos usar una ruta
anidada para traer ambos al √°mbito en una l√≠nea, como se muestra en el Listado
7-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<p><span class="caption">Listado 7-20: Combinando las rutas del listado 7-19 en
una sentencia <code>use</code></span></p>
<p>Esta l√≠nea trae <code>std::io</code> y <code>std::io::Write</code> al √°mbito.</p>
<h3 id="el-operador-asterisco-glob"><a class="header" href="#el-operador-asterisco-glob">El Operador Asterisco (Glob)</a></h3>
<p>Si queremos incluir al √°mbito <em>todos</em> los elementos p√∫blicos definidos en una ruta,
podemos especificar esa ruta seguido del operador glob <code>*</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>Esta sentencia <code>use</code> trae todos los elementos p√∫blicos definidos en <code>std::collections</code> al √°mbito actual. Tenga cuidado al utilizar el operador <code>glob</code>. El operador <code>glob</code> puede hacer m√°s dif√≠cil saber qu√© elementos est√°n en el √°mbito y d√≥nde se defini√≥ un elemento que este siendo utilizado en su programa.</p>
<p>El operador glob se utiliza a menudo cuando se realizan pruebas para llevar todo lo que se est√° probando al m√≥dulo de <code>pruebas</code>; hablaremos de ello en la secci√≥n <a href="ch11-01-writing-tests.html#como-escribir-tests">&quot;C√≥mo escribir pruebas&quot;</a><!-- ignore --> del cap√≠tulo 11. El operador glob tambi√©n se utiliza a veces como parte del patr√≥n prelude: consulte <a href="../std/prelude/index.html#other-preludes">la documentaci√≥n de la biblioteca est√°ndar</a><!-- ignore --> para obtener m√°s informaci√≥n sobre ese patr√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="separando-m√≥dulos-en-diferentes-archivos"><a class="header" href="#separando-m√≥dulos-en-diferentes-archivos">Separando m√≥dulos en diferentes archivos</a></h2>
<p>Hasta ahora, todos los ejemplos en este cap√≠tulo defin√≠an varios m√≥dulos en un archivo. Cuando los m√≥dulos se vuelven grandes, es posible que
desees mover sus definiciones a un archivo separado para que el c√≥digo sea m√°s
f√°cil de navegar.</p>
<p>Por ejemplo, comencemos desde el c√≥digo en el listado 7-17 que ten√≠a m√∫ltiples
m√≥dulos de restaurante. Extraeremos los m√≥dulos en archivos en lugar de tener
todos los m√≥dulos definidos en el archivo ra√≠z del crate. En este caso, el
archivo ra√≠z del crate es <em>src/lib.rs</em>, pero este procedimiento tambi√©n
funciona con crates binarios cuyo archivo ra√≠z del crate es <em>src/main.rs</em>.</p>
<p>Primero, extraeremos el m√≥dulo <code>front_of_house</code> a su propio archivo. Elimine el
c√≥digo dentro de las llaves para el m√≥dulo <code>front_of_house</code>, dejando solo la
declaraci√≥n <code>mod front_of_house;</code>, de modo que <em>src/lib.rs</em> contenga el c√≥digo
que se muestra en el listado 7-21. Ten en cuenta que esto no compilar√° hasta
que creemos el archivo <em>src/front_of_house.rs</em> en el listado 7-22.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<p><span class="caption">Listado 7-21: Declarando el m√≥dulo <code>front_of_house</code> cuyo
cuerpo estar√° en <em>src/front_of_house.rs</em></span></p>
<p>Luego, coloca el c√≥digo que estaba entre las llaves en un nuevo archivo
llamado <em>src/front_of_house.rs</em>, como se muestra en el Listado 7-22. El
compilador sabe que debe buscar en este archivo porque se encontr√≥ con la declaraci√≥n
del m√≥dulo en la ra√≠z del crate con el nombre <code>front_of_house</code>.</p>
<p><span class="filename">Filename: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
<p><span class="caption">Listado 7-22: Definiciones dentro del m√≥dulo <code>front_of_house</code>
en <em>src/front_of_house.rs</em></span></p>
<p>Ten en cuenta que solo necesitas cargar un archivo usando una declaraci√≥n <code>mod</code>
<em>una vez</em> en tu √°rbol de m√≥dulos. Una vez que el compilador sabe que el archivo
es parte del proyecto (y sabe en qu√© parte del √°rbol de m√≥dulos reside el c√≥digo
debido a d√≥nde has puesto la declaraci√≥n <code>mod</code>), otros archivos en tu proyecto
deben hacer referencia al c√≥digo del archivo cargado usando una ruta que indique donde se
declar√≥, como se cubre en la secci√≥n <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúRutas para referirse a un elemento en el
√°rbol de m√≥dulos‚Äù</a><!-- ignore -->. En otras palabras, <code>mod</code> no es una
operaci√≥n de ‚Äúincluir‚Äù que puede haber visto en otros lenguajes de
programaci√≥n.</p>
<p>Luego, extraeremos el m√≥dulo <code>hosting</code> a su propio archivo. El proceso es un
poco diferente porque <code>hosting</code> es un m√≥dulo secundario de <code>front_of_house</code>, no
del m√≥dulo ra√≠z. Colocaremos el archivo para <code>hosting</code> en un nuevo directorio
que se llamar√° por sus antepasados en el √°rbol de m√≥dulos, en este caso
<em>src/front_of_house/</em>.</p>
<p>Para comenzar a mover <code>hosting</code>, cambiamos <em>src/front_of_house.rs</em> para
contener solo la declaraci√≥n del m√≥dulo <code>hosting</code>:</p>
<p><span class="filename">Filename: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
<p>Luego creamos un directorio <em>src/front_of_house</em> y un archivo <em>hosting.rs</em> para
contener las definiciones realizadas en el m√≥dulo <code>hosting</code>:</p>
<p><span class="filename">Filename: src/front_of_house/hosting.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}</code></pre>
<p>S√≠, en cambio, colocamos <em>hosting.rs</em> en el directorio <em>src</em>, el compilador
esperar√≠a que el c√≥digo de <em>hosting.rs</em> estuviera en un m√≥dulo <code>hosting</code>
declarado en la ra√≠z del crate, y no declarado como un hijo del m√≥dulo
<code>front_of_house</code>. Las reglas del compilador sobre qu√© archivos comprobar
para cada c√≥digo de m√≥dulo hacen que los directorios y archivos se ajusten m√°s
al √°rbol de m√≥dulos.</p>
<blockquote>
<h3 id="rutas-alternativas-de-archivos"><a class="header" href="#rutas-alternativas-de-archivos">Rutas alternativas de archivos</a></h3>
<p>Hasta ahora hemos cubierto las rutas de archivos m√°s idiom√°ticas que utiliza
el compilador de Rust, pero Rust tambi√©n admite un estilo m√°s antiguo de ruta de
archivo. Para un m√≥dulo llamado <code>front_of_house</code> declarado en la ra√≠z del
crate, el compilador buscar√° el c√≥digo del m√≥dulo en:</p>
<ul>
<li><em>src/front_of_house.rs</em> (lo que cubrimos)</li>
<li><em>src/front_of_house/mod.rs</em> (estilo antiguo, ruta a√∫n soportada)</li>
</ul>
<p>Para un m√≥dulo llamado <code>hosting</code> que es un subm√≥dulo de <code>front_of_house</code>, el
compilador buscar√° el c√≥digo del m√≥dulo en:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (lo que cubrimos)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (estilo antiguo, ruta a√∫n soportada)</li>
</ul>
<p>Si usas ambos estilos para el mismo m√≥dulo, obtendr√°s un error del
compilador. Usar una mezcla de ambos estilos para diferentes m√≥dulos en el
mismo proyecto est√° permitido, pero podr√≠a ser confuso para las personas que
navegan por tu proyecto.</p>
<p>La principal desventaja del estilo que usa archivos llamados <em>mod.rs</em> es que
tu proyecto puede terminar con muchos archivos llamados <em>mod.rs</em>, lo que puede
ser confuso cuando los tienes abiertos en tu editor al mismo tiempo.</p>
</blockquote>
<p>Hemos movido el c√≥digo de cada m√≥dulo a un archivo separado, y el √°rbol de
m√≥dulos permanece igual. Las llamadas a las funciones de <code>eat_at_restaurant</code>
funcionar√°n sin ninguna modificaci√≥n, incluso si las definiciones viven en
archivos diferentes. Esta t√©cnica le permite mover m√≥dulos a nuevos archivos a
medida que crecen en tama√±o.</p>
<p>Ten en cuenta que la declaraci√≥n <code>pub use crate::front_of_house::hosting</code> en
<em>src/lib.rs</em> tampoco ha cambiado, ni <code>use</code> tiene ning√∫n impacto en qu√© archivos
se compilan como parte del crate. La palabra clave <code>mod</code> declara m√≥dulos, y
Rust busca en un archivo con el mismo nombre que el m√≥dulo para el c√≥digo que
va en ese m√≥dulo.</p>
<h2 id="resumen-6"><a class="header" href="#resumen-6">Resumen</a></h2>
<p>Rust te permite dividir un paquete en m√∫ltiples crates y un crate en m√≥dulos
para que puedas referirte a elementos definidos en un m√≥dulo desde otro m√≥dulo.
Puedes hacer esto especificando rutas absolutas o relativas. Estas rutas se
pueden traer al √°mbito con una declaraci√≥n <code>use</code> para que puedas usar una ruta
m√°s corta para m√∫ltiples usos del elemento en ese √°mbito. El c√≥digo de los m√≥dulos
es privado por defecto, pero puedes hacer que las definiciones sean
p√∫blicas agregando la palabra clave <code>pub</code>.</p>
<p>En el siguiente cap√≠tulo, veremos algunas estructuras de datos de colecci√≥n en
la biblioteca est√°ndar que puedes usar en tu c√≥digo bien organizado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colecciones-comunes"><a class="header" href="#colecciones-comunes">Colecciones comunes</a></h1>
<p>La biblioteca est√°ndar de Rust incluye una serie de estructuras de datos muy
√∫tiles llamadas <em>colecciones</em>. La mayor√≠a de los otros tipos de datos
representan un valor espec√≠fico, pero las colecciones pueden contener varios
valores. A diferencia de los tipos de datos built-in array y tupla, los
datos a los que apuntan estas colecciones se almacenan en el heap, lo que
significa que la cantidad de datos no necesita conocerse en el momento de la
compilaci√≥n y puede crecer o disminuir a medida que se ejecuta el programa. Cada
tipo de colecci√≥n tiene diferentes capacidades y costos, y elegir uno
apropiado para su situaci√≥n actual es una habilidad que desarrollar√° con el
tiempo. En este cap√≠tulo, discutiremos tres colecciones que se usan muy a menudo
en los programas Rust:</p>
<ul>
<li>Un <em>vector</em> le permite almacenar un n√∫mero variable de valores uno al lado del
otro.</li>
<li>Un <em>string</em> es una colecci√≥n de caracteres. Hemos mencionado el tipo <code>String</code>
anteriormente, pero en este cap√≠tulo hablaremos de √©l en profundidad.</li>
<li>Un <em>hash map</em> le permite asociar un valor con una clave especifica. Es una
implementaci√≥n particular de la estructura de datos m√°s general llamada <em>map</em>.</li>
</ul>
<p>Para aprender sobre los otros tipos de colecciones proporcionados por la
biblioteca est√°ndar, consulte <a href="https://doc.rust-lang.org/std/collections/index.html">la documentaci√≥n</a>.</p>
<p>Discutiremos c√≥mo crear y actualizar vectores, strings y hash maps, as√≠ como
lo que hace que cada uno sea especial.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenando-listas-de-valores-con-vectores"><a class="header" href="#almacenando-listas-de-valores-con-vectores">Almacenando listas de valores con vectores</a></h2>
<p>El primer tipo de colecci√≥n que veremos es <code>Vec&lt;T&gt;</code>, tambi√©n conocido como un
<em>vector</em>. Los vectores te permiten almacenar m√°s de un valor en una sola
estructura de datos que pone todos los valores uno al lado del otro en la
memoria. Los vectores solo pueden almacenar valores del mismo tipo. Son √∫tiles
cuando tienes una lista de elementos, como las l√≠neas de texto en un archivo o
los precios de los art√≠culos en un carrito de compras.</p>
<h3 id="creando-un-nuevo-vector"><a class="header" href="#creando-un-nuevo-vector">Creando un nuevo vector</a></h3>
<p>Para crear un nuevo vector vac√≠o, llamamos a la funci√≥n <code>Vec::new</code>, como se
muestra en el listado 8-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-1: Creando un nuevo vector vac√≠o para mantener
valores de tipo <code>i32</code></span></p>
<p>Ten en cuenta que agregamos una anotaci√≥n de tipo aqu√≠. Como no estamos
insertando ning√∫n valor en este vector, Rust no sabe qu√© tipo de elementos
queremos almacenar. Este es un punto importante. Los vectores se implementan
usando gen√©ricos; cubriremos c√≥mo usar gen√©ricos con tus propios tipos en el
Cap√≠tulo 10. Por ahora, sepa que el tipo <code>Vec&lt;T&gt;</code> proporcionado por la
biblioteca est√°ndar puede contener cualquier tipo. Cuando creamos un vector
para contener un tipo espec√≠fico, podemos especificar el tipo dentro de
corchetes angulares. En el listado 8-1, le hemos dicho a Rust que el <code>Vec&lt;T&gt;</code>
en <code>v</code> contendr√° elementos del tipo <code>i32</code>.</p>
<p>A menudo, crear√°s un <code>Vec&lt;T&gt;</code> con valores iniciales y Rust inferir√° el tipo de
valor que deseas almacenar, por lo que rara vez necesitar√°s hacer esta
anotaci√≥n de tipo. Rust proporciona convenientemente la macro <code>vec!</code>, que
crear√° un nuevo vector que contenga los valores que le des. El listado 8-2
crea un nuevo <code>Vec&lt;i32&gt;</code> que contiene los valores <code>1</code>, <code>2</code> y <code>3</code>. El tipo
entero es <code>i32</code> porque ese es el tipo entero predeterminado, como discutimos
en la secci√≥n <a href="ch03-02-data-types.html#tipos-de-datos">&quot;Tipos de datos&quot;</a><!-- ignore --> del Cap√≠tulo 3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-2: Creando un nuevo vector que contiene
valores</span></p>
<p>Debido a que hemos dado valores iniciales <code>i32</code>, Rust puede inferir que el tipo
de <code>v</code> es <code>Vec&lt;i32&gt;</code>, y la anotaci√≥n de tipo no es necesaria. A continuaci√≥n,
veremos c√≥mo modificar un vector.</p>
<h3 id="actualizando-un-vector"><a class="header" href="#actualizando-un-vector">Actualizando un vector</a></h3>
<p>Para crear un vector y luego agregar elementos a √©l, podemos usar el m√©todo
<code>push</code>, como se muestra en el listado 8-3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-3: Usando el m√©todo <code>push</code> para a√±adir valores
a un vector</span></p>
<p>Como con cualquier variable, si queremos poder cambiar su valor, necesitamos
hacerlo mutable usando la palabra clave <code>mut</code>, como se discuti√≥ en el Cap√≠tulo
3. Los n√∫meros que colocamos dentro son todos del tipo <code>i32</code>, y Rust infiere
esto de los datos, por lo que no necesitamos la anotaci√≥n <code>Vec&lt;i32&gt;</code>.</p>
<h3 id="leyendo-elementos-de-vectores"><a class="header" href="#leyendo-elementos-de-vectores">Leyendo elementos de vectores</a></h3>
<p>Hay dos formas de hacer referencia a un valor almacenado en un vector: a trav√©s
de la indexaci√≥n o usando el m√©todo <code>get</code>. En los siguientes ejemplos,
hemos anotado los tipos de los valores que se devuelven de estas funciones para
obtener una mayor claridad.</p>
<p>En el listado 8-4 se muestran ambos m√©todos de acceso a un valor en un vector,
con sintaxis de indexaci√≥n y el m√©todo <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {third}&quot;);

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!(&quot;The third element is {third}&quot;),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-4: Usando la sintaxis de indexaci√≥n o el m√©todo
<code>get</code> accediendo a un objeto en un vector</span></p>
<p>Ten en cuenta algunos detalles aqu√≠. Usamos el valor de √≠ndice <code>2</code> para obtener
el tercer elemento porque los vectores se indexan por n√∫mero, comenzando en
cero. Usar <code>&amp;</code> y <code>[]</code> nos da una referencia al elemento en el √≠ndice. Cuando
usamos el m√©todo <code>get</code> con el √≠ndice pasado como argumento, obtenemos un
<code>Option&lt;&amp;T&gt;</code> que podemos usar con <code>match</code>.</p>
<p>La raz√≥n por la que Rust proporciona estas dos formas de hacer referencia a un
elemento es para que puedas elegir c√≥mo se comporta el programa cuando intentas
usar un valor de √≠ndice fuera del rango de elementos existentes. Como ejemplo,
veamos qu√© sucede cuando tenemos un vector de cinco elementos y luego intentamos
acceder a un elemento en el √≠ndice 100 con cada t√©cnica, como se muestra en el
listado 8-5.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-5: Intentando acceder al elemento en el √≠ndice
100 en un vector que contiene 5 elementos</span></p>
<p>Cuando ejecutamos este c√≥digo, el primer m√©todo <code>[]</code> causar√° que el programa
falle porque intenta acceder a un elemento que no existe. Este m√©todo es mejor
usarlo cuando quieres que tu programa se bloquee si hay un intento de acceder a
un elemento m√°s all√° del final del vector.</p>
<p>Cuando el m√©todo <code>get</code> se pasa un √≠ndice que est√° fuera del rango del vector,
simplemente devuelve <code>None</code> sin entrar en p√°nico. Tendr√≠as que usar este m√©todo
si acceder a un elemento m√°s all√° del rango del vector puede suceder con
frecuencia en circunstancias normales. Tu c√≥digo tendr√° entonces la l√≥gica
necesaria para gestionar la presencia de Some(&amp;element) o None, tal y como se explica en el cap√≠tulo 6. Por
ejemplo, el √≠ndice podr√≠a provenir de una persona que ingresa un n√∫mero. Si
ingresan accidentalmente un n√∫mero que es demasiado grande y el programa obtiene
un valor <code>None</code>, podr√≠as decirle al usuario cu√°ntos elementos hay en el vector
actual y darle otra oportunidad de ingresar un valor v√°lido. Eso ser√≠a m√°s
amigable para el usuario que bloquear el programa debido a un error tipogr√°fico.</p>
<p>Cuando el programa tiene una referencia v√°lida, el borrow checker hace cumplir
las reglas de ownership y borrowing (cubiertas en el Cap√≠tulo 4) para asegurar
que esta referencia y cualquier otra referencia a los contenidos del vector
permanezcan v√°lidas. Recuerda la regla que establece que no puedes tener
referencias mutables e inmutables en el mismo √°mbito. Esa regla se aplica en el
listado 8-6, donde tenemos una referencia inmutable al primer elemento en un
vector e intentamos agregar un elemento al final. Este programa no funcionar√° si
tambi√©n intentamos referirnos a ese elemento m√°s adelante en la funci√≥n.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {first}&quot;);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listado 8-6: Intentando agregar un elemento a un vector
mientras se mantiene una referencia a un elemento</span></p>
<p>Al compilar este c√≥digo se producir√° este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;The first element is: {first}&quot;);
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin &quot;collections&quot;) due to 1 previous error
</code></pre>
<p>El c√≥digo en el listado 8-6 podr√≠a parecer que deber√≠a funcionar: ¬øpor qu√© una
referencia al primer elemento se preocupar√≠a por los cambios al final del
vector? Este error se debe a la forma en que funcionan los vectores: porque los
vectores colocan los valores uno al lado del otro en la memoria, agregar un
nuevo elemento al final del vector puede requerir asignar nueva memoria y
copiar los elementos antiguos al nuevo espacio, si no hay suficiente espacio
para poner todos los elementos uno al lado del otro donde se almacena el vector
actualmente. En ese caso, la referencia al primer elemento apuntar√≠a a la
memoria desasignada. Las reglas de borrowing evitan que los programas terminen en
esa situaci√≥n.</p>
<blockquote>
<p>Nota: Para m√°s informaci√≥n sobre los detalles de implementaci√≥n del tipo <code>Vec&lt;T&gt;</code>,
v√©ase <a href="https://doc.rust-lang.org/nomicon/vec/vec.html">&quot;The Rustonomicon&quot;</a>.</p>
</blockquote>
<h3 id="iterando-sobre-los-valores-en-un-vector"><a class="header" href="#iterando-sobre-los-valores-en-un-vector">Iterando sobre los valores en un vector</a></h3>
<p>Para acceder a cada elemento en un vector a su vez, iteramos a trav√©s de todos
los elementos, en lugar de usar √≠ndices para acceder a uno a la vez. El listado
8-7 muestra c√≥mo usar un bucle <code>for</code> para obtener referencias inmutables a cada
elemento en un vector de valores <code>i32</code> e imprimirlos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{i}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-7: Imprimiendo cada elemento en un vector
iterando sobre los elementos usando un ciclo <code>for</code></span></p>
<p>Tambi√©n podemos iterar sobre referencias mutables a cada elemento en un vector
mutable, lo que nos permite cambiar los valores en un vector en el lugar. El
c√≥digo en el listado 8-8 agregar√° <code>50</code> a cada elemento en un vector.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-8: Iterando sobre referencias mutables a
elementos en un vector</span></p>
<p>Para cambiar el valor al que se refiere la referencia mutable, tenemos que usar
el operador de desreferencia <code>*</code> para llegar al valor en <code>i</code> antes de poder
usar el operador <code>+=</code>. Hablaremos m√°s sobre el operador de desreferencia en la
secci√≥n <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">‚ÄúSiguiendo el puntero al valor con el operador de
desreferencia‚Äù</a><!-- ignore --> del Cap√≠tulo 15.</p>
<p>Iterando sobre un vector, ya sea inmutable o mutable, es seguro debido a las
reglas del borrow checker. Si intent√°ramos insertar o eliminar elementos en los
cuerpos del ciclo <code>for</code> en el listado 8-7 y el listado 8-8, obtendr√≠amos un
error del compilador similar al que obtuvimos con el c√≥digo en el listado 8-6.
La referencia al vector que el ciclo <code>for</code> contiene evita la modificaci√≥n
simult√°nea de todo el vector.</p>
<h3 id="usar-un-enum-para-almacenar-m√∫ltiples-tipos"><a class="header" href="#usar-un-enum-para-almacenar-m√∫ltiples-tipos">Usar un <code>enum</code> para almacenar m√∫ltiples tipos</a></h3>
<p>Los vectores solo pueden almacenar valores del mismo tipo. Esto puede ser
inconveniente; definitivamente hay casos de uso para necesitar almacenar una
lista de elementos de diferentes tipos. Afortunadamente, las variantes de un
<code>enum</code> se definen bajo el mismo tipo de <code>enum</code>, por lo que cuando necesitamos
que un tipo represente elementos de diferentes tipos, ¬°podemos definir y usar un
<code>enum</code>!</p>
<p>Por ejemplo, digamos que queremos almacenar en una lista los elementos de una
tabla de hoja de c√°lculo: algunas columnas pueden contener n√∫meros, y otras
cadenas de texto. Podemos definir un <code>enum</code> cuyas variantes contendr√°n los
diferentes tipos de datos, y todas las variantes se considerar√°n del mismo tipo:
el del <code>enum</code>. Luego podemos crear un vector para contener ese <code>enum</code> y, por lo
tanto, en √∫ltima instancia, contener diferentes tipos. Hemos demostrado esto en
el listado 8-9.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-9: Definiendo un <code>enum</code> para almacenar valores
de diferentes tipos en un vector</span></p>
<p>Rust necesita saber qu√© tipos habr√° en el vector en tiempo de compilaci√≥n para
saber exactamente cu√°nta memoria en el mont√≥n se necesitar√° para almacenar cada
elemento. Tambi√©n debemos ser expl√≠citos sobre qu√© tipos est√°n permitidos en
este vector. Si Rust permitiera que un vector contenga cualquier tipo, existir√≠a
la posibilidad de que uno o m√°s de los tipos causaran errores con las
operaciones realizadas en los elementos del vector. Usar un <code>enum</code> m√°s una
expresi√≥n <code>match</code> significa que Rust se asegurar√° en tiempo de compilaci√≥n de
que se maneje cada caso posible, como se discuti√≥ en el Cap√≠tulo 6.</p>
<p>Si tu no sabes el conjunto exhaustivo de tipos que un programa obtendr√° en
tiempo de ejecuci√≥n para almacenar en un vector, la t√©cnica de <code>enum</code> no
funcionar√°. En su lugar, puede usar un objeto de rasgo, que cubriremos en el
Cap√≠tulo 17.</p>
<p>Ahora que hemos discutido algunas de las formas m√°s comunes de usar vectores,
aseg√∫rese de revisar <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">la documentaci√≥n de la API</a><!-- ignore --> para
todos los muchos m√©todos √∫tiles definidos en <code>Vec&lt;T&gt;</code> por la biblioteca
est√°ndar. Por ejemplo, adem√°s de <code>push</code>, un m√©todo <code>pop</code> elimina y devuelve el
√∫ltimo elemento.</p>
<h3 id="liberar-un-vector-libera-sus-elementos"><a class="header" href="#liberar-un-vector-libera-sus-elementos">Liberar un vector libera sus elementos</a></h3>
<p>Como cualquier otro <code>struct</code>, un vector se libera cuando sale del √°mbito, como
se anota en el listado 8-10.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-10: Mostrando d√≥nde se colocan el vector y sus
elementos</span></p>
<p>Cuando se libera el vector, tambi√©n se libera todo su contenido, lo que
significa que se limpiar√°n los enteros que contiene. El borrow checker garantiza
que cualquier referencia al contenido de un vector solo se utilice mientras el
vector en s√≠ sea v√°lido.</p>
<p>Pasemos al siguiente tipo de colecci√≥n: ¬°<code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenando-texto-codificado-en-utf-8-con-strings"><a class="header" href="#almacenando-texto-codificado-en-utf-8-con-strings">Almacenando texto codificado en UTF-8 con Strings</a></h2>
<p>Hemos hablado de strings en el Cap√≠tulo 4, pero las veremos con m√°s detalle
Los nuevos Rustaceans suelen quedarse atascados en las cadenas por una
combinaci√≥n de tres razones: la propensi√≥n de Rust a exponer posibles errores,
los strings son una estructura de datos m√°s complicada de lo que muchos
programadores le dan cr√©dito, y UTF-8. Estos factores se combinan de una manera
que puede parecer dif√≠cil cuando se viene de otros lenguajes de programaci√≥n.</p>
<p>Discutiremos strings en el contexto de las colecciones porque las strings se
implementan como una colecci√≥n de bytes, m√°s algunos m√©todos para proporcionar
funcionalidad √∫til cuando esos bytes se interpretan como texto. En esta
secci√≥n, hablaremos sobre las operaciones en <code>String</code> que cada tipo de
colecci√≥n tiene, como crear, actualizar y leer. Tambi√©n discutiremos las
formas en que <code>String</code> es diferente de las otras colecciones, es decir, c√≥mo
indexar en un <code>String</code> se complica por las diferencias entre c√≥mo las personas
y las computadoras interpretan los datos de <code>String</code>.</p>
<h3 id="qu√©-es-un-string"><a class="header" href="#qu√©-es-un-string">¬øQu√© es un string?</a></h3>
<p>Bien primero definamos lo que queremos decir con el t√©rmino <em>string</em>. Rust solo
tiene un tipo de string en el lenguaje principal, que es el string slice <code>str</code>
que generalmente se ve en su forma prestada <code>&amp;str</code>. En el Cap√≠tulo 4, hablamos
sobre <em>string slices</em>, que son referencias a algunos datos de cadena codificados
en UTF-8 almacenados en otro lugar. Las literales de cadena, por ejemplo, se
almacenan en el binario del programa y, por lo tanto, son trozos de cadena.</p>
<p>El tipo <code>String</code>, que es proporcionado por la biblioteca est√°ndar en lugar de
codificado en el lenguaje principal, es un tipo de cadena que puede crecer, mutable,
de propiedad, codificado en UTF-8. Cuando los Rustaceans se refieren a &quot;strings&quot; en Rust,
pueden estar refiri√©ndose a cualquiera de los tipos <code>String</code> o <code>str</code>, no solo
a uno de esos tipos. Aunque esta secci√≥n trata principalmente de <code>String</code>, ambos
tipos se usan mucho en la biblioteca est√°ndar de Rust, y tanto <code>String</code> como
las rebanadas de cadena son codificadas en UTF-8.</p>
<h3 id="creando-un-nuevo-string"><a class="header" href="#creando-un-nuevo-string">Creando un nuevo String</a></h3>
<p>Muchas de las mismas operaciones disponibles con <code>Vec&lt;T&gt;</code> tambi√©n est√°n
disponibles con <code>String</code>, ya que <code>String</code> se implementa en realidad como un
envoltorio alrededor de un vector de bytes con algunas garant√≠as, restricciones
y capacidades adicionales. Un ejemplo de una funci√≥n que funciona de la misma
manera con <code>Vec&lt;T&gt;</code> y <code>String</code> es la funci√≥n <code>new</code> para crear una instancia,
que se muestra en el listado 8-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-11: Creando un nuevo y vac√≠o <code>String</code></span></p>
<p>Esta l√≠nea crea un nuevo <code>String</code> vac√≠o llamado <code>s</code>, el cual podemos luego cargar
con datos. A menudo, tendremos algunos datos iniciales que queremos comenzar
en el string. Para eso, usamos el m√©todo <code>to_string</code>, que est√° disponible en
cualquier tipo que implemente el trait <code>Display</code>, como lo hacen los String
Literals. El listado 8-12 muestra dos ejemplos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = &quot;initial contents&quot;;

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = &quot;initial contents&quot;.to_string();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-12: Usando el m√©todo <code>to_string</code> para crear un
<code>String</code> a partir de un string literal</span></p>
<p>Este c√≥digo crea un string que contiene <code>initial contents</code>.</p>
<p>Podemos tambi√©n usar la funci√≥n <code>String::from</code> para crear un <code>String</code> a partir
de un string literal. El c√≥digo en el listado 8-13 es equivalente al c√≥digo del
listado 8-12 que usa <code>to_string</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;initial contents&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-13: Usando la funci√≥n <code>String::from</code> para crear
un <code>String</code> a partir de un string literal</span></p>
<p>Debido a que los strings se usan para muchas cosas, podemos usar muchas APIs
gen√©ricas diferentes para strings, lo que nos proporciona muchas opciones.
Algunos de ellos pueden parecer redundantes, ¬°pero todos tienen su lugar! En
este caso, <code>String::from</code> y <code>to_string</code> hacen lo mismo, por lo que elegir
depende del estilo y la legibilidad.</p>
<p>Recuerda que los strings son UTF-8 codificados, por lo que podemos incluir
cualquier dato codificado correctamente en ellos, Como se muestra en el listado
8-14.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
    let hello = String::from(&quot;Dobr√Ω den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;◊©◊ú◊ï◊ù&quot;);
    let hello = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
    let hello = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
    let hello = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
    let hello = String::from(&quot;‰Ω†Â•Ω&quot;);
    let hello = String::from(&quot;Ol√°&quot;);
    let hello = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-14: Almacenamiento de saludos en diferentes
idiomas en strings</span></p>
<p>Todos estos strings son valores v√°lidos de <code>String</code>.</p>
<h3 id="actualizando-un-string"><a class="header" href="#actualizando-un-string">Actualizando un String</a></h3>
<p>Un <code>String</code> puede crecer en tama√±o y su contenido puede cambiar, al igual que
el contenido de un <code>Vec&lt;T&gt;</code>, si se introducen m√°s datos en el. Adem√°s, puedes usar
convenientemente el operador <code>+</code> o el macro <code>format!</code> para concatenar valores de
<code>String</code>.</p>
<h4 id="agregando-a-un-string-con-push_str-y-push"><a class="header" href="#agregando-a-un-string-con-push_str-y-push">Agregando a un String con <code>push_str</code> y <code>push</code></a></h4>
<p>Podemos hacer crecer un <code>String</code> usando el m√©todo <code>push_str</code> para agregar un
string slice, como se muestra en el listado 8-15.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-15: Agregando un string slice a un <code>String</code>
usando el m√©todo <code>push_str</code></span></p>
<p>Despu√©s de estas dos l√≠neas, <code>s</code> contendr√° <code>foobar</code>. El m√©todo <code>push_str</code> toma
un string slice porque no necesariamente queremos tomar posesi√≥n del par√°metro.
Por ejemplo, en el c√≥digo del listado 8-16, queremos poder usar <code>s2</code> despu√©s de
agregar su contenido a <code>s1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {s2}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-16: Uso de un string slice despu√©s de agregar
su contenido a un <code>String</code></span></p>
<p>Si el m√©todo <code>push_str</code> tomara posesi√≥n de <code>s2</code>, no podr√≠amos imprimir su valor
en la √∫ltima l√≠nea. ¬°Sin embargo, este c√≥digo funciona como esperamos!</p>
<p>El m√©todo <code>push</code> toma un solo car√°cter como par√°metro y lo agrega al <code>String</code>.
El listado 8-17 agrega la letra <code>l</code> a un <code>String</code> usando el m√©todo <code>push</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-17: Agregando un car√°cter a un valor <code>String</code>
usando <code>push</code></span></p>
<p>Como resultado, <code>s</code> contendr√° <code>lol</code>.</p>
<h4 id="concatenacion-con-el-operador--o-la-macro-format"><a class="header" href="#concatenacion-con-el-operador--o-la-macro-format">Concatenacion con el operador <code>+</code> o la Macro <code>format!</code></a></h4>
<p>A veces, necesitar√°s combinar dos strings. Sin embargo, no es tan simple como
usar el operador <code>+</code> con dos referencias a <code>String</code>. El c√≥digo en el listado
8-18 no compilar√°:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-18: Usando el operador <code>+</code> para combinar dos
valores <code>String</code> en un nuevo valor <code>String</code></span></p>
<p>El string <code>s3</code> contendr√° <code>Hello, world!</code>. La raz√≥n por la que <code>s1</code> ya no es
v√°lido despu√©s de la adici√≥n, y la raz√≥n por la que usamos una referencia a
<code>s2</code>, tiene que ver con la firma del m√©todo que se llama cuando usamos el
operador <code>+</code>. El operador <code>+</code> usa el m√©todo <code>add</code>, cuya firma se ve algo como
esto:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>En la biblioteca est√°ndar, ver√°s <code>add</code> definido usando gen√©ricos y tipos
asociados. Aqu√≠, hemos sustituido tipos concretos, que es lo que sucede cuando
llamamos a este m√©todo con valores <code>String</code>. Discutiremos los gen√©ricos en el
Cap√≠tulo 10. Esta firma nos da las pistas que necesitamos para entender las
partes complicadas del operador <code>+</code>.</p>
<p>Primero, <code>s2</code> tiene un <code>&amp;</code>, lo que significa que estamos agregando una referencia
del segundo string al primer string. Esto se debe al par√°metro <code>s</code> en la
funci√≥n <code>add</code>: solo podemos agregar un <code>&amp;str</code> a un <code>String</code>; no podemos agregar
dos valores <code>String</code> juntos. Pero espera, el tipo de <code>&amp;s2</code> es <code>&amp;String</code>, no
<code>&amp;str</code>, como se especifica en el segundo par√°metro de <code>add</code>. ¬øEntonces por qu√©
compila el listado 8-18?</p>
<p>La raz√≥n por la que podemos usar <code>s2</code> en la llamada a <code>add</code> es que el
compilador puede <em>convertir</em> el argumento <code>&amp;String</code> en un <code>&amp;str</code>. Cuando<br />
llamamos al m√©todo <code>add</code>, Rust usa una <em>coerci√≥n de dereferencia</em>, que aqu√≠
convierte <code>&amp;s2</code> en <code>&amp;s2[..]</code>. Discutiremos la coerci√≥n de dereferencia con m√°s
detalle en el Cap√≠tulo 15. Debido a que <code>add</code> no toma posesi√≥n del par√°metro
<code>s</code>, <code>s2</code> seguir√° siendo un <code>String</code> v√°lido despu√©s de esta operaci√≥n.</p>
<p>En segundo lugar, podemos ver en la firma que <code>add</code> toma el ownership de <code>self</code>,
porque <code>self</code> no tiene un <code>&amp;</code>. Esto significa que <code>s1</code> en el listado 8-18 se
mover√° a la llamada de <code>add</code> y ya no ser√° v√°lido despu√©s de eso. Entonces,
aunque <code>let s3 = s1 + &amp;s2;</code> parece que copiar√° ambos strings y crear√° uno
nuevo, esta declaraci√≥n realmente toma posesi√≥n de <code>s1</code>, agrega una copia del
contenido de <code>s2</code> y luego devuelve la propiedad del resultado. En otras
palabras, parece que est√° haciendo muchas copias, pero no lo est√°; la
implementaci√≥n es m√°s eficiente que copiar.</p>
<p>Si necesitamos concatenar m√∫ltiples strings, el comportamiento del operador <code>+</code>
se vuelve dif√≠cil de manejar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>En este punto, <code>s</code> contendr√° <code>tic-tac-toe</code>. Con todos los caracteres <code>+</code> y <code>&quot;</code>
es dif√≠cil ver qu√© est√° pasando. Para una combinaci√≥n de cadenas m√°s
complicada, podemos usar la macro <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{s1}-{s2}-{s3}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo tambi√©n establece <code>s</code> en <code>tic-tac-toe</code>. La macro <code>format!</code> funciona
como <code>println!</code>, pero en lugar de imprimir la salida en la pantalla, devuelve
un <code>String</code> con el contenido. La versi√≥n del c√≥digo que usa <code>format!</code> es mucho
m√°s f√°cil de leer, y el c√≥digo generado por la macro <code>format!</code> usa referencias
para que esta llamada no tome posesi√≥n de ninguno de sus par√°metros.</p>
<h3 id="indexando-en-strings"><a class="header" href="#indexando-en-strings">Indexando en Strings</a></h3>
<p>En muchos otros lenguajes de programaci√≥n, acceder a caracteres individuales en
un string referenci√°ndolos por √≠ndice es una operaci√≥n v√°lida y com√∫n. Sin
embargo, si intentas acceder a partes de un <code>String</code> usando la sintaxis de
indexaci√≥n en Rust, obtendr√°s un error. Considera el c√≥digo inv√°lido en el
listado 8-19.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}</span></code></pre>
<p><span class="caption">Listado 8-19: Intentando usar la sintaxis de indexaci√≥n con
un String</span></p>
<p>Este c√≥digo dar√° como resultado el siguiente error:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`, which is required by `String: Index&lt;_&gt;`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin &quot;collections&quot;) due to 1 previous error
</code></pre>
<p>El error y la nota cuentan la historia: los strings de Rust no admiten
indexaci√≥n. Pero, ¬øpor qu√© no? Para responder a esa pregunta, necesitamos
discutir c√≥mo Rust almacena los strings en la memoria.</p>
<h4 id="representaci√≥n-interna"><a class="header" href="#representaci√≥n-interna">Representaci√≥n Interna</a></h4>
<p>Un <code>String</code> es un wrapper sobre un <code>Vec&lt;u8&gt;</code>. Veamos algunos de nuestros
strings de ejemplo UTF-8 correctamente codificados del listado 8-14. Primero,
este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobr√Ω den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;◊©◊ú◊ï◊ù&quot;);
</span><span class="boring">    let hello = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
</span><span class="boring">    let hello = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
</span><span class="boring">    let hello = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
</span><span class="boring">    let hello = String::from(&quot;‰Ω†Â•Ω&quot;);
</span><span class="boring">    let hello = String::from(&quot;Ol√°&quot;);
</span><span class="boring">    let hello = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p>En este caso, <code>len</code> ser√° <code>4</code>, lo que significa que el vector que almacena el
string <code>‚ÄúHola‚Äù</code> tiene 4 bytes de largo. Cada una de estas letras toma un byte
cuando se codifica en UTF-8. La siguiente l√≠nea, sin embargo, puede
sorprenderte. (Nota que este string comienza con la letra cir√≠lica <em>Ze</em> may√∫scula,
no con el n√∫mero √°rabe 3.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobr√Ω den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;◊©◊ú◊ï◊ù&quot;);
</span><span class="boring">    let hello = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
</span><span class="boring">    let hello = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
</span><span class="boring">    let hello = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
</span><span class="boring">    let hello = String::from(&quot;‰Ω†Â•Ω&quot;);
</span><span class="boring">    let hello = String::from(&quot;Ol√°&quot;);
</span>    let hello = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
<span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}</span></code></pre></pre>
<p>Si tu te preguntas que tan largo es el string, podr√≠as decir 12. De hecho, la
respuesta de Rust es 24: ese es el n√∫mero de bytes que se necesitan para
codificar ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äù en UTF-8, porque cada valor escalar Unicode en ese
string toma 2 bytes de almacenamiento. Por lo tanto, un √≠ndice en los bytes del
string no siempre se correlacionar√° con un valor escalar Unicode v√°lido. Para
demostrarlo, considera este c√≥digo inv√°lido de Rust:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let answer = &amp;hello[0];</code></pre>
<p>Tu Ahora sabes que <code>answer</code> no ser√° <code>–ó</code>, la primera letra. Cuando codificado
en UTF-8, el primer byte de <code>–ó</code> es <code>208</code> y el segundo es <code>151</code>, por lo que
parecer√≠a que <code>answer</code> deber√≠a ser <code>208</code>, pero <code>208</code> no es un car√°cter v√°lido
por s√≠ solo. Devolver <code>208</code> probablemente no sea lo que un usuario querr√≠a si
pidieran la primera letra de esta cadena; sin embargo, esos son los √∫nicos
datos que Rust tiene en el √≠ndice de bytes 0. Los usuarios generalmente no
quieren que se devuelva el valor de byte, incluso si la cadena contiene solo
letras latinas: si <code>&amp;&quot;hello&quot;[0]</code> fuera un c√≥digo v√°lido que devolviera el valor
de byte, devolver√≠a <code>104</code>, no <code>h</code>.</p>
<p>La respuesta, entonces, es que para evitar devolver un valor inesperado y
causar errores que podr√≠an no descubrirse de inmediato, Rust no compila este
c√≥digo en absoluto y evita malentendidos al comienzo del proceso de
desarrollo.</p>
<h4 id="bytes-valores-escalares-y-grupos-de-grafemas"><a class="header" href="#bytes-valores-escalares-y-grupos-de-grafemas">Bytes, valores escalares y grupos de grafemas</a></h4>
<p>Otro punto sobre UTF-8 es que hay tres formas relevantes de ver las cadenas
desde la perspectiva de Rust: como bytes, valores escalares y grupos de
grafemas (lo m√°s parecido a lo que llamar√≠amos <em>letras</em>).</p>
<p>Si observamos la palabra ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù en escritura Devanagari, se almacena como un
vector de valores <code>u8</code> que se ve as√≠:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Eso es 18 bytes y es como las computadoras almacenan los datos. Si los
observamos como valores escalares Unicode, que es lo que es el tipo <code>char</code> de
Rust, esos bytes se ven as√≠:</p>
<pre><code class="language-text">['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
</code></pre>
<p>Aqu√≠ hay seis valores <code>char</code>, pero el cuarto y el sexto no son letras: son
diacr√≠ticos que no tienen sentido por s√≠ mismos. Finalmente, si los miramos
como grupos de grafemas, obtendr√≠amos lo que una persona llamar√≠a las cuatro
letras que componen la palabra hindi:</p>
<pre><code class="language-text">[&quot;‡§®&quot;, &quot;‡§Æ&quot;, &quot;‡§∏‡•ç&quot;, &quot;‡§§‡•á&quot;]
</code></pre>
<p>Rust proporciona diferentes formas de interpretar los datos de string sin
procesar que las computadoras almacenan para que cada programa pueda elegir la
interpretaci√≥n que necesita, sin importar en qu√© idioma humano est√©n los datos.</p>
<p>Una √∫ltima raz√≥n por la que Rust no permite indexar en un <code>String</code> para obtener
un car√°cter es que se espera que las operaciones de indexaci√≥n siempre tomen
tiempo constante (O(1)). Pero no es posible garantizar ese rendimiento con un
<code>String</code>, porque Rust tendr√≠a que recorrer el contenido desde el principio
hasta el √≠ndice para determinar cu√°ntos caracteres v√°lidos hab√≠a.</p>
<h3 id="slicing-strings"><a class="header" href="#slicing-strings">Slicing Strings</a></h3>
<p>La indexaci√≥n en un <code>String</code> suele ser una mala idea porque no est√° claro cu√°l
deber√≠a ser el tipo de retorno de la operaci√≥n de indexaci√≥n de string: un
valor de byte, un car√°cter, un grupo de grafemas o una rebanada de string. Si
realmente necesita usar √≠ndices para crear rebanadas de string, por lo tanto,
Rust le pide que sea m√°s espec√≠fico.</p>
<p>En lugar de indexar usando <code>[]</code> con un solo n√∫mero, puede usar <code>[]</code> con un
rango para crear un string slice conteniendo bytes particulares:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>Aqu√≠, <code>s</code> ser√° un <code>&amp;str</code> que contiene los primeros cuatro bytes del string. Antes,
mencionamos que cada uno de estos caracteres era de dos bytes, lo que significa
que <code>s</code> ser√° <code>–ó–¥</code>.</p>
<p>Si intent√°ramos hacer un slice con solo una parte de los bytes de un car√°cter,
algo como <code>&amp;hello[0..1]</code>, Rust entrar√≠a en p√°nico en tiempo de
ejecuci√≥n de la misma manera que si se accediera a un √≠ndice no v√°lido
en un vector:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside '–ó' (bytes 0..2) of `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Debemos tener cuidado cuando creamos string slices, porque hacerlo puede 
bloquear su programa.</p>
<h3 id="m√©todos-para-iterar-sobre-strings"><a class="header" href="#m√©todos-para-iterar-sobre-strings">M√©todos para iterar sobre Strings</a></h3>
<p>La mejor manera de operar en partes de strings es ser expl√≠cito sobre si
desea caracteres o bytes. Para valores escalares Unicode individuales, use el
m√©todo <code>chars</code>. Llamar a <code>chars</code> en ‚Äú–ó–¥‚Äù separa y devuelve dos valores de tipo
<code>char</code>, y puede iterar sobre el resultado para acceder a cada elemento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;–ó–¥&quot;.chars() {
    println!(&quot;{c}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo imprimir√° lo siguiente:</p>
<pre><code class="language-text">–ó
–¥
</code></pre>
<p>Alternativamente, el m√©todo <code>bytes</code> devuelve cada byte sin procesar, que puede
ser apropiado para su dominio:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;–ó–¥&quot;.bytes() {
    println!(&quot;{b}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo imprimir√° los cuatro bytes que componen el string:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Pero aseg√∫rate de recordar que los valores escalares de Unicode v√°lidos pueden 
estar compuestos por m√°s de un byte.</p>
<p>Obtener grupos de grafemas a partir de cadenas, como en el caso del alfabeto 
Devanagari, es complejo, por lo que esta funcionalidad no est√° proporcionada por
la biblioteca est√°ndar. Hay paquetes disponibles en 
<a href="https://crates.io/">crates.io</a><!-- ignore --> si necesitas esta funcionalidad.</p>
<h3 id="los-strings-no-son-tan-simples"><a class="header" href="#los-strings-no-son-tan-simples">Los Strings no son tan simples</a></h3>
<p>Para resumir, los strings son complicados. Los diferentes lenguajes de
programaci√≥n hacen diferentes elecciones sobre c√≥mo presentar esta complejidad
al programador. Rust ha elegido hacer que el manejo correcto de los datos
<code>String</code> sea el comportamiento predeterminado para todos los programas de Rust,
lo que significa que los programadores tienen que pensar m√°s en el manejo de
datos UTF-8 por adelantado. Este compromiso expone m√°s de la complejidad de
las cadenas de lo que parece en otros lenguajes de programaci√≥n, pero evita
que tenga que manejar errores que involucran caracteres no ASCII m√°s adelante
en su ciclo de vida de desarrollo.</p>
<p>La buena noticia es que la biblioteca est√°ndar ofrece mucha funcionalidad
construida a partir de los tipos <code>String</code> y <code>&amp;str</code> para ayudar a manejar estas
situaciones complejas correctamente. Aseg√∫rese de consultar la documentaci√≥n
para obtener m√©todos √∫tiles como <code>contains</code> para buscar en un string y
<code>replace</code> para sustituir partes de un string por otro string.</p>
<p>Pasemos a algo un poco menos complejo: ¬°Hash Maps!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenar-claves-con-valores-asociados-en-hashmaps"><a class="header" href="#almacenar-claves-con-valores-asociados-en-hashmaps">Almacenar Claves con Valores Asociados en HashMaps</a></h2>
<p>La √∫ltima de nuestras colecciones comunes es el <em>hash map</em>. El tipo <code>HashMap&lt;K, V&gt;</code> almacena un mapeo de claves de tipo <code>K</code> a valores de tipo <code>V</code> usando una
<em>funci√≥n hash</em>, que determina c√≥mo coloca estas claves y valores en la memoria.
Muchos lenguajes de programaci√≥n admiten este tipo de estructura de datos, pero
a menudo usan un nombre diferente, como <em>hash</em>, <em>map</em>, <em>object</em>, <em>hash table</em>,
<em>diccionario</em> o <em>arreglos asociativos</em>, solo para nombrar algunos.</p>
<p>Los hash maps son √∫tiles cuando desea buscar datos no usando un √≠ndice, como
puede hacerlo con vectores, sino usando una clave que puede ser de cualquier
tipo. Por ejemplo, en un juego, podr√≠a realizar un seguimiento de la puntuaci√≥n
de cada equipo en un hash map en el que cada clave es el nombre de un equipo y
los valores son la puntuaci√≥n de cada equipo. Dado un nombre de equipo, puede
recuperar su puntuaci√≥n.</p>
<p>Repasaremos la API b√°sica de los hash maps en esta secci√≥n, pero muchas m√°s
cosas buenas se esconden en las funciones definidas en <code>HashMap&lt;K, V&gt;</code> por la
biblioteca est√°ndar. Como siempre, consulte la documentaci√≥n de la biblioteca
est√°ndar para obtener m√°s informaci√≥n.</p>
<h3 id="creando-un-nuevo-hashmap"><a class="header" href="#creando-un-nuevo-hashmap">Creando un nuevo HashMap</a></h3>
<p>Una forma de crear un hash map vac√≠o es usar <code>new</code> y agregar elementos con
<code>insert</code>. En el Listado 8-20, estamos realizando un seguimiento de las
puntuaciones de dos equipos cuyos nombres son <em>Blue</em> y <em>Yellow</em>. El equipo
Blue comienza con 10 puntos y el equipo Yellow comienza con 50.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-20: Creando un nuevo hash map e insertando
algunas claves y valores</span></p>
<p>Ten en cuenta que es importante importar primero el m√≥dulo <code>HashMap</code> de la
biblioteca est√°ndar de colecciones. De nuestras tres colecciones comunes,
√©sta es la menos utilizada, por lo que no se incluye autom√°ticamente en las
caracter√≠sticas del <em>prelude</em>. Adem√°s, los hash maps tienen menos soporte por
parte de la biblioteca est√°ndar; por ejemplo, no hay una macro incorporada para
construirlos.</p>
<p>Al igual que los vectores, los hash maps almacenan sus datos en el <em>heap</em>. Este
<code>HashMap</code> tiene claves de tipo <code>String</code> y valores de tipo <code>i32</code>. Al igual que los
vectores, los hash maps son homog√©neos: todas las claves deben tener el mismo
tipo entre s√≠ y todos los valores deben tener el mismo tipo.</p>
<h3 id="accediendo-a-los-valores-en-un-hashmap"><a class="header" href="#accediendo-a-los-valores-en-un-hashmap">Accediendo a los valores en un HashMap</a></h3>
<p>Podemos obtener un valor de un hash map proporcionando su clave al m√©todo <code>get</code>
como se muestra en el listado 8-21.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-21: Acceso al puntaje para el equipo Blue
almacenado en el hash map</span></p>
<p>Aqu√≠, <code>score</code> tendr√° el valor que est√° asociado con el equipo Blue, y el
resultado ser√° <code>10</code>. El m√©todo <code>get</code> devuelve un <code>Option&lt;&amp;V&gt;</code>; si no hay un
valor para ese clave en el hash map, <code>get</code> devolver√° <code>None</code>. Este programa
maneja un <code>Option</code> llamando a <code>copied</code> para obtener un <code>Option&lt;i32&gt;</code> en lugar
de un <code>Option&lt;&amp;i32&gt;</code>, luego <code>unwrap_or</code> para establecer <code>score</code> en cero si
<code>scores</code> no tiene una entrada para la clave.</p>
<p>Podemos iterar sobre cada par clave-valor en un hash map de manera similar a
como lo hacemos con vectores, usando un ciclo <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{key}: {value}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo imprimir√° cada par en un orden arbitrario:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="hashmaps-y-ownership"><a class="header" href="#hashmaps-y-ownership">HashMaps y Ownership</a></h3>
<p>Para los tipos que implementan el trait <code>Copy</code>, como <code>i32</code>, los valores se
copian en el hash map. Para valores de propiedad como <code>String</code>, los valores se
mover√°n y el hash map ser√° el propietario de esos valores, como se demuestra
en el listado 8-22.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;Blue&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-22: Mostrando que claves y valores son propiedad
del hash map una vez que se insertan</span></p>
<p>No podemos usar <code>field_name</code> y <code>field_value</code> despu√©s de que se hayan movido al
hash map con la llamada a <code>insert</code>.</p>
<p>Si insertamos referencias a valores en el hash map, los valores no se mover√°n
al hash map. Los valores a los que apuntan las referencias deben ser v√°lidos
al menos mientras el hash map sea v√°lido. Hablaremos m√°s sobre estos problemas
en la secci√≥n <a href="ch10-03-lifetime-syntax.html#validando-referencias-con-lifetimes">‚ÄúValidando referencias con Lifetimes‚Äù</a><!-- ignore --> en el
Cap√≠tulo 10.</p>
<h3 id="actualizando-un-hashmap"><a class="header" href="#actualizando-un-hashmap">Actualizando un HashMap</a></h3>
<p>Aunque la cantidad de pares clave/valor es creciente, cada clave √∫nica solo puede
tener un valor asociado con ella a la vez (pero no viceversa: por ejemplo, el
equipo Blue y el equipo Yellow podr√≠an tener el valor <code>10</code> almacenados en el hash
map <code>scores</code>).</p>
<p>Cuando queremos cambiar los datos en un hash map, tenemos que decidir c√≥mo
manejar el caso en el que una clave ya tiene un valor asignado. Podr√≠as
reemplazar el valor antiguo por el nuevo valor, ignorando completamente el
valor antiguo. Podr√≠as mantener el valor antiguo e ignorar el nuevo valor,
agregando el nuevo valor solo si la clave <em>no</em> tiene ya un valor. O podr√≠as
combinar el valor antiguo y el nuevo valor. ¬°Veamos c√≥mo hacer cada una de
estas!</p>
<h4 id="reemplazando-un-valor"><a class="header" href="#reemplazando-un-valor">Reemplazando un valor</a></h4>
<p>Si insertamos una clave y un valor en un hash map y luego insertamos esa misma
clave con un valor diferente, el valor asociado con esa clave se reemplazar√°.
Aunque el c√≥digo en el listado 8-23 llama a <code>insert</code> dos veces, el hash map
solo contendr√° un par clave-valor porque estamos insertando el valor para la clave
del equipo Blue dos veces.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);

    println!(&quot;{scores:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-23: Reemplazando un valor almacenado con una
clave en particular</span></p>
<p>Este c√≥digo imprimir√° <code>{&quot;Blue&quot;: 25}</code>. El valor original de <code>10</code> ha sido
sobrescrito.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="insertando-una-clave-y-un-valor-solo-si-una-clave-no-est√°-presente"><a class="header" href="#insertando-una-clave-y-un-valor-solo-si-una-clave-no-est√°-presente">Insertando una clave y un valor solo si una clave no est√° presente</a></h4>
<p>Es com√∫n verificar si una clave en particular ya existe en el hash map con un
valor y luego realizar las siguientes acciones: si la clave existe en el hash
map, el valor existente debe permanecer tal como est√°; si la clave no existe,
insertarla junto con su valor.</p>
<p>Los hash maps tienen una API especial para esto llamada <code>entry</code> que toma la clave
que desea verificar como par√°metro. El valor de retorno del m√©todo <code>entry</code> es
un enum llamado <code>Entry</code> que representa un valor que puede o no existir. Digamos
que queremos verificar si la clave para el equipo Yellow tiene un valor
asociado. Si no lo tiene, queremos insertar el valor <code>50</code>, y lo mismo para el
equipo Blue. Usando la API <code>entry</code>, el c√≥digo se ve como el listado 8-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{scores:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-24: Usando el m√©todo <code>entry</code> para insertar solo
si la clave a√∫n no tiene un valor</span></p>
<p>El m√©todo <code>or_insert</code> en <code>Entry</code> est√° definido para devolver una referencia
mutable al valor correspondiente a la clave <code>Entry</code> si esa clave existe, y si no,
inserta el par√°metro como el nuevo valor para esta clave y devuelve una
referencia mutable al nuevo valor. Esta t√©cnica es mucho m√°s limpia que
escribir la l√≥gica nosotros mismos y, adem√°s, juega mejor con el borrow
checker.</p>
<p>Ejecutar el c√≥digo en el listado 8-24 imprimir√° <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>.
La primera llamada a <code>entry</code> insertar√° la clave para el equipo Yellow con el
valor 50 porque el equipo Yellow no tiene un valor todav√≠a. La segunda llamada
a <code>entry</code> no cambiar√° el hash map porque el equipo Blue ya tiene el valor <code>10</code>.</p>
<h4 id="actualizando-un-valor-basado-en-el-valor-anterior"><a class="header" href="#actualizando-un-valor-basado-en-el-valor-anterior">Actualizando un valor basado en el valor anterior</a></h4>
<p>Otro caso com√∫n para los hash maps es buscar un valor para una clave y luego
actualizar ese valor en funci√≥n del valor anterior. Por ejemplo, el listado 8-25
muestra un c√≥digo que cuenta cu√°ntas veces aparece cada palabra en alg√∫n texto.
Usamos un hash map con las palabras como claves y aumentamos el valor para
mantener un recuento de cu√°ntas veces hemos visto esa palabra. Si es la primera
vez que vemos una palabra, primero insertaremos el valor <code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = &quot;hello world wonderful world&quot;;

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!(&quot;{map:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 8-25: Contando ocurrencias de palabras usando un
hash map que almacena palabras y cuenta</span></p>
<p>Este c√≥digo imprimir√° <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. Es posible
que veas los mismos pares clave-valor en un orden diferente: recuerda la secci√≥n
<a href="ch08-03-hash-maps.html#accediendo-a-los-valores-en-un-hashmap">‚ÄúAccediendo a valores en un hash map‚Äù</a><!-- ignore --> que iterar sobre
un hash map ocurre en un orden arbitrario.</p>
<p>El m√©todo <code>split_whitespace</code> devuelve un iterator sobre sub-slices, separados
por espacios en blanco, del valor en <code>text</code>. El m√©todo <code>or_insert</code> devuelve una
referencia mutable (<code>&amp;mut V</code>) al valor para la clave especificada. Aqu√≠,
almacenamos esa referencia mutable en la variable <code>count</code>, por lo que para
asignar a ese valor, primero debemos desreferenciar <code>count</code> usando el asterisco
(<code>*</code>). La referencia mutable sale del √°mbito al final del ciclo <code>for</code>, por lo
que todos estos cambios son seguros y permitidos por las reglas del borrowing.</p>
<h3 id="funciones-de-hashing"><a class="header" href="#funciones-de-hashing">Funciones de Hashing</a></h3>
<p>Por defecto, <code>HashMap</code> usa una funci√≥n de hashing llamada <em>SipHash</em> que puede
proporcionar resistencia a ataques de Denegaci√≥n de Servicio (DoS) que
involucran tablas hash<sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore -->. Este no es el algoritmo de
hashing m√°s r√°pido disponible, pero el compromiso por una mejor seguridad que
viene con la ca√≠da en el rendimiento vale la pena. Si perfilas tu c√≥digo y
encuentras que la funci√≥n de hash predeterminada es demasiado lenta para tus
prop√≥sitos, puedes cambiar a otra funci√≥n especificando un hasher diferente. Un
<em>hasher</em> es un tipo que implementa el trait <code>BuildHasher</code>. Hablaremos sobre
traits y c√≥mo implementarlos en el <a href="ch10-02-traits.html">Cap√≠tulo 10</a>. No necesariamente tienes que
implementar tu propio hasher desde cero;
<a href="https://crates.io/">crates.io</a><!-- ignore -->
tiene bibliotecas compartidas por otros usuarios de Rust que proporcionan
hashes que implementan muchos algoritmos de hashing comunes.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="resumen-7"><a class="header" href="#resumen-7">Resumen</a></h2>
<p>Los vectores, los strings y los hash maps proporcionan una funcionalidad
importante que necesitar√°s cuando quieras almacenar, acceder y modificar datos.
Aqu√≠ hay algunos ejercicios que ahora deber√≠as estar equipado para resolver:</p>
<ol>
<li>Dada una lista de enteros, usa un vector y devuelve la mediana (cuando se
ordena, el valor en la posici√≥n media) y la moda (el valor que ocurre con m√°s
frecuencia; un hash map ser√° √∫til aqu√≠) de la lista.</li>
<li>Convierte strings a pig latin. La primera consonante de cada palabra se
mueve al final de la palabra y se agrega &quot;<em>ay</em>&quot;, por lo que &quot;<em>primero</em>&quot; se
convierte en &quot;<em>rimepay</em>&quot;. Sin embargo, si la palabra comienza con una vocal,
simplemente agregue &quot;hay&quot; al final de la palabra (&quot;<em>manzanaay</em>&quot;). ¬°Ten en
cuenta las reglas de UTF-8!</li>
<li>Usando un hash map y vectores, cree un texto de interfaz para permitir que un
usuario agregue nombres de empleados a un departamento en una empresa. Por
ejemplo, &quot;Agregar Sally a Ingenier√≠a&quot; o &quot;Agregar Amir a Ventas&quot;. Luego,
permita que el usuario recupere una lista de todas las personas en un
departamento o todas las personas en la empresa por departamento, ordenadas
alfab√©ticamente.</li>
</ol>
<p>La documentaci√≥n de la biblioteca est√°ndar describe m√©todos que los vectores,
strings y hash maps tienen que ser √∫tiles para estos ejercicios.</p>
<p>Nos estamos adentrando en programas m√°s complejos en los que las operaciones
pueden fallar, por lo que es un momento perfecto para discutir el manejo de
errores. ¬°Haremos eso a continuaci√≥n!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manejo-de-errores"><a class="header" href="#manejo-de-errores">Manejo de Errores</a></h1>
<p>Los errores son un hecho de la vida en el software, por lo que Rust tiene una
serie de caracter√≠sticas para manejar situaciones en las que algo sale mal. En
muchos casos, Rust te obliga a reconocer la posibilidad de un error y tomar
alguna acci√≥n antes de que tu c√≥digo se compile. ¬°Este requisito hace que su
programa sea m√°s robusto al garantizar que descubrir√° errores y los manejar√°
adecuadamente antes de implementar su c√≥digo en producci√≥n!</p>
<p>Rust agrupa los errores en dos categor√≠as principales: errores <em>recuperables</em> e
<em>irrecuperables</em>. Para un error recuperable, como un error de <em>archivo no
encontrado</em>, lo m√°s probable es que solo queramos informar el problema al
usuario y volver a intentar la operaci√≥n. Los errores irreversibles siempre son
s√≠ntomas de errores, como intentar acceder a una ubicaci√≥n m√°s all√° del final
de un arreglo, por lo que queremos detener inmediatamente el programa.</p>
<p>La mayor√≠a de los lenguajes no distinguen entre estos dos tipos de errores y los
manejan de la misma manera, utilizando mecanismos como excepciones. Rust no
tiene excepciones. En cambio, tiene el tipo <code>Result&lt;T, E&gt;</code> para errores
recuperables y el macro <code>panic!</code> que detiene la ejecuci√≥n cuando el programa
encuentra un error irrecuperable. Este cap√≠tulo cubre primero la llamada a
<code>panic!</code> y luego habla sobre la devoluci√≥n de valores <code>Result&lt;T, E&gt;</code>.
Adem√°s, exploraremos consideraciones al decidir si intentar recuperarse de un
error o detener la ejecuci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="errores-irrecuperables-con-panic"><a class="header" href="#errores-irrecuperables-con-panic">Errores irrecuperables con <code>panic!</code></a></h2>
<p>A veces, sucede algo malo en su c√≥digo y no hay nada que pueda hacer al
respecto. En estos casos, Rust tiene la macro <code>panic!</code>. Hay dos formas de causar
un panic en la pr√°ctica: tomando una acci√≥n que hace que nuestro c√≥digo entre en
p√°nico (como acceder a un arreglo m√°s all√° del final) o llamando expl√≠citamente
a la macro <code>panic!</code>. En ambos casos, causamos un p√°nico en nuestro programa. De
forma predeterminada, estos p√°nicos imprimir√°n un mensaje de error, se deshar√°n,
limpiar√°n la pila y se cerrar√°n. A trav√©s de una variable de entorno, tambi√©n
puede hacer que Rust muestre la pila de llamadas cuando ocurre un p√°nico para
facilitar el seguimiento de la fuente del panic.</p>
<blockquote>
<h3 id="deshacer-la-pila-o-abortar-en-respuesta-a-un-p√°nico"><a class="header" href="#deshacer-la-pila-o-abortar-en-respuesta-a-un-p√°nico">Deshacer la pila o abortar en respuesta a un p√°nico</a></h3>
<p>Por defecto, cuando ocurre un panic, el programa comienza a <em>deshacerse</em>, lo
que significa que Rust retrocede por la pila y limpia los datos de cada
funci√≥n que encuentra. Sin embargo, este retroceso y limpieza es mucho
trabajo. Rust, por lo tanto, le permite elegir la alternativa de <em>abortar</em>
inmediatamente, lo que termina el programa sin limpiar.</p>
<p>La memoria que el programa estaba usando deber√° ser limpiada por el sistema
operativo. Si en su proyecto necesita hacer que el binario resultante sea lo
m√°s peque√±o posible, puede cambiar de deshacer el programa a abortarlo al
producir un p√°nico agregando <code>panic = 'abort'</code> a las secciones <code>[profile]</code>
apropiadas en su archivo <em>Cargo.toml</em>. Por ejemplo, si desea abortar en caso
de p√°nico en el modo de lanzamiento, agregue esto:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Intentemos llamar un <code>panic!</code> en un programa simple:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}</code></pre></pre>
<p>Cuando ejecutes el programa, ver√°s algo como esto:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>La llamada a <code>panic!</code> causa el mensaje de error contenido en las dos √∫ltimas
l√≠neas. La primera l√≠nea muestra nuestro mensaje de panic y el lugar en nuestro
c√≥digo fuente donde ocurri√≥ el panic: <em>src/main.rs:2:5</em> indica que es la segunda
l√≠nea, quinto car√°cter de nuestro archivo <em>src/main.rs</em>.</p>
<p>En este caso, la l√≠nea indicada es parte de nuestro c√≥digo, y si vamos a esa
l√≠nea, vemos la llamada a la macro <code>panic!</code>. En otros casos, la llamada a
<code>panic!</code> podr√≠a estar en el c√≥digo que nuestro c√≥digo llama, y el nombre de
archivo y el n√∫mero de l√≠nea informados por el mensaje de error ser√°n el c√≥digo
de otra persona donde se llama a la macro <code>panic!</code>, no la l√≠nea de nuestro
c√≥digo que finalmente condujo a la llamada a <code>panic!</code>. Podemos usar el backtrace
de las funciones de las que provino la llamada a <code>panic!</code> para determinar la
parte de nuestro c√≥digo que est√° causando el problema. Discutiremos el backtrace
en m√°s detalle a continuaci√≥n.</p>
<h3 id="usando-el-backtrace-de-panic"><a class="header" href="#usando-el-backtrace-de-panic">Usando el backtrace de <code>panic!</code></a></h3>
<p>Veamos otro ejemplo de c√≥mo es cuando una llamada a <code>panic!</code> proviene de una
biblioteca debido a un error en nuestro c√≥digo en lugar de que nuestro c√≥digo
llame directamente a la macro. El listado 9-1 tiene alg√∫n c√≥digo que intenta
acceder a un √≠ndice en un vector m√°s all√° del rango de √≠ndices v√°lidos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
<p><span class="caption">Listado 9-1: Intentando acceder a un elemento m√°s all√° del
fin de un vector, que provocar√° una llamada a <code>panic!</code></span></p>
<p>Aqu√≠, estamos intentando acceder al elemento 100 de nuestro vector (que est√° en
el √≠ndice 99 porque el indexado comienza en cero), pero el vector solo tiene 3
elementos. En esta situaci√≥n, Rust entrar√° en p√°nico. Usar <code>[]</code> se supone que
devuelve un elemento, pero si pasa un √≠ndice no v√°lido, no hay ning√∫n elemento
que Rust podr√≠a devolver aqu√≠ que sea correcto.</p>
<p>En C, intentar leer m√°s all√° del final de una estructura de datos es un
undefined. Podr√≠a obtener lo que est√° en la ubicaci√≥n de memoria que
corresponder√≠a a ese elemento en la estructura de datos, aunque la memoria no
pertenece a esa estructura. Esto se llama <em>buffer overread</em> y puede provocar
vulnerabilidades de seguridad si un atacante puede manipular el √≠ndice de tal
manera que lea datos que no deber√≠a estar permitido que se almacenen despu√©s de
la estructura de datos.</p>
<p>Para proteger su programa de este tipo de vulnerabilidad, si intenta leer un
elemento en un √≠ndice que no existe, Rust detendr√° la ejecuci√≥n y se negar√° a
continuar. Intent√©moslo y veamos:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Este error apunta a la l√≠nea 4 de nuestro <code>main.rs</code> donde intentamos acceder al
√≠ndice 99. La siguiente l√≠nea de nota nos dice que podemos establecer la
variable de entorno <code>RUST_BACKTRACE</code> para obtener el backtrace de exactamente lo
que sucedi√≥ para causar el error. El <em>Backtrace</em> es una lista de todas las
funciones que se han llamado para llegar a este punto. El backtrace en Rust
funciona como lo hacen en otros lenguajes: la clave para leer el backtrace es
comenzar desde la parte superior y leer hasta que vea archivos que escribi√≥. Ese
es el lugar donde se origin√≥ el problema. Las l√≠neas por encima de ese punto son
el c√≥digo que su c√≥digo ha llamado; las l√≠neas a continuaci√≥n son el c√≥digo que
llam√≥ a su c√≥digo. Estas l√≠neas antes y despu√©s pueden incluir c√≥digo de Rust
core, c√≥digo de biblioteca est√°ndar o crates que est√©s usando. Intentemos
obtener el backtrace estableciendo la variable de entorno <code>RUST_BACKTRACE</code> a
cualquier valor excepto 0. El listado 9-2 muestra una salida similar a la que
ver√°s.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ export RUST_BACKTRACE=1; cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/std/src/panicking.rs:645:5
   1: core::panicking::panic_fmt
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/panicking.rs:72:14
   2: core::panicking::panic_bounds_check
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/panicking.rs:208:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/slice/index.rs:255:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/alloc/src/vec/mod.rs:2770:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at /rustc/07dca489ac2d933c78d3c5158e3f43beefeb02ce/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Listado 9-2: El backtrace generado por una llamada a
<code>panic!</code> se muestra cuando la variable de entorno <code>RUST_BACKTRACE</code> est√°
configurada</span></p>
<p>¬°Eso es mucho resultado! La salida exacta que vea puede ser diferente seg√∫n su
sistema operativo y la versi√≥n de Rust. Para obtener el backtrace con esta
informaci√≥n, deben estar habilitados los s√≠mbolos de depuraci√≥n. Los s√≠mbolos de
depuraci√≥n est√°n habilitados de forma predeterminada cuando se usa <code>cargo build</code>
o <code>cargo run</code> sin el indicador <code>--release</code>, como tenemos aqu√≠.</p>
<p>En la salida en el listado 9-2, la l√≠nea 6 del backtrace apunta a la l√≠nea en
nuestro proyecto que est√° causando el problema: la l√≠nea 4 de <code>src/main.rs</code>. Si
no queremos que nuestro programa entre en p√°nico, debemos comenzar nuestra
investigaci√≥n en la ubicaci√≥n se√±alada por la primera l√≠nea que menciona un
archivo que escribimos. En la listado 9-1, donde escribimos deliberadamente un
c√≥digo que entrar√≠a en p√°nico, la forma de solucionar el p√°nico es no solicitar
un elemento m√°s all√° del rango de los √≠ndices del vector. Cuando su c√≥digo entra
en p√°nico en el futuro, deber√° averiguar qu√© acci√≥n est√° tomando el c√≥digo con
qu√© valores para causar el p√°nico y qu√© deber√≠a hacer el c√≥digo en su lugar.</p>
<p>¬°Volveremos a <code>panic!</code> y cu√°ndo deber√≠amos y no deber√≠amos usar <code>panic!</code> para
manejar las condiciones de error en la secci√≥n <a href="ch09-03-to-panic-or-not-to-panic.html#panic-o-no-panic">‚ÄúTo <code>panic!</code> or Not to
<code>panic!</code>‚Äù</a><!-- ignore --> m√°s adelante en este
cap√≠tulo. A continuaci√≥n, veremos c√≥mo recuperarnos de un error usando <code>Result</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="errores-recuperables-con-result"><a class="header" href="#errores-recuperables-con-result">Errores recuperables con <code>Result</code></a></h2>
<p>La mayor√≠a de los errores no son lo suficientemente graves como para requerir
que el programa se detenga por completo. A veces, cuando una funci√≥n falla, es
por una raz√≥n que puede interpretar y responder f√°cilmente. Por ejemplo, si
intenta abrir un archivo y esa operaci√≥n falla porque el archivo no existe,
es posible que desee crear el archivo en lugar de terminar el proceso.</p>
<p>Recordemos el cap√≠tulo
<a href="ch02-00-guessing-game-tutorial.html#manejando-el-posible-fallo-con-result">‚ÄúManejo de fallas potenciales con <code>Result</code>‚Äù</a><!--ignore -->
en el Cap√≠tulo 2 que el enum <code>Result</code> se define como tener dos variantes,
<code>Ok</code> y <code>Err</code>, de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code> y <code>E</code> son par√°metros de tipo gen√©rico: hablaremos de los gen√©ricos con m√°s
detalle en el Cap√≠tulo 10. Lo que necesita saber ahora es que <code>T</code> representa el
tipo del valor que ser√° devuelto en un caso de √©xito dentro de la variante <code>Ok</code>,
y <code>E</code> representa el tipo del error que ser√° devuelto en un caso de fallo dentro
de la variante <code>Err</code>. Debido a que <code>Result</code> tiene estos par√°metros de tipo
gen√©rico, podemos usar el tipo <code>Result</code> y las funciones definidas en √©l en
muchas situaciones diferentes donde el valor de √©xito y el valor de error que
queremos devolver pueden diferir.</p>
<p>Llamemos a una funci√≥n que devuelve un valor <code>Result</code> porque la funci√≥n podr√≠a
fallar. En el listado 9-3 intentamos abrir un archivo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 9-3: Abriendo un archivo</span></p>
<p>El tipo de retorno de <code>File::open</code> es un <code>Result&lt;T, E&gt;</code>. El par√°metro gen√©rico
<code>T</code> ha sido llenado por la implementaci√≥n de <code>File::open</code> con el tipo del valor
de √©xito, <code>std::fs::File</code>, que es un manejador de archivo. El tipo de <code>E</code>
utilizado en el valor de error es <code>std::io::Error</code>. Este tipo de retorno
significa que la llamada a <code>File::open</code> podr√≠a tener √©xito y devolver un
manejador de archivo del que podemos leer o escribir. La llamada a la funci√≥n
tambi√©n podr√≠a fallar: por ejemplo, el archivo podr√≠a no existir, o podr√≠amos
no tener permiso para acceder al archivo. La funci√≥n <code>File::open</code> necesita tener
una forma de decirnos si tuvo √©xito o fall√≥ y al mismo tiempo darnos el
manejador de archivo o la informaci√≥n de error. Esta informaci√≥n es exactamente
lo que transmite el enum <code>Result</code>.</p>
<p>En el caso en que <code>File::open</code> tenga √©xito, el valor en la variable
<code>greeting_file_result</code> ser√° una instancia de <code>Ok</code> que contiene un manejador de
archivo. En el caso en que falla, el valor en <code>greeting_file_result</code> ser√° una
instancia de <code>Err</code> que contiene m√°s informaci√≥n sobre el tipo de error que
ocurri√≥.</p>
<p>Necesitamos agregar al c√≥digo en el listado 9-3 para tomar diferentes acciones
dependiendo del valor que <code>File::open</code> devuelve. El listado 9-4 muestra una
forma de manejar √©l <code>Result</code> usando una herramienta b√°sica, la expresi√≥n
<code>match</code> que discutimos en el Cap√≠tulo 6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {error:?}&quot;),
    };
}</code></pre></pre>
<p><span class="caption">Listado 9-4: Usando una expresi√≥n <code>match</code> para manejar las
variantes <code>Result</code> que podr√≠an devolverse</span></p>
<p>Ten en cuenta que, al igual que el enum <code>Option</code>, el enum <code>Result</code> y sus
variantes se han tra√≠do al √°mbito por el <a href="ch02-00-guessing-game-tutorial.html#prelude-meaning">prelude</a>, por lo que no necesitamos
especificar <code>Result::</code> antes de las variantes <code>Ok</code> y <code>Err</code> en las opciones de
<code>match</code>.</p>
<p>Cuando el result es <code>Ok</code>, este c√≥digo devolver√° el valor interno <code>file</code> fuera
de la variante <code>Ok</code>, y luego asignaremos ese valor de manejador de archivo a la
variable <code>greeting_file</code>. Despu√©s del <code>match</code>, podemos usar el manejador de
archivo para leer o escribir.</p>
<p>La otra opci√≥n en el <code>match</code> es <code>Err</code>, que significa que el <code>File::open</code> ha
fallado y el valor interno <code>err</code> de la variante <code>Err</code> contendr√° informaci√≥n
sobre c√≥mo o por qu√© fall√≥ <code>File::open</code>. En este caso, llamamos a la funci√≥n
<code>panic!</code> y pasamos el valor <code>err</code> al <code>panic!</code>. Esto causa que nuestro programa
se bloquee y muestre el mensaje de error que <code>panic!</code> proporciona. Si ejecutamos
este c√≥digo, obtendremos el siguiente mensaje de error:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Como de costumbre, esta salida nos dice exactamente qu√© ha salido mal.</p>
<h3 id="haciendo-coincidir-diferentes-errores"><a class="header" href="#haciendo-coincidir-diferentes-errores">Haciendo coincidir diferentes errores</a></h3>
<p>El c√≥digo en el listado 9-4 ser√° <code>panic!</code> no importa por qu√© <code>File::open</code> fall√≥.
Sin embargo, queremos tomar diferentes acciones para diferentes razones de
falla: si <code>File::open</code> fall√≥ porque el archivo no existe, queremos crear el
archivo y devolver el manejador del nuevo archivo. Si <code>File::open</code> fall√≥ por
cualquier otra raz√≥n, por ejemplo, porque no ten√≠amos permiso para abrir el
archivo, todav√≠a queremos que el c√≥digo dispare el <code>panic!</code> de la misma manera que lo hizo
en el listado 9-4. Para esto agregamos una expresi√≥n <code>match</code> interna, que se
muestra en el listado 9-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {e:?}&quot;),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {other_error:?}&quot;);
            }
        },
    };
}</code></pre>
<p><span class="caption">Listado 9-5: Manejando diferentes tipos de errores de
diferentes formas</span></p>
<p>El tipo de valor que <code>File::open</code> devuelve dentro de la variante <code>Err</code> es
<code>io::Error</code>, que es una estructura proporcionada por la biblioteca est√°ndar.
Esta estructura tiene un m√©todo <code>kind</code> que podemos llamar para obtener un valor
<code>io::ErrorKind</code>. El enum <code>io::ErrorKind</code> es proporcionado por la biblioteca
est√°ndar y tiene variantes que representan los diferentes tipos de errores que
podr√≠an resultar de una operaci√≥n <code>io</code>. La variante que queremos usar es
<code>ErrorKind::NotFound</code>, que indica que el archivo que estamos tratando de abrir
a√∫n no existe. As√≠ que hacemos coincidir en <code>greeting_file_result</code>, pero
tambi√©n tenemos una coincidencia interna en <code>error.kind()</code>.</p>
<p>La condici√≥n que queremos verificar en la coincidencia interna es si el valor
devuelto por <code>error.kind()</code> es la variante <code>NotFound</code> del enum <code>ErrorKind</code>. Si
es as√≠, intentamos crear el archivo con <code>File::create</code>. Sin embargo, debido a
que <code>File::create</code> tambi√©n podr√≠a fallar, necesitamos una segunda opci√≥n en la
expresi√≥n <code>match</code> interna. Cuando no se puede crear el archivo, se imprime un
mensaje de error diferente. La segunda opci√≥n del <code>match</code> externo permanece
igual, por lo que el programa se bloquea en cualquier error adem√°s del error de
archivo faltante.</p>
<blockquote>
<h3 id="alternativas-a-usar-match-con-resultt-e"><a class="header" href="#alternativas-a-usar-match-con-resultt-e">Alternativas a usar <code>match</code> con <code>Result&lt;T, E&gt;</code></a></h3>
<p>¬°Eso es mucho <code>match</code>! La expresi√≥n <code>match</code> es √∫til, pero tambi√©n es bastante
verbosa. En el Cap√≠tulo 13 aprender√°s sobre los closures, que se usan con
muchos de los m√©todos definidos en <code>Result&lt;T, E&gt;</code>. Estos m√©todos pueden ser
m√°s concisos que usar <code>match</code> al manejar valores <code>Result&lt;T, E&gt;</code> en tu c√≥digo.</p>
<p>Por ejemplo, aqu√≠ hay otra forma de escribir la misma l√≥gica que se muestra en
el listado 9-5, esta vez usando closures y el m√©todo <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {error:?}&quot;);
            })
        } else {
            panic!(&quot;Problem opening the file: {error:?}&quot;);
        }
    });
}</code></pre>
<p>Aunque este c√≥digo tiene el mismo comportamiento que el listado 9-5, no
contiene ninguna expresi√≥n <code>match</code> y es m√°s f√°cil de leer. Vuelve a este
ejemplo despu√©s de leer el Cap√≠tulo 13, y busca el m√©todo <code>unwrap_or_else</code> en
la documentaci√≥n de la biblioteca est√°ndar. Muchos m√°s de estos m√©todos pueden
limpiar enormes expresiones <code>match</code> anidadas cuando se trata de errores.</p>
</blockquote>
<h3 id="atajos-para-panic-en-caso-de-error-unwrap-y-expect"><a class="header" href="#atajos-para-panic-en-caso-de-error-unwrap-y-expect">Atajos para <code>panic</code> en caso de error: <code>unwrap</code> y <code>expect</code></a></h3>
<p>Usando <code>match</code> funciona bastante bien, pero puede ser un poco verboso y no
siempre comunica bien la intenci√≥n. El tipo <code>Result&lt;T, E&gt;</code> tiene muchos m√©todos
auxiliares definidos en √©l para hacer varias tareas m√°s espec√≠ficas. El m√©todo
<code>unwrap</code> es un m√©todo de atajo implementado exactamente como la expresi√≥n
<code>match</code> que escribimos en el listado 9-4. Si el valor <code>Result</code> es la variante
<code>Ok</code>, <code>unwrap</code> devolver√° el valor dentro de <code>Ok</code>. Si el <code>Result</code> es la variante
<code>Err</code>, <code>unwrap</code> llamar√° a la macro <code>panic!</code> por nosotros. Aqu√≠ hay un ejemplo de
<code>unwrap</code> en acci√≥n:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap();
}</code></pre></pre>
<p>Si ejecutamos este c√≥digo sin un archivo <em>hello.txt</em>, veremos un mensaje de
error de la llamada <code>panic!</code> que el m√©todo <code>unwrap</code> hace:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre>
<p>Del mismo modo, el m√©todo <code>expect</code> nos permite elegir el mensaje de error de
<code>panic!</code>. Usando <code>expect</code> en lugar de <code>unwrap</code> y proporcionando buenos mensajes
de error puede transmitir tu intenci√≥n y facilitar el seguimiento de la fuente
de un p√°nico. La sintaxis de <code>expect</code> se ve as√≠:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)
        .expect(&quot;hello.txt should be included in this project&quot;);
}</code></pre></pre>
<p>Nosotros usamos <code>expect</code> de la misma manera que <code>unwrap</code>: para devolver el
manejo de archivo o llamar a la macro <code>panic!</code>. El mensaje de error utilizado
por <code>expect</code> en su llamada a <code>panic!</code> ser√° el par√°metro que pasamos a <code>expect</code>,
en lugar del mensaje predeterminado de <code>panic!</code> que usa <code>unwrap</code>. As√≠ es como
se ve:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre>
<p>En producci√≥n, la mayor√≠a de los Rustaceans eligen <code>expect</code> en lugar de
<code>unwrap</code> y dan m√°s contexto sobre por qu√© se espera que la operaci√≥n siempre
tenga √©xito. De esa manera, si tus suposiciones se demuestran incorrectas,
tienes m√°s informaci√≥n para usar en la depuraci√≥n.</p>
<h3 id="propagaci√≥n-de-errores"><a class="header" href="#propagaci√≥n-de-errores">Propagaci√≥n de errores</a></h3>
<p>Cuando escribes una funci√≥n cuyo cuerpo puede generar un error, en lugar de
manejar el error dentro de la funci√≥n, puedes devolver el error al c√≥digo que
llam√≥ la funci√≥n. Esto se conoce como <em>propagaci√≥n</em> del error y le da m√°s
control al c√≥digo que llama, donde puede haber m√°s informaci√≥n o l√≥gica que
dicte c√≥mo se debe manejar el error que la que tienes disponible en el contexto
de tu c√≥digo.</p>
<p>Por ejemplo, El listado 9-6 muestra una funci√≥n que lee un nombre de usuario de
un archivo. Si el archivo no existe o no se puede leer, esta funci√≥n devolver√°
esos errores al c√≥digo que llam√≥ a la funci√≥n.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hello.txt&quot;);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-6: Una funci√≥n que devuelve errores al c√≥digo
llamado usando <code>match</code></span></p>
<p>Esta funci√≥n se puede escribir de una manera mucho m√°s corta, pero vamos a
empezar por hacer mucho de ella manualmente para explorar el manejo de errores;
al final, mostraremos la forma m√°s corta. Veamos primero el tipo de retorno de
la funci√≥n: <code>Result&lt;String, io::Error&gt;</code>. Esto significa que la funci√≥n est√°
devolviendo un valor del tipo <code>Result&lt;T, E&gt;</code> donde el par√°metro gen√©rico <code>T</code> se
ha rellenado con el tipo concreto <code>String</code>, y el tipo gen√©rico <code>E</code> se ha
rellenado con el tipo concreto <code>io::Error</code>.</p>
<p>Si esta funci√≥n tiene √©xito sin ning√∫n problema, el c√≥digo que llama a esta
funci√≥n recibir√° un valor <code>Ok</code> que contiene una <code>String</code> - el nombre de usuario
que esta funci√≥n ley√≥ del archivo. Si esta funci√≥n encuentra alg√∫n problema, el
c√≥digo que llama recibir√° un valor <code>Err</code> que contiene una instancia de
<code>io::Error</code> que contiene m√°s informaci√≥n sobre cu√°les fueron los problemas.
Elegimos <code>io::Error</code> como el tipo de retorno de esta funci√≥n porque eso sucede
que es el tipo del valor de error devuelto de ambas operaciones que estamos
llamando en el cuerpo de esta funci√≥n que podr√≠an fallar: la funci√≥n
<code>File::open</code> y el m√©todo <code>read_to_string</code>.</p>
<p>El cuerpo de la funci√≥n comienza llamando a la funci√≥n <code>File::open</code>. Entonces
manejamos el valor <code>Result</code> con una expresi√≥n <code>match</code> similar a la del Listado
9-4. Si <code>File::open</code> tiene √©xito, el archivo manejador en el patr√≥n de variable
<code>file</code> se convierte en el valor en la variable de patr√≥n mutable <code>username_file</code>
y la funci√≥n contin√∫a. En el caso de <code>Err</code>, en lugar de llamar a <code>panic!</code>,
usamos la palabra clave <code>return</code> para devolver temprano la funci√≥n por
completo y pasar el valor de error de <code>File::open</code>, ahora en la variable de
patr√≥n <code>e</code>, de vuelta al c√≥digo que llama a esta funci√≥n como el valor de error
de esta funci√≥n.</p>
<p>Entonces, si tenemos un manejador de archivo en <code>username_file</code>, la funci√≥n
crea un nuevo <code>String</code> en la variable <code>username</code> y llama al m√©todo
<code>read_to_string</code> en el manejador de archivo en <code>username_file</code> para leer el
contenido del archivo en <code>username</code>. El m√©todo <code>read_to_string</code> tambi√©n
devuelve un <code>Result</code> porque podr√≠a fallar, incluso si <code>File::open</code> tuvo √©xito.
As√≠ que necesitamos otro <code>match</code> para manejar ese <code>Result</code>: si <code>read_to_string</code>
tiene √©xito, entonces nuestra funci√≥n ha tenido √©xito, y devolvemos el nombre de
usuario del archivo que ahora est√° en <code>username</code> envuelto en un <code>Ok</code>. Si
<code>read_to_string</code> falla, devolvemos el valor de error de la misma manera que
devolvimos el valor de error en el <code>match</code> que manej√≥ el valor de retorno de
<code>File::open</code>. Sin embargo, no necesitamos decir expl√≠citamente <code>return</code>, porque
esta es la √∫ltima expresi√≥n de la funci√≥n.</p>
<p>El c√≥digo que llama a este c√≥digo se encargar√° de obtener un valor <code>Ok</code> que
contiene un nombre de usuario o un valor <code>Err</code> que contiene un <code>io::Error</code>. Es
responsabilidad del c√≥digo que llama decidir qu√© hacer con esos valores. Si el
c√≥digo que llama obtiene un valor <code>Err</code>, podr√≠a llamar a <code>panic!</code> y bloquear el
programa, usar un nombre de usuario predeterminado o buscar el nombre de
usuario en alg√∫n lugar que no sea un archivo, por ejemplo. No tenemos
suficiente informaci√≥n sobre lo que el c√≥digo que llama realmente est√° tratando
de hacer, por lo que propagamos toda la informaci√≥n de √©xito o error hacia
arriba para que la maneje apropiadamente.</p>
<p>Este patr√≥n de propagaci√≥n de errores es tan com√∫n en Rust que Rust proporciona
el operador de interrogaci√≥n <code>?</code> para hacer esto m√°s f√°cil.</p>
<h4 id="un-atajo-para-propagar-errores-el-operador-"><a class="header" href="#un-atajo-para-propagar-errores-el-operador-">Un atajo para propagar errores: el operador <code>?</code></a></h4>
<p>El listado 9-7 muestra una implementaci√≥n de <code>read_username_from_file</code> que tiene
la misma funcionalidad que en el Listado 9-6, pero esta implementaci√≥n utiliza
el operador <code>?</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-7: Una funci√≥n que devuelve errores al c√≥digo
llamado usando el operador <code>?</code></span></p>
<p>El <code>?</code> colocado despu√©s de un valor <code>Result</code> se define para funcionar de casi
la misma manera que las expresiones <code>match</code> que definimos para manejar los
valores <code>Result</code> en el listado 9-6. Si el valor de <code>Result</code> es un <code>Ok</code>, el
valor dentro del <code>Ok</code> se devolver√° de esta expresi√≥n, y el programa continuar√°.
Si el valor es un <code>Err</code>, √©l <code>Err</code> se devolver√° de toda la funci√≥n como si
hubi√©ramos usado la palabra clave <code>return</code> para que el valor de error se
propague al c√≥digo que llama.</p>
<p>Hay una diferencia entre lo que hace la expresi√≥n <code>match</code> del listado 9-6 y lo
que hace el operador <code>?</code>: los valores de error que tienen el operador <code>?</code>
llamado en ellos pasan a trav√©s de la funci√≥n <code>from</code>, definida en el trait
<code>From</code> en la biblioteca est√°ndar, que se usa para convertir valores de un tipo
a otro. Cuando el operador <code>?</code> llama a la funci√≥n <code>from</code>, el tipo de error
recibido se convierte en el tipo de error definido en el tipo de retorno de la
funci√≥n actual. Esto es √∫til cuando una funci√≥n devuelve un tipo de error para
representar todas las formas en que una funci√≥n podr√≠a fallar, incluso si las
partes podr√≠an fallar por muchas razones diferentes.</p>
<p>Por ejemplo, podr√≠amos cambiar la funci√≥n <code>read_username_from_file</code> en el
listado 9-7 para devolver un tipo de error personalizado llamado <code>OurError</code> que
definimos. Si tambi√©n definimos <code>impl From&lt;io::Error&gt; for OurError</code> para
construir una instancia de <code>OurError</code> a partir de un <code>io::Error</code>, entonces el
operador <code>?</code> llama en el cuerpo de <code>read_username_from_file</code> llamar√° a <code>from</code>
y convertir√° los tipos de error sin necesidad de agregar m√°s c√≥digo a la
funci√≥n.</p>
<p>En el contexto del listado 9-7, el <code>?</code> al final de la llamada a <code>File::open</code>
devolver√° el valor dentro de un <code>Ok</code> a la variable <code>username_file</code>. Si ocurre
un error, el <code>?</code> operador devolver√° temprano toda la funci√≥n y dar√° cualquier
valor <code>Err</code> al c√≥digo que llama. Lo mismo se aplica al <code>?</code> al final de la
llamada a <code>read_to_string</code>.</p>
<p>El operador <code>?</code> elimina mucho c√≥digo repetitivo y realiza esta funci√≥n de
implementaci√≥n m√°s simple. Incluso podr√≠amos acortar a√∫n m√°s este c√≥digo
encadenando llamadas de m√©todo inmediatamente despu√©s del <code>?</code>, como se muestra
en el Listado 9-8.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-8: M√©todo de encadenamiento
llamado despu√©s del operador <code>?</code></span></p>
<p>Hemos movido la creaci√≥n del nuevo <code>String</code> en <code>username</code> al principio de la
funci√≥n; esa parte no ha cambiado. En lugar de crear una variable
<code>username_file</code>, hemos encadenado la llamada a <code>read_to_string</code> directamente
sobre el resultado de <code>File::open(&quot;hello.txt&quot;)?</code>. Todav√≠a tenemos un <code>?</code> al
final de la llamada a <code>read_to_string</code>, y todav√≠a devolvemos un valor <code>Ok</code>
que contiene <code>username</code> cuando tanto <code>File::open</code> como <code>read_to_string</code>
tienen √©xito en lugar de devolver errores. La funcionalidad es nuevamente la
misma que en el listado 9-6 y el listado 9-7; esta es solo una forma diferente
y m√°s ergon√≥mica de escribirla.</p>
<p>El listado 9-9 muestra una forma de hacer esto a√∫n m√°s conciso usando
<code>fs::read_to_string</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-9: Usando <code>fs::read_to_string</code> en lugar de
abrir y luego leer el archivo</span></p>
<p>Leer un archivo en un <code>String</code> es una operaci√≥n bastante com√∫n, por lo que la
biblioteca est√°ndar proporciona la conveniente funci√≥n <code>fs::read_to_string</code>
que abre el archivo, crea un nuevo <code>String</code>, lee el contenido del archivo,
coloca el contenido en ese <code>String</code> y lo devuelve. Por supuesto, usar
<code>fs::read_to_string</code> no nos da la oportunidad de explicar todo el manejo de
errores, por lo que lo hicimos de la manera m√°s larga primero.</p>
<h4 id="donde-se-puede-usar-el-operador-"><a class="header" href="#donde-se-puede-usar-el-operador-">Donde se puede usar el operador <code>?</code></a></h4>
<p>El operador <code>?</code> solo puede usarse en funciones cuyo tipo de retorno sea
compatible con el valor que se usa con el operador <code>?</code>. Porque el operador <code>?</code>
est√° definido para realizar una devoluci√≥n temprana de un valor de la funci√≥n,
de la misma manera que la expresi√≥n <code>match</code> que definimos en el listado 9-6.
En el listado 9-6, el <code>match</code> estaba usando un valor <code>Result</code>, y el brazo de
devoluci√≥n temprana devolvi√≥ un valor <code>Err(e)</code>. El tipo de retorno de la
funci√≥n debe ser un <code>Result</code> para que sea compatible con este <code>return</code>.</p>
<p>En el listado 9-10, veamos el error que obtendremos si usamos el operador <code>?</code>
en una funci√≥n <code>main</code> con un tipo de retorno incompatible con el tipo de valor
que usamos <code>?</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;
}</code></pre>
<p><span class="caption">Listado 9-10: Intentando usar el <code>?</code> en la funci√≥n <code>main</code>
que devuelve <code>()</code> no se compilar√°</span></p>
<p>Este c√≥digo abre un archivo, que puede fallar. El operador <code>?</code> sigue el valor
<code>Result</code> devuelto por <code>File::open</code>, pero esta funci√≥n <code>main</code> tiene el tipo de
retorno de <code>()</code>, no <code>Result</code>. Cuando compilamos este c√≥digo, obtenemos el
siguiente mensaje de error:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open(&quot;hello.txt&quot;)?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin &quot;error-handling&quot;) due to 1 previous error
</code></pre>
<p>Este error se√±ala que solo podemos usar el operador <code>?</code> en una funci√≥n que
devuelve <code>Result</code> o <code>Option</code> o en cualquier otro tipo que implemente
<code>FromResidual</code>.</p>
<p>Para corregir el error, tienes dos opciones. Una opci√≥n es cambiar el tipo de
retorno de tu funci√≥n para que sea compatible con el valor que est√°s usando el
operador <code>?</code> mientras no tengas restricciones que lo impidan. La otra t√©cnica
es usar un <code>match</code> o uno de los m√©todos <code>Result&lt;T, E&gt;</code> para manejar el
<code>Result&lt;T, E&gt;</code> de la manera que sea apropiada.</p>
<p>El mensaje de error tambi√©n menciona que el operador <code>?</code> tambi√©n se puede usar
con valores <code>Option&lt;T&gt;</code>. Al igual que con el uso de <code>?</code> en <code>Result</code>, solo
puedes usar <code>?</code> en <code>Option</code> en una funci√≥n que devuelve <code>Option</code>. El
comportamiento del operador <code>?</code> cuando se llama en un <code>Option&lt;T&gt;</code> es similar a
su comportamiento cuando se llama en un <code>Result&lt;T, E&gt;</code>: si el valor es <code>None</code>,
el <code>None</code> se devolver√° temprano desde la funci√≥n en ese punto. Si el valor es
<code>Some</code>, el valor dentro de <code>Some</code> es el valor resultante de la expresi√≥n y la
funci√≥n contin√∫a. El listado 9-11 tiene un ejemplo de una funci√≥n que encuentra
el √∫ltimo car√°cter de la primera l√≠nea en el texto dado:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hello, world\nHow are you today?&quot;),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 9-11: Using the <code>?</code> operator on an <code>Option&lt;T&gt;</code>
value</span></p>
<p>Esta funci√≥n devuelve <code>Option&lt;char&gt;</code> porque es posible que haya un car√°cter
all√≠, pero tambi√©n es posible que no lo haya. Este c√≥digo toma el argumento de
string slice <code>text</code> y llama al m√©todo <code>lines</code> en √©l, que devuelve un
iterador sobre las l√≠neas en el string. Debido a que esta funci√≥n quiere
examinar la primera l√≠nea, llama a <code>next</code> en el iterador para obtener el primer
valor del iterador. Si <code>text</code> es un string vac√≠o, esta llamada a <code>next</code>
devolver√° <code>None</code>, en cuyo caso usamos <code>?</code> para detener y devolver <code>None</code> desde
<code>last_char_of_first_line</code>. Si <code>text</code> no es un string vac√≠o, <code>next</code> devolver√°
un valor <code>Some</code> que contiene un string slice de la primera l√≠nea en <code>text</code>.</p>
<p>El <code>?</code> extrae el string slice, y podemos llamar a <code>chars</code> en ese string slice
para obtener un iterador de sus caracteres. Estamos interesados en el √∫ltimo
car√°cter en esta primera l√≠nea, por lo que llamamos a <code>last</code> para devolver el
√∫ltimo elemento en el iterador. Esto es un <code>Option</code> porque es posible que la
primera l√≠nea sea el string vac√≠o, por ejemplo, si <code>text</code> comienza con una
l√≠nea en blanco pero tiene caracteres en otras l√≠neas, como en <code>&quot;\nhi&quot;</code>. Sin
embargo, si hay un √∫ltimo car√°cter en la primera l√≠nea, se devolver√° en la
variante <code>Some</code>. El operador <code>?</code> en el medio nos da una forma concisa de
expresar esta l√≥gica, lo que nos permite implementar la funci√≥n en una l√≠nea.
Si no pudi√©ramos usar el operador <code>?</code> en <code>Option</code>, tendr√≠amos que implementar
esta l√≥gica usando m√°s llamadas de m√©todo o una expresi√≥n <code>match</code>.</p>
<p>Ten en cuenta que puedes usar el operador <code>?</code> en una funci√≥n que devuelve
<code>Result</code> y puedes usar el operador <code>?</code> en una funci√≥n que devuelve <code>Option</code>,
pero no puedes mezclar y combinar. El operador <code>?</code> no convertir√°
autom√°ticamente un <code>Result</code> en un <code>Option</code> o viceversa; en esos casos, puedes
usar m√©todos como el m√©todo <code>ok</code> en <code>Result</code> o el m√©todo <code>ok_or</code> en <code>Option</code>
para hacer la conversi√≥n expl√≠citamente.</p>
<p>Hasta ahora, todas las funciones <code>main</code> que hemos usado devuelven <code>()</code>. La
funci√≥n <code>main</code> es especial porque es el punto de entrada y salida de los
programas ejecutables, y hay restricciones sobre cu√°l puede ser su tipo de
retorno para que los programas se comporten como se espera.</p>
<p>Por suerte, <code>main</code> tambi√©n puede devolver un <code>Result&lt;(), E&gt;</code>. El Listado 9-12
tiene el c√≥digo del listado 9-10, pero hemos cambiado el tipo de retorno de
<code>main</code> para que sea <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> y hemos agregado un valor de
retorno <code>Ok(())</code> al final. Este c√≥digo ahora se compilar√°:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}</code></pre>
<p><span class="caption">Listado‚àÇ 9-12: Cambiando <code>main</code> devuelve <code>Result&lt;(), E&gt;</code>
permitiendo el uso del operador <code>?</code> en valores <code>Result</code></span></p>
<p>El <code>Box&lt;dyn Error&gt;</code> tipo es un <em>trait object</em>, que hablaremos en la secci√≥n
<a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">‚ÄúUsando Trait Objects que permiten valores de diferentes
tipos‚Äù</a><!-- ignore --> en el Cap√≠tulo 17. Por ahora, puedes leer
<code>Box&lt;dyn Error&gt;</code> para significar ‚Äúcualquier tipo de error‚Äù. Usar <code>?</code> en un
valor <code>Result</code> en una funci√≥n <code>main</code> con el tipo de error <code>Box&lt;dyn Error&gt;</code> est√°
permitido, porque permite que cualquier valor <code>Err</code> se devuelva temprano. A
pesar de que el cuerpo de esta funci√≥n <code>main</code> solo devolver√° errores de tipo
<code>std::io::Error</code>, al especificar <code>Box&lt;dyn Error&gt;</code>, esta firma seguir√° siendo
correcta incluso si se agrega m√°s c√≥digo que devuelva otros errores al cuerpo
de <code>main</code>.</p>
<p>Cuando una funci√≥n <code>main</code> devuelve un <code>Result</code>, el ejecutable puede
salir con un valor de <code>0</code> si <code>main</code> devuelve <code>Ok(())</code> y saldr√° con un valor
distinto de <code>0</code> si <code>main</code> devuelve un <code>Err</code>. Los ejecutables escritos en C
devuelven enteros cuando salen: los programas que salen con √©xito devuelven el
entero <code>0</code>, y los programas que devuelven un error devuelven alg√∫n entero
distinto de <code>0</code>. Rust tambi√©n devuelve enteros de ejecutables para ser
compatibles con esta convenci√≥n.</p>
<p>La funci√≥n <code>main</code> puede devolver cualquier tipo que implemente el trait
<a href="https://doc.rust-lang.org/std/process/trait.Termination.html"><code>std::process::Termination</code></a><!-- ignore -->, que incluye una
funci√≥n <code>report</code> que devuelve un <code>ExitCode</code>. Consulta la documentaci√≥n de la
biblioteca est√°ndar para obtener m√°s informaci√≥n sobre la implementaci√≥n del
trait <code>Termination</code> para tus propios tipos.</p>
<p>Ahora que hemos discutido los detalles de llamar a <code>panic!</code> o devolver
<code>Result</code>, volvamos al tema de c√≥mo decidir cu√°l es apropiado usar en qu√© casos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic-o-no-panic"><a class="header" href="#panic-o-no-panic"><code>panic!</code> o no <code>panic!</code></a></h2>
<p>Entonces, ¬øc√≥mo decides cu√°ndo debes llamar a <code>panic!</code> y cu√°ndo debes devolver
<code>Result</code>? Cuando el c√≥digo entra en panic, no hay forma de recuperarse. Podr√≠as
llamar a <code>panic!</code> para cualquier situaci√≥n de error, ya sea que haya una forma
posible de recuperarse o no, pero entonces est√°s tomando la decisi√≥n de que una
situaci√≥n es irreparable en nombre del c√≥digo que llama. Cuando eliges devolver
un valor <code>Result</code>, le das al c√≥digo que llama opciones. El c√≥digo que llama
podr√≠a elegir intentar recuperarse de una manera que sea apropiada para su
situaci√≥n, o podr√≠a decidir que un valor <code>Err</code> en este caso es irreparable, por
lo que puede llamar a <code>panic!</code> y convertir su error recuperable en uno
irreparable. Por lo tanto, devolver <code>Result</code> es una buena opci√≥n predeterminada
cuando est√°s definiendo una funci√≥n que podr√≠a fallar.</p>
<p>En situaciones como ejemplos, c√≥digo de prototipo y pruebas, es m√°s apropiado
escribir c√≥digo que entre en panic en lugar de devolver un <code>Result</code>. Veamos
por qu√©, luego discutiremos situaciones en las que el compilador no puede
darse cuenta de que la falla es imposible, pero t√∫ como humano puedes. El
cap√≠tulo concluir√° con algunas pautas generales sobre c√≥mo decidir si entrar en
panic en el c√≥digo de la biblioteca.</p>
<h3 id="ejemplos-c√≥digo-de-prototipo-y-test"><a class="header" href="#ejemplos-c√≥digo-de-prototipo-y-test">Ejemplos, c√≥digo de prototipo y test</a></h3>
<p>Cuando est√°s escribiendo un ejemplo para ilustrar alg√∫n concepto, tambi√©n
incluir c√≥digo de manejo de errores robusto puede hacer que el ejemplo sea
menos claro. En los ejemplos, se entiende que una llamada a un m√©todo como
<code>unwrap</code> que podr√≠a entrar en panic se entiende como un marcador de posici√≥n
para la forma en que desea que su aplicaci√≥n maneje los errores, que puede
diferir seg√∫n lo que el resto de su c√≥digo est√° haciendo.</p>
<p>De manera similar, los m√©todos <code>unwrap</code> y <code>expect</code> son muy √∫tiles cuando se
prototipa, antes de que est√©s listo para decidir c√≥mo manejar los errores.
Dejan marcadores claros en tu c√≥digo para cuando est√©s listo para hacer que tu
programa sea m√°s robusto.</p>
<p>Si una llamada a un m√©todo falla en una prueba, querr√°s que toda la prueba
falle, incluso si ese m√©todo no es la funcionalidad en prueba. Debido a que
<code>panic!</code> es la forma en que una prueba se marca como fallida, llamar a
<code>unwrap</code> o <code>expect</code> es exactamente lo que deber√≠a suceder.</p>
<h3 id="casos-en-los-que-tienes-mas-informacion-que-el-compilador"><a class="header" href="#casos-en-los-que-tienes-mas-informacion-que-el-compilador">Casos en los que tienes mas informacion que el compilador</a></h3>
<p>Tambi√©n ser√≠a apropiado llamar a <code>unwrap</code> o <code>expect</code> cuando tienes alguna otra
l√≥gica que garantiza que el <code>Result</code> tendr√° un valor <code>Ok</code>, pero la l√≥gica no
es algo que el compilador entiende. A√∫n tendr√°s un valor <code>Result</code> que debes
manejar: la operaci√≥n que est√°s llamando a√∫n tiene la posibilidad de fallar en
general, incluso si es l√≥gicamente imposible en tu situaci√≥n particular. Si
puedes asegurar inspeccionando manualmente el c√≥digo que nunca tendr√°s una
variante <code>Err</code>, es perfectamente aceptable llamar a <code>unwrap</code>, e incluso mejor
documentar la raz√≥n por la que crees que nunca tendr√°s una variante <code>Err</code> en el
texto de <code>expect</code>. Aqu√≠ hay un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;
        .parse()
        .expect(&quot;Hardcoded IP address should be valid&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Aqu√≠ estamos creando una instancia <code>IpAddr</code> analizando una cadena codificada.
Podemos ver que <code>127.0.0.1</code> es una direcci√≥n IP v√°lida, por lo que es aceptable
usar <code>expect</code> aqu√≠. Sin embargo, tener una cadena v√°lida codificada no cambia
el tipo de retorno del m√©todo <code>parse</code>: a√∫n obtenemos un valor <code>Result</code>, y el
compilador a√∫n nos har√° manejar el <code>Result</code> como si la variante <code>Err</code> fuera una
posibilidad porque el compilador no es lo suficientemente inteligente como
para ver que esta cadena es siempre una direcci√≥n IP v√°lida. Si la cadena de
direcci√≥n IP proviniera de un usuario en lugar de estar codificada en el
programa y, por lo tanto, <em>tuviera</em> una posibilidad de falla, definitivamente
querr√≠amos manejar el <code>Result</code> de una manera m√°s robusta en su lugar. Mencionar
la suposici√≥n de que esta direcci√≥n IP est√° codificada nos indicar√° que
cambiemos <code>expect</code> a un mejor c√≥digo de manejo de errores si en el futuro
necesitamos obtener la direcci√≥n IP de otra fuente.</p>
<h3 id="pautas-para-el-manejo-de-errores"><a class="header" href="#pautas-para-el-manejo-de-errores">Pautas para el manejo de errores</a></h3>
<p>Es aconsejable que tu c√≥digo entre en panic cuando sea posible que tu c√≥digo
termine en un estado incorrecto. En este contexto, un <em>estado incorrecto</em> es
cuando se ha roto alguna suposici√≥n, garant√≠a, contrato o invariante, como
cuando se pasan valores no v√°lidos, valores contradictorios o valores
faltantes a tu c√≥digo, m√°s uno o m√°s de los siguientes:</p>
<ul>
<li>El mal estado es algo inesperado, a diferencia de algo que probablemente
suceda ocasionalmente, como un usuario que ingresa datos en el formato
incorrecto.</li>
<li>Tu c√≥digo despu√©s de este punto debe confiar en no estar en este mal estado,
en lugar de verificar el problema en cada paso.</li>
<li>No hay una buena manera de codificar esta informaci√≥n en los tipos que
usas. Trabajaremos a trav√©s de un ejemplo de lo que queremos decir en la
secci√≥n <a href="ch17-03-oo-design-patterns.html#codificando-estados-y-comportamiento-como-tipos">‚ÄúCodificaci√≥n de estados y comportamientos como tipos‚Äù</a><!-- ignore --> del Cap√≠tulo 17.
</li>
</ul>
<p>Si alguien llama a tu c√≥digo y pasa valores que no tienen sentido, es mejor
devolver un error si puedes para que el usuario de la biblioteca pueda decidir
qu√© hacer en ese caso. Sin embargo, en los casos en que continuar podr√≠a ser
inseguro o da√±ino, la mejor opci√≥n podr√≠a ser llamar a <code>panic!</code> y alertar a la
persona que usa tu biblioteca sobre el error en su c√≥digo para que puedan
solucionarlo durante el desarrollo. De manera similar, <code>panic!</code> a menudo es
apropiado si est√°s llamando a un c√≥digo externo que est√° fuera de tu control y
devuelve un estado no v√°lido que no tienes forma de solucionar.</p>
<p>Sin embargo, cuando se espera que falle, es m√°s apropiado devolver un <code>Result</code>
que hacer una llamada a <code>panic!</code>. Los ejemplos incluyen un analizador que
recibe datos con formato incorrecto o una solicitud HTTP que devuelve un estado
que indica que has alcanzado un l√≠mite de velocidad. En estos casos, devolver
un <code>Result</code> indica que el fallo es una posibilidad esperada que el c√≥digo
llamado decidida c√≥mo manejarlo.</p>
<p>Cuando tu c√≥digo realiza una operaci√≥n que podr√≠a poner a un usuario en riesgo
si se llama con valores no v√°lidos, tu c√≥digo debe verificar primero que los
valores sean v√°lidos y entrar en panic si los valores no son v√°lidos. Esto es
principalmente por razones de seguridad: intentar operar con datos no v√°lidos
puede exponer tu c√≥digo a vulnerabilidades. Esta es la raz√≥n principal por la
que la biblioteca est√°ndar llamar√° a <code>panic!</code> si intentas un acceso a memoria
fuera de los l√≠mites: intentar acceder a la memoria que no pertenece a la
estructura de datos actual es un problema de seguridad com√∫n. Las funciones
suelen tener <em>contratos</em>: su comportamiento solo est√° garantizado si las
entradas cumplen con requisitos particulares. Entrar en panic cuando se viola
el contrato tiene sentido porque una violaci√≥n del contrato siempre indica un
error del lado del llamador y no es un tipo de error que deseas que el c√≥digo
llamado tenga que manejar expl√≠citamente. De hecho, no hay una manera
razonable para que el c√≥digo de llamada se recupere; los programadores que
llaman deben corregir el c√≥digo. Los contratos para una funci√≥n, especialmente
cuando una violaci√≥n causar√° un panic, deben explicarse en la documentaci√≥n
de la API de la funci√≥n.</p>
<p>Sin embargo, tener muchas comprobaciones de errores en todas tus funciones
ser√≠a verboso y molesto. Afortunadamente, puedes usar el sistema de tipos de
Rust (y, por lo tanto, la comprobaci√≥n de tipos realizada por el compilador)
para hacer muchas de las comprobaciones por ti. Si tu funci√≥n tiene un tipo
particular como par√°metro, puedes proceder con la l√≥gica de tu c√≥digo sabiendo
que el compilador ya se ha asegurado de que tengas un valor v√°lido. Por
ejemplo, si tienes un tipo en lugar de un <code>Option</code>, tu programa espera tener
<em>algo</em> en lugar de <em>nada</em>. Tu c√≥digo entonces no tiene que manejar dos casos
para las variantes <code>Some</code> y <code>None</code>: solo tendr√° un caso para tener
definitivamente un valor. El c√≥digo que intenta pasar nada a tu funci√≥n ni
siquiera se compilar√°, por lo que tu funci√≥n no tiene que verificar ese caso
en tiempo de ejecuci√≥n. Otro ejemplo es usar un tipo de entero sin signo como
<code>u32</code>, que garantiza que el par√°metro nunca sea negativo.</p>
<h3 id="creacion-de-tipos-personalizados-para-validacion"><a class="header" href="#creacion-de-tipos-personalizados-para-validacion">Creacion de tipos personalizados para validacion</a></h3>
<p>Tomemos la idea de usar el sistema de tipos de Rust para garantizar que
tengamos un valor v√°lido un paso m√°s all√° y veamos c√≥mo crear un tipo
personalizado para validaci√≥n. Recuerda el juego de adivinanzas en el Cap√≠tulo
2 en el que nuestro c√≥digo le pidi√≥ al usuario que adivinara un n√∫mero entre 1
y 100. Nunca validamos que la suposici√≥n del usuario estuviera entre esos
n√∫meros antes de verificarla con nuestro n√∫mero secreto; solo validamos que la
suposici√≥n fuera positiva. En este caso, las consecuencias no fueron muy
graves: nuestra salida de ‚ÄúDemasiado alto‚Äù o ‚ÄúDemasiado bajo‚Äù seguir√≠a siendo
correcta. Pero ser√≠a una mejora √∫til guiar al usuario hacia suposiciones
v√°lidas y tener un comportamiento diferente cuando un usuario adivina un
n√∫mero que est√° fuera del rango en comparaci√≥n con cuando un usuario escribe,
por ejemplo, letras en su lugar.</p>
<p>Una forma de hacer esto ser√≠a analizar la suposici√≥n como un <code>i32</code> en lugar de
solo un <code>u32</code> para permitir n√∫meros potencialmente negativos, y luego agregar
una verificaci√≥n de que el n√∫mero est√© en el rango, de esta manera:</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;The secret number will be between 1 and 100.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
<p>La expresi√≥n <code>if</code> verifica si nuestro valor est√° fuera del rango, le dice al
usuario sobre el problema y llama a <code>continue</code> para iniciar la siguiente
iteraci√≥n del ciclo y pedir otra suposici√≥n. Despu√©s de la expresi√≥n <code>if</code>,
podemos continuar con las comparaciones entre <code>guess</code> y el n√∫mero secreto
sabiendo que <code>guess</code> est√° entre 1 y 100.</p>
<p>Sin embargo, esta no es una soluci√≥n ideal: si fuera absolutamente cr√≠tico que
el programa solo operara en valores entre 1 y 100, y tuviera muchas funciones
con este requisito, tener una verificaci√≥n como esa en cada funci√≥n ser√≠a
tedioso (y podr√≠a afectar el rendimiento).</p>
<p>En su lugar, podemos crear un nuevo tipo y poner las verificaciones en una
funci√≥n para crear una instancia del tipo en lugar de repetir las
verificaciones en cada funci√≥n. De esa manera, es seguro que las funciones
utilicen el nuevo tipo en sus firmas y utilicen los valores que reciben con
confianza. El Listado 9-13 muestra una forma de definir un tipo <code>Guess</code> que
solo crear√° una instancia de <code>Guess</code> si la funci√≥n <code>new</code> recibe un valor entre
1 y 100.</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {value}.&quot;);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-13: Un tipo <code>Guess</code> que solo continuar√° con
valores entre 1 y 100</span></p>
<p>Primero, definimos un struct llamado <code>Guess</code> que tiene un campo llamado <code>value</code>
que contiene un <code>i32</code>. Aqu√≠ es donde se almacenar√° el n√∫mero.</p>
<p>Luego implementamos una funci√≥n asociada llamada <code>new</code> en <code>Guess</code> que crea
instancias de valores <code>Guess</code>. La funci√≥n <code>new</code> est√° definida para tener un
par√°metro llamado <code>value</code> de tipo <code>i32</code> y para devolver un <code>Guess</code>. El c√≥digo
en el cuerpo de la funci√≥n <code>new</code> prueba <code>value</code> para asegurarse de que est√©
entre 1 y 100. Si <code>value</code> no pasa esta prueba, hacemos una llamada <code>panic!</code>,
que alertar√° al programador que est√° escribiendo el c√≥digo de llamada que
tiene un error que debe corregir, porque crear un <code>Guess</code> con un <code>value</code> fuera
de este rango violar√≠a el contrato en el que <code>Guess::new</code> se basa. Las
condiciones en las que <code>Guess::new</code> podr√≠a entrar en p√°nico deben discutirse
en la documentaci√≥n de la API de cara al p√∫blico; cubriremos las convenciones
de documentaci√≥n que indican la posibilidad de un <code>panic!</code> en la documentaci√≥n
de la API que creas en el Cap√≠tulo 14. Si <code>value</code> pasa la prueba, creamos un
nuevo <code>Guess</code> con su campo <code>value</code> establecido en el <code>value</code> y devolvemos el
<code>Guess</code>.</p>
<p>A continuaci√≥n, implementamos un m√©todo llamado <code>value</code> que toma prestado
<code>self</code>, no tiene otros par√°metros y devuelve un <code>i32</code>. Este tipo de m√©todo se
llama a veces <em>getter</em>, porque su prop√≥sito es obtener algunos datos de sus
campos y devolverlos. Este m√©todo p√∫blico es necesario porque el campo <code>value</code>
del struct <code>Guess</code> es privado. Es importante que el campo <code>value</code> sea privado
para que el c√≥digo que usa el struct <code>Guess</code> no pueda establecer <code>value</code>
directamente: el c√≥digo fuera del m√≥dulo <em>debe</em> usar la funci√≥n <code>Guess::new</code>
para crear una instancia de <code>Guess</code>, lo que garantiza que no hay forma de que
un <code>Guess</code> tenga un <code>value</code> que no haya sido verificado por las condiciones en
la funci√≥n <code>Guess::new</code>.</p>
<p>Una funci√≥n que tiene un par√°metro o devuelve solo n√∫meros entre 1 y 100 podr√≠a
entonces declarar en su firma que toma o devuelve un <code>Guess</code> en lugar de un
<code>i32</code> y no necesitar√≠a hacer ninguna verificaci√≥n adicional en su cuerpo.</p>
<h2 id="resumen-8"><a class="header" href="#resumen-8">Resumen</a></h2>
<p>Las caracter√≠sticas de manejo de errores de Rust est√°n dise√±adas para ayudarte
a escribir un c√≥digo m√°s robusto. La macro <code>panic!</code> indica que tu programa
est√° en un estado que no puede manejar y te permite indicarle al proceso que
se detenga en lugar de intentar continuar con valores no v√°lidos o incorrectos.
El enum <code>Result</code> usa el sistema de tipos de Rust para indicar que las
operaciones pueden fallar de una manera que tu c√≥digo podr√≠a recuperar. Puedes
usar <code>Result</code> para decirle al c√≥digo que llama a tu c√≥digo que necesita manejar
el √©xito o el error de manera potencial. Usar <code>panic!</code> y <code>Result</code> en las
situaciones apropiadas har√° que tu c√≥digo sea m√°s confiable ante los problemas
inevitables.</p>
<p>Ahora que has visto formas √∫tiles en que la biblioteca est√°ndar usa generics
con los enums <code>Option</code> y <code>Result</code>, hablaremos sobre c√≥mo funcionan los
generics y c√≥mo puedes usarlos en tu c√≥digo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-gen√©ricos-traits-y-lifetimes"><a class="header" href="#tipos-gen√©ricos-traits-y-lifetimes">Tipos Gen√©ricos, Traits y Lifetimes</a></h1>
<p>Cada lenguaje de programaci√≥n tiene herramientas para manejar eficazmente la
duplicaci√≥n de conceptos. En Rust, una de esas herramientas son los <em>gen√©ricos</em>:
sustitutos abstractos de tipos concretos u otras propiedades. Podemos expresar
el comportamiento de los gen√©ricos o c√≥mo se relacionan con otros gen√©ricos sin
saber qu√© estar√° en su lugar cuando se compile y ejecute el c√≥digo.</p>
<p>Las funciones pueden tomar par√°metros de alg√∫n tipo gen√©rico, en lugar de un
tipo concreto como <code>i32</code> o <code>String</code>, de la misma manera que una funci√≥n toma
par√°metros con valores desconocidos para ejecutar el mismo c√≥digo en m√∫ltiples
valores concretos. De hecho, ya hemos usado gen√©ricos en el Cap√≠tulo 6 con
<code>Option&lt;T&gt;</code>, Cap√≠tulo 8 con <code>Vec&lt;T&gt;</code> y <code>HashMap&lt;K, V&gt;</code>, y Cap√≠tulo 9 con
<code>Result&lt;T, E&gt;</code>. ¬°En este cap√≠tulo, explorar√° c√≥mo definir sus propios tipos,
funciones y m√©todos con gen√©ricos!</p>
<p>Primero, revisaremos c√≥mo extraer una funci√≥n para reducir la duplicaci√≥n de
c√≥digo. Luego usaremos la misma t√©cnica para hacer una funci√≥n gen√©rico a
partir de dos funciones que difieren solo en los tipos de sus par√°metros.
Tambi√©n explicaremos c√≥mo usar tipos gen√©ricos en definiciones de structs y
enums.</p>
<p>Entonces aprender√°s c√≥mo usar <em>traits</em> para definir el comportamiento de una
manera gen√©rica. Puedes combinar traits con tipos gen√©ricos para restringir un
tipo gen√©rico para que acepte solo aquellos tipos que tienen un comportamiento
particular, en lugar de cualquier tipo.</p>
<p>Finalmente, discutiremos <em>lifetimes</em>: una variedad de gen√©ricos que le dan al
compilador informaci√≥n sobre c√≥mo se relacionan las referencias entre s√≠.
Lifetimes nos permiten darle al compilador suficiente informaci√≥n sobre los
valores prestados para que pueda garantizar que las referencias ser√°n v√°lidas
en m√°s situaciones de las que podr√≠a sin nuestra ayuda.</p>
<h2 id="eliminando-la-duplicaci√≥n-extrayendo-una-funci√≥n"><a class="header" href="#eliminando-la-duplicaci√≥n-extrayendo-una-funci√≥n">Eliminando la duplicaci√≥n extrayendo una funci√≥n</a></h2>
<p>Los gen√©ricos nos permiten reemplazar tipos espec√≠ficos con un marcador de
posici√≥n que representa m√∫ltiples tipos para eliminar la duplicaci√≥n de c√≥digo.
Antes de sumergirnos en la sintaxis de los gen√©ricos, veamos primero c√≥mo
eliminar la duplicaci√≥n de c√≥digo de una manera que no involucre tipos
gen√©ricos extrayendo una funci√≥n que reemplace valores espec√≠ficos con un
marcador de posici√≥n que represente m√∫ltiples valores. ¬°Luego aplicaremos la
misma t√©cnica para extraer una funci√≥n gen√©rica! Al observar c√≥mo reconocer el
c√≥digo duplicado que puede usar en una funci√≥n, comenzar√° a reconocer el
c√≥digo duplicado que puede usar en los gen√©ricos.</p>
<p>Comenzamos con un corto programa en el listado 10-1 que encuentra el n√∫mero
m√°s grande en una lista.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {largest}&quot;);
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre></pre>
<p><span class="caption">Listado 10-1: Encontrando el mayor n√∫mero en una lista de
n√∫meros</span></p>
<p>Almacenamos una lista de enteros en la variable <code>number_list</code> y colocamos una
referencia al primer n√∫mero de la lista en una variable llamada <code>largest</code>.
Luego iteramos a trav√©s de todos los n√∫meros de la lista, y si el n√∫mero
actual es mayor que el n√∫mero almacenado en <code>largest</code>, reemplazamos la
referencia en esa variable. Sin embargo, si el n√∫mero actual es menor o igual
al n√∫mero m√°s grande visto hasta ahora, la variable no cambia, y el c√≥digo
pasa al siguiente n√∫mero de la lista. Despu√©s de considerar todos los n√∫meros
de la lista, <code>largest</code> deber√≠a hacer referencia al n√∫mero m√°s grande, que en
este caso es 100.</p>
<p>Ahora se nos ha encargado encontrar el n√∫mero m√°s grande en dos listas de
n√∫meros. Para hacerlo, podemos duplicar el c√≥digo en el listado 10-1 y usar la
misma l√≥gica en dos lugares diferentes en el programa, como se muestra en el
listado 10-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {largest}&quot;);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {largest}&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 10-2: C√≥digo para encontrar el mayor n√∫mero en
<em>dos</em> listas de n√∫meros</span></p>
<p>Aunque este c√≥digo funciona, duplicar el c√≥digo es tedioso y propenso a errores.
Tambi√©n tenemos que recordar actualizar el c√≥digo en varios lugares cuando
queremos cambiarlo.</p>
<p>Para eliminar esta duplicaci√≥n, crearemos una abstracci√≥n definiendo una
funci√≥n que opera en cualquier lista de enteros que se pase en un par√°metro.
Esta soluci√≥n hace que nuestro c√≥digo sea m√°s claro y nos permite expresar el
concepto de encontrar el n√∫mero m√°s grande en una lista de forma abstracta.</p>
<p>En el listado 10-3, extraemos el c√≥digo que encuentra el mayor n√∫mero en una
funci√≥n llamada <code>largest</code>. Luego llamamos a la funci√≥n para encontrar el mayor
n√∫mero en las dos listas del listado 10-2. Tambi√©n podr√≠amos usar la funci√≥n
en cualquier otra lista de valores <code>i32</code> que podr√≠amos tener en el futuro.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {result}&quot;);
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {result}&quot;);
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre></pre>
<p><span class="caption">Listado 10-3: C√≥digo abstracto para encontrar el n√∫mero
mayor en dos listas</span></p>
<p>La funci√≥n <code>largest</code> tiene un par√°metro llamado <code>list</code>, que representa cualquier
slice de valores <code>√¨32</code> que podr√≠amos pasar a la funci√≥n. Como resultado, cuando
llamamos a la funci√≥n, el c√≥digo se ejecuta en los valores espec√≠ficos que
pasamos.</p>
<p>En resumen, estos son los pasos que tomamos para cambiar el c√≥digo del listado
10-2 al listado 10-3:</p>
<ol>
<li>Identificar c√≥digo duplicado.</li>
<li>Extraer el c√≥digo duplicado en el cuerpo de la funci√≥n y especificar las
entradas y salidas de ese c√≥digo en la firma de la funci√≥n.</li>
<li>Actualizar las dos instancias de c√≥digo duplicado para llamar a la funci√≥n
en su lugar.</li>
</ol>
<p>A continuaci√≥n, usaremos estos mismos pasos con los gen√©ricos para reducir la
duplicaci√≥n de c√≥digo. De la misma manera que el cuerpo de la funci√≥n puede
operar en una <code>list</code> abstracta en lugar de valores espec√≠ficos, los gen√©ricos
permiten que el c√≥digo opere en tipos abstractos.</p>
<p>Por ejemplo, digamos que ten√≠amos dos funciones: una que encuentra el mayor
elemento en un slices de valores <code>i32</code> y otra que encuentra el mayor elemento
en un slice de valores <code>char</code>. ¬øC√≥mo eliminar√≠amos esa duplicaci√≥n?
¬°Averig√º√©moslo!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-de-datos-gen√©ricos"><a class="header" href="#tipos-de-datos-gen√©ricos">Tipos de Datos Gen√©ricos</a></h2>
<p>Utilizamos gen√©ricos para crear definiciones para elementos como firmas de
funciones o structs, que luego podemos usar con muchos tipos de datos
concretos diferentes. Primero veamos c√≥mo definir funciones, structs,
enums y m√©todos usando gen√©ricos. Luego discutiremos c√≥mo los gen√©ricos
afectan el rendimiento del c√≥digo.</p>
<h3 id="definiciones-in-function"><a class="header" href="#definiciones-in-function">Definiciones in function</a></h3>
<p>Al definir una funci√≥n que usa gen√©ricos, colocamos los gen√©ricos en la firma de
la funci√≥n donde normalmente especificar√≠amos los tipos de datos de los
par√°metros y el valor de retorno. Hacerlo hace que nuestro c√≥digo sea m√°s
flexible y brinda m√°s funcionalidad a los llamadores de nuestra funci√≥n al
tiempo que evita la duplicaci√≥n de c√≥digo.</p>
<p>Continuando con nuestra funci√≥n <code>largest</code>, el listado 10-4 muestra dos
funciones que encuentran el valor m√°s grande en un slice. Luego
combinaremos estos en una sola funci√≥n que usa gen√©ricos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {result}&quot;);
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {result}&quot;);
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
<p><span class="caption">Listado 10-4: Dos funciones que difieren solo en sus
nombres y los tipos en sus firmas</span></p>
<p>La funci√≥n <code>largest_i32</code> es la que extrajimos en el listado 10-3 que encuentra
el <code>i32</code> m√°s grande en un slice. La funci√≥n <code>largest_char</code> encuentra el
<code>char</code> m√°s grande en un slice. Los cuerpos de las funciones tienen el mismo
c√≥digo, as√≠ que eliminemos la duplicaci√≥n introduciendo un par√°metro de tipo
generic en una sola funci√≥n.</p>
<p>Para parametrizar los tipos en una nueva funci√≥n √∫nica, necesitamos nombrar el
par√°metro de tipo, tal como lo hacemos para los par√°metros de valor de una
funci√≥n. Pero usaremos <code>T</code> porque, por convenci√≥n, los nombres de los
par√°metros de tipo en Rust son cortos, a menudo solo una letra, y la
convenci√≥n de nomenclatura de tipo de Rust es UpperCamelCase. Abreviatura de
&quot;tipo&quot;, <code>T</code> es la opci√≥n predeterminada de la mayor√≠a de los programadores de
Rust.</p>
<p>Cuando usamos un par√°metro en el cuerpo de la funci√≥n, tenemos que declarar el
nombre del par√°metro en la firma para que el compilador sepa qu√© significa ese
nombre. De manera similar, cuando usamos un nombre de par√°metro de tipo en la
firma de una funci√≥n, tenemos que declarar el nombre del par√°metro de tipo
antes de usarlo. Para definir la funci√≥n gen√©rico <code>largest</code>, coloque las
declaraciones de nombre de tipo dentro de corchetes angulares, <code>&lt;&gt;</code>, entre el
nombre de la funci√≥n y la lista de par√°metros, as√≠:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>Leemos esta definici√≥n como: la funci√≥n <code>largest</code> es gen√©rico sobre alg√∫n tipo
<code>T</code>. Esta funci√≥n tiene un par√°metro llamado <code>list</code>, que es un slice de valores
de tipo <code>T</code>. La funci√≥n <code>largest</code> devolver√° una referencia a un valor del mismo
tipo <code>T</code>.</p>
<p>El listado 10-5 muestra la definici√≥n de la funci√≥n <code>largest</code> combinada usando
el tipo de datos gen√©rico en su firma. La lista tambi√©n muestra c√≥mo podemos
llamar a la funci√≥n con un slice de valores <code>i32</code> o valores <code>char</code>. Tenga en
cuenta que este c√≥digo a√∫n no se compilar√°, pero lo arreglaremos m√°s adelante
en este cap√≠tulo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {result}&quot;);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {result}&quot;);
}</code></pre>
<p><span class="caption">Listing 10-5: La funci√≥n <code>largest</code> est√° usando par√°metros
de tipo gen√©rico; esto a√∫n no se compila</span></p>
<p>Si compilamos este c√≥digo ahora, obtendremos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>El texto de ayuda menciona <code>std::cmp::PartialOrd</code>, que es un <em>trait</em>, y vamos a
hablar de traits en la siguiente secci√≥n. Por ahora, sepa que este error
indica que el cuerpo de <code>largest</code> no funcionar√° para todos los tipos posibles
que podr√≠a ser <code>T</code>. Debido a que queremos comparar valores de tipo <code>T</code> en el
cuerpo, solo podemos usar tipos cuyos valores se pueden ordenar. Para habilitar
las comparaciones, la biblioteca est√°ndar tiene el trait <code>std::cmp::PartialOrd</code>
que puede implementar en tipos (consulte el Ap√©ndice C para obtener m√°s
informaci√≥n sobre este trait). Siguiendo la sugerencia del texto de ayuda,
restringimos los tipos v√°lidos para <code>T</code> solo a aquellos que implementan
<code>PartialOrd</code> y este ejemplo se compilar√°, porque la biblioteca est√°ndar
implementa <code>PartialOrd</code> tanto en <code>i32</code> como en <code>char</code>.</p>
<h3 id="definiciones-in-struct"><a class="header" href="#definiciones-in-struct">Definiciones In Struct</a></h3>
<p>Tambi√©n podemos definir structs para usar tipos gen√©ricos en uno o m√°s campos
usando la sintaxis <code>&lt;&gt;</code>. El listado 10-6 define un struct <code>Point&lt;T&gt;</code> para
contener valores <code>x</code> e <code>y</code> de cualquier tipo <code>T</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Listing 10-6: Un struct <code>Point&lt;T&gt;</code> que contiene valores
<code>x</code> and <code>y</code> de tipo <code>T</code></span></p>
<p>La sintaxis para usar gen√©ricos en las definiciones de structs es similar a la
que se usa en las definiciones de funciones. Primero, declaramos el nombre del
par√°metro de tipo dentro de corchetes angulares, justo despu√©s del nombre del
struct. Luego, usamos el tipo gen√©rico en la definici√≥n del struct donde
especificar√≠amos tipos de datos concretos.</p>
<p>Ten en cuenta que porque hemos usado un solo tipo gen√©rico para definir
<code>Point&lt;T&gt;</code>, esta definici√≥n dice que el struct <code>Point&lt;T&gt;</code> es gen√©rico sobre alg√∫n
tipo <code>T</code>, y los campos <code>x</code> e <code>y</code> son <em>ambos</em> ese mismo tipo, sea cual sea ese
tipo. Si creamos una instancia de un <code>Point&lt;T&gt;</code> que tenga valores de diferentes
tipos, como en el listado 10-7, nuestro c√≥digo no se compilar√°.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
<p><span class="caption">Listing 10-7: Los campos <code>x</code> e <code>y</code> deben ser del mismo
tipo porque ambos tienen el mismo tipo de dato gen√©rico <code>T</code>.</span></p>
<p>En este ejemplo, cuando asignamos el valor entero 5 a <code>x</code>, le decimos al
compilador que el tipo gen√©rico <code>T</code> ser√° un entero para esta instancia de
<code>Point&lt;T&gt;</code>. Luego, cuando especificamos 4.0 para <code>y</code>, que hemos definido para
tener el mismo tipo que <code>x</code>, obtendremos un error de tipo incompatible como
este:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>Para definir un struct <code>Point</code> donde <code>x</code> e <code>y</code> son ambos gen√©ricos pero podr√≠an
tener diferentes tipos, podemos usar m√∫ltiples par√°metros de tipo gen√©rico. Por
ejemplo, en el listado 10-8, cambiamos la definici√≥n de <code>Point</code> para que sea
generic sobre los tipos <code>T</code> y <code>U</code> donde <code>x</code> es de tipo <code>T</code> y <code>y</code> es de tipo
<code>U</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Listado 10-8: Un <code>Point&lt;T, U&gt;</code> gen√©rico sobre dos tipos
para que <code>x</code> e <code>y</code> puedan ser valores de tipos diferentes</span></p>
<p>¬°Ahora todas las instancias de <code>Point</code> que se muestran se permiten! Puede usar
tantos par√°metros de tipo gen√©rico en una definici√≥n como desee, pero usar m√°s
de unos pocos hace que su c√≥digo sea dif√≠cil de leer. Si encuentra que necesita
muchos tipos gen√©rico en su c√≥digo, podr√≠a indicar que su c√≥digo necesita
reestructurarse en piezas m√°s peque√±as.</p>
<h3 id="definiciones-in-enum"><a class="header" href="#definiciones-in-enum">Definiciones In Enum</a></h3>
<p>Como hicimos con structs, podemos definir enums para contener tipos gen√©rico en
sus variantes. Echemos otro vistazo al enum <code>Option&lt;T&gt;</code> que la biblioteca
est√°ndar proporciona, que usamos en el Cap√≠tulo 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>Esta definici√≥n deber√≠a tener m√°s sentido para ti ahora. Como puede ver, el
enum <code>Option&lt;T&gt;</code> es gen√©rico sobre el tipo <code>T</code> y tiene dos variantes: <code>Some</code>,
que contiene un valor de tipo <code>T</code>, y <code>None</code>, que no contiene ning√∫n valor.
Al usar el enum <code>Option&lt;T&gt;</code>, podemos expresar el concepto abstracto de un valor
opcional, y porque <code>Option&lt;T&gt;</code> es gen√©rico, podemos usar esta abstracci√≥n sin
importar el tipo del valor opcional.</p>
<p>Los enums tambi√©n pueden usar m√∫ltiples tipos gen√©rico. La definici√≥n del enum
<code>Result</code> que usamos en el Cap√≠tulo 9 es un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>El enum <code>Result</code> es un gen√©rico en dos tipos, <code>T</code> y <code>E</code>. Tiene dos variantes:
<code>Ok</code>, que contiene un valor de tipo <code>T</code>, y <code>Err</code>, que contiene un valor de tipo
<code>E</code>. Esta definici√≥n es apropiada porque el significado de <code>Result</code> es que uno
de estos dos tipos, <code>T</code> o <code>E</code>, ser√° el tipo del valor que se devuelve cuando se
produce un error o cuando se tiene √©xito (devolviendo un valor de tipo <code>T</code>) o
falla (devolviendo un valor de tipo <code>E</code>). De hecho, esta es la definici√≥n que
usamos para abrir un archivo en el listado 9-3, donde <code>T</code> se llen√≥ con el tipo
<code>std::fs::File</code> cuando el archivo se abri√≥ con √©xito y <code>E</code> se llen√≥ con el tipo
<code>std::io::Error</code> cuando hubo problemas para abrir el archivo.</p>
<p>Cuando reconoces situaciones en tu c√≥digo con m√∫ltiples definiciones de struct
o enum que difieren solo en los tipos de los valores que contienen, puedes
evitar la duplicaci√≥n usando tipos gen√©rico en su lugar.</p>
<h3 id="definiciones-in-method"><a class="header" href="#definiciones-in-method">Definiciones In Method</a></h3>
<p>Podemos implementar m√©todos en structs y enums y usar tipos gen√©rico en sus
definiciones tambi√©n. El listado 10-9 muestra el struct <code>Point&lt;T&gt;</code> que
definimos en el listado 10-6 con un m√©todo llamado <code>x</code> implementado en √©l.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}</code></pre></pre>
<p><span class="caption">Listado 10-9: Implementando un m√©todo llamado <code>x</code> en el
struct <code>Point&lt;T&gt;</code> que devolver√° una referencia al campo <code>x</code> de tipo <code>T</code></span></p>
<p>Aqu√≠, hemos definido un m√©todo llamado <code>x</code> en <code>Point&lt;T&gt;</code> que devuelve una
referencia a la data en el campo <code>x</code>.</p>
<p>Ten en cuenta que tenemos que declarar <code>T</code> justo despu√©s de <code>impl</code> para que
podamos usar <code>T</code> para especificar que estamos implementando m√©todos en el tipo
<code>Point&lt;T&gt;</code>. Al declarar <code>T</code> como un tipo gen√©rico despu√©s de <code>impl</code>, Rust puede
identificar que el tipo en los corchetes angulares en <code>Point</code> es un tipo
generic en lugar de un tipo concreto. Podr√≠amos haber elegido un nombre
diferente para este par√°metro gen√©rico que el par√°metro gen√©rico declarado en la
definici√≥n del struct, pero usar el mismo nombre es convencional. Los m√©todos
escritos dentro de un <code>impl</code> que declara el tipo gen√©rico se definir√°n en
cualquier instancia del tipo, sin importar qu√© tipo concreto termine
sustituyendo al tipo gen√©rico.</p>
<p>Tambi√©n podemos especificar restricciones en los tipos gen√©rico al definir
m√©todos en el tipo. Por ejemplo, podr√≠amos implementar m√©todos solo en
instancias de <code>Point&lt;T&gt;</code> con un tipo <code>f32</code> concreto en lugar de en instancias
de <code>Point&lt;T&gt;</code> con cualquier tipo gen√©rico. En el listado 10-10 usamos el tipo
concreto <code>f32</code>, lo que significa que no declaramos ning√∫n tipo despu√©s de
<code>impl</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 10-10: Un bloque <code>impl</code> que solo aplica a un
struct con un tipo concreto particular para el par√°metro del tipo gen√©rico
<code>T</code></span></p>
<p>Este c√≥digo significa que el tipo <code>Point&lt;f32&gt;</code> tendr√° un m√©todo
<code>distance_from_origin</code> definido en √©l, y otros tipos de <code>Point&lt;T&gt;</code> que no sean
de tipo <code>f32</code> no tendr√°n este m√©todo definido. El m√©todo mide qu√© tan lejos
est√° nuestro punto del punto en las coordenadas (0.0, 0.0) y usa operaciones
matem√°ticas que solo est√°n disponibles para tipos de punto flotante.</p>
<p>Los par√°metros de tipo gen√©rico en una definici√≥n de struct no siempre son los
mismos que los que usas en las firmas de m√©todos de ese mismo struct. El
listado 10-11 usa los tipos gen√©rico <code>X1</code> e <code>Y1</code> para el struct <code>Point</code> y <code>X2</code>
<code>Y2</code> para la firma del m√©todo <code>mixup</code> para hacer el ejemplo m√°s claro. El
m√©todo crea una nueva instancia de <code>Point</code> con el valor <code>x</code> del <code>self</code> <code>Point</code>
(de tipo <code>X1</code>) y el valor <code>y</code> del <code>Point</code> pasado (de tipo <code>Y2</code>).</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}</code></pre></pre>
<p><span class="caption">Listado 10-11: Un m√©todo que usa diferentes tipos gen√©rico
de la definici√≥n de su struct</span></p>
<p>En <code>main</code>, hemos definido un <code>Point</code> que tiene un <code>i32</code> para <code>x</code> (con valor <code>5</code>)
y un <code>f64</code> para <code>y</code> (con valor <code>10.4</code>). La variable <code>p2</code> es un <code>Point</code> struct
que tiene un string slice para <code>x</code> (con valor <code>&quot;Hello&quot;</code>) y un <code>char</code> para <code>y</code>
(con valor <code>c</code>). Llamar a <code>mixup</code> en <code>p1</code> con el argumento <code>p2</code> nos da <code>p3</code>,
que tendr√° un <code>i32</code> para <code>x</code>, porque <code>x</code> vino de <code>p1</code>. La variable <code>p3</code> tendr√°
un <code>char</code> para <code>y</code>, porque <code>y</code> vino de <code>p2</code>. La llamada al macro <code>println!</code>
imprimir√° <code>p3.x = 5, p3.y = c</code>.</p>
<p>El prop√≥sito de este ejemplo es demostrar una situaci√≥n en la que algunos
par√°metros gen√©rico se declaran con <code>impl</code> y otros se declaran con la definici√≥n
del m√©todo. Aqu√≠, los par√°metros gen√©rico <code>X1</code> e <code>Y1</code> se declaran despu√©s de
<code>impl</code> porque van con la definici√≥n del struct. Los par√°metros gen√©rico <code>X2</code> e
<code>Y2</code> se declaran despu√©s de <code>fn mixup</code>, porque solo son relevantes para el
m√©todo.</p>
<h3 id="rendimiento-de-codigo-usando-genericos"><a class="header" href="#rendimiento-de-codigo-usando-genericos">Rendimiento de codigo usando genericos</a></h3>
<p>Quiz√°s te est√©s preguntando si hay un costo de rendimiento al usar par√°metros
de tipo gen√©rico. La buena noticia es que usar tipos gen√©rico no har√° que tu
programa se ejecute m√°s lento de lo que lo har√≠a con tipos concretos.</p>
<p>Rust logra esto realizando <em>monomorfizaci√≥n</em> del c√≥digo usando gen√©ricos en
tiempo de compilaci√≥n. <em>Monomorfizaci√≥n</em> es el proceso de convertir c√≥digo
gen√©rico en c√≥digo espec√≠fico llenando los tipos concretos que se usan cuando
se compila. En este proceso, el compilador hace lo contrario de los pasos que
usamos para crear la funci√≥n gen√©rica en el listado 10-5: el compilador mira
todos los lugares donde se llama el c√≥digo gen√©rico y genera c√≥digo para los
tipos concretos con los que se llama el c√≥digo gen√©rico.</p>
<p>Veamos como funciona esto usando el enum gen√©rico de la biblioteca est√°ndar
<code>Option&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>Cuando Rust compila este c√≥digo, realiza monomorfizaci√≥n. Durante ese
proceso, el compilador lee los valores que se han usado en las instancias de
<code>Option&lt;T&gt;</code> e identifica dos tipos de <code>Option&lt;T&gt;</code>: uno es <code>i32</code> y el otro es
<code>f64</code>. Como tal, expande la definici√≥n gen√©rica de <code>Option&lt;T&gt;</code> en dos
definiciones especializadas a <code>i32</code> y <code>f64</code>, reemplazando as√≠ la definici√≥n
gen√©rica con las espec√≠ficas.</p>
<p>La versi√≥n monomorfizada del c√≥digo se ve similar al siguiente (el compilador
usa nombres diferentes a los que estamos usando aqu√≠ para ilustraci√≥n):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
<p>El gen√©rico <code>Option&lt;T&gt;</code> se reemplaza con las definiciones espec√≠ficas creadas por
el compilador. Debido a que Rust compila c√≥digo gen√©rico en c√≥digo que
especifica el tipo en cada instancia, no pagamos ning√∫n costo de rendimiento
por usar gen√©ricos. Cuando el c√≥digo se ejecuta, se comporta de la misma manera
que si hubi√©ramos duplicado cada definici√≥n a mano. El proceso de
monomorfizaci√≥n hace que los gen√©ricos de Rust sean extremadamente eficientes
en tiempo de ejecuci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="traits-definiendo-comportamiento-compartido"><a class="header" href="#traits-definiendo-comportamiento-compartido">Traits: Definiendo Comportamiento Compartido</a></h2>
<p>Un <em>trait</em> define funcionalidad que un tipo particular tiene y puede compartir
con otros tipos. Podemos usar traits para definir comportamiento compartido de
una manera abstracta. Podemos usar <em>trait bounds</em> para especificar que un tipo
gen√©rico puede ser cualquier tipo que tenga cierto comportamiento.</p>
<blockquote>
<p>Nota: Los traits son similares a una caracter√≠stica a menudo llamada
<em>interfaces</em> en otros lenguajes, aunque con algunas diferencias.
En espa√±ol tambi√©n se les conoce como <em>rasgos</em> pero en el libro intentaremos
mantener la palabra clave sin traducir, no obstante creamos esta
<a href="https://github.com/RustLangES/rust-book-es/discussions/29">encuesta</a> para futuras
revisiones.</p>
</blockquote>
<h3 id="definiendo-un-trait"><a class="header" href="#definiendo-un-trait">Definiendo un Trait</a></h3>
<p>El comportamiento de un tipo consiste en los m√©todos que podemos llamar en ese
tipo. Diferentes tipos comparten el mismo comportamiento si podemos llamar los
mismos m√©todos en todos esos tipos. Las definiciones de traits son una manera
de agrupar firmas de m√©todos para definir un conjunto de comportamientos
necesarios para lograr alg√∫n prop√≥sito.</p>
<p>Por ejemplo, digamos que tenemos m√∫ltiples structs que contienen varios tipos y
cantidades de texto: un struct <code>NewsArticle</code> que contiene una historia de
noticias archivada en una ubicaci√≥n particular y un <code>Tweet</code> que puede tener
como m√°ximo 280 caracteres junto con metadatos que indican si es un nuevo
tweet, un retweet, o una respuesta a otro tweet.</p>
<p>Queremos hacer una biblioteca de agregaci√≥n de medios llamada <code>aggregator</code> que
puede mostrar res√∫menes de datos que podr√≠an estar almacenados en una
instancia de <code>NewsArticle</code> o <code>Tweet</code>. Para hacer esto, necesitamos un resumen
de cada tipo, y solicitaremos ese resumen llamando un m√©todo <code>summarize</code> en
una instancia. El listado 10-12 muestra la definici√≥n de un trait <code>Summary</code>
p√∫blico que expresa este comportamiento.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
<p><span class="caption">Listado 10-12: Un trait <code>Summary</code> que consiste en el
comportamiento proporcionado por un m√©todo <code>summarize</code></span></p>
<p>Aqu√≠, declaramos un trait usando la palabra clave <code>trait</code> y luego el nombre
del trait, que en este caso es <code>Summary</code>. Tambi√©n hemos declarado el trait
como <code>pub</code> para que los crates que dependen de este crate puedan hacer uso de
este trait tambi√©n, como veremos en algunos ejemplos. Dentro de las llaves
curvas, declaramos las firmas de los m√©todos que describen los comportamientos
de los tipos que implementan este trait, que en este caso es <code>fn summarize (&amp;self) -&gt; String</code>.</p>
<p>Despu√©s de la firma del m√©todo, en lugar de proporcionar una implementaci√≥n
dentro de llaves curvas, usamos un punto y coma. Cada tipo que implementa este
trait debe proporcionar su propio comportamiento personalizado para el cuerpo
del m√©todo. El compilador har√° cumplir que cualquier tipo que tenga el trait
<code>Summary</code> tendr√° el m√©todo <code>summarize</code> definido con esta firma exactamente.</p>
<p>Un trait puede tener m√∫ltiples m√©todos en su cuerpo: las firmas de los m√©todos
se enumeran una por l√≠nea y cada l√≠nea termina en un punto y coma.</p>
<h3 id="implementando-un-trait-en-un-tipo"><a class="header" href="#implementando-un-trait-en-un-tipo">Implementando un Trait en un Tipo</a></h3>
<p>Ahora que hemos definido el trait <code>Summary</code>, podemos implementarlo en los
tipos en nuestro agregador de medios. El listado 10-13 muestra una
implementaci√≥n del trait <code>Summary</code> en el struct <code>NewsArticle</code> que usa el
encabezado, el autor y la ubicaci√≥n para crear el valor de retorno de
<code>summarize</code>. Para el struct <code>Tweet</code>, definimos <code>summarize</code> como el nombre de
usuario seguido del texto completo del tweet, asumiendo que el contenido del
tweet ya est√° limitado a 280 caracteres.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}</code></pre>
<p><span class="caption">Listado 10-13: Implementaci√≥n del trait <code>Summary</code> en los
tipos <code>NewsArticle</code> y <code>Tweet</code></span></p>
<p>Implementar un trait en un tipo es similar a implementar m√©todos regulares.
La diferencia es que despu√©s de <code>impl</code>, ponemos el nombre del trait que
queremos implementar, luego usamos la palabra clave <code>for</code>, y luego
especificamos el nombre del tipo que queremos implementar el trait. Dentro del
bloque <code>impl</code>, ponemos las firmas de los m√©todos que la definici√≥n del trait ha
definido. En lugar de agregar un punto y coma despu√©s de cada firma, usamos
llaves y llenamos el cuerpo del m√©todo con el comportamiento espec√≠fico que
queremos que los m√©todos del trait tengan para el tipo en particular.</p>
<p>Ahora que la biblioteca ha implementado el trait <code>Summary</code> en <code>NewsArticle</code> y
<code>Tweet</code>, los usuarios de la biblioteca pueden llamar a los m√©todos de trait
en las instancias de <code>NewsArticle</code> y <code>Tweet</code> en la misma forma en que llamamos
a los m√©todos regulares. La √∫nica diferencia es que el usuario debe traer el
trait al scope, as√≠ como los tipos. Aqu√≠ hay un ejemplo de c√≥mo un crate
binario podr√≠a usar nuestra biblioteca de <code>aggregator</code>:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}</code></pre>
<p>Este c√≥digo imprime <code>New article available! horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Otros crates que dependen de nuestro crate <code>aggregator</code> pueden usar el trait
<code>Summary</code> en el √°mbito para implementar <code>Summary</code> en sus propios tipos. Una
restricci√≥n a tener en cuenta es que podemos implementar un trait en un tipo
solo si al menos uno de los trait o el tipo es local a nuestro crate. Por
ejemplo, podemos implementar traits de la biblioteca est√°ndar como <code>Display</code>
en un tipo personalizado como <code>Tweet</code> como parte de nuestra funcionalidad de
crate <code>aggregator</code>, porque el tipo <code>Tweet</code> es local a nuestro crate
<code>aggregator</code>. Tambi√©n podemos implementar <code>Summary</code> en <code>Vec&lt;T&gt;</code> en nuestro
crate <code>aggregator</code>, porque el trait <code>Summary</code> es local a nuestro crate
<code>aggregator</code>.</p>
<p>Pero no podemos implementar traits externos en tipos externos. Por ejemplo,
digamos que queremos implementar <code>Display</code> en <code>Vec&lt;T&gt;</code> como parte de nuestra
funcionalidad de crate <code>aggregator</code>. Esto no es posible porque tanto <code>Display</code>
como <code>Vec&lt;T&gt;</code> est√°n definidos en la biblioteca est√°ndar y no son locales a
nuestro crate <code>aggregator</code>. La restricci√≥n de implementar un trait en un tipo
solo si uno de ellos es local a nuestro crate es parte de una propiedad
llamada <em>coherencia</em>, y m√°s espec√≠ficamente la <em>regla hu√©rfana</em>, as√≠ llamada
porque el tipo padre no est√° presente. Esta regla asegura que el c√≥digo de
otras personas no pueda romper su c√≥digo y viceversa. Sin la regla, dos crates
podr√≠an implementar el mismo trait para el mismo tipo, y Rust no sabr√≠a qu√©
implementaci√≥n usar.</p>
<h3 id="implementaciones-predeterminadas"><a class="header" href="#implementaciones-predeterminadas">Implementaciones predeterminadas</a></h3>
<p>A veces es √∫til tener un comportamiento predeterminado para algunos o todos
los m√©todos en un trait en lugar de requerir implementaciones para todos los
m√©todos en cada tipo. Luego, a medida que implementamos el trait en un tipo
particular, podemos mantener o anular el comportamiento predeterminado para
cada m√©todo.</p>
<p>En el listado 10-14, especificamos un string predeterminado para el m√©todo
<code>summarize</code> del trait <code>Summary</code> en lugar de solo definir la firma del m√©todo,
como hicimos en el listado 10-12.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 10-14: Definici√≥n de un trait <code>Summary</code> con un
valor predeterminado implementado del m√©todo <code>summarize</code></span></p>
<p>Para usar una implementaci√≥n predeterminada para resumir instancias de
<code>NewsArticle</code>, especificamos un bloque <code>impl</code> vac√≠o con <code>impl Summary for NewsArticle {}</code>.</p>
<p>Aunque ya no estamos definiendo el m√©todo <code>summarize</code> en <code>NewsArticle</code>
directamente, hemos proporcionado una implementaci√≥n predeterminada y
especificado que <code>NewsArticle</code> implementa el trait <code>Summary</code>. Como resultado,
todav√≠a podemos llamar al m√©todo <code>summarize</code> en una instancia de <code>NewsArticle</code>,
como esto:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}</span></code></pre>
<p>Este c√≥digo imprime <code>New article available! (Read more...)</code>.</p>
<p>Crear una implementaci√≥n predeterminada no requiere que cambiemos nada sobre
la implementaci√≥n de <code>Summary</code> en <code>Tweet</code> en el listado 10-13. La raz√≥n es que
la sintaxis para anular una implementaci√≥n predeterminada es la misma que la
sintaxis para implementar un m√©todo de trait que no tiene una implementaci√≥n
predeterminada.</p>
<p>Las implementaciones predeterminadas pueden llamar otros m√©todos en el mismo
trait, incluso si esos m√©todos no tienen una implementaci√≥n predeterminada.
De esta manera, un trait puede proporcionar una gran cantidad de
funcionalidad √∫til y solo requiere que los implementadores especifiquen una
peque√±a parte de ella. Por ejemplo, podr√≠amos definir el trait <code>Summary</code> para
tener un m√©todo <code>summarize_author</code> cuya implementaci√≥n es requerida, y luego
definir un m√©todo <code>summarize</code> que tenga una implementaci√≥n predeterminada que
llame al m√©todo <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Para usar esta version de <code>Summary</code>, solo necesitamos definir <code>summarize_author</code>
cuando implementamos el trait en un tipo:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}</code></pre>
<p>Despu√©s de definir <code>summarize_author</code>, podemos llamar a <code>summarize</code> en
instancias de la estructura <code>Tweet</code>, y la implementaci√≥n predeterminada de
<code>summarize</code> llamar√° a la definici√≥n de <code>summarize_author</code> que hemos
proporcionado. Debido a que hemos implementado <code>summarize_author</code>, el trait
<code>Summary</code> nos ha dado el comportamiento del m√©todo <code>summarize</code> sin requerirnos
escribir m√°s c√≥digo.</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}</span></code></pre>
<p>Este c√≥digo imprime <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Ten en cuenta que no es posible llamar a la implementaci√≥n predeterminada desde
una implementaci√≥n primordial de ese mismo m√©todo.</p>
<h3 id="traits-como-parametros"><a class="header" href="#traits-como-parametros">Traits como parametros</a></h3>
<p>Ahora que sabes c√≥mo definir y implementar traits, podemos explorar c√≥mo usar
traits para definir funciones que aceptan muchos tipos diferentes. Usaremos el
trait <code>Summary</code> que implementamos en los tipos <code>NewsArticle</code> y <code>Tweet</code> en el
listado 10-13 para definir una funci√≥n <code>notify</code> que llama al m√©todo <code>summarize</code>
en su par√°metro <code>item</code>, que es de alg√∫n tipo que implementa el trait <code>Summary</code>.
Para hacer esto, usamos la sintaxis <code>impl Trait</code>, como esto:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}</code></pre>
<p>En lugar de un tipo concreto para el par√°metro <code>item</code>, especificamos el
par√°metro <code>impl</code> y el nombre del trait. Cualquier tipo que implemente el trait
<code>Summary</code> puede ser pasado al par√°metro <code>item</code> en la funci√≥n <code>notify</code>. El
c√≥digo que llama a la funci√≥n <code>notify</code> con cualquier otro tipo, como un <code>String</code>
o un <code>i32</code>, no compilar√° porque esos tipos no implementan <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="sintaxis-de-trait-bound"><a class="header" href="#sintaxis-de-trait-bound">Sintaxis de trait bound</a></h4>
<p>La sintaxis <code>impl Trait</code> funciona para casos sencillos, pero en realidad es
az√∫car sint√°ctico para una forma m√°s larga conocida como <em>trait bound</em>; se ve
as√≠:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}</code></pre>
<p>Esta forma m√°s larga es equivalente al ejemplo en la secci√≥n anterior pero m√°s
detallado. Colocamos los l√≠mites de los traits con la declaraci√≥n del par√°metro
generic despu√©s de dos puntos y dentro de corchetes angulares.</p>
<p>La sintaxis <code>impl Trait</code> es conveniente y hace que el c√≥digo sea m√°s conciso en
casos simples, mientras que la sintaxis de trait bound m√°s completa puede
expresar m√°s complejidad en otros casos. Por ejemplo, podemos tener dos
par√°metros que implementan <code>Summary</code>. Hacerlo con la sintaxis <code>impl Trait</code> se
ve as√≠:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Usando <code>impl Trait</code> es apropiado si queremos que esta funci√≥n permita que
<code>item1</code> y <code>item2</code> tengan tipos diferentes (siempre que ambos tipos implementen
<code>Summary</code>). Sin embargo, si queremos forzar que ambos par√°metros tengan el
mismo tipo, debemos usar un trait bound, como esto:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>El tipo generic <code>T</code> especificado como el tipo de los par√°metros <code>item1</code> e
<code>item2</code> restringe la funci√≥n de tal manera que el tipo concreto del valor
pasado como argumento para <code>item1</code> e <code>item2</code> debe ser el mismo.</p>
<h4 id="especificando-m√∫ltiples-trait-bounds-con-la-sintaxis-"><a class="header" href="#especificando-m√∫ltiples-trait-bounds-con-la-sintaxis-">Especificando m√∫ltiples trait bounds con la sintaxis <code>+</code></a></h4>
<p>Tambi√©n podemos especificar m√°s de un trait bound. Digamos que queremos que
<code>notify</code> use la representaci√≥n de cadena de un tipo que implementa <code>Summary</code>
en el cuerpo de la funci√≥n. Para hacer esto, necesitamos que el par√°metro
<code>item</code> implemente tanto <code>Display</code> como <code>Summary</code>. Podemos hacerlo usando la
sintaxis <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>La sintaxis <code>+</code> tambi√©n es v√°lida con los trait bounds en tipos generics:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>Con los dos trait bounds especificados, el cuerpo de <code>notify</code> puede llamar a
<code>summarize</code> y usar <code>{}</code> para formatear <code>item</code>.</p>
<h4 id="trait-bounds-m√°s-claros-con-cl√°usulas-where"><a class="header" href="#trait-bounds-m√°s-claros-con-cl√°usulas-where">Trait bounds m√°s claros con cl√°usulas <code>where</code></a></h4>
<p>Usar demasiados trait bounds tiene sus inconvenientes. Cada generic tiene sus
propios trait bounds, por lo que las funciones con m√∫ltiples par√°metros de tipo
generic pueden contener mucha informaci√≥n de trait bound entre el nombre de la
funci√≥n y su lista de par√°metros, lo que hace que la firma de la funci√≥n sea
dif√≠cil de leer. Por esta raz√≥n, Rust tiene una sintaxis alternativa para
especificar los trait bounds dentro de una cl√°usula <code>where</code> despu√©s de la
firma de la funci√≥n. As√≠ que en lugar de escribir esto:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>podemos usar una cl√°usula <code>where</code>, como esta:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>La firma de esta funci√≥n est√° menos desordenada: el nombre de la funci√≥n, la
lista de par√°metros y el tipo de retorno est√°n muy juntos, similar a una funci√≥n
sin muchos trait bounds.</p>
<h3 id="devolviendo-tipos-que-implementan-traits"><a class="header" href="#devolviendo-tipos-que-implementan-traits">Devolviendo tipos que implementan traits</a></h3>
<p>Tambi√©n podemos usar la sintaxis <code>impl Trait</code> en el tipo de retorno de una
funci√≥n para devolver un valor de alg√∫n tipo que implementa un trait, como se
muestra aqu√≠:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}</code></pre>
<p>Al usar <code>impl Summary</code> para el tipo de retorno, especificamos que la funci√≥n
<code>returns_summarizable</code> devuelve alg√∫n tipo que implementa el trait <code>Summary</code>
sin nombrar el tipo concreto. En este caso, <code>returns_summarizable</code> devuelve un
<code>Tweet</code>, pero el c√≥digo que llama a esta funci√≥n no necesita saber eso.</p>
<p>La capacidad de especificar un tipo que es una implementaci√≥n de un trait
especialmente √∫til en el contexto de los closures y los iteradores, que
cubriremos en el Cap√≠tulo 13. Los closures y los iteradores crean tipos que
solo el compilador conoce o tipos que son muy largos de especificar. La sintaxis
<code>impl Trait</code> te permite especificar de manera concisa que una funci√≥n devuelve
alg√∫n tipo que implementa el trait <code>Iterator</code> sin necesidad de escribir un tipo
muy largo.</p>
<p>Sin embargo, no puedes usar <code>impl Trait</code> si la funci√≥n devuelve m√°s de un tipo.
Por ejemplo, este c√≥digo que devuelve un <code>NewsArticle</code> o un <code>Tweet</code> con el tipo
de retorno especificado como <code>impl Summary</code> no compilar√≠a:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p>Volviendo un <code>NewsArticle</code> o un <code>Tweet</code> no est√° permitido debido a las
restricciones en torno a c√≥mo se implementa la sintaxis <code>impl Trait</code> en el
compilador. Cubriremos c√≥mo escribir una funci√≥n con este comportamiento en la
secci√≥n <a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">‚ÄúUsando objetos trait que permiten valores de diferentes
tipos‚Äù</a><!--
ignore --> del Cap√≠tulo 17.</p>
<h3 id="usando-trait-bounds-para-implementar-m√©todos-condicionalmente"><a class="header" href="#usando-trait-bounds-para-implementar-m√©todos-condicionalmente">Usando trait bounds para implementar m√©todos condicionalmente</a></h3>
<p>Al usar un trait bound con un bloque <code>impl</code> que usa par√°metros de tipo generic,
podemos implementar m√©todos condicionalmente para tipos que implementan los
traits especificados. Por ejemplo, el tipo <code>Pair&lt;T&gt;</code> en el listado 10-15 siempre
implementa la funci√≥n <code>new</code> para devolver una nueva instancia de <code>Pair&lt;T&gt;</code>
(recuerda de la secci√≥n <a href="ch05-03-method-syntax.html#definiendo-metodos">‚ÄúDefiniendo m√©todos‚Äù</a><!-- ignore --> del
Cap√≠tulo 5 que <code>Self</code> es un alias de tipo para el tipo del bloque <code>impl</code>, que en
este caso es <code>Pair&lt;T&gt;</code>). Pero en el siguiente bloque <code>impl</code>, <code>Pair&lt;T&gt;</code> solo
implementa el m√©todo <code>cmp_display</code> si su tipo interno <code>T</code> implementa el trait
<code>PartialOrd</code> que permite la comparaci√≥n <em>y</em> el trait <code>Display</code> que permite la
impresi√≥n.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}</code></pre>
<p><span class="caption">Listado 10-15: Implementaci√≥n condicional de m√©todos en un
tipo generic dependiendo de los trait bounds</span></p>
<p>Tambi√©n podemos implementar condicionalmente un trait para cualquier tipo que
implemente otro trait. Implementaciones de un trait en cualquier tipo que
satisfaga los trait bounds se llaman <em>implementaciones blanket</em> y se usan
extensivamente en la biblioteca est√°ndar de Rust. Por ejemplo, la biblioteca
est√°ndar implementa el trait <code>ToString</code> en cualquier tipo que implemente el
trait <code>Display</code>. El bloque <code>impl</code> en la biblioteca est√°ndar se ve similar a este
c√≥digo:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>Debido a que la biblioteca est√°ndar tiene esta implementaci√≥n, podemos llamar al
m√©todo <code>to_string</code> definido por el trait <code>ToString</code> en cualquier tipo que
implemente el trait <code>Display</code>. Por ejemplo, podemos convertir enteros en sus
valores <code>String</code> correspondientes de esta manera porque los enteros implementan
<code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Las implementaciones generales aparecen en la documentaci√≥n del trait en la
secci√≥n ‚ÄúImplementors‚Äù.</p>
<p>Traits y trait bounds nos permiten usar gen√©ricos para reducir la duplicaci√≥n de
c√≥digo, pero tambi√©n para especificar a el compilador que queremos que un tipo
generic tenga un comportamiento particular. El compilador puede usar la
informaci√≥n de los trait bounds para verificar que todos los tipos concretos que
usamos con nuestro c√≥digo proporcionan el comportamiento correcto. En lenguajes
de tipado din√°mico, obtendr√≠amos un error en tiempo de ejecuci√≥n si llamamos a
un m√©todo en un tipo que no define el m√©todo. Pero Rust mueve estos errores al
tiempo de compilaci√≥n, por lo que estamos obligados a corregir los problemas
antes de que nuestro c√≥digo pueda ejecutarse. Adem√°s, no tenemos que escribir
c√≥digo que verifique el comportamiento en tiempo de ejecuci√≥n porque ya hemos
verificado en tiempo de compilaci√≥n. Hacerlo mejora el rendimiento sin tener que
renunciar a la flexibilidad de los generics.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="validando-referencias-con-lifetimes"><a class="header" href="#validando-referencias-con-lifetimes">Validando Referencias con Lifetimes</a></h2>
<p>Los <em>lifetimes</em> son otro tipo de gen√©ricos que ya hemos estado usando. En lugar
de asegurarnos de que un tipo tenga el comportamiento que queremos, los
lifetimes aseguran que las referencias sean v√°lidas el tiempo que las
necesitemos.</p>
<p>Un detalle que no discutimos en la secci√≥n <a href="ch04-02-references-and-borrowing.html#referencias-y-prestamos">‚ÄúReferencias y
Borrowing&quot;</a><!-- ignore --> en el Cap√≠tulo 4 es que
cada referencia en Rust tiene un <em>lifetime</em>, que es el scope para el que esa
referencia es v√°lida. La mayor√≠a de las veces, los lifetimes son impl√≠citos e
inferidos, al igual que la mayor√≠a de las veces, los tipos se infieren.
Solo debemos anotar los tipos cuando son posibles varios tipos. De manera
similar, debemos anotar los lifetimes cuando los lifetimes de las referencias
podr√≠an estar relacionados de algunas maneras diferentes. Rust nos obliga a
anotar las relaciones usando par√°metros gen√©ricos de lifetime para garantizar
que las referencias reales utilizadas en tiempo de ejecuci√≥n sean
definitivamente v√°lidas.</p>
<p>Anotar lifetimes no es ni siquiera un concepto que la mayor√≠a de los otros
lenguajes de programaci√≥n tengan, por lo que esto se sentir√° poco familiar.
Aunque no cubriremos los lifetimes en su totalidad en este cap√≠tulo,
discutiremos las formas comunes en que podr√≠a encontrar la sintaxis de los
lifetimes para que pueda familiarizarse con el concepto.</p>
<h3 id="previniendo-referencias-colgantes-con-lifetimes"><a class="header" href="#previniendo-referencias-colgantes-con-lifetimes">Previniendo Referencias Colgantes con Lifetimes</a></h3>
<p>El objetivo principal de los lifetimes es prevenir <em>referencias colgantes</em>,
que hacen que un programa haga referencia a datos que no son los que se
pretende referenciar. Considere el programa en el listado 10-16, que tiene un
scope externo y un scope interno.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {r}&quot;);
}</code></pre>
<p><span class="caption">Listado 10-16: Un intento de usar una referencia cuyo
valor ha quedado fuera del scope</span></p>
<blockquote>
<p>Nota: Los ejemplos en los Listados 10-16, 10-17 y 10-23 declaran variables
sin darles un valor inicial, por lo que el nombre de la variable existe en el
scope externo. A primera vista, esto podr√≠a parecer estar en conflicto con el
hecho de que Rust no tiene valores nulos. Sin embargo, si intentamos usar una
variable antes de darle un valor, obtendremos un error en tiempo de
compilaci√≥n, lo que muestra que Rust de hecho no permite valores nulos.</p>
</blockquote>
<p>El scope externo declara una variable llamada <code>r</code> sin valor inicial, y el scope
interno declara una variable llamada <code>x</code> con el valor inicial de 5. Dentro del
scope interno, intentamos establecer el valor de <code>r</code> como una referencia a <code>x</code>.
Luego, el scope interno termina, e intentamos imprimir el valor en <code>r</code>. Este
c√≥digo no se compilar√° porque el valor al que se refiere <code>r</code> ha quedado fuera
del scope antes de que intentemos usarlo. Aqu√≠ est√° el mensaje de error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!(&quot;r: {r}&quot;);
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>La variable <code>x</code> no ‚Äúvive lo suficiente‚Äù. La raz√≥n es que <code>x</code> estar√° fuera del
scope cuando el scope interno termine en la l√≠nea 7. Pero <code>r</code> todav√≠a es
v√°lido para el scope externo; porque su scope es m√°s grande, decimos que
‚Äúvive m√°s tiempo‚Äù. Si Rust permitiera que este c√≥digo funcionara, <code>r</code> estar√≠a
referenciando memoria que se desasign√≥ cuando <code>x</code> qued√≥ fuera del scope, y
cualquier cosa que intentemos hacer con <code>r</code> no funcionar√≠a correctamente. ¬øC√≥mo
determina Rust que este c√≥digo es inv√°lido? Utiliza el <em>borrow checker</em>.</p>
<h3 id="el-borrow-checker"><a class="header" href="#el-borrow-checker">El Borrow Checker</a></h3>
<p>El compilador de Rust tiene un <em>borrow checker</em> que compara scopes para
determinar si todos los <em>borrows</em> son v√°lidos. El listado 10-17 muestra el
mismo c√≥digo que el listado 10-16, pero con anotaciones que muestran los
lifetimes de las variables.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {r}&quot;);   //          |
}                         // ---------+</code></pre>
<p><span class="caption">Listado 10-17: Anotaciones de los lifetimes de <code>r</code> y
<code>x</code>, denominados <code>'a</code> y <code>'b</code>, respectivamente</span></p>
<p>Aqu√≠, hemos anotado el lifetime de <code>r</code> con <code>'a</code> y el lifetime de <code>x</code> con <code>'b</code>.
Como puede ver, el bloque interno <code>'b</code> es mucho m√°s peque√±o que el bloque
externo <code>'a</code>. En tiempo de compilaci√≥n, Rust compara el tama√±o de los dos
lifetimes y ve que <code>r</code> tiene un lifetime de <code>'a</code> pero que se refiere a la
memoria con un lifetime de <code>'b</code>. El programa es rechazado porque <code>'b</code> es m√°s
corto que <code>'a</code>: el sujeto de la referencia no vive tanto como la referencia.</p>
<p>El listado 10-18 corrige el c√≥digo para que no tenga una referencia pendiente y
se compile sin errores.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {r}&quot;);   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<p><span class="caption">Listado 10-18: Una referencia v√°lida porque los datos
tienen un lifetime m√°s largo que la referencia</span></p>
<p>Aqu√≠, <code>x</code> tiene el lifetime <code>'b</code> que en este caso es m√°s grande que <code>'a</code>. Esto
significa que <code>r</code> puede hacer referencia a <code>x</code> porque Rust sabe que la
referencia en <code>r</code> siempre ser√° v√°lida mientras <code>x</code> sea v√°lida.</p>
<p>Ahora que sabemos d√≥nde est√°n los lifetimes de las referencias y c√≥mo Rust
analiza los lifetimes para garantizar que las referencias siempre sean v√°lidas,
exploraremos los lifetimes gen√©ricos de los par√°metros y valores de retorno en
el contexto de las funciones.</p>
<h3 id="generic-lifetimes-en-funciones"><a class="header" href="#generic-lifetimes-en-funciones">Generic Lifetimes en Funciones</a></h3>
<p>Escribiremos una funci√≥n que devuelva el m√°s largo de dos <em>string slices</em>.
Esta funci√≥n tomar√° dos <em>string slices</em> y devolver√° un solo <em>string slice</em>.
Despu√©s de haber implementado la funci√≥n <code>longest</code>, el c√≥digo en el listado
10-19 deber√≠a imprimir <code>The longest string is abcd</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {result}&quot;);
}</code></pre>
<p><span class="caption">Listado 10-19: Una funci√≥n <code>main</code> que llama a la
funci√≥n <code>longest</code> para encontrar el m√°s largo de dos string slices</span></p>
<p>Ten en cuenta que queremos que la funci√≥n tome <em>string slices</em>, que son
referencias, en lugar de <em>strings</em>, porque no queremos que la funci√≥n <code>longest</code>
tome posesi√≥n de sus par√°metros. Consulta la secci√≥n <a href="ch04-03-slices.html#string-slices-as-parameters">‚ÄúString Slices as
Parameters‚Äù</a><!-- ignore --> en el Cap√≠tulo 4 para
obtener m√°s informaci√≥n sobre por qu√© los par√°metros que usamos en el listado
10-19 son los que queremos.</p>
<p>Si intentamos implementar la funci√≥n <code>longest</code> como se muestra en el listado
10-20, no se compilar√°.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
<p><span class="caption">Listado 10-20: Una implementaci√≥n de la funci√≥n <code>longest</code>
que devuelve el m√°s largo de dos string slices pero a√∫n no compila</span></p>
<p>En su lugar, obtenemos el siguiente error que habla sobre lifetimes:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

error: lifetime may not live long enough
  --&gt; src/main.rs:11:9
   |
9  | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |               - let's call the lifetime of this reference `'1`
10 |     if x.len() &gt; y.len() {
11 |         x
   |         ^ returning this value requires that `'1` must outlive `'static`

error: lifetime may not live long enough
  --&gt; src/main.rs:13:9
   |
9  | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |                        - let's call the lifetime of this reference `'2`
...
13 |         y
   |         ^ returning this value requires that `'2` must outlive `'static`

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 3 previous errors
</code></pre>
<p>El texto de ayuda revela que el tipo de retorno necesita un par√°metro de
lifetime generic en √©l porque Rust no puede decir si la referencia que se
devuelve se refiere a <code>x</code> o <code>y</code>. De hecho, nosotros tampoco lo sabemos, porque
el bloque <code>if</code> en el cuerpo de esta funci√≥n devuelve una referencia a <code>x</code> y el
bloque <code>else</code> devuelve una referencia a <code>y</code>!</p>
<p>Cuando estamos definiendo esta funci√≥n, no sabemos los valores concretos que
se pasar√°n a esta funci√≥n, por lo que no sabemos si se ejecutar√° el caso <code>if</code> o
el caso <code>else</code>. Tampoco conocemos los lifetimes concretos de las referencias
que se pasar√°n, por lo que no podemos mirar los scopes como lo hicimos en los
Listados 10-17 y 10-18 para determinar si la referencia que devolvemos siempre
ser√° v√°lida. El <em>borrow checker</em> tampoco puede determinar esto, porque no sabe
c√≥mo se relacionan los lifetimes de <code>x</code> e <code>y</code> con el lifetime del valor de
retorno. Para corregir este error, agregaremos par√°metros de lifetime generics
que definan la relaci√≥n entre las referencias para que el <em>borrow checker</em>
pueda realizar su an√°lisis.</p>
<h3 id="sintaxis-de-las-anotaciones-de-los-lifetimes"><a class="header" href="#sintaxis-de-las-anotaciones-de-los-lifetimes">Sintaxis de las anotaciones de los lifetimes</a></h3>
<p>Las anotaciones de los lifetimes no cambian cu√°nto tiempo viven las
referencias. En cambio, describen las relaciones de los lifetimes de m√∫ltiples
referencias entre s√≠ sin afectar los lifetimes. Al igual que las funciones
pueden aceptar cualquier tipo cuando la firma especifica un par√°metro de tipo
gen√©rico, las funciones pueden aceptar referencias con cualquier lifetime
especificando un par√°metro de lifetime generic.</p>
<p>Las anotaciones de los lifetimes tienen una sintaxis ligeramente inusual: los
nombres de los par√°metros de los lifetimes deben comenzar con un ap√≥strofe (<code>'</code>)
y generalmente son todos en min√∫sculas y muy cortos, como los tipos generics.
La mayor√≠a de la gente usa el nombre <code>'a</code> para la primera anotaci√≥n de
lifetime. Colocamos las anotaciones de los par√°metros de los lifetimes despu√©s
del <code>&amp;</code> de una referencia, usando un espacio para separar la anotaci√≥n del tipo
de referencia.</p>
<p>Estos son algunos ejemplos: una referencia a un <code>i32</code> sin un par√°metro de
lifetime, una referencia a un <code>i32</code> que tiene un par√°metro de lifetime llamado
<code>'a</code>, y una referencia mutable a un <code>i32</code> que tambi√©n tiene el lifetime <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>Una anotaci√≥n de lifetime en si misma no tiene mucho significado, porque las
anotaciones est√°n destinadas a decirle a Rust c√≥mo los par√°metros de lifetime
generics de m√∫ltiples referencias se relacionan entre s√≠. Examinemos c√≥mo las
anotaciones de los lifetimes se relacionan entre s√≠ en el contexto de la
funci√≥n <code>longest</code>.</p>
<h3 id="anotaciones-de-los-lifetimes-en-las-firmas-de-las-funciones"><a class="header" href="#anotaciones-de-los-lifetimes-en-las-firmas-de-las-funciones">Anotaciones de los Lifetimes en las Firmas de las Funciones</a></h3>
<p>Para usar anotaciones de los lifetimes en las firmas de las funciones, primero
necesitamos declarar los par√°metros de los lifetimes generic dentro de los
corchetes angulares entre el nombre de la funci√≥n y la lista de par√°metros,
como lo hicimos con los par√°metros de tipo generic.</p>
<p>Queremos que la firma exprese la siguiente restricci√≥n: la referencia devuelta
ser√° v√°lida siempre que ambos par√°metros sean v√°lidos. Esta es la relaci√≥n
entre los lifetimes de los par√°metros y el valor de retorno. Nombraremos al
lifetime <code>'a</code> y luego lo agregaremos a cada referencia, como se muestra en el
listado 10-21.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Listado 10-21: La definici√≥n de la funci√≥n <code>longest</code>
que especifica que todas las referencias en la firma deben tener el mismo
lifetime <code>'a</code></span></p>
<p>Este c√≥digo debe compilar y producir el resultado que queremos cuando lo
usamos con la funci√≥n <code>main</code> en el listado 10-19.</p>
<p>La firma de la funci√≥n ahora le dice a Rust que durante el lifetime <code>'a</code>, la
funci√≥n toma dos par√°metros, ambos los cuales son string slices que viven al
menos tanto como el lifetime <code>'a</code>. La firma de la funci√≥n tambi√©n le dice a
Rust que el string slice devuelto tambi√©n vivir√° al menos tanto como el
lifetime <code>'a</code>. En la pr√°ctica, significa que el lifetime de la referencia
devuelta por la funci√≥n <code>longest</code> es el mismo que el m√°s peque√±o de los
lifetimes de los valores a los que se refieren los argumentos de la funci√≥n.
Estas relaciones son lo que queremos que Rust use al analizar este c√≥digo.</p>
<p>Recuerda, cuando especificamos los par√°metros de los lifetimes en la firma de
esta funci√≥n, no estamos cambiando los lifetimes de ninguna de las referencias
que se pasan en o se devuelven. En cambio, estamos especificando que el
<em>borrow checker</em> deber√≠a rechazar cualquier valor que no cumpla con estas
restricciones. Ten en cuenta que la funci√≥n <code>longest</code> no necesita saber
exactamente cu√°nto tiempo vivir√°n <code>x</code> e <code>y</code>, solo que alg√∫n scope puede
sustituirse por <code>'a</code> que satisfar√° esta firma.</p>
<p>Cuando anotamos lifetimes en funciones, las anotaciones van en la firma de la
funci√≥n, no en el cuerpo de la funci√≥n. Las anotaciones de los lifetimes se
convierten en parte del contrato de la funci√≥n, al igual que los tipos en la
firma. Tener las firmas de las funciones que contienen el contrato de los
lifetimes significa que el an√°lisis que hace el compilador de Rust puede ser
m√°s simple. Si hay un problema con la forma en que se anot√≥ una funci√≥n o la
forma en que se llama, los errores del compilador pueden apuntar a la parte de
nuestro c√≥digo y las restricciones con m√°s precisi√≥n. Si, en cambio, el
compilador de Rust hiciera m√°s inferencias sobre lo que pretend√≠amos que
fueran las relaciones de los lifetimes, el compilador solo podr√≠a se√±alar el
uso de nuestro c√≥digo muchas etapas despu√©s de la causa del problema.</p>
<p>Cuando pasamos referencias concretas a <code>longest</code>, se sustituye un lifetime
concreto por <code>'a</code>. Este lifetime concreto corresponde a la parte del scope de <code>x</code>
que se superpone con el scope de y. En otras palabras, el lifetime
gen√©rico <code>'a</code> adquirir√° el lifetime concreto que sea menor entre los lifetimes de
<code>x</code> e <code>y</code>. Debido a que hemos anotado la referencia devuelta con el mismo par√°metro
de lifetime <code>'a</code>, la referencia devuelta tambi√©n ser√° v√°lida por la duraci√≥n del
lifetime m√°s corta entre <code>x</code> e <code>y</code>.</p>
<p>Veamos c√≥mo las anotaciones de los lifetimes restringen la funci√≥n <code>longest</code>
pasando referencias que tienen diferentes lifetimes concretos. El listado
10-22 es un ejemplo sencillo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {result}&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 10-22: Usando la funci√≥n <code>longest</code> con referencias
a valores <code>String</code> que tienen diferentes lifetimes concretos</span></p>
<p>En este ejemplo, <code>string1</code> es v√°lida hasta el final del scope externo, <code>string2</code>
es v√°lida hasta el final del scope interno, y <code>result</code> referencia algo que es
v√°lido hasta el final del scope interno. Ejecuta este c√≥digo, y ver√°s que el
<em>borrow checker</em> lo aprueba; se compilar√° e imprimir√° <code>The longest string is long string is long</code>.</p>
<p>A continuaci√≥n, intentemos un ejemplo que muestre que el lifetime de la
referencia en <code>result</code> debe ser el m√°s peque√±o de los dos argumentos.
Moveremos la declaraci√≥n de la variable <code>result</code> fuera del scope interno, pero
dejaremos la asignaci√≥n del valor a <code>result</code> dentro del scope interno. Luego
moveremos la llamada a <code>println!</code> que usa <code>result</code> fuera del scope interno,
despu√©s de que el scope interno haya terminado. El c√≥digo del listado 10-23 no
compilar√°.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {result}&quot;);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 10-23: Intentando utilizar <code>result</code> despu√©s de que
<code>string2</code> haya quedado fuera del scope</span></p>
<p>Cuando intentamos compilar este c√≥digo, obtenemos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from(&quot;xyz&quot;);
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {result}&quot;);
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>El error muestra que para que <code>result</code> sea v√°lido para la instrucci√≥n
<code>println!</code>, <code>string2</code> tendr√≠a que ser v√°lido hasta el final del scope externo.
Rust sabe esto porque anotamos los lifetimes de los par√°metros de la funci√≥n y
los valores de retorno usando el mismo par√°metro de lifetime <code>'a</code>.</p>
<p>Como humanos, podemos mirar este c√≥digo y ver que <code>string1</code> es m√°s larga que
<code>string2</code> y por lo tanto <code>result</code> contendr√° una referencia a <code>string1</code>. Debido a
que <code>string1</code> a√∫n no ha quedado fuera del scope, una referencia a <code>string1</code>
todav√≠a ser√° v√°lida para la instrucci√≥n <code>println!</code>. Sin embargo, el compilador
no puede ver que la referencia sea v√°lida en este caso. Le hemos dicho a Rust
que el lifetime de la referencia devuelta por la funci√≥n <code>longest</code> es el mismo
que el m√°s peque√±o de los lifetimes de las referencias pasadas. Por lo tanto,
el <em>borrow checker</em> rechaza el c√≥digo del listado 10-23 como posiblemente
conteniendo una referencia no v√°lida.</p>
<p>Intenta dise√±ar m√°s experimentos que var√≠en los valores y los lifetimes de las
referencias que se pasan a la funci√≥n <code>longest</code> y c√≥mo se usa la referencia
devuelta. Haz hip√≥tesis sobre si tus experimentos pasar√°n el <em>borrow checker</em>
antes de compilar; luego comprueba si tienes raz√≥n!</p>
<h3 id="pensando-en-t√©rminos-de-lifetimes"><a class="header" href="#pensando-en-t√©rminos-de-lifetimes">Pensando en t√©rminos de lifetimes</a></h3>
<p>La forma en que necesitas especificar los par√°metros de los lifetimes depende
de lo que tu funci√≥n est√© haciendo. Por ejemplo, si cambiamos la implementaci√≥n
de la funci√≥n <code>longest</code> para que siempre devuelva el primer par√°metro en lugar
de la referencia a la cadena m√°s larga, no necesitar√≠amos especificar un
lifetime en el par√°metro <code>y</code>. El siguiente c√≥digo compilar√°:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
<p>Hemos especificado un par√°metro de lifetime <code>'a</code> para el par√°metro <code>x</code> y el tipo
de retorno, pero no para el par√°metro <code>y</code> porque el lifetime de <code>y</code> no tiene
ninguna relaci√≥n con el lifetime de <code>x</code> o el valor de retorno.</p>
<p>Cuando se devuelve una referencia desde una funci√≥n, el par√°metro del lifetime
para el tipo de retorno debe coincidir con el par√°metro del lifetime de uno de
los par√°metros. Si la referencia devuelta no se refiere a uno de los par√°metros,
debe referirse a un valor creado dentro de esa funci√≥n. Sin embargo, esto ser√≠a
una referencia colgante porque el valor quedar√° fuera del scope al final de la
funci√≥n. Considera esta implementaci√≥n intentada de la funci√≥n <code>longest</code> que no
se compilar√°:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}</code></pre>
<p>Aqu√≠, aunque hemos especificado un par√°metro de lifetime <code>'a</code> para el tipo de
retorno, esta implementaci√≥n no se compilar√° porque el lifetime del valor
retornado no est√° relacionado en absoluto con el lifetime de los par√°metros.
Este es el mensaje de error que obtenemos:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin &quot;chapter10&quot;) due to 1 previous error
</code></pre>
<p>El problema es que <code>result</code> sale del scope y se limpia al final de la funci√≥n
<code>longest</code>. Tambi√©n estamos tratando de devolver una referencia a <code>result</code> desde
la funci√≥n. No hay forma de especificar par√°metros de lifetime que cambien la
referencia colgante, y Rust no nos permitir√° crear una referencia colgante. En
este caso, la mejor soluci√≥n ser√≠a devolver un tipo de dato propiedad en lugar
de una referencia para que la funci√≥n que llama sea responsable de limpiar el
valor.</p>
<p>En √∫ltima instancia, la sintaxis de lifetime se trata de conectar las duraciones
de vida de varios par√°metros y valores de retorno de funciones. Una vez que se
conectan, Rust tiene suficiente informaci√≥n para permitir operaciones seguras en
memoria y prohibir operaciones que puedan crear punteros colgantes o que de otro
modo violen la seguridad de la memoria.</p>
<h3 id="anotaciones-de-lifetime-en-definiciones-de-struct"><a class="header" href="#anotaciones-de-lifetime-en-definiciones-de-struct">Anotaciones de lifetime en definiciones de struct</a></h3>
<p>Hasta ahora, los structs que hemos definido contienen tipos de ownership.
Podemos definir structs que contengan referencias, pero en ese caso necesitamos
agregar una anotaci√≥n de lifetime en cada referencia en la definici√≥n del
struct. El listado 10-24 tiene un struct llamado <code>ImportantExcerpt</code> que contiene
una string slice.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<p><span class="caption">Listado 10-24: Un struct que contiene una referencia,
lo que requiere una annotation de lifetime</span></p>
<p>Este struct tiene el campo <code>part</code> que contiene un string slice, que es una
referencia. Como con los tipos de datos generics, declaramos el nombre del
par√°metro de lifetime gen√©rico dentro de corchetes angulares despu√©s del nombre
del struct para que podamos usar el par√°metro de lifetime en el cuerpo de la
definici√≥n del struct. Esta anotaci√≥n significa que una instancia de
<code>ImportantExcerpt</code> no puede sobrevivir m√°s all√° de la referencia que contiene
en su campo <code>part</code>.</p>
<p>La funci√≥n <code>main</code> aqu√≠ crea una instancia del struct <code>ImportantExcerpt</code> que
contiene una referencia a la primera oraci√≥n de la variable <code>novel</code>. La data en
<code>novel</code> existe antes de que se cree la instancia de <code>ImportantExcerpt</code>. Adem√°s,
<code>novel</code> no sale del scope hasta despu√©s de que la instancia de <code>ImportantExcerpt</code>
sale del scope, por lo que la referencia en la instancia de <code>ImportantExcerpt</code>
es v√°lida.</p>
<h3 id="omisi√≥n-de-lifetime"><a class="header" href="#omisi√≥n-de-lifetime">Omisi√≥n de lifetime</a></h3>
<p>Has aprendido que cada referencia tiene un lifetime y que debes especificar
par√°metros de lifetime para las funciones o structs que usan referencias. Sin
embargo, en el Cap√≠tulo 4, tuvimos una funci√≥n en el listado 4-9, que se muestra
nuevamente en el listado 10-25, que se compil√≥ sin anotaciones de lifetime.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listado 10-25: Una funci√≥n que definimos en el listado 4-9
que compil√≥ sin anotaciones de lifetime, a pesar de que el par√°metro y el tipo
de retorno son referencias</span></p>
<p>La raz√≥n por la que esta funci√≥n se compila sin anotaciones de lifetime es
hist√≥rica: en las primeras versiones (pre-1.0) de Rust, este c√≥digo no se
compilar√≠a porque cada referencia necesitaba un lifetime expl√≠cito. En ese
momento, la firma de la funci√≥n se habr√≠a escrito as√≠:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Despu√©s de escribir mucho c√≥digo en Rust, el equipo de Rust descubri√≥ que los
programadores de Rust estaban ingresando las mismas anotaciones de lifetime una
y otra vez en situaciones particulares. Estas situaciones eran predecibles y
segu√≠an algunos patrones deterministas. Los desarrolladores programaron estos
patrones en el c√≥digo del compilador para que el borrow checker pudiera inferir
los lifetimes en estas situaciones y no necesitara anotaciones expl√≠citas.</p>
<p>Este fragmento de la historia de Rust es relevante porque es posible que
aparezcan patrones m√°s deterministas y se agreguen al compilador. En el futuro,
se pueden requerir a√∫n menos anotaciones de lifetime.</p>
<p>Los patrones programados en el an√°lisis de referencias de Rust se llaman <em>reglas
de omisi√≥n de lifetime</em>. Estas no son reglas que los programadores deben<br />
seguir; son un conjunto de casos particulares que el compilador considerar√°, y
si su c√≥digo se ajusta a estos casos, no es necesario que escriba los lifetimes
expl√≠citamente.</p>
<p>Las reglas de omisi√≥n no proporcionan inferencia completa. Si Rust aplica
determin√≠sticamente las reglas pero todav√≠a hay ambig√ºedad sobre qu√© lifetimes
tienen las referencias, el compilador no adivinar√° qu√© lifetime deber√≠an tener
las referencias restantes. En lugar de adivinar, el compilador le dar√° un error
que puede resolver agregando las anotaciones de lifetime.</p>
<p>Los lifetime en los par√°metros de una funci√≥n o m√©todo se llaman lifetime de
entrada y los lifetime en los valores de retorno se llaman <em>output lifetimes</em>.</p>
<p>El compilador usa tres reglas para determinar los lifetime de las referencias
cuando no hay anotaciones expl√≠citas. La primera regla se aplica a los lifetime
de entrada, y la segunda y tercera regla se aplican a los <em>output lifetimes</em>. Si
el compilador llega al final de las tres reglas y a√∫n hay referencias para las
que no puede determinar los lifetime, el compilador mostrar√° un error. Estas
reglas se aplican tanto a las definiciones de <code>fn</code> como a los bloques <code>impl</code>.</p>
<p>La primera regla es que el compilador asigna un par√°metro de lifetime a cada
par√°metro que sea una referencia. En otras palabras, una funci√≥n con un
par√°metro obtiene un par√°metro de lifetime: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; una
funci√≥n con dos par√°metros obtiene dos par√°metros de lifetime separados: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; y as√≠ sucesivamente.</p>
<p>La segunda regla es que, si hay un par√°metro de input de lifetime, ese lifetime
se asigna a todos los par√°metros de output de lifetime:<code>fn foo&lt;'a&gt;(x: &amp;'a i32)  -&gt; &amp;'a i32</code>.</p>
<p>La tercera regla es que si hay m√∫ltiples par√°metros de input de lifetime, pero
uno de ellos es <code>&amp;self</code> o <code>&amp;mut self</code> porque este es un m√©todo, el lifetime de
<code>self</code> se asigna a todos los par√°metros de output de lifetime. Esto hace que los
m√©todos sean mucho m√°s agradables de leer y escribir porque se necesitan menos
s√≠mbolos.</p>
<p>Imaginemos que somos el compilador. Aplicaremos estas reglas para descubrir los
lifetime de las referencias en la firma de la funci√≥n <code>first_word</code> en el
listado 10-25. La firma comienza sin ning√∫n lifetime asociado con las
referencias:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Luego el compilador aplica la primera regla, que especifica que cada par√°metro
tiene su propio lifetime. Como de costumbre, llamaremos a este lifetime <code>'a</code>,
por lo que ahora la firma es la siguiente:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>La segunda regla aplica porque hay exactamente un par√°metro de input con
lifetime. Este segundo conjunto establece que el lifetime del √∫nico par√°metro de
input se asigna a todos los par√°metros de output, por lo que la firma de la
funci√≥n se convierte en la siguiente:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Ahora todas las referencias en esta firma de funci√≥n tienen lifetime, y el
compilador puede continuar su an√°lisis sin necesidad de que el programador
anote los lifetime en esta firma de funci√≥n.</p>
<p>Veamos otro ejemplo, esta vez usando la funci√≥n <code>longest</code> que no ten√≠a
par√°metros de lifetime cuando comenzamos a trabajar con ella en el listado
10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Aplicamos la primera regla: cada par√°metro obtiene su propio lifetime. Esta vez
tenemos dos par√°metros en lugar de uno, por lo que tenemos dos lifetimes:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Podemos ver que la segunda regla no se aplica porque hay m√°s de un input
lifetime. La tercera regla tampoco se aplica porque <code>longest</code> es una funci√≥n
en lugar de un m√©todo, por lo que no hay un par√°metro de <code>self</code>. Despu√©s de
trabajar a trav√©s de las tres reglas, todav√≠a no hemos descubierto cu√°l es el
lifetime de retorno. Es por eso que obtuvimos un error al intentar compilar el
c√≥digo en el listado 10-20: el compilador trabaj√≥ a trav√©s de las reglas de
omisi√≥n de lifetime, pero a√∫n no pudo descubrir todos los lifetime de las
referencias en la firma.</p>
<p>Dado que la tercera regla solo se aplica realmente en las firmas de los m√©todos,
veremos los lifetime en ese contexto a continuaci√≥n para ver por qu√© la tercera
regla significa que no tenemos que anotar los lifetime en las firmas de los
m√©todos con mucha frecuencia.</p>
<h3 id="anotaciones-de-lifetime-en-las-definiciones-de-m√©todos"><a class="header" href="#anotaciones-de-lifetime-en-las-definiciones-de-m√©todos">Anotaciones de lifetime en las definiciones de m√©todos</a></h3>
<p>Cuando implementamos m√©todos en un struct con lifetimes, usamos la misma
sintaxis que la de los par√°metros de tipo generic que se muestra en el listado
10-11. Donde declaramos y usamos los par√°metros de lifetime depende de si est√°n
relacionados con los campos del struct o con los par√°metros y valores de retorno
del m√©todo.</p>
<p>Los nombres de lifetime para los campos de una estructura siempre deben declararse
despu√©s de la palabra clave <code>impl</code> y luego usarse despu√©s del nombre del struct,
porque esos lifetime son parte del tipo del struct.</p>
<p>En las firmas de los m√©todos dentro del bloque <code>impl</code>, las referencias pueden
estar vinculadas a los lifetime de los campos del struct, o pueden ser
independientes. Adem√°s, las reglas de omisi√≥n de lifetime a menudo hacen que no
sean necesarias las anotaciones de lifetime en las firmas de los m√©todos. Veamos
algunos ejemplos usando el struct llamado <code>ImportantExcerpt</code> que definimos en el
listado 10-24.</p>
<p>En primer lugar, usaremos un m√©todo llamado <code>level</code> cuyo par√°metro es una
referencia a <code>self</code>, y cuyo valor de retorno es un <code>i32</code>, que no es una
referencia a nada:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Attention please: {announcement}&quot;);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>La declaraci√≥n del par√°metro de lifetime despu√©s de <code>impl</code> y su uso despu√©s del
nombre del struct son requeridos, pero no estamos obligados a anotar el lifetime
de la referencia a <code>self</code> porque se aplica la primera regla de omisi√≥n.</p>
<p>Aqu√≠ hay un ejemplo donde la tercera regla de omisi√≥n de lifetime se aplica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {announcement}&quot;);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Hay dos input lifetimes, por lo que Rust aplica la primera regla de omisi√≥n de
lifetime y les da a <code>&amp;self</code> y <code>announcement</code> sus propios lifetimes. Luego,
debido a que uno de los par√°metros es <code>&amp;self</code>, el tipo de retorno obtiene el
lifetime de <code>&amp;self</code>, y todos los lifetimes han sido contabilizados.</p>
<h3 id="el-lifetime-static"><a class="header" href="#el-lifetime-static">El lifetime static</a></h3>
<p>Un lifetime especial que necesitamos discutir es <code>'static</code>, que denota que
la referencia afectada puede vivir durante toda la duraci√≥n del programa. Todos
los string literals tienen el lifetime <code>'static</code>, que podemos anotar de la
siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}</span></code></pre></pre>
<p>El texto de este string se almacena directamente en el programa binario, que
siempre est√° disponible. Por lo tanto, la duraci√≥n de todos los string literals
es <code>'static</code>.</p>
<p>Es posible que veas sugerencias para usar el lifetime <code>'static</code> en mensajes de
error. Pero antes de especificar <code>'static</code> como el lifetime para una referencia,
piensa si la referencia que tienes realmente vive durante toda la duraci√≥n de tu
programa o no, y si quieres que lo haga. La mayor√≠a de las veces, un mensaje de
error que sugiere el lifetime <code>'static</code> resulta de intentar crear una referencia
colgante o una falta de coincidencia de los lifetimes disponibles. En tales
casos, la soluci√≥n es corregir esos problemas, no especificar el lifetime
<code>'static</code>.</p>
<h2 id="par√°metros-de-tipo-generic-trait-bounds-y-lifetimes-juntos"><a class="header" href="#par√°metros-de-tipo-generic-trait-bounds-y-lifetimes-juntos">Par√°metros de tipo generic, trait bounds y lifetimes juntos</a></h2>
<p>¬°Veamos brevemente la sintaxis de especificar par√°metros de tipo generic, trait
bounds y lifetimes todo en una funci√≥n!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Today is someone's birthday!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;The longest string is {result}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Announcement! {ann}&quot;);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>Esta es la funci√≥n <code>longest</code> del listado 10-21 que devuelve el string m√°s largo
de dos string slices. Pero ahora tiene un par√°metro adicional llamado <code>ann</code> del
tipo generic <code>T</code>, que puede llenarse con cualquier tipo que implemente el trait
<code>Display</code> como se especifica en la cl√°usula <code>where</code>. Este par√°metro adicional
se imprimir√° con <code>{}</code>, por lo que es necesario el trait bound <code>Display</code>. Debido
a que los lifetimes son un tipo de generic, las declaraciones del par√°metro de
lifetime <code>'a</code> y el par√°metro de tipo generic <code>T</code> van en la misma lista dentro
de los corchetes angulares despu√©s del nombre de la funci√≥n.</p>
<h2 id="resumen-9"><a class="header" href="#resumen-9">Resumen</a></h2>
<p>¬°Hemos cubierto mucho en este cap√≠tulo! Ahora que conoces los par√°metros de
tipo generic, los traits y los trait bounds, y los par√°metros de lifetime
generic, est√°s listo para escribir c√≥digo sin repetici√≥n que funcione en muchas
situaciones diferentes. Los par√°metros de tipo generic te permiten aplicar el
c√≥digo a diferentes tipos. Los traits y los trait bounds garantizan que, aunque
los tipos son generic, tendr√°n el comportamiento que el c√≥digo necesita.
Aprendiste c√≥mo usar las anotaciones de lifetime para garantizar que este c√≥digo
flexible no tendr√° referencias colgantes. ¬°Y todo este an√°lisis ocurre en tiempo
de compilaci√≥n, lo que no afecta el rendimiento en tiempo de ejecuci√≥n!</p>
<p>Aunque no lo creas, hay mucho m√°s que aprender sobre los temas que discutimos en
este cap√≠tulo: el Cap√≠tulo 17 discute los trait objects, que son otra forma de
usar traits. Tambi√©n hay escenarios m√°s complejos que involucran anotaciones de
lifetime que solo necesitar√°s en escenarios muy avanzados; para esos, debes leer
la <a href="https://doc.rust-lang.org/reference/index.html">Referencia de Rust</a>. Pero a continuaci√≥n, aprender√°s c√≥mo
escribir pruebas en Rust para que puedas asegurarte de que tu c√≥digo funcione
como deber√≠a.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escribiendo-tests-automatizados"><a class="header" href="#escribiendo-tests-automatizados">Escribiendo Tests automatizados</a></h1>
<p>En su ensayo de 1972 &quot;El programador humilde&quot;, Edsger W. Dijkstra dijo que
&quot;Los tests de programas pueden ser una forma muy efectiva de mostrar la
presencia de errores, pero es in√∫til para mostrar su ausencia&quot;. Eso no significa
que no debamos intentar probar tanto como podamos!</p>
<p>La correcci√≥n en nuestros programas es el grado en que nuestro c√≥digo hace lo
que pretendemos que haga. Rust est√° dise√±ado con un alto grado de preocupaci√≥n
por la correcci√≥n de los programas, pero la correcci√≥n es compleja y no es
f√°cil de probar. El sistema de tipos de Rust soporta una gran parte de esta
carga, pero el sistema de tipos no puede atrapar todo. Como tal, Rust incluye
soporte para escribir tests de software automatizados.</p>
<p>Digamos que escribimos una funci√≥n <code>add_two</code> que suma 2 a cualquier n√∫mero que
se le pase. La firma de esta funci√≥n acepta un entero como par√°metro y devuelve
un entero como resultado. Cuando implementamos y compilamos esa funci√≥n, Rust
hace toda la comprobaci√≥n de tipos y de pr√©stamos que has aprendido hasta ahora
para asegurarse de que, por ejemplo, no estamos pasando un valor <code>String</code> o una
referencia no v√°lida a esta funci√≥n. Pero Rust <em>no puede</em> comprobar que esta
funci√≥n haga precisamente lo que pretendemos, que es devolver el par√°metro m√°s
2 en lugar de, por ejemplo, el par√°metro m√°s 10 o el par√°metro menos 50! Ah√≠ es
donde entran los tests.</p>
<p>Podemos escribir tests que afirmen, por ejemplo, que cuando pasamos <code>3</code> a la
funci√≥n <code>add_two</code>, el valor devuelto es <code>5</code>. Podemos ejecutar estos tests
siempre que hagamos cambios en nuestro c√≥digo para asegurarnos de que cualquier
comportamiento correcto existente no haya cambiado.</p>
<p>El Testing es una habilidad compleja: aunque no podemos cubrir todos los
detalles sobre c√≥mo escribir buenos tests en un cap√≠tulo, discutiremos los
mecanismos de las instalaciones de testing de Rust. Hablaremos sobre las
anotaciones y macros disponibles para ti cuando escribas tus tests, el
comportamiento predeterminado y las opciones proporcionadas para ejecutar tus
tests, y c√≥mo organizar los tests en tests unitarios y tests de integraci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="como-escribir-tests"><a class="header" href="#como-escribir-tests">Como escribir tests</a></h2>
<p>Los tests son funciones en Rust que verifican que el c√≥digo no-test funciona de
la manera esperada. Los cuerpos de las funciones de test t√≠picamente realizan
estas tres acciones:</p>
<ol>
<li>Configurar cualquier dato o estado necesario.</li>
<li>Ejecutar el c√≥digo que se quiere testear.</li>
<li>Verificar que los resultados son los esperados.</li>
</ol>
<p>Veamos las caracter√≠sticas que Rust provee espec√≠ficamente para escribir tests
que incluyen el atributo <code>test</code>, algunas macros, y el atributo <code>should_panic</code>.</p>
<h3 id="la-anatomia-de-una-funcion-de-test"><a class="header" href="#la-anatomia-de-una-funcion-de-test">La anatomia de una funcion de test</a></h3>
<p>En su forma m√°s simple, un test en Rust es una funci√≥n que est√° anotada con el
atributo <code>test</code>. Los atributos son metadatos sobre piezas de c√≥digo Rust; un
ejemplo es el atributo <code>derive</code> que usamos con structs en el Cap√≠tulo 5. Para
cambiar una funci√≥n en una funci√≥n de test, agrega <code>#[test]</code> en la l√≠nea antes
de <code>fn</code>. Cuando ejecutas tus tests con el comando <code>cargo test</code>, Rust construye
un binario que corre las funciones anotadas y reporta si cada funci√≥n de test
pasa o falla.</p>
<p>Cuando creamos un nuevo proyecto de librer√≠a con Cargo, se genera
autom√°ticamente un m√≥dulo de test con una funci√≥n de test. Este m√≥dulo te da
una plantilla para escribir tus tests para que no tengas que buscar la
estructura y sintaxis exacta cada vez que comiences un nuevo proyecto. ¬°Puedes
agregar tantas funciones de test adicionales y tantos m√≥dulos de test como
quieras!</p>
<p>Exploraremos algunos aspectos de c√≥mo funcionan los tests experimentando con la
plantilla de test antes de testear cualquier c√≥digo. Luego escribiremos algunos
tests del mundo real que llaman a alg√∫n c√≥digo que hemos escrito y verifican
que su comportamiento es correcto.</p>
<p>Creemos un nuevo proyecto de librer√≠a llamado <code>adder</code> que sume dos n√∫meros:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>El contenido del archivo <code>src/lib.rs</code> en tu librer√≠a <code>adder</code> deber√≠a verse como
el Listado 11-1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p><span class="caption">Listing 11-1: El m√≥dulo test y la funci√≥n generada
autom√°ticamente por <code>cargo new</code></span></p>
<p>Por ahora, ignoremos las dos primeras l√≠neas y nos enfoquemos solamente en la 
funci√≥n <code>it_works()</code>.
Nota la anotaci√≥n <code>#[test]</code>: este atributo indica que esta es una funci√≥n de
test, as√≠ que el test runner sabe que tratar esta funci√≥n como un test. Tambi√©n
podr√≠amos tener funciones no-test en el m√≥dulo <code>tests</code> para ayudar a configurar
escenarios comunes o realizar operaciones comunes, as√≠ que siempre necesitamos
indicar qu√© funciones son tests.</p>
<p>El cuerpo de la funci√≥n de test llama a la macro <code>assert_eq!</code>, que verifica que
dos valores sean iguales. Si los valores no son iguales, <code>assert_eq!</code> falla y
el test falla. Si son iguales, no pasa nada y el test pasa.</p>
<p>El comando <code>cargo test</code> ejecuta todos los tests en tu proyecto de librer√≠a, Como
puedes ver en el Listado 11-2.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><span class="caption">Listing 11-2: El resultado de ejecutar el test generado
autom√°ticamente</span></p>
<p>Cargo compila y ejecuta el test. Vemos la l√≠nea <code>running 1 test</code>. La siguiente
l√≠nea muestra el nombre de la funci√≥n de test generada, llamada <code>it_works</code>, y
que el resultado de ejecutar ese test es <code>ok</code>. El resumen general <code>test result: ok.</code> significa que todos los tests pasaron, y la porci√≥n que lee <code>1 passed; 0 failed</code> totaliza el n√∫mero de tests que pasaron o fallaron.</p>
<p>Es posible marcar un test como ignorado para que no se ejecute en una
particular instancia; cubriremos eso en la secci√≥n <a href="ch11-02-running-tests.html#ignorando-algunos-tests-a-menos-que-se-soliciten-especificamente">‚ÄúIgnorando algunos tests a
menos que sean espec√≠ficamente requeridos‚Äù</a><!-- ignore --> m√°s tarde
en este cap√≠tulo. Porque no hemos hecho eso aqu√≠, el resumen muestra <code>0 ignored</code>. Tambi√©n podemos pasar un argumento al comando <code>cargo test</code> para
ejecutar solo tests cuyo nombre coincida con un string; esto se llama
<em>filtrado</em> y lo cubriremos en la secci√≥n <a href="ch11-02-running-tests.html#ejecutando-un-subset-de-tests-por-nombre">‚ÄúEjecutando un subconjunto de tests
por nombre‚Äù</a><!-- ignore -->. Tampoco hemos filtrado los tests que se
ejecutan, as√≠ que el final del resumen muestra <code>0 filtered out</code>.</p>
<p>La estad√≠stica <code>0 measured</code> es para tests de benchmark que miden performance.
Los tests de benchmark, al momento de escribir esto, solo est√°n disponibles en
Rust nightly. Ver <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">la documentaci√≥n sobre tests de benchmark</a> para
aprender m√°s.</p>
<p>La siguiente parte del output de test, comenzando con <code>Doc-tests adder</code>, es
para los resultados de cualquier test de documentaci√≥n. No tenemos tests de
documentaci√≥n a√∫n, pero Rust puede compilar cualquier ejemplo de c√≥digo que
aparezca en nuestra documentaci√≥n de API. ¬°Esta caracter√≠stica ayuda a mantener
tus docs y tu c√≥digo en sincron√≠a! Discutiremos c√≥mo escribir tests de
documentaci√≥n en la secci√≥n <a href="ch14-02-publishing-to-crates-io.html#comentarios-de-documentacion-como-tests">‚ÄúDocumentaci√≥n como tests‚Äù</a><!--
ignore --> del Cap√≠tulo 14. Por ahora, ignoraremos el output <code>Doc-tests</code>.</p>
<p>Comenzaremos a personalizar el test para nuestras propias necesidades. Primero
cambiaremos el nombre de la funci√≥n <code>it_works</code> a un nombre diferente, como
<code>exploration</code>, as√≠:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Entonces ejecutamos <code>cargo test</code> de nuevo. El output ahora muestra <code>exploration</code>
en lugar de <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Ahora agregaremos otro test, ¬°pero esta vez haremos un test que falle! Los
tests fallan cuando algo en la funci√≥n de test hace panic. Cada test se ejecuta
en un nuevo thread, y cuando el thread principal ve que un thread de test ha
muerto, el test se marca como fallido. En el Cap√≠tulo 9, hablamos sobre c√≥mo la
forma m√°s simple de hacer panic es llamar a la macro <code>panic!</code>. Ingresa el nuevo
test como una funci√≥n llamada <code>another</code>, as√≠ que tu archivo <em>src/lib.rs</em> se ve
como el Listado 11-3.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
    
    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}</code></pre>
<p><span class="caption">Listing 11-3: Agregando un segundo test que fallar√° porque
llamamos a la macro <code>panic!</code></span></p>
<p>Volvemos a ejecutar los tests usando <code>cargo test</code>. El output deber√≠a verse como
el Listado 11-4, que muestra que nuestro test <code>exploration</code> pas√≥ y <code>another</code>
fall√≥.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p><span class="caption">Listing 11-4: Resultados del test cuando un test pasa y el
otro falla</span></p>
<p>En lugar de <code>ok</code>, la l√≠nea <code>test tests::another</code> muestra <code>FAILED</code>. Dos nuevas
secciones aparecen entre los resultados individuales y el resumen: la primera
muestra la raz√≥n detallada de cada falla de test. En este caso, obtenemos los
detalles de que <code>another</code> fall√≥ porque <code>panicked at 'Make this test fail'</code> en la
l√≠nea 10 del archivo <em>src/lib.rs</em>. La siguiente secci√≥n lista solo los nombres
de todos los tests que fallaron, lo cual es √∫til cuando hay muchos tests y
mucho output detallado de tests fallidos. Podemos usar el nombre de un test
fallido para ejecutar solo ese test y depurarlo m√°s f√°cilmente; hablaremos m√°s
sobre formas de ejecutar tests en la secci√≥n <a href="ch11-02-running-tests.html#controlando-como-los-tests-son-ejecutados">‚ÄúControlando c√≥mo se ejecutan los
tests‚Äù</a><!-- ignore -->.</p>
<p>La l√≠nea de resumen se muestra al final: en general, nuestro resultado de test
es <code>FAILED</code>. Tenemos un test que pas√≥ y uno que fall√≥.</p>
<p>Ahora que has visto c√≥mo se ven los resultados de tests en diferentes
escenarios, veamos algunas macros que son √∫tiles en tests que no sean <code>panic!</code>.</p>
<h3 id="comprobando-resultados-con-la-macro-assert"><a class="header" href="#comprobando-resultados-con-la-macro-assert">Comprobando resultados con la macro <code>assert!</code></a></h3>
<p>La macro <code>assert!</code>, proporcionada por la biblioteca est√°ndar, es √∫til cuando
quieres asegurarte de que alguna condici√≥n en un test se eval√∫e como <code>true</code>. Le
damos a la macro <code>assert!</code> un argumento que se eval√∫a a un booleano. Si el valor
es <code>true</code>, no pasa nada y el test pasa. Si el valor es <code>false</code>, la macro
<code>assert!</code> llama a <code>panic!</code> para hacer que el test falle. Usar la macro <code>assert!</code>
nos ayuda a verificar que nuestro c√≥digo est√© funcionando de la forma que
queremos.</p>
<p>En el cap√≠tulo 5, en el Listado 5-15, usamos un struct <code>Rectangle</code> y un m√©todo
<code>can_hold</code>, que se repiten aqu√≠ en el Listado 11-5. Pondremos este c√≥digo en el
archivo <em>src/lib.rs</em>, luego escribiremos algunos tests para √©l usando la macro
<code>assert!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<p><span class="caption">Listing 11-5: Usando el struct <code>Rectangle</code> y su m√©todo
<code>can_hold</code> del Cap√≠tulo 5</span></p>
<p>El m√©todo <code>can_hold</code> devuelve un valor booleano, lo que significa que es un caso
de uso perfecto para la macro <code>assert!</code>. En el Listado 11-6, escribimos un test
que ejercita el m√©todo <code>can_hold</code> creando una instancia de <code>Rectangle</code> que tiene
un ancho de 8 y una altura de 7 y afirmando que puede contener otra instancia
de <code>Rectangle</code> que tiene un ancho de 5 y una altura de 1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<p><span class="caption">Listing 11-6: Un test para <code>can_hold</code> que verifica si un
rect√°ngulo m√°s grande puede contener un rect√°ngulo m√°s peque√±o</span></p>
<p>Observa que hemos agregado una nueva l√≠nea dentro del m√≥dulo <code>tests</code>: <code>use super::*;</code>. El m√≥dulo <code>tests</code> es un m√≥dulo regular que sigue las reglas de
visibilidad habituales que cubrimos en el Cap√≠tulo 7 en la secci√≥n
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúPaths para referirse a un item en el √°rbol de
m√≥dulos‚Äù</a><!-- ignore -->.
Como el m√≥dulo <code>tests</code> es un m√≥dulo interno, necesitamos traer el c√≥digo bajo
test en el m√≥dulo externo al alcance del m√≥dulo interno. Usamos un asterisco aqu√≠
para que cualquier cosa que definamos en el m√≥dulo externo est√© disponible para
este m√≥dulo <code>tests</code>.</p>
<p>Hemos llamado a nuestro test <code>larger_can_hold_smaller</code>, y hemos creado dos
instancias de <code>Rectangle</code> que necesitamos. Luego llamamos a la macro <code>assert!</code>
y le pasamos el resultado de llamar a <code>larger.can_hold(&amp;smaller)</code>. Esta
expresi√≥n deber√≠a devolver <code>true</code>, por lo que nuestro test deber√≠a pasar.
¬°Ve√°moslo!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>¬°Pas√≥! Ahora agreguemos otro test, esta vez afirmando que un rect√°ngulo m√°s
peque√±o no puede contener un rect√°ngulo m√°s grande:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Porque el resultado correcto de la funci√≥n <code>can_hold</code> en este caso es <code>false</code>,
necesitamos negar ese resultado antes de pasarlo a la macro <code>assert!</code>. Como
resultado, nuestro test pasar√° si <code>can_hold</code> devuelve <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>¬°Dos tests que pasan! Ahora veamos qu√© sucede con nuestros resultados de test
cuando introducimos un bug en nuestro c√≥digo. Cambiaremos la implementaci√≥n del
m√©todo <code>can_hold</code> reemplazando el signo mayor que con un signo menor que cuando
compara los anchos:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ejecutar los tests ahora produce lo siguiente:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>¬°Nuestros tests atraparon el bug! Debido a que <code>larger.width</code> es 8 y
<code>smaller.width</code> es 5, la comparaci√≥n de los anchos en <code>can_hold</code> ahora devuelve
<code>false</code>: 8 no es menor que 5.</p>
<h3 id="testeando-la-igualdad-con-las-macros-assert_eq-y-assert_ne"><a class="header" href="#testeando-la-igualdad-con-las-macros-assert_eq-y-assert_ne">Testeando la igualdad con las macros <code>assert_eq!</code> y <code>assert_ne!</code></a></h3>
<p>Una manera com√∫n de verificar la funcionalidad es probar la igualdad entre el
resultado del c√≥digo bajo test y el valor que esperamos que el c√≥digo devuelva.
Podr√≠as hacer esto usando la macro <code>assert!</code> y pas√°ndole una expresi√≥n usando
el operador <code>==</code>. Sin embargo, este es un test tan com√∫n que la biblioteca
est√°ndar provee un par de macros ‚Äî<code>assert_eq!</code> y <code>assert_ne!</code>‚Äî para realizar
este test de manera m√°s conveniente. Estas macros comparan dos argumentos por
igualdad o desigualdad, respectivamente. Tambi√©n imprimir√°n los dos valores si
la aserci√≥n falla, lo que hace m√°s f√°cil ver <em>por qu√©</em> fall√≥ el test;
conversamente, la macro <code>assert!</code> solo indica que obtuvo un valor <code>false</code> para
la expresi√≥n <code>==</code>, sin imprimir los valores que llevaron al valor <code>false</code>.</p>
<p>En el Listado 11-7, escribimos una funci√≥n llamada <code>add_two</code> que suma <code>2</code> a su
par√°metro, luego testeamos esta funci√≥n usando la macro <code>assert_eq!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}</code></pre>
<p><span class="caption">Listing 11-7: Testeando la funci√≥n <code>add_two</code> usando la
macro <code>assert_eq!</code></span></p>
<p>¬°Veamos que pasa!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Hemos pasado <code>4</code> como argumento a <code>assert_eq!</code>, que es igual al resultado de
llamar a <code>add_two(2)</code>. La l√≠nea para este test es <code>test tests::it_adds_two ... ok</code>, y el texto <code>ok</code> indica que nuestro test pas√≥!</p>
<p>Vamos a introducir un error en nuestro c√≥digo para ver c√≥mo se ve <code>assert_eq!</code>
cuando falla. Cambiaremos la implementaci√≥n de la funci√≥n <code>add_two</code> para que
en su lugar a√±ada <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ejecutemos los tests nuevamente:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:11:9:
assertion `left == right` failed
  left: 4
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>¬°Nuestro test atrap√≥ el bug! El test <code>it_adds_two</code> fall√≥, y el mensaje nos dice
que la aserci√≥n que fall√≥ fue <code> assertion `left == right` failed</code> y
cu√°les son los valores de <code>left</code> y <code>right</code>. Este mensaje nos ayuda a comenzar a
debuggear: el argumento <code>left</code> fue <code>4</code> pero el argumento <code>right</code>, donde
llamamos a <code>add_two(2)</code>, fue <code>5</code>. Puedes imaginar que esto ser√≠a especialmente
√∫til cuando tenemos muchos tests en marcha.</p>
<p>Cabe se√±alar que en algunos lenguajes y frameworks de test, los par√°metros de
las funciones de aserci√≥n de igualdad se llaman <code>expected</code> y <code>actual</code>, y el
orden en que especificamos los argumentos importa. Sin embargo, en Rust, se
llaman <code>left</code> y <code>right</code>, y el orden en que especificamos el valor que esperamos
y el valor que el c√≥digo produce no importa. Podr√≠amos escribir la aserci√≥n en
este test como <code>assert_eq!(add_two(2), 4)</code>, lo que resultar√≠a en el mismo
mensaje de error que muestra <code>assertion failed: `(left == right)`</code>.</p>
<p>La macro <code>assert_ne!</code> pasar√° si los dos valores que le proporcionamos no son
iguales. Esta macro es m√°s √∫til en casos en los que no estamos seguros de cu√°l
ser√° el valor, pero sabemos que el valor definitivamente <em>no deber√≠a</em> ser. Por
ejemplo, si estamos testeando una funci√≥n que est√° garantizada de cambiar su
entrada de alguna manera, pero la forma en que la entrada cambia depende del
d√≠a de la semana en que ejecutamos nuestros tests, lo mejor ser√≠a afirmar que
el output de la funci√≥n no es igual al input.</p>
<p>En la base, las macros <code>assert_eq!</code> y <code>assert_ne!</code> usan los operadores <code>==</code> y
<code>!=</code>, respectivamente. Cuando las aserciones fallan, estas macros imprimen sus
argumentos usando el formato de debug, lo que significa que los valores que se
comparan deben implementar los traits <code>PartialEq</code> y <code>Debug</code>. Todos los tipos
primitivos y la mayor√≠a de los tipos de la biblioteca est√°ndar implementan
estos traits. Para las estructuras y enumeraciones que definas, deber√°s
implementar <code>PartialEq</code> para afirmar la igualdad de esos tipos. Tambi√©n
necesitar√°s implementar <code>Debug</code> para imprimir los valores cuando la aserci√≥n
falla. Debido a que ambos traits son derivables, como se mencion√≥ en el
Listado 5-12 en el Cap√≠tulo 5, esto suele ser tan sencillo como agregar la
anotaci√≥n <code>#[derive(PartialEq, Debug)]</code> a la definici√≥n de tu estructura o
enumeraci√≥n. Consulta el Ap√©ndice C,
<a href="appendix-03-derivable-traits.html">‚ÄúTraits derivables,‚Äù</a><!-- ignore -->
para obtener m√°s detalles sobre estos y otros traits derivables.</p>
<h3 id="agregando-mensajes-de-fallo-personalizados"><a class="header" href="#agregando-mensajes-de-fallo-personalizados">Agregando mensajes de fallo personalizados</a></h3>
<p>Tambi√©n puedes agregar un mensaje personalizado a ser impreso con el mensaje de
fallo como argumentos opcionales a las macros <code>assert!</code>, <code>assert_eq!</code> y
<code>assert_ne!</code>. Cualquier argumento especificado despu√©s de los argumentos
requeridos se pasa a la macro <code>format!</code> (discutida en el Cap√≠tulo 8 en la
secci√≥n <a href="ch08-02-strings.html#concatenacion-con-el-operador--o-la-macro-format">‚ÄúConcatenaci√≥n con el operador <code>+</code> o la macro
<code>format!</code>‚Äù</a><!-- ignore
-->), por lo que puedes pasar una format string que contenga marcadores de
posici√≥n <code>{}</code> y valores para ir en esos marcadores de posici√≥n. Los mensajes
personalizados son √∫tiles para documentar lo que significa una aserci√≥n; cuando
un test falla, tendr√°s una mejor idea de cu√°l es el problema con el c√≥digo.</p>
<p>Por ejemplo, supongamos que tenemos una funci√≥n que saluda a las personas por
nombre y queremos probar que el nombre que pasamos a la funci√≥n aparece en el
output:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {name}!&quot;)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}</code></pre>
<p>Las especificaciones para este programa a√∫n no se han acordado, y estamos
bastante seguros de que el texto <code>Hello</code> al comienzo del saludo cambiar√°.
Decidimos que no queremos tener que actualizar el test cuando cambien los
requisitos, por lo que en lugar de verificar la igualdad exacta con el valor
devuelto de la funci√≥n <code>greeting</code>, solo afirmaremos que el output contiene el
texto del par√°metro de entrada.</p>
<p>Ahora introduciremos un bug en este c√≥digo cambiando <code>greeting</code> para excluir el
<code>name</code> y veremos c√≥mo se ve el fallo de test predeterminado:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ejecutando este test produce lo siguiente:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains(&quot;Carol&quot;)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>El resultado indica simplemente que la aserci√≥n fall√≥ y en qu√© l√≠nea se
encuentra. Un mensaje de fallo m√°s √∫til imprimir√≠a el valor de la funci√≥n
<code>greeting</code>. Agreguemos un mensaje de fallo personalizado compuesto por un
format string con un marcador de posici√≥n reemplazado por el valor real que
obtuvimos de la funci√≥n <code>greeting</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hello!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Greeting did not contain name, value was `{}`&quot;,
            result
        );
    }
<span class="boring">}</span></code></pre>
<p>Ahora, cuando ejecutemos el test, obtendremos un mensaje de error m√°s
informativo:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Podemos ver el valor que realmente obtuvimos en el output del test, lo que
nos ayudar√≠a a debuggear lo que sucedi√≥ en lugar de lo que esper√°bamos que
sucediera.</p>
<h3 id="comprobando-panics-con-should_panic"><a class="header" href="#comprobando-panics-con-should_panic">Comprobando panics con <code>should_panic</code></a></h3>
<p>Adem√°s de verificar los valores de retorno, es importante verificar que nuestro
c√≥digo maneje las condiciones de error como esperamos. Por ejemplo, considera
el tipo <code>Guess</code> que creamos en el Listado 9-13 del Cap√≠tulo 9. Otro c√≥digo que
usa <code>Guess</code> depende de la garant√≠a de que las instancias de <code>Guess</code> contendr√°n
solo valores entre 1 y 100. Podemos escribir un test que asegure que al
intentar crear una instancia de <code>Guess</code> con un valor fuera de ese rango, se
produzca un panic.</p>
<p>Lo hacemos agregando el atributo <code>should_panic</code> a nuestra funci√≥n de test. El
test pasa si el c√≥digo dentro de la funci√≥n hace un panic; el test falla si el
c√≥digo dentro de la funci√≥n no hace un panic.</p>
<p>El Listado 11-8 muestra un test que verifica que las condiciones de error de
<code>Guess::new</code> sucedan cuando esperamos que sucedan.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {value}.&quot;);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Listing 11-8: Testeando que una condici√≥n causar√° un
<code>panic!</code></span></p>
<p>Colocamos el atributo <code>#[should_panic]</code> despu√©s del atributo <code>#[test]</code> y antes
de la funci√≥n de test a la que se aplica. Veamos el resultado cuando pase este
test:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>¬°Se ve bien! Ahora introduzcamos un bug en nuestro c√≥digo eliminando la
condici√≥n de que la funci√≥n <code>new</code> har√° un panic si el valor es mayor que 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be between 1 and 100, got {value}.&quot;);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Cuando ejecutemos el test del Listado 11-8, veremos que fallar√°:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>No obtenemos un mensaje muy √∫til en este caso, pero cuando miramos la funci√≥n
de test, vemos que est√° anotada con <code>#[should_panic]</code>. El fallo que obtuvimos
significa que el c√≥digo en la funci√≥n de test no caus√≥ un panic.</p>
<p>Los tests que usan <code>should_panic</code> pueden ser imprecisos. Un test <code>should_panic</code>
pasar√≠a incluso si el test hace un panic por una raz√≥n diferente a la que
esper√°bamos. Para hacer que los tests <code>should_panic</code> sean m√°s precisos,
podemos agregar un par√°metro opcional <code>expected</code> al atributo <code>should_panic</code>.
El test harness se asegurar√° de que el mensaje de error contenga el texto
proporcionado. Por ejemplo, considera el c√≥digo modificado para <code>Guess</code> en el
Listado 11-9 donde la funci√≥n <code>new</code> hace un panic con mensajes diferentes
dependiendo de si el valor es demasiado peque√±o o demasiado grande.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {value}.&quot;
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {value}.&quot;
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Listing 11-9: Testeando un <code>panic!</code> con un mensaje panic
que contiene un substring espec√≠fico</span></p>
<p>Este test fallar√° porque el valor que pusimos en el par√°metro <code>expected</code> del
atributo <code>should_panic</code> es un substring del mensaje que genera la funci√≥n
<code>Guess::new</code>. Podr√≠amos haber especificado todo el mensaje de excepci√≥n que
esperamos, que en este caso ser√≠a <code>Guess value must be less than or equal to 100, got 200.</code>. Lo que elijas especificar depende de cu√°nto del mensaje de
excepci√≥n es √∫nico o din√°mico y de cu√°n preciso quieras que sea tu test. En
este caso, un substring del mensaje de excepci√≥n es suficiente para asegurar
que el c√≥digo en la funci√≥n de test ejecuta el caso <code>else if value &gt; 100</code>.</p>
<p>Para ver que sucede cuando un test <code>should_panic</code> con un mensaje <code>expected</code>
falla, introduzcamos un bug en nuestro c√≥digo al intercambiar los cuerpos de
los bloques <code>if value &lt; 1</code> y <code>else if value &gt; 100</code>:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {value}.&quot;
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {value}.&quot;
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Esta vez, cuando ejecutemos el test <code>should_panic</code>, fallar√°:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>El mensaje de error indica que el test fall√≥ con un error como esper√°bamos, pero
el mensaje de panic no incluy√≥ el string esperado <code>less than or equal to 100</code>. El mensaje de panic que obtuvimos en este caso fue
<code>Guess value must be greater than or equal to 1, got 200.</code>. ¬°Ahora podemos
empezar a descubrir d√≥nde est√° nuestro bug!</p>
<h3 id="usando-resultt-e-en-tests"><a class="header" href="#usando-resultt-e-en-tests">Usando <code>Result&lt;T, E&gt;</code> en Tests</a></h3>
<p>Hasta ahora, todos nuestros tests entran en panic cuando fallan. ¬°Tambi√©n podemos
escribir tests que usen <code>Result&lt;T, E&gt;</code>! Aqu√≠ est√° el test del Listado 11-1,
reescrito para usar <code>Result&lt;T, E&gt;</code> y devolver un <code>Err</code> en lugar de hacer un
panic:</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}</code></pre>
<p>La funci√≥n <code>it_works</code> ahora tiene el tipo de retorno <code>Result&lt;(), String&gt;</code>. En
el cuerpo de la funci√≥n, en lugar de llamar al macro <code>assert_eq!</code>, devolvemos
<code>Ok(())</code> cuando el test pasa y un <code>Err</code> con un <code>String</code> dentro cuando el test
falla.</p>
<p>Escribir tests que devuelvan un <code>Result&lt;T, E&gt;</code> te permite usar el operador
<code>?</code> en el cuerpo de los tests, lo que puede ser una forma conveniente de
escribir tests que fallar√°n si cualquier operaci√≥n dentro de ellos devuelve
una variante <code>Err</code>.</p>
<p>No puedes utilizar la anotaci√≥n <code>#[should_panic]</code> en tests que usen <code>Result&lt;T, E&gt;</code>. Para asegurar que una operaci√≥n devuelve una variante <code>Err</code>, <em>no</em> uses el
operador <code>?</code> en el valor <code>Result&lt;T, E&gt;</code>. En su lugar, usa
<code>assert!(value.is_err())</code>.</p>
<p>Ahora que conoces varias formas de escribir tests, veamos qu√© sucede cuando
ejecutamos nuestros tests y exploremos las diferentes opciones que podemos usar
con <code>cargo test</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="controlando-como-los-tests-son-ejecutados"><a class="header" href="#controlando-como-los-tests-son-ejecutados">Controlando como los tests son ejecutados</a></h2>
<p>Al igual que <code>cargo run</code> compila tu c√≥digo y luego ejecuta el binario
resultante, <code>cargo test</code> compila tu c√≥digo en modo de test y ejecuta el binario
resultante. El comportamiento por defecto del binario producido por <code>cargo test</code>
es ejecutar todos los tests en paralelo y capturar la salida generada durante la
ejecuci√≥n de los tests, previniendo que la salida sea mostrada y haciendo m√°s
f√°cil leer la salida relacionada con los resultados de los tests. Sin embargo,
puedes especificar opciones de l√≠nea de comandos para cambiar este
comportamiento por defecto.</p>
<p>Algunas opciones de l√≠nea de comandos van a <code>cargo test</code>, y otras van al binario
de test resultante. Para separar estos dos tipos de argumentos, debes listar los
argumentos que van a <code>cargo test</code> seguidos del separador <code>--</code> y luego los que
van al binario de test. Ejecutar <code>cargo test --help</code> muestra las opciones que
puedes usar con <code>cargo test</code>, y ejecutar <code>cargo test -- --help</code> muestra las
opciones que puedes usar despu√©s del separador.</p>
<h3 id="ejecutando-tests-en-paralelo-o-consecutivamente"><a class="header" href="#ejecutando-tests-en-paralelo-o-consecutivamente">Ejecutando tests en paralelo o consecutivamente</a></h3>
<p>Cuando ejecutas m√∫ltiples tests, por defecto estos se ejecutan en paralelo
usando hilos, lo que significa que terminan de ejecutarse m√°s r√°pido y obtienes
feedback m√°s r√°pido. Debido a que los tests se ejecutan al mismo tiempo, debes
asegurarte que tus tests no dependan entre s√≠ o de cualquier estado compartido,
incluyendo un entorno compartido, como el directorio de trabajo actual o las
variables de entorno.</p>
<p>Por ejemplo, digamos que cada uno de tus tests ejecuta c√≥digo que crea un
archivo en disco llamado <em>test-output.txt</em> y escribe algunos datos en ese
archivo. Luego cada test lee los datos en ese archivo y aserta que el archivo
contiene un valor particular, el cual es diferente en cada test. Debido a que
los tests se ejecutan al mismo tiempo, un test podr√≠a sobreescribir el archivo
en el tiempo entre que otro test escribe y lee el archivo. El segundo test
fallar√°, no porque el c√≥digo sea incorrecto, sino porque los tests han
interferido entre s√≠ mientras se ejecutaban en paralelo. Una soluci√≥n es
asegurarte que cada test escriba en un archivo diferente; otra soluci√≥n es
ejecutar los tests uno a la vez.</p>
<p>Si no deseas ejecutar los tests en paralelo o si deseas tener un control m√°s
fino sobre el n√∫mero de hilos usados, puedes enviar la bandera <code>--test-threads</code>
y el n√∫mero de hilos que deseas usar al binario de test. Echa un vistazo al
siguiente ejemplo:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Establecemos el n√∫mero de hilos de test a <code>1</code>, indicando al programa que no use
ning√∫n paralelismo. Ejecutar los tests usando un hilo tomar√° m√°s tiempo que
ejecutarlos en paralelo, pero los tests no interferir√°n entre s√≠ si comparten
estado.</p>
<h3 id="mostrando-el-output-de-las-funciones"><a class="header" href="#mostrando-el-output-de-las-funciones">Mostrando el Output de las funciones</a></h3>
<p>Por defecto, si un test pasa, la librer√≠a de tests de Rust captura cualquier
cosa impresa en la salida est√°ndar. Por ejemplo, si llamamos a <code>println!</code> en un
test y el test pasa, no veremos la salida de <code>println!</code> en la terminal; solo
veremos la l√≠nea que indica que el test pas√≥. Si un test falla, veremos lo que
sea que se haya impreso en la salida est√°ndar junto con el resto del mensaje de
falla.</p>
<p>Como ejemplo, el Listado 11-10 tiene una funci√≥n tonta que imprime el valor de
su par√°metro y retorna 10, as√≠ como un test que pasa y un test que falla.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {a}&quot;);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}</code></pre>
<p><span class="caption">Listing 11-10: Tests para una funci√≥n que llama a
<code>println!</code></span></p>
<p>Cuando ejecutamos estos tests con <code>cargo test</code>, vemos el siguiente output:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 5
 right: 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Nota que en ninguna parte de este output vemos <code>I got the value 4</code>, que es lo
que se imprime cuando el test que pasa se ejecuta. Ese output ha sido capturado.
El output del test que falla, <code>I got the value 8</code>, aparece en la secci√≥n del
resumen de tests, que tambi√©n muestra la causa de la falla del test.</p>
<p>Si queremos ver los valores impresos por los tests que pasan tambi√©n, podemos
decirle a Rust que muestre el output de los tests exitosos con <code>--show-output</code>.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Cuando ejecutamos los tests en el Listado 11-10 nuevamente con el flag
<code>--show-output</code>, vemos el siguiente output:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 5
 right: 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="ejecutando-un-subset-de-tests-por-nombre"><a class="header" href="#ejecutando-un-subset-de-tests-por-nombre">Ejecutando un Subset de tests por nombre</a></h3>
<p>A veces, ejecutar un conjunto completo de tests puede tomar mucho tiempo. Si
est√°s trabajando en c√≥digo en un √°rea particular, podr√≠as querer ejecutar solo
los tests que pertenecen a ese c√≥digo. Puedes elegir qu√© tests ejecutar
pas√°ndole a <code>cargo test</code> el nombre o nombres del test(s) que quieres ejecutar
como argumento.</p>
<p>Para demostrar c√≥mo ejecutar un subset de tests, primero crearemos tres tests
para nuestra funci√≥n <code>add_two</code>, como se muestra en el Listado 11-11, y
elegiremos cu√°les ejecutar.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}</code></pre>
<p><span class="caption">Listing 11-11: Tres tests con tres nombres
diferentes</span></p>
<p>Si ejecutamos los tests sin pasar ning√∫n argumento, como vimos anteriormente,
todos los tests se ejecutar√°n en paralelo:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="ejecutando-un-solo-test"><a class="header" href="#ejecutando-un-solo-test">Ejecutando un solo test</a></h4>
<p>Podemos pasar el nombre de cualquier funci√≥n de test a <code>cargo test</code> para
ejecutar solo ese test:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Solo se ejecut√≥ el test con el nombre <code>one_hundred</code>; los otros dos tests no
coincidieron con ese nombre. El output de los tests nos indica que tenemos m√°s
tests que no se ejecutaron al mostrar <code>2 filtered out</code> al final.</p>
<p>No podemos especificar los nombres de varios tests de esta manera; solo se usar√°
el primer valor dado a <code>cargo test</code>. Pero hay una manera de ejecutar varios
tests.</p>
<h4 id="filtrando-para-ejecutar-m√∫ltiples-tests"><a class="header" href="#filtrando-para-ejecutar-m√∫ltiples-tests">Filtrando para ejecutar m√∫ltiples tests</a></h4>
<p>Podemos especificar parte de un nombre de test y cualquier test cuyo nombre
coincida con ese valor se ejecutar√°. Por ejemplo, como dos de nuestros tests
tienen <code>add</code> en el nombre, podemos ejecutar esos dos ejecutando <code>cargo test add</code>:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>Este comando ejecut√≥ todos los test con <code>add</code> en el nombre y filtr√≥ el test
con el nombre <code>one_hundred</code>. Tambi√©n nota que el m√≥dulo en el que aparece un
test se convierte en parte del nombre del test, por lo que podemos ejecutar
todos los tests en un m√≥dulo filtrando por el nombre del m√≥dulo.</p>
<h3 id="ignorando-algunos-tests-a-menos-que-se-soliciten-especificamente"><a class="header" href="#ignorando-algunos-tests-a-menos-que-se-soliciten-especificamente">Ignorando algunos tests a menos que se soliciten especificamente</a></h3>
<p>A veces, algunos tests espec√≠ficos pueden ser muy lentos para ejecutarse, por lo
que puede que quieras excluirlos en la mayor√≠a de las ejecuciones de
<code>cargo test</code>. En lugar de listar como argumentos todos los tests que quieres
ejecutar, puedes anotar los tests que consumen mucho tiempo usando el atributo
<code>ignore</code> para excluirlos, como se muestra aqu√≠:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}</code></pre>
<p>Despu√©s de <code>#[test]</code> agregamos la l√≠nea <code>#[ignore]</code> al test que queremos
excluir. Ahora cuando ejecutamos nuestros tests, <code>it_works</code> se ejecuta, pero
<code>expensive_test</code> no:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Esta funci√≥n <code>expensive_test</code> est√° listada como <code>ignored</code>. Si queremos ejecutar
solo los tests ignorados, podemos usar <code>cargo test -- -- ignored</code>:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Controlando que tests se ejecutan, puedes asegurarte de que los resultados de
<code>cargo test</code> ser√°n r√°pidos. Cuando est√©s en un punto en el que tenga sentido
verificar los resultados de los tests ignorados y tengas tiempo para esperar
los resultados, puedes ejecutar <code>cargo test -- --ignored</code> en su lugar. Si
quieres ejecutar todos los tests, ignorados o no, puedes ejecutar <code>cargo test -- --include-ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="organizaci√≥n-de-los-tests"><a class="header" href="#organizaci√≥n-de-los-tests">Organizaci√≥n de los Tests</a></h2>
<p>Como se mencion√≥ al comienzo del cap√≠tulo, el testing es una disciplina, y
diferentes personas usan diferentes terminolog√≠as y organizaci√≥n. La comunidad
de Rust piensa en los tests en t√©rminos de dos categor√≠as principales: tests de
unidad e integraci√≥n. Los <em>tests de unidad</em> son peque√±os y m√°s enfocados,
probando un m√≥dulo a la vez en aislamiento, y pueden probar interfaces privadas.
Los <em>tests de integraci√≥n</em> son completamente externos a tu biblioteca y usan tu
c√≥digo de la misma manera que cualquier otro c√≥digo externo, usando solo la
interfaz p√∫blica y potencialmente ejercitando m√∫ltiples m√≥dulos por test.</p>
<p>Escribir ambos tipos de tests es importante para asegurar que las piezas de tu
biblioteca est√°n haciendo lo que esperas, separada y conjuntamente.</p>
<h3 id="tests-unitarios"><a class="header" href="#tests-unitarios">Tests Unitarios</a></h3>
<p>El prop√≥sito de los tests unitarios es probar cada unidad de c√≥digo en
aislamiento del resto del c√≥digo para r√°pidamente identificar donde el c√≥digo
est√° y no est√° funcionando como se espera. Pondr√°s los tests unitarios en el
directorio <em>src</em> en cada archivo con el c√≥digo que est√°n testeando. La
convenci√≥n es crear un m√≥dulo llamado <code>tests</code> en cada archivo para contener las
funciones de test y anotar el m√≥dulo con <code>cfg(test)</code>.</p>
<h4 id="el-m√≥dulo-de-tests-y-cfgtest"><a class="header" href="#el-m√≥dulo-de-tests-y-cfgtest">El m√≥dulo de tests y <code>#[cfg(test)]</code></a></h4>
<p>La anotaci√≥n <code>#[cfg(test)]</code> en el m√≥dulo de tests le dice a Rust que compile y
ejecute el c√≥digo de test solo cuando ejecutas <code>cargo test</code>, no cuando ejecutas
<code>cargo build</code>. Esto ahorra tiempo de compilaci√≥n cuando solo quieres compilar
la biblioteca y ahorra espacio en el resultado compilado porque los tests no
est√°n incluidos. Ver√°s que porque los tests de integraci√≥n van en un directorio
diferente, no necesitan la anotaci√≥n <code>#[cfg(test)]</code>. Sin embargo, porque los
tests unitarios van en los mismos archivos que el c√≥digo, usar√°s <code>#[cfg(test)]</code>
para especificar que no deber√≠an ser incluidos en el resultado compilado.</p>
<p>Recuerda que cuando generamos el nuevo proyecto <code>adder</code> en la primera secci√≥n
de este cap√≠tulo, Cargo gener√≥ este c√≥digo para nosotros:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Este c√≥digo es el m√≥dulo de tests generado autom√°ticamente. El atributo <code>cfg</code>
significa <em>configuraci√≥n</em> y le dice a Rust que el siguiente item deber√≠a ser
incluido solo si una cierta opci√≥n de configuraci√≥n est√° presente. En este
caso, la opci√≥n de configuraci√≥n es <code>test</code>, la cual es provista por Rust para
compilar y ejecutar tests. Al usar el atributo <code>cfg</code>, Cargo compila nuestro
c√≥digo de test solo si activamente ejecutamos los tests con <code>cargo test</code>. Esto
incluye cualquier funci√≥n auxiliar que pueda estar dentro de este m√≥dulo, en
adici√≥n a las funciones anotadas con <code>#[test]</code>.</p>
<h4 id="testeando-funciones-privadas"><a class="header" href="#testeando-funciones-privadas">Testeando Funciones Privadas</a></h4>
<p>Hay debate dentro de la comunidad de testing sobre si las funciones privadas
deber√≠an ser testeables directamente, y otros lenguajes hacen dif√≠cil o
imposible testear funciones privadas. Independientemente de la ideolog√≠a de
testing a la que te adhieras, las reglas de privacidad de Rust te permiten
testear funciones privadas. Considera el c√≥digo en el Listado 11-12 con la
funci√≥n privada <code>internal_adder</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}</code></pre>
<p><span class="caption">Listing 11-12: Testeando una funci√≥n privada</span></p>
<p>Nota que la funci√≥n <code>internal_adder</code> no est√° marcada como <code>pub</code>. Los tests son
solo c√≥digo Rust, y el m√≥dulo <code>tests</code> es solo otro m√≥dulo. Como discutimos en
la secci√≥n <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúPaths for Referring to an Item in the Module Tree‚Äù</a><!--
ignore -->, items en m√≥dulos hijos pueden usar los items en sus ancestros. En
este test, traemos todos los items del padre del m√≥dulo <code>tests</code> al alcance con
<code>use super::*</code>, y entonces el test puede llamar a <code>internal_adder</code>. Si no
piensas que las funciones privadas deber√≠an ser testeables, no hay nada en Rust
que te obligue a hacerlo.</p>
<h3 id="tests-de-integraci√≥n"><a class="header" href="#tests-de-integraci√≥n">Tests de Integraci√≥n</a></h3>
<p>En Rust, los tests de integraci√≥n son completamente externos a tu biblioteca.
Usan tu biblioteca de la misma manera que cualquier otro c√≥digo externo, lo
cual significa que solo pueden llamar a funciones que son parte de la API
p√∫blica. Su prop√≥sito es probar si muchas partes de tu biblioteca funcionan
correctamente juntas. Unidades de c√≥digo que funcionan correctamente por su
cuenta podr√≠an tener problemas cuando se integran, as√≠ que la cobertura de
tests del c√≥digo integrado es importante tambi√©n. Para crear tests de
integraci√≥n, primero necesitas un directorio <em>tests</em>.</p>
<h4 id="el-directorio-tests"><a class="header" href="#el-directorio-tests">El directorio <em>tests</em></a></h4>
<p>Se crea un directorio llamado tests en el nivel superior del directorio de
nuestro proyecto, al lado de <em>src</em>. Cargo sabe buscar archivos de test de
integraci√≥n en este directorio. Podemos crear tantos archivos de test como
queramos en este directorio, y Cargo compilar√° cada archivo como un crate
individual.</p>
<p>Creemos un test de integraci√≥n. Con el c√≥digo en el Listado 11-12 a√∫n en el
archivo <em>src/lib.rs</em>, crea un directorio <em>tests</em> y crea un nuevo archivo
llamado <em>tests/integration_test.rs</em>. Tu estructura de directorios deber√≠a
verse as√≠:</p>
<pre><code class="language-text">adder
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ tests
    ‚îî‚îÄ‚îÄ integration_test.rs
</code></pre>
<p>Introducimos el c√≥digo en el Listado 11-13 en el archivo
<em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}</code></pre>
<p><span class="caption">Listing 11-13: Un test de integraci√≥n de una funci√≥n en el
crate <code>adder</code></span></p>
<p>Cada archivo en el directorio <em>tests</em> es un crate separado, as√≠ que necesitamos
importar nuestra biblioteca en el scope de cada crate de test. Por esa raz√≥n,
agregamos <code>use adder::add_two</code> al inicio del c√≥digo, lo cual no necesitamos en 
los tests unitarios.</p>
<p>No es necesario anotar ning√∫n c√≥digo en <em>tests/integration_test.rs</em> con
<code>#[cfg(test)]</code>. Cargo trata al directorio <code>tests</code> de manera especial y compila
los archivos en este directorio solo cuando ejecutamos <code>cargo test</code>. Ejecuta
<code>cargo test</code> ahora:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Las tres secciones de output incluyen los tests unitarios, el test de
integraci√≥n y los tests de documentaci√≥n. Nota que si alg√∫n test en una
secci√≥n falla, las siguientes secciones no ser√°n ejecutadas. Por ejemplo, si
falla un test unitario, no habr√° ning√∫n output para los tests de integraci√≥n y
de documentaci√≥n porque esos tests solo ser√°n ejecutados si todos los tests
unitarios pasan.</p>
<p>La primera secci√≥n es para los tests unitarios es la misma que hemos visto:
una l√≠nea para cada test unitario (uno llamado <code>internal</code> que agregamos en el
Listado 11-12) y luego una l√≠nea de resumen para los tests unitarios.</p>
<p>Los tests de integraci√≥n comienzan con la l√≠nea
<code>Running tests/integration_test.rs</code>. Luego, hay una l√≠nea para cada funci√≥n
de test en ese test de integraci√≥n y una l√≠nea de resumen para los tests de
integraci√≥n justo antes de que comience la secci√≥n <code>Doc-tests adder</code>.</p>
<p>Cada archivo de test de integraci√≥n tiene su propia secci√≥n, as√≠ que si
agregamos m√°s archivos en el directorio <em>tests</em>, habr√° m√°s secciones de tests
de integraci√≥n.</p>
<p>Todav√≠a podemos ejecutar una funci√≥n de test de integraci√≥n en particular
especificando el nombre de la funci√≥n de test como argumento de <code>cargo test</code>.
Para ejecutar todos los tests en un archivo de test de integraci√≥n en
particular, usa el argumento <code>--test</code> de <code>cargo test</code> seguido del nombre del
archivo:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Este comando ejecuta solo los tests en el archivo <em>tests/integration_test.rs</em>.</p>
<h4 id="subm√≥dulos-en-tests-de-integraci√≥n"><a class="header" href="#subm√≥dulos-en-tests-de-integraci√≥n">Subm√≥dulos en Tests de Integraci√≥n</a></h4>
<p>En la medida en que se agregan m√°s tests de integraci√≥n, es posible que
quieras crear m√°s archivos en el directorio tests para ayudar a organizarlas;
por ejemplo, puedes agrupar las funciones de test por la funcionalidad que
est√°n probando. Como se mencion√≥ anteriormente, cada archivo en el directorio
<em>tests</em> es compilado como un crate separado, lo cual es √∫til para crear
scopes separados para imitar m√°s de cerca la manera en que los usuarios finales
usar√°n tu crate. Sin embargo, esto significa que los archivos en el directorio
<em>tests</em> no comparten el mismo comportamiento que los archivos en <em>src</em>, como
aprendiste en el Cap√≠tulo 7 sobre c√≥mo separar el c√≥digo en m√≥dulos y archivos.</p>
<p>La diferencia en el comportamiento de los archivos en <em>src</em> y <em>tests</em> es m√°s
notable cuando tienes un conjunto de funciones de ayuda para usar en m√∫ltiples
archivos de test de integraci√≥n y tratas de seguir los pasos en la secci√≥n</p>
<!--ignore[‚ÄúSeparando M√≥dulos en Diferentes 
Archivos‚Äù][separating-modules-into-files]--> del Cap√≠tulo 7 para extraerlas
<p>en un m√≥dulo com√∫n. Por ejemplo, si creamos <em>tests/common.rs</em> y colocamos una
funci√≥n llamada <code>setup</code> en √©l, podemos agregar algo de c√≥digo a <code>setup</code> que
queremos llamar desde m√∫ltiples funciones de test en m√∫ltiples archivos de
test:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}</code></pre>
<p>Cuando volvemos a ejecutar los tests, veremos una secci√≥n en el output de los
tests para el archivo <em>common.rs</em>, aunque este archivo no contiene ninguna
funci√≥n de test ni hemos llamada a la funci√≥n <code>setup</code> desde ning√∫n lado:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Tener <code>common</code> apareciendo en los resultados de los tests con <code>running 0 tests</code>
mostrado para √©l no es lo que quer√≠amos. Solo quer√≠amos compartir algo de c√≥digo
con los otros archivos de test de integraci√≥n.</p>
<p>Para evitar que <code>common</code> aparezca en el output de los tests, en lugar de crear
<em>tests/common.rs</em>, crearemos <em>tests/common/mod.rs</em>. El directorio del proyecto
ahora se ve as√≠:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ common
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs
    ‚îî‚îÄ‚îÄ integration_test.rs
</code></pre>
<p>Esta es la convenci√≥n de nomenclatura anterior que Rust tambi√©n entiende y que
mencionamos en la secci√≥n <a href="ch07-05-separating-modules-into-different-files.html#rutas-alternativas-de-archivos">‚ÄúRutas de Archivos Alternativas‚Äù</a> del
Cap√≠tulo 7. Nombrar el archivo de esta manera le dice a Rust que no trate al
m√≥dulo <code>common</code> como un archivo de test de integraci√≥n. Cuando movemos el c√≥digo
de la funci√≥n <code>setup</code> a <em>tests/common/mod.rs</em> y borramos el archivo
<em>tests/common.rs</em>, la secci√≥n en el output de los tests ya no aparecer√°. Los
archivos en subdirectorios del directorio <em>tests</em> no son compilados como crates
separados ni tienen secciones en el output de los tests.</p>
<p>Despu√©s de haber creado <em>tests/common/mod.rs</em>, podemos usarlo desde cualquier
archivo de test de integraci√≥n como un m√≥dulo. Aqu√≠ hay un ejemplo de llamar a
la funci√≥n <code>setup</code> desde el test <code>it_adds_two</code> en <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}</code></pre>
<p>Nota que la declaraci√≥n <code>mod common;</code> es la misma que la declaraci√≥n de m√≥dulo
que demostramos en el Listado 7-21. Luego, en la funci√≥n de test, podemos llamar
a la funci√≥n <code>common::setup()</code>.</p>
<h4 id="tests-de-integraci√≥n-para-crates-binarios"><a class="header" href="#tests-de-integraci√≥n-para-crates-binarios">Tests de Integraci√≥n para Crates Binarios</a></h4>
<p>Si nuestro proyecto es un crate binario que solo contiene un archivo
<em>src/main.rs</em> y no tiene un archivo <em>src/lib.rs</em>, no podemos crear tests de
integraci√≥n en el directorio <em>tests</em> y traer funciones definidas en el archivo
<em>src/main.rs</em> al scope con una declaraci√≥n <code>use</code>. Solo los crates de librer√≠a
exponen funciones que otros crates pueden usar; los crates binarios est√°n
destinados a ser ejecutados por s√≠ mismos.</p>
<p>Esta es una de las razones por las que los proyectos Rust que proveen un binario
tienen un archivo <em>src/main.rs</em> que llama a la l√≥gica que vive en el archivo
<em>src/lib.rs</em>. Usando esa estructura, los tests de integraci√≥n <em>pueden</em> probar el
crate de la librer√≠a con <code>use</code> para hacer que la funcionalidad importante est√©
disponible. Si la funcionalidad importante funciona, la peque√±a cantidad de
c√≥digo en el archivo <em>src/main.rs</em> tambi√©n funcionar√°, y ese peque√±o c√≥digo no
necesita ser testeado.</p>
<h2 id="resumen-10"><a class="header" href="#resumen-10">Resumen</a></h2>
<p>Las caracter√≠sticas de testing de Rust proveen una manera de especificar c√≥mo el
c√≥digo deber√≠a funcionar para asegurarse de que contin√∫e funcionando como
esperas, incluso mientras haces cambios. Los tests unitarios ejercitan
diferentes partes de una librer√≠a por separado y pueden testear detalles de
implementaci√≥n privados. Los tests de integraci√≥n chequean que muchas partes de
la librer√≠a funcionen juntas correctamente, y usan la API p√∫blica de la
librer√≠a para testear el c√≥digo de la misma manera que el c√≥digo externo lo
usar√°. Aunque el sistema de tipos y las reglas de ownership de Rust ayudan a
prevenir algunos tipos de bugs, los tests son todav√≠a importantes para reducir
bugs de l√≥gica que tienen que ver con c√≥mo se espera que tu c√≥digo se comporte.</p>
<p>¬°Combinemos el conocimiento que aprendiste en este cap√≠tulo y en cap√≠tulos
anteriores para trabajar en un proyecto!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="un-proyecto-de-io-construyendo-un-programa-de-l√≠nea-de-comandos"><a class="header" href="#un-proyecto-de-io-construyendo-un-programa-de-l√≠nea-de-comandos">Un proyecto de I/O: Construyendo un programa de l√≠nea de comandos</a></h1>
<p>Este cap√≠tulo es un resumen de las muchas habilidades que has aprendido hasta
ahora y una exploraci√≥n de algunas caracter√≠sticas m√°s de la biblioteca est√°ndar.
Construiremos una herramienta de l√≠nea de comandos que interact√∫a con la entrada
y salida de archivos y de l√≠nea de comandos para practicar algunos de los
conceptos de Rust que ahora tienes bajo el cintur√≥n.</p>
<p>La velocidad, la seguridad, la salida binaria √∫nica y el soporte multiplataforma
de Rust hacen que sea un lenguaje ideal para crear herramientas de l√≠nea de
comandos, as√≠ que para nuestro proyecto, haremos nuestra propia versi√≥n de la
herramienta de b√∫squeda cl√°sica de la l√≠nea de comandos <code>grep</code> (<strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). En el caso de uso m√°s
simple, <code>grep</code> busca un archivo especificado para una cadena especificada.
Para ello, <code>grep</code> toma como argumentos una ruta de archivo y una cadena. Luego
lee el archivo, encuentra las l√≠neas en ese archivo que contienen el argumento
de cadena y las imprime.</p>
<p>En el camino, mostraremos c√≥mo hacer que nuestra herramienta de l√≠nea de comandos
use las caracter√≠sticas del terminal que muchas otras herramientas de l√≠nea de
comandos usan. Leeremos el valor de una variable de entorno para permitir que el
usuario configure el comportamiento de nuestra herramienta. Tambi√©n imprimiremos
mensajes de error a la consola de error est√°ndar (<code>stderr</code>) en lugar de la
salida est√°ndar (<code>stdout</code>), para que, por ejemplo, el usuario pueda redirigir
la salida exitosa a un archivo y seguir viendo los mensajes de error en la
pantalla.</p>
<p>Andrew Gallant, miembro de la comunidad de Rust, ya ha creado una versi√≥n
completamente funcional y muy r√°pida de <code>grep</code>, llamada <code>ripgrep</code>. En
comparaci√≥n, nuestra versi√≥n ser√° bastante simple, pero este cap√≠tulo te dar√°
algunos de los conocimientos b√°sicos que necesitas para entender un proyecto
del mundo real como <code>ripgrep</code>.</p>
<p>Nuestro proyecto <code>grep</code> combinar√° una serie de conceptos que has aprendido
hasta ahora:</p>
<ul>
<li>Organizar c√≥digo (usando lo que aprendiste sobre m√≥dulos en
<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Cap√≠tulo 7</a><!-- ignore -->)</li>
<li>Uso de vectores y strings (colecciones, <a href="ch08-00-common-collections.html">Cap√≠tulo 8</a><!-- ignore -->)</li>
<li>Manejo de errores (<a href="ch09-00-error-handling.html">Cap√≠tulo 9</a><!-- ignore -->)</li>
<li>Uso de traits y lifetimes cuando corresponda (<a href="ch10-00-generics.html">Cap√≠tulo 10</a><!-- ignore
  -->)</li>
<li>Escribiendo tests (<a href="ch11-00-testing.html">Cap√≠tulo 11</a><!-- ignore -->)</li>
</ul>
<p>Tambi√©n presentaremos brevemente los closures, iterators, y trait objects, que
los cap√≠tulos <a href="ch13-00-functional-features.html">13</a><!-- ignore --> y <a href="ch17-00-oop.html">17</a><!-- ignore --> cubrir√°n en
detalle.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="aceptando-argumentos-de-l√≠nea-de-comandos"><a class="header" href="#aceptando-argumentos-de-l√≠nea-de-comandos">Aceptando argumentos de l√≠nea de comandos</a></h2>
<p>Vamos a crear un nuevo proyecto con, como siempre, <code>cargo new</code>. Llamaremos a
nuestro proyecto <code>minigrep</code> para distinguirlo de la herramienta <code>grep</code> que
puede que ya tengas en tu sistema.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>La primera tarea es hacer que <code>minigrep</code> acepte sus dos argumentos de l√≠nea de
comandos: la ruta del archivo y una cadena para buscar. Es decir, queremos
poder ejecutar nuestro programa con <code>cargo run</code>, dos guiones para indicar que
los siguientes argumentos son para nuestro programa en lugar de para <code>cargo</code>,
una cadena para buscar y una ruta a un archivo para buscar, as√≠:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>En este momento, el programa generado por <code>cargo new</code> no puede procesar los
argumentos que le damos. Algunas bibliotecas existentes en
<a href="https://crates.io/">crates.io</a> pueden ayudar a escribir un programa que
acepte argumentos de l√≠nea de comandos, pero como est√°s aprendiendo este
concepto, implementemos esta capacidad nosotros mismos.</p>
<h3 id="leyendo-los-valores-de-los-argumentos"><a class="header" href="#leyendo-los-valores-de-los-argumentos">Leyendo los valores de los argumentos</a></h3>
<p>Para permitir que <code>minigrep</code> lea los valores de los argumentos de l√≠nea de
comandos que le pasamos, necesitaremos la funci√≥n <code>std::env::args</code> proporcionada
en la biblioteca est√°ndar de Rust. Esta funci√≥n devuelve un iterador de los
argumentos de l√≠nea de comandos pasados a <code>minigrep</code>. Cubriremos los iteradores
completamente en <a href="ch13-00-functional-features.html">el cap√≠tulo 13</a><!-- ignore -->. Por ahora, solo
necesitas saber dos detalles sobre los iteradores: los iteradores producen una
serie de valores, y podemos llamar al m√©todo <code>collect</code> en un iterador para
convertirlo en una colecci√≥n, como un vector, que contiene todos los elementos
que el iterador produce.</p>
<p>El c√≥digo en el Listado 12-1 permite que tu programa <code>minigrep</code> lea cualquier
argumento de l√≠nea de comandos que se le pase y luego recoja los valores en un
vector.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<p><span class="caption">Listing 12-1: Recopilando los argumentos de l√≠nea de
comandos en un vector e imprimi√©ndolos</span></p>
<p>Primero, traemos el m√≥dulo <code>std::env</code> al alcance con una declaraci√≥n <code>use</code> para
que podamos usar su funci√≥n <code>args</code>. Ten en cuenta que la funci√≥n
<code>std::env::args</code> est√° anidada en dos niveles de m√≥dulos. Como discutimos en
<a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creando-rutas-de-use-idiomaticas">el cap√≠tulo 7</a><!-- ignore -->, en los casos en que la
funci√≥n deseada est√° anidada en m√°s de un m√≥dulo, hemos elegido traer el m√≥dulo
padre al alcance en lugar de la funci√≥n. Al hacerlo, podemos usar f√°cilmente
otras funciones de <code>std::env</code>. Tambi√©n es menos ambiguo que agregar
<code>use std::env::args</code> y luego llamar a la funci√≥n con solo <code>args</code>, porque
<code>args</code> podr√≠a confundirse f√°cilmente con una funci√≥n definida en el m√≥dulo
actual.</p>
<blockquote>
<h3 id="la-funci√≥n-args-y-unicode-inv√°lido"><a class="header" href="#la-funci√≥n-args-y-unicode-inv√°lido">La funci√≥n <code>args</code> y Unicode inv√°lido</a></h3>
<p>Ten en cuenta que <code>std::env::args</code> lanzar√° un p√°nico si alg√∫n argumento
contiene Unicode inv√°lido. Si tu programa necesita aceptar argumentos que
contengan Unicode inv√°lido, usa <code>std::env::args_os</code> en su lugar. Esa funci√≥n
devuelve un iterator que produce valores <code>OsString</code> en lugar de valores
<code>String</code>. Hemos elegido usar <code>std::env::args</code> aqu√≠ por simplicidad, porque
los valores <code>OsString</code> difieren seg√∫n la plataforma y son m√°s complejos de
trabajar que los valores <code>String</code>.</p>
</blockquote>
<p>En la primera l√≠nea de <code>main</code>, llamamos a <code>env::args</code> y usamos inmediatamente
<code>collect</code> para convertir el iterator en un vector que contiene todos los valores
producidos por el iterator. Podemos usar la funci√≥n <code>collect</code> para crear muchos
tipos de colecciones, por lo que anotamos expl√≠citamente el tipo de <code>args</code> para
especificar que queremos un vector de strings. Aunque rara vez necesitamos
anotar tipos en Rust, <code>collect</code> es una funci√≥n que a menudo necesitas anotar
porque Rust no puede inferir el tipo de colecci√≥n que deseas.</p>
<p>Finalmente, imprimimos el vector usando la macro debug. Intentemos ejecutar el
c√≥digo primero sin argumentos y luego con dos argumentos:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    &quot;target/debug/minigrep&quot;,
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    &quot;target/debug/minigrep&quot;,
    &quot;needle&quot;,
    &quot;haystack&quot;,
]
</code></pre>
<p>EL primer valor en el vector es <code>&quot;target/debug/minigrep&quot;</code>, que es el nombre de
nuestro binario. Esto coincide con el comportamiento de la lista de argumentos
en C, lo que permite que los programas usen el nombre por el que fueron
invocados en su ejecuci√≥n. A menudo es conveniente tener acceso al nombre del
programa en caso de que desees imprimirlo en mensajes o cambiar el
comportamiento del programa seg√∫n el alias de la l√≠nea de comandos que se us√≥
para invocar el programa. Pero para los prop√≥sitos de este cap√≠tulo, lo
ignoraremos y solo guardaremos los dos argumentos que necesitamos.</p>
<h3 id="guardando-los-valores-de-los-argumentos-en-variables"><a class="header" href="#guardando-los-valores-de-los-argumentos-en-variables">Guardando los valores de los argumentos en variables</a></h3>
<p>El programa actualmente puede acceder a los valores especificados como
argumentos de l√≠nea de comandos. Ahora necesitamos guardar los valores de los
dos argumentos en variables para que podamos usar los valores en el resto del
programa. Hacemos eso en el Listado 12-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!(&quot;Searching for {query}&quot;);
    println!(&quot;In file {file_path}&quot;);
}</code></pre>
<p><span class="caption">Listing 12-2: Creando variables para contener el argumento
de consulta y la ruta de archivo</span></p>
<p>Como vimos cuando imprimimos en el vector, el nombre del programa ocupa el
primer valor del vector en <code>args[0]</code>, por lo que estamos comenzando a leer los
argumentos en el √≠ndice <code>1</code>. El primer argumento <code>minigrep</code> que toma es la
cadena que estamos buscando, por lo que ponemos una referencia al primer
argumento en la variable <code>query</code>. El segundo argumento ser√° la ruta del archivo,
por lo que ponemos una referencia al segundo argumento en la variable
<code>file_path</code>.</p>
<p>Temporalmente, imprimimos los valores de estas variables para demostrar que el
c√≥digo est√° funcionando como pretendemos. Ejecutemos el programa nuevamente con
los argumentos <code>test</code> y <code>sample.txt</code>:</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>¬°Genial, el programa est√° funcionando! Los valores de los argumentos que
necesitamos se est√°n guardando en las variables correctas. M√°s adelante
agregaremos un manejo de errores para tratar ciertas situaciones err√≥neas
potenciales, como cuando el usuario no proporciona argumentos; por ahora,
ignoraremos esa situaci√≥n y trabajaremos en agregar capacidades de lectura de
archivos en su lugar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="leyendo-un-archivo"><a class="header" href="#leyendo-un-archivo">Leyendo un archivo</a></h2>
<p>Ahora agregaremos funcionalidad para leer el archivo especificado en el 
argumento <code>file_path</code>. Primero, necesitamos un archivo de muestra para probarlo:
¬°usaremos un archivo con una peque√±a cantidad de texto en varias l√≠neas con 
algunas palabras repetidas! ¬°El Listado 12-3 tiene un poema de Emily Dickinson 
que funcionar√° bien! Cree un archivo llamado <em>poem.txt</em> en el nivel ra√≠z de su
proyecto e ingrese el poema &quot;¬°Soy nadie! ¬øQui√©n eres t√∫?&quot;</p>
<p><span class="filename">Filename: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listing 12-3: Un poema de Emily Dickinson sirve como
buen caso de test</span></p>
<p>Con el texto en su lugar, edite <em>src/main.rs</em> y agregue c√≥digo para leer el
archivo, como se muestra en el Listado 12-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {query}&quot;);
</span>    println!(&quot;In file {file_path}&quot;);

    let contents = fs::read_to_string(file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    println!(&quot;With text:\n{contents}&quot;);
}</code></pre>
<p><span class="caption">Listing 12-4: Leyendo el contenido del archivo 
especificado por el segundo argumento</span></p>
<p>Primero, importamos la parte relevante de la biblioteca est√°ndar con una
sentencia <code>use</code>: necesitamos <code>std::fs</code> para manejar archivos.</p>
<p>En <code>main</code>, la nueva sentencia <code>fs::read_to_string</code> toma el <code>file_path</code>, abre
ese archivo y devuelve un <code>std::io::Result&lt;String&gt;</code> del contenido del archivo.</p>
<p>Luego, nuevamente agregamos una declaraci√≥n <code>println!</code> temporal que imprime el
valor de <code>contents</code> despu√©s de que se lee el archivo, para que podamos verificar
que el programa est√° funcionando hasta ahora.</p>
<p>Ejecutemos este c√≥digo con cualquier string como primer argumento de la l√≠nea de
comandos (porque a√∫n no hemos implementado la parte de b√∫squeda) y el archivo
<em>poem.txt</em> como segundo argumento:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>¬°Genial! El c√≥digo ley√≥ el archivo y luego imprimi√≥ el contenido del archivo.
Pero el c√≥digo tiene algunas fallas. En este momento, la funci√≥n <code>main</code> tiene
m√∫ltiples responsabilidades: en general, las funciones son m√°s claras y m√°s
f√°ciles de mantener si cada funci√≥n es responsable de una sola idea. El otro
problema es que no estamos manejando los errores tan bien como podr√≠amos. El
programa todav√≠a es peque√±o, por lo que estas fallas no son un gran problema,
pero a medida que el programa crece, ser√° m√°s dif√≠cil corregirlos de manera
limpia. Es una buena pr√°ctica comenzar a refactorizar desde el principio al
desarrollar un programa, porque es mucho m√°s f√°cil refactorizar cantidades
menores de c√≥digo. Haremos eso a continuaci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refactorizando-para-mejorar-la-modularidad-y-el-manejo-de-errores"><a class="header" href="#refactorizando-para-mejorar-la-modularidad-y-el-manejo-de-errores">Refactorizando para mejorar la modularidad y el manejo de errores</a></h2>
<p>Para mejorar nuestro programa, solucionaremos cuatro problemas que tienen que
ver con la estructura del programa y c√≥mo maneja los errores potenciales. En
primer lugar, nuestra funci√≥n <code>main</code> ahora realiza dos tareas: analiza los
argumentos y lee los archivos. A medida que nuestro programa crece, el n√∫mero
de tareas separadas que maneja la funci√≥n <code>main</code> aumentar√°. A medida que una
funci√≥n adquiere responsabilidades, se vuelve m√°s dif√≠cil de razonar, m√°s
dif√≠cil de probar y m√°s dif√≠cil de cambiar sin romper una de sus partes. Es
mejor separar la funcionalidad para que cada funci√≥n sea responsable de una
tarea.</p>
<p>Este problema tambi√©n est√° relacionado con el segundo problema: aunque <code>query</code>
y <code>file_path</code> son variables de configuraci√≥n para nuestro programa, variables
como <code>contents</code> se utilizan para realizar la l√≥gica del programa. Cuanto m√°s
largo sea <code>main</code>, m√°s variables necesitaremos para traer al alcance; Cuantas
m√°s variables tengamos en el alcance, m√°s dif√≠cil ser√° realizar un seguimiento
del prop√≥sito de cada una. Es mejor agrupar las variables de configuraci√≥n en
una estructura para que su prop√≥sito quede claro.</p>
<p>El tercer problema es que hemos usado <code>expect</code> para imprimir un mensaje de
error cuando falla la lectura del archivo, pero el mensaje de error solo
imprime <code>Should have been able to read the file</code>. La lectura de un archivo
puede fallar de varias maneras: por ejemplo, el archivo podr√≠a faltar, o
podr√≠amos no tener permiso para abrirlo. En este momento, independientemente
de la situaci√≥n, imprimir√≠amos el mismo mensaje de error para todo, ¬°lo que no
le dar√≠a al usuario ninguna informaci√≥n!</p>
<p>Cuarto, usamos <code>expect</code> repetidamente para manejar un error, y si el
usuario ejecuta nuestro programa sin especificar suficientes argumentos,
obtendr√°n un error de <code>√≠ndice fuera de l√≠mites</code> de Rust que no explica
claramente el problema. Ser√≠a mejor si todo el c√≥digo de manejo de errores
estuviera en un solo lugar para que los futuros mantenedores tuvieran un solo
lugar para consultar el c√≥digo si la l√≥gica de manejo de errores necesitaba
cambiar. Tener todo el c√≥digo de manejo de errores en un solo lugar tambi√©n
asegurar√° que estamos imprimiendo mensajes que ser√°n significativos para
nuestros usuarios finales.</p>
<p>Abordemos estos cuatro problemas refactorizando nuestro proyecto.</p>
<h3 id="separacion-de-preocupaciones-para-proyectos-binarios"><a class="header" href="#separacion-de-preocupaciones-para-proyectos-binarios">Separacion de preocupaciones para proyectos binarios</a></h3>
<p>El problema organizativo de asignar la responsabilidad de m√∫ltiples tareas a la
funci√≥n <code>main</code> es com√∫n a muchos proyectos binarios. Como resultado, la
comunidad de Rust ha desarrollado pautas para dividir las preocupaciones
separadas de un programa binario cuando <code>main</code> comienza a crecer. Este proceso
tiene los siguientes pasos:</p>
<ul>
<li>Divide tu programa en un <em>main.rs</em> y un <em>lib.rs</em> y mueve la l√≥gica de tu
programa a <em>lib.rs</em>.</li>
<li>Mientras la l√≥gica de an√°lisis de l√≠nea de comandos sea peque√±a, puede
permanecer en <em>main.rs</em>.</li>
<li>Cuando la l√≥gica de an√°lisis de l√≠nea de comandos comience a complicarse,
extr√°ela de <em>main.rs</em> y mu√©vala a <em>lib.rs</em>.</li>
</ul>
<p>Las responsabilidades que quedan en la funci√≥n <code>main</code> despu√©s de este proceso
deber√≠an limitarse a lo siguiente:</p>
<ul>
<li>Llamar a la l√≥gica de an√°lisis de l√≠nea de comandos con los valores de
argumento</li>
<li>Configuraci√≥n de cualquier otra configuraci√≥n</li>
<li>Llamando a una funci√≥n <code>run</code> en <em>lib.rs</em></li>
<li>Manejo del error si <code>run</code> devuelve un error</li>
</ul>
<p>Este patr√≥n se trata de separar las preocupaciones: <em>main.rs</em> maneja la
ejecuci√≥n del programa, y <em>lib.rs</em> maneja toda la l√≥gica de la tarea en
cuesti√≥n. Debido a que no puede probar la funci√≥n <code>main</code> directamente, esta
estructura le permite probar toda la l√≥gica de su programa movi√©ndola a
funciones en <em>lib.rs</em>. El c√≥digo que permanece en <em>main.rs</em> ser√° lo
suficientemente peque√±o como para verificar su correcci√≥n ley√©ndolo. Rehagamos
nuestro programa siguiendo este proceso.</p>
<h4 id="extracci√≥n-del-parser-de-argumentos"><a class="header" href="#extracci√≥n-del-parser-de-argumentos">Extracci√≥n del parser de argumentos</a></h4>
<p>Extraeremos la funcionalidad para analizar los argumentos en una funci√≥n que
<code>main</code> llamar√° para prepararse para mover la l√≥gica de an√°lisis de l√≠nea de
comandos a <em>src/lib.rs</em>. La lista 12-5 muestra el nuevo inicio de <code>main</code> que
llama a una nueva funci√≥n <code>parse_config</code>, que definiremos en <em>src/main.rs</em> por
el momento.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {query}&quot;);
</span><span class="boring">    println!(&quot;In file {file_path}&quot;);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<p><span class="caption">Listing 12-5: Extrayendo una funci√≥n <code>parse_config</code> de
<code>main</code></span></p>
<p>En este cambio, a√∫n estamos recopilando los argumentos de la l√≠nea de comandos
en un vector, pero en lugar de asignar el valor del argumento en el √≠ndice 1 a
la variable <code>query</code> y el valor del argumento en el √≠ndice 2 a la variable
<code>file_path</code> dentro de la funci√≥n <code>main</code>, pasamos todo el vector a la funci√≥n
<code>parse_config</code>. La funci√≥n <code>parse_config</code> luego tiene la l√≥gica que determina
qu√© argumento va en qu√© variable y pasa los valores de vuelta a <code>main</code>. Todav√≠a
creamos las variables <code>query</code> y <code>file_path</code> en <code>main</code>, pero <code>main</code> ya no tiene
la responsabilidad de determinar c√≥mo se corresponden los argumentos de la
l√≠nea de comandos y las variables.</p>
<p>Esta reorganizaci√≥n puede parecer excesiva para nuestro peque√±o programa, pero
estamos refactorizando en peque√±os pasos incrementales. Despu√©s de hacer este
cambio, ejecute el programa nuevamente para verificar que el an√°lisis de
argumentos a√∫n funcione. Es bueno verificar su progreso con frecuencia, para
ayudar a identificar la causa de los problemas cuando ocurren.</p>
<h4 id="agrupaci√≥n-de-valores-de-configuraci√≥n"><a class="header" href="#agrupaci√≥n-de-valores-de-configuraci√≥n">Agrupaci√≥n de valores de configuraci√≥n</a></h4>
<p>Podemos dar otro peque√±o paso para mejorar a√∫n m√°s la funci√≥n <code>parse_config</code>.
En este momento, estamos devolviendo una tupla, pero luego rompemos esa tupla
en partes individuales nuevamente. Esto es una se√±al de que tal vez no
tenemos la abstracci√≥n correcta todav√≠a.</p>
<p>Otro indicador que muestra que hay margen de mejora es la parte <code>config</code> de
<code>parse_config</code>, que implica que los dos valores que devolvemos est√°n
relacionados y ambos son parte de un valor de configuraci√≥n. Actualmente, no
estamos transmitiendo este significado en el struct de los datos que no sea
agrupar los dos valores en una tupla; en su lugar, pondremos los dos valores en
un struct y daremos a cada uno de los campos del struct un nombre significativo.
Hacerlo har√° que sea m√°s f√°cil para los futuros mantenedores de este c√≥digo
comprender c√≥mo se relacionan los diferentes valores entre s√≠ y cu√°l es su
prop√≥sito.</p>
<p>Listing 12-6 muestra las mejoras a la funci√≥n <code>parse_config</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<p><span class="caption">Listing 12-6: Refactorizando <code>parse_config</code> para que
devuelva una instancia de un struct <code>Config</code></span></p>
<p>Hemos agregado un struct llamado <code>Config</code> definido para tener campos llamados
<code>query</code> y <code>file_path</code>. La firma de <code>parse_config</code> ahora √≠ndica que devuelve un
valor <code>Config</code>. En el cuerpo de <code>parse_config</code>, donde sol√≠amos devolver
rebanadas de cadena que hacen referencia a valores <code>String</code> en <code>args</code>, ahora
definimos <code>Config</code> para contener valores <code>String</code> de propiedad. La variable
<code>args</code> en <code>main</code> es el propietario de los valores de argumento y solo permite
que la funci√≥n <code>parse_config</code> los pida prestados, lo que significa que
violar√≠amos las reglas de pr√©stamo de Rust si <code>Config</code> intentara tomar
posesi√≥n de los valores en <code>args</code>.</p>
<p>Hay varias formas de administrar los datos de <code>String</code>; la m√°s f√°cil, aunque
algo ineficiente, es llamar al m√©todo <code>clone</code> en los valores. Esto har√° una
copia completa de los datos para que la instancia de <code>Config</code> posea, lo que
toma m√°s tiempo y memoria que almacenar una referencia a los datos de string.
Sin embargo, clonar los datos tambi√©n hace que nuestro c√≥digo sea muy
sencillo porque no tenemos que administrar los lifetimes de las referencias; en
estas circunstancias, renunciar a un poco de rendimiento para ganar simplicidad
es un intercambio v√°lido.</p>
<blockquote>
<h3 id="los-intercambios-de-usar-clone"><a class="header" href="#los-intercambios-de-usar-clone">Los intercambios de usar <code>clone</code></a></h3>
<p>Hay una tendencia entre muchos Rustaceans a evitar usar <code>clone</code> para
solucionar problemas de propiedad debido a su costo de tiempo de ejecuci√≥n.
En <a href="ch13-00-functional-features.html">el cap√≠tulo 13</a><!-- ignore -->, aprender√° a usar m√©todos m√°s
eficientes en este tipo de situaciones. Pero por ahora, est√° bien copiar
algunas cadenas para seguir progresando porque solo har√°s estas copias una
vez y tu ruta de archivo y cadena de consulta son muy peque√±as. Es mejor
tener un programa que funcione un poco ineficiente que intentar
hiperoptimizar el c√≥digo en tu primer paso. A medida que adquieras m√°s
experiencia con Rust, ser√° m√°s f√°cil comenzar con la soluci√≥n m√°s eficiente,
, pero por ahora, es perfectamente aceptable llamar a <code>clone</code>.</p>
</blockquote>
<p>Hemos actualizado <code>main</code> para que coloque la instancia de <code>Config</code> devuelta por
<code>parse_config</code> en una variable llamada <code>config</code>, y hemos actualizado el c√≥digo
que anteriormente usaba las variables separadas <code>query</code> y <code>file_path</code> para que
ahora use los campos en el struct <code>Config</code> en su lugar.</p>
<p>Ahora nuestro c√≥digo transmite m√°s claramente que <code>query</code> y <code>file_path</code> est√°n
relacionados y que su prop√≥sito es configurar c√≥mo funcionar√° el programa.
Cualquier c√≥digo que use estos valores sabe que debe buscarlos en la instancia
<code>config</code> en los campos nombrados por su prop√≥sito.</p>
<h4 id="creando-un-constructor-para-config"><a class="header" href="#creando-un-constructor-para-config">Creando un constructor para <code>Config</code></a></h4>
<p>Hasta ahora, hemos extra√≠do la l√≥gica responsable de analizar los argumentos de
la l√≠nea de comandos de <code>main</code> y la hemos colocado en la funci√≥n <code>parse_config</code>.
Hacerlo nos ayud√≥ a ver que los valores <code>query</code> y <code>file_path</code> estaban
relacionados y que esa relaci√≥n deber√≠a transmitirse en nuestro c√≥digo. Luego
agregamos un struct <code>Config</code> para nombrar el prop√≥sito relacionado de <code>query</code>
y <code>file_path</code> y poder devolver los nombres de los valores como nombres de campo
de struct desde la funci√≥n <code>parse_config</code>.</p>
<p>As√≠ que ahora el prop√≥sito de la funci√≥n <code>parse_config</code> es crear una instancia
de <code>Config</code>, podemos cambiar <code>parse_config</code> de una funci√≥n normal a una funci√≥n
llama <code>new</code> que es asociada con <code>Config</code>. que est√© asociada con el struct
<code>Config</code>. Haciendo este cambio, el c√≥digo ser√° m√°s idiom√°tico. Podemos crear
instancias de tipos en la biblioteca est√°ndar, como <code>String</code>, llamando a
<code>String::new</code>. De manera similar, al cambiar <code>parse_config</code> a una funci√≥n
asociada con <code>Config</code>, podremos crear instancias de <code>Config</code> llamando a
<code>Config::new</code>. El listado 12-7 muestra los cambios que debemos hacer.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<p><span class="caption">Listing 12-7: Cambiando <code>parse_config</code> a
<code>Config::new</code></span></p>
<p>Hemos actualizado <code>main</code> donde est√°bamos llamando a <code>parse_config</code> para que en
su lugar llame a <code>Config::new</code>. Hemos cambiado el nombre de <code>parse_config</code> a
<code>new</code> y lo hemos movido dentro de un bloque <code>impl</code>, que asocia la funci√≥n <code>new</code>
con <code>Config</code>. Intenta compilar este c√≥digo nuevamente para asegurarte de que
funciona.</p>
<h3 id="arreglando-el-manejo-de-errores"><a class="header" href="#arreglando-el-manejo-de-errores">Arreglando el manejo de errores</a></h3>
<p>Ahora trabajaremos en la correcci√≥n de nuestro manejo de errores. Recuerda que
intentar acceder a los valores en el vector <code>args</code> en el √≠ndice 1 o el √≠ndice
2 har√° que el programa entre en p√°nico si el vector contiene menos de tres
elementos. Intenta ejecutar el programa sin ning√∫n argumento; se ver√° as√≠:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>La l√≠nea <code>index out of bounds: the len is 1 but the index is 1</code> es un mensaje
de error destinado a los programadores. No ayudar√° a nuestros usuarios finales
a comprender lo que deben hacer en su lugar. Arreglemos eso ahora.</p>
<h4 id="mejorando-el-mensaje-de-error"><a class="header" href="#mejorando-el-mensaje-de-error">Mejorando el mensaje de error</a></h4>
<p>En el Listado 12-8, agregamos una verificaci√≥n en la funci√≥n <code>new</code> que
verificar√° que el slice sea lo suficientemente largo antes de acceder al √≠ndice
1 y 2. Si el slice no es lo suficientemente largo, el programa entra en p√°nico
y muestra un mensaje de error mejor.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;not enough arguments&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-8: Agregando una verificaci√≥n para el n√∫mero de
argumentos</span></p>
<p>Este c√≥digo es similar a <a href="ch09-03-to-panic-or-not-to-panic.html#creacion-de-tipos-personalizados-para-validacion">la funci√≥n <code>Guess::new</code> que escribimos en el Listado
9-13</a><!-- ignore -->, donde llamamos a <code>panic!</code> cuando el
argumento <code>value</code> estaba fuera del rango de valores v√°lidos. En lugar de
verificar un rango de valores aqu√≠, estamos verificando que la longitud de
<code>args</code> sea al menos 3 y el resto de la funci√≥n puede operar bajo la suposici√≥n
de que esta condici√≥n se ha cumplido. Si <code>args</code> tiene menos de tres elementos,
esta condici√≥n ser√° verdadera y llamaremos a la macro <code>panic!</code> para finalizar
el programa inmediatamente.</p>
<p>Con estas pocas l√≠neas de c√≥digo adicionales en <code>new</code>, ejecutemos el programa
sin ning√∫n argumento nuevamente para ver c√≥mo se ve el error ahora:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Este output es mejor: ahora tenemos un mensaje de error razonable. Sin embargo,
tambi√©n tenemos informaci√≥n superflua que no queremos dar a nuestros usuarios.
Quiz√°s usar la t√©cnica que usamos en el Listado 9-13 no es la mejor para usar
aqu√≠: una llamada a <code>panic!</code> es m√°s apropiada para un problema de programaci√≥n
que para un problema de uso,
<a href="ch09-03-to-panic-or-not-to-panic.html#pautas-para-el-manejo-de-errores">como se discuti√≥ en el Cap√≠tulo 9</a><!-- ignore -->.
En su lugar, usaremos la otra t√©cnica que aprendiste en el Cap√≠tulo 9:
<a href="ch09-02-recoverable-errors-with-result.html">devolver un <code>Result</code></a><!-- ignore --> que indique el √©xito o un
error.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="devolver-un-result-en-lugar-de-llamar-a-panic"><a class="header" href="#devolver-un-result-en-lugar-de-llamar-a-panic">Devolver un <code>Result</code> en lugar de llamar a <code>panic!</code></a></h4>
<p>En su lugar, podemos devolver un <code>Result</code> que contendr√° una instancia de
<code>Config</code> en el caso de √©xito y describir√° el problema en el caso de error.
Tambi√©n cambiaremos el nombre de la funci√≥n de <code>new</code> a <code>build</code> porque muchos
programadores esperan que las funciones <code>new</code> nunca fallen. Cuando
<code>Config::build</code> se comunique con <code>main</code>, podemos usar el tipo <code>Result</code> para
se√±alar que hubo un problema. Luego podemos cambiar <code>main</code> para convertir una
variante <code>Err</code> en un error m√°s pr√°ctico para nuestros usuarios sin el texto
circundante sobre <code>thread 'main'</code> y <code>RUST_BACKTRACE</code> que una llamada a <code>panic!</code>
provoca.</p>
<p>El Listado 12-9 muestra los cambios que debemos hacer en el valor de retorno de
la funci√≥n que ahora llamamos <code>Config::build</code> y el cuerpo de la funci√≥n
necesario para devolver un <code>Result</code>. Ten en cuenta que esto no se compilar√°
hasta que actualicemos <code>main</code> tambi√©n, lo cual haremos en el siguiente
listado.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<p><span class="caption">Listing 12-9: Devolviendo un <code>Result</code> desde
<code>Config::build</code></span></p>
<p>Nuestra funci√≥n <code>build</code> devuelve un <code>Result</code> con una instancia de <code>Config</code> en
el caso de √©xito y una referencia a un string en el caso de error. Nuestros
valores de error siempre ser√°n string literals que tengan el lifetime <code>'static</code>.</p>
<p>Hemos hecho dos cambios en el cuerpo de la funci√≥n: en lugar de llamar a
<code>panic!</code> cuando el usuario no pasa suficientes argumentos, ahora devolvemos un
valor <code>Err</code>, y hemos envuelto el valor de retorno <code>Config</code> en un <code>Ok</code>. Estos
cambios hacen que la funci√≥n se ajuste a su nueva firma de tipo.</p>
<p>Devolviendo un valor <code>Err</code> desde <code>Config::build</code> permite que la funci√≥n
<code>main</code> maneje el <code>Result</code> devuelto por la funci√≥n <code>build</code> y salga del proceso
de manera m√°s limpia en el caso de error.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="llamando-a-configbuild-y-manejando-errores"><a class="header" href="#llamando-a-configbuild-y-manejando-errores">Llamando a <code>Config::build</code> y manejando errores</a></h4>
<p>Para manejar el caso de error e imprimir un mensaje amigable para el usuario,
necesitamos actualizar <code>main</code> para manejar el <code>Result</code> que devuelve
<code>Config::build</code>, como se muestra en el Listado 12-10. Tambi√©n tomaremos la
responsabilidad de salir de la herramienta de l√≠nea de comandos con un c√≥digo
de error distinto de cero de <code>panic!</code> e implementarlo a mano. Un estado de
salida distinto de cero es una convenci√≥n para se√±alar al proceso que llam√≥ a
nuestro programa que el programa sali√≥ con un estado de error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-10: Saliendo con un c√≥digo de error si falla la
construcci√≥n de una <code>Config</code></span></p>
<p>En este listado, hemos usado un m√©todo que a√∫n no hemos cubierto en detalle:
<code>unwrap_or_else</code>, que est√° definido en <code>Result&lt;T, E&gt;</code> por la biblioteca
est√°ndar. Usar <code>unwrap_or_else</code> nos permite definir un manejo de errores
personalizado que no sea <code>panic!</code>. Si el <code>Result</code> es un valor <code>Ok</code>, el
comportamiento de este m√©todo es similar a <code>unwrap</code>: devuelve el valor interno
que <code>Ok</code> est√° envolviendo. Sin embargo, si el valor es un valor <code>Err</code>, este
m√©todo llama al c√≥digo en el <em>closure</em>, que es una funci√≥n an√≥nima que
definimos y pasamos como argumento a <code>unwrap_or_else</code>. Cubriremos los closures
con m√°s detalle en el <a href="ch13-00-functional-features.html">Cap√≠tulo 13</a><!-- ignore -->. Por ahora, solo
necesitas saber que <code>unwrap_or_else</code> pasar√° el valor interno del <code>Err</code>, que en
este caso es el string est√°tico <code>&quot;not enough arguments&quot;</code> que agregamos en el
Listado 12-9, a nuestro closure en el argumento <code>err</code> que aparece entre las
barras verticales <code>|</code>. El c√≥digo en el closure imprime el valor de <code>err</code> cuando
se ejecuta.</p>
<p>Hemos agregado una nueva l√≠nea <code>use</code> para traer <code>process</code> de la biblioteca
est√°ndar al alcance. El c√≥digo en el closure que se ejecutar√° en el caso de
error es solo de dos l√≠neas: imprimimos el valor de <code>err</code> y luego llamamos a
<code>process::exit</code>. La funci√≥n <code>process::exit</code> detendr√° el programa
inmediatamente y devolver√° el n√∫mero que se pas√≥ como c√≥digo de estado de
salida. Esto es similar al manejo basado en <code>panic!</code> que usamos en el Listado
12-8, pero ya no obtenemos todo el output extra. ¬°Prob√©moslo!</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>¬°Genial! Este output es mucho m√°s amigable para nuestros usuarios.</p>
<h3 id="extrayendo-la-l√≥gica-de-main"><a class="header" href="#extrayendo-la-l√≥gica-de-main">Extrayendo la l√≥gica de <code>main</code></a></h3>
<p>Ahora que hemos terminado de refactorizar el an√°lisis de configuraci√≥n, pasemos
a la l√≥gica del programa. Como dijimos en <a href="ch12-03-improving-error-handling-and-modularity.html#separacion-de-preocupaciones-para-proyectos-binarios">‚ÄúSeparaci√≥n de preocupaciones para
proyectos
binarios‚Äù</a><!-- ignore -->
, extraeremos una funci√≥n llamada <code>run</code> que contendr√° toda la l√≥gica actualmente
en la funci√≥n <code>main</code> que no est√° involucrada con la configuraci√≥n o el manejo
de errores. Cuando terminemos, <code>main</code> ser√° conciso y f√°cil de verificar por
inspecci√≥n, y podremos escribir pruebas para toda la otra l√≥gica.</p>
<p>El Listado 12-11 muestra la funci√≥n <code>run</code> extra√≠da. Por ahora, solo estamos
haciendo la peque√±a mejora incremental de extraer la funci√≥n. Todav√≠a estamos
definiendo la funci√≥n en <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    println!(&quot;With text:\n{contents}&quot;);
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-11: Extracting a <code>run</code> function containing the
rest of the program logic</span></p>
<p>La funci√≥n <code>run</code> ahora contiene toda la l√≥gica restante de <code>main</code>, comenzando
desde la lectura del archivo. La funci√≥n <code>run</code> toma la instancia de <code>Config</code>
como argumento.</p>
<h4 id="devolviendo-errores-desde-la-funci√≥n-run"><a class="header" href="#devolviendo-errores-desde-la-funci√≥n-run">Devolviendo errores desde la funci√≥n <code>run</code></a></h4>
<p>Con la l√≥gica del programa restante separada en la funci√≥n <code>run</code>, podemos
mejorar el manejo de errores, como hicimos con <code>Config::build</code> en el Listado
12-9. En lugar de permitir que el programa entre en p√°nico llamando a
<code>expect</code>, la funci√≥n <code>run</code> devolver√° un <code>Result&lt;T, E&gt;</code> cuando algo salga mal.
Esto nos permitir√° consolidar a√∫n m√°s la l√≥gica que rodea el manejo de errores
en <code>main</code> de una manera amigable para el usuario. El Listado 12-12 muestra los
cambios que debemos hacer en la firma y el cuerpo de <code>run</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!(&quot;With text:\n{contents}&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-12: Cambiando la funci√≥n <code>run</code> para devolver
<code>Result</code></span></p>
<p>Hemos realizado tres cambios significativos aqu√≠. Primero, cambiamos el tipo de
retorno de la funci√≥n <code>run</code> a <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. Esta funci√≥n
anteriormente devolv√≠a el tipo unitario, <code>()</code>, y lo mantenemos como el valor
devuelto en el caso <code>Ok</code>.</p>
<p>Para el tipo de error, usamos el <em>trait object</em> <code>Box&lt;dyn Error&gt;</code> (y hemos
tra√≠do <code>std::error::Error</code> al alcance con una declaraci√≥n <code>use</code> en la parte
superior). Cubriremos los <em>trait objects</em> en el <a href="ch17-00-oop.html">Cap√≠tulo 17</a><!-- ignore
-->. Por ahora, solo sepa que <code>Box&lt;dyn Error&gt;</code> significa que la funci√≥n
devolver√° un tipo que implementa el trait <code>Error</code>, pero no tenemos que
especificar qu√© tipo particular ser√° el valor de retorno. Esto nos da
flexibilidad para devolver valores de error que pueden ser de diferentes tipos
en diferentes casos de error. La palabra clave <code>dyn</code> es corta para ‚Äúdynamic‚Äù.</p>
<p>Segundo, hemos eliminado la llamada a <code>expect</code> en favor del operador <code>?</code>, como
hablamos en el <a href="ch09-02-recoverable-errors-with-result.html#un-atajo-para-propagar-errores-el-operador-">Cap√≠tulo 9</a><!-- ignore -->. En lugar de
<code>panic!</code> en un error, <code>?</code> devolver√° el valor de error de la funci√≥n actual para
que el llamador lo maneje.</p>
<p>Tercero, la funci√≥n <code>run</code> ahora devuelve un valor <code>Ok</code> en caso de √©xito. Hemos
declarado con √©xito la funci√≥n <code>run</code> como <code>()</code> en la firma, lo que significa
que necesitamos envolver el valor unitario en el valor <code>Ok</code>. Esta sintaxis
<code>Ok(())</code> puede parecer un poco extra√±a al principio, pero usar <code>()</code> de esta
manera es la forma idiom√°tica de indicar que estamos llamando a <code>run</code> solo por
sus efectos secundarios; no devuelve un valor que necesitamos.</p>
<p>Cuando ejecutamos el c√≥digo, se compila, pero no muestra nada:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust nos dice que nuestro c√≥digo ignor√≥ el valor <code>Result</code> y el valor <code>Result</code>
podr√≠a indicar que ocurri√≥ un error. Pero no estamos comprobando si hubo un
error o no, ¬°y el compilador nos recuerda que probablemente quisimos tener algo
de c√≥digo de manejo de errores aqu√≠! Corrijamos ese problema ahora.</p>
<h4 id="manejando-errores-devueltos-por-run-en-main"><a class="header" href="#manejando-errores-devueltos-por-run-en-main">Manejando errores devueltos por <code>run</code> en <code>main</code></a></h4>
<p>Comprobaremos los errores y los manejaremos usando una t√©cnica similar a la que
usamos con <code>Config::build</code> en el Listado 12-10, pero con una ligera diferencia:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {e}&quot;);
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Usamos <code>if let</code> en lugar de <code>unwrap_or_else</code> para verificar si <code>run</code> devuelve un
valor <code>Err</code> y llamar a <code>process::exit(1)</code> si lo hace. La funci√≥n <code>run</code> no
devuelve un valor que queremos <code>unwrap</code> de la misma manera que <code>Config::build</code>
devuelve la instancia de <code>Config</code>. Debido a que <code>run</code> devuelve <code>()</code> en el caso
de √©xito, solo nos importa detectar un error, por lo que no necesitamos que
<code>unwrap_or_else</code> devuelva el valor desempaquetado, que solo ser√≠a <code>()</code>.</p>
<p>Los cuerpos de las funciones <code>if let</code> y <code>unwrap_or_else</code> son los mismos en
ambos casos: imprimimos el error y salimos.</p>
<h3 id="dividiendo-el-c√≥digo-en-un-crate-de-biblioteca"><a class="header" href="#dividiendo-el-c√≥digo-en-un-crate-de-biblioteca">Dividiendo el c√≥digo en un crate de biblioteca</a></h3>
<p>Nuestro proyecto <code>minigrep</code> se ve bien hasta ahora. Ahora dividiremos el archivo
<em>src/main.rs</em> y pondremos parte del c√≥digo en el archivo <em>src/lib.rs</em>. De esa
manera podemos probar el c√≥digo y tener un archivo <em>src/main.rs</em> con menos
responsabilidades.</p>
<p>Vamos a mover todo el c√≥digo que no sea la funci√≥n <code>main</code> de <em>src/main.rs</em> a
<em>src/lib.rs</em>:</p>
<ul>
<li>La funci√≥n <code>run</code></li>
<li>Las declaraciones <code>use</code> relevantes</li>
<li>La definici√≥n de <code>Config</code></li>
<li>La funci√≥n <code>Config::build</code></li>
</ul>
<p>El contenido de <em>src/main.rs</em> deber√≠a tener la firma que se muestra en el
Listado 12-13 (omitimos los cuerpos de las funciones por brevedad). Ten en
cuenta que esto no se compilar√° hasta que modifiquemos <em>src/main.rs</em> en el
Listado 12-14.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Listing 12-13: Moviendo <code>Config</code> y <code>run</code> a
<em>src/lib.rs</em></span></p>
<p>Hemos hecho uso de la palabra clave <code>pub</code>: en <code>Config</code>, en sus campos y en su
m√©todo <code>build</code>, y en la funci√≥n <code>run</code>. ¬°Ahora tenemos un crate de biblioteca que
tiene una API p√∫blica que podemos probar!.</p>
<p>Ahora necesitamos traer el c√≥digo que movimos a <em>src/lib.rs</em> al scope del crate
binario en <em>src/main.rs</em>, como se muestra en el Listado 12-14.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!(&quot;Application error: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<p><span class="caption">Listing 12-14: Usando el crate biblioteca <code>minigrep</code> en
<em>src/main.rs</em></span></p>
<p>Agregamos una l√≠nea <code>use minigrep::Config</code> para traer el tipo <code>Config</code> desde el
crate de biblioteca al scope del crate binario, y agregamos el prefijo
<code>minigrep::</code> a la llamada a <code>run</code>. Ahora toda la funcionalidad deber√≠a estar
conectada y deber√≠a funcionar. Ejecuta el programa con <code>cargo run</code> y aseg√∫rate
de que todo funcione correctamente.</p>
<p>¬°Uf! Eso fue mucho trabajo, pero nos hemos preparado para el √©xito en el
futuro. Ahora es mucho m√°s f√°cil manejar errores, y hemos hecho que el c√≥digo
sea m√°s modular. Casi todo nuestro trabajo se har√° en <em>src/lib.rs</em> a partir de
ahora.</p>
<p>¬°Aprovechemos esta nueva modularidad haciendo algo que habr√≠a sido dif√≠cil con
el c√≥digo antiguo, pero es f√°cil con el nuevo c√≥digo: escribiremos algunas
pruebas!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="desarrollando-la-funcionalidad-de-la-biblioteca-con-tdd"><a class="header" href="#desarrollando-la-funcionalidad-de-la-biblioteca-con-tdd">Desarrollando la funcionalidad de la biblioteca con T.D.D.</a></h2>
<p>Ahora que hemos extra√≠do la l√≥gica en <em>src/lib.rs</em> y dejado la recolecci√≥n de
argumentos y el manejo de errores en <em>src/main.rs</em>, es mucho m√°s f√°cil escribir
pruebas para la funcionalidad principal de nuestro c√≥digo. Podemos llamar a las
funciones directamente con varios argumentos y verificar los valores de
retorno sin tener que llamar a nuestro binario desde la l√≠nea de comandos.</p>
<p>En esta secci√≥n, agregaremos la l√≥gica de b√∫squeda al programa <code>minigrep</code>
utilizando el proceso de desarrollo impulsado por pruebas (TDD) con los
siguientes pasos:</p>
<ol>
<li>Escriba un test que falle y ejec√∫tala para asegurarse de que falla por la
raz√≥n que espera.</li>
<li>Escribe o modifica solo el c√≥digo suficiente para que el nuevo test pase.</li>
<li>Refactoriza el c√≥digo que acabas de agregar o cambiar y aseg√∫rate de que los
tests sigan pasando.</li>
<li>¬°Repite desde el paso 1!</li>
</ol>
<p>Aunque es solo una de las muchas formas de escribir software, TDD puede ayudar
a impulsar el dise√±o del c√≥digo. Escribir la prueba antes de escribir el c√≥digo
que hace que la prueba pase ayuda a mantener una alta cobertura de prueba
durante todo el proceso.</p>
<p>Vamos a probar la implementaci√≥n de la funcionalidad que realmente buscar√° el
string de consulta en el contenido del archivo y producir√° una lista de l√≠neas
que coincidan con la consulta. Agregaremos esta funcionalidad en una funci√≥n
llamada <code>search</code>.</p>
<h3 id="escribiendo-un-test-fallido"><a class="header" href="#escribiendo-un-test-fallido">Escribiendo un test fallido</a></h3>
<p>Debido a que ya no los necesitamos, eliminemos las declaraciones <code>println!</code> de
<em>src/lib.rs</em> y <em>src/main.rs</em> que usamos para verificar el comportamiento del
programa. Luego, en <em>src/lib.rs</em>, agregue un m√≥dulo <code>tests</code> con una funci√≥n de
prueba, como lo hicimos en <a href="ch11-01-writing-tests.html#la-anatomia-de-una-funcion-de-test">Cap√≠tulo 11</a><!-- ignore -->. La
funci√≥n de prueba especifica el comportamiento que queremos que tenga la
funci√≥n <code>search</code>: tomar√° una consulta y el texto a buscar, y devolver√° solo las
l√≠neas del texto que contengan la consulta. El listado 12-15 muestra esta
prueba, que a√∫n no se compilar√°.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }
}</code></pre>
<p><span class="caption">Listing 12-15: Creando un test fallido para la funci√≥n
<code>search</code> que deseamos tener</span></p>
<p>Este test busca el string <code>&quot;duct&quot;</code>. El texto que estamos buscando son tres
l√≠neas, solo una de las cuales contiene <code>&quot;duct&quot;</code> (Tenga en cuenta que la barra
invertida despu√©s de la comilla doble de apertura le dice a Rust que no ponga
un car√°cter de nueva l√≠nea al comienzo del contenido de esta cadena literal).
Afirmamos que el valor devuelto de la funci√≥n <code>search</code> contiene solo la l√≠nea
que esperamos.</p>
<p>A√∫n no podemos ejecutar este test y verlo fallar porque el test ni siquiera se
compila: ¬°la funci√≥n <code>search</code> a√∫n no existe! De acuerdo con los principios de
TDD, agregaremos solo el c√≥digo suficiente para que la prueba se compile y se
ejecute agregando una definici√≥n de la funci√≥n <code>search</code> que siempre devuelve
un vector vac√≠o, como se muestra en el listado 12-16. Luego, la prueba deber√≠a
compilar y fallar porque un vector vac√≠o no coincide con un vector que
contiene la l√≠nea <code>&quot;safe, fast, productive.&quot;</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-16: Definiendo solo lo necesario de la funci√≥n
<code>search</code> para que nuestro test compile</span></p>
<p>Observa que necesitamos definir un lifetime expl√≠cito <code>'a</code> en la firma de
<code>search</code> y usar ese lifetime con el argumento <code>contents</code> y el valor de retorno.
Recuerde en <a href="ch10-03-lifetime-syntax.html">Cap√≠tulo 10</a><!-- ignore --> que los par√°metros de
lifetime especifican qu√© lifetime de argumento est√° conectado al lifetime del
valor de retorno. En este caso, indicamos que el vector devuelto debe contener
string slices que hagan referencia a slices del argumento <code>contents</code> (en lugar
del argumento <code>query</code>).</p>
<p>En otras palabras, le decimos a Rust que los datos devueltos por la funci√≥n
<code>search</code> vivir√°n tanto tiempo como los datos pasados a la funci√≥n <code>search</code> en
el argumento <code>contents</code>. ¬°Esto es importante! Los datos a los que hace
referencia un slice deben ser v√°lidos para que la referencia sea v√°lida; si el
compilador asume que estamos haciendo string slices de <code>query</code> en lugar de
<code>contents</code>, har√° sus comprobaciones de seguridad incorrectamente.</p>
<p>Si olvidamos las anotaciones de lifetime y tratamos de compilar esta funci√≥n,
obtendremos este error:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust no puede saber qu√© argumento de los dos necesitamos, por lo que debemos
decirle expl√≠citamente. Debido a que <code>contents</code> es el argumento que contiene
todo nuestro texto y queremos devolver las partes de ese texto que coincidan,
sabemos que <code>contents</code> es el argumento que debe estar conectado al valor de
retorno usando la sintaxis de lifetime.</p>
<p>Otros lenguajes de programaci√≥n no requieren que conectes argumentos a valores
de retorno en la firma, pero esta pr√°ctica ser√° m√°s f√°cil con el tiempo. Quiz√°s
quiera comparar este ejemplo con la secci√≥n <a href="ch10-03-lifetime-syntax.html#validando-referencias-con-lifetimes">&quot;Validando referencias con
lifetimes&quot;</a><!-- ignore --> en el
Cap√≠tulo 10.</p>
<p>Ahora ejecutemos el test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'tests::one_result' panicked at src/lib.rs:44:9:
assertion `left == right` failed
  left: [&quot;safe, fast, productive.&quot;]
 right: []
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>¬°Genial, el test falla, exactamente como esper√°bamos! ¬°Vamos a hacer que el
test pase!</p>
<h3 id="escribiendo-c√≥digo-para-pasar-el-test"><a class="header" href="#escribiendo-c√≥digo-para-pasar-el-test">Escribiendo c√≥digo para pasar el test</a></h3>
<p>Actualmente, nuestro test falla porque siempre devolvemos un vector vac√≠o. Para
solucionar eso e implementar <code>search</code>, nuestro programa debe seguir estos
pasos:</p>
<ul>
<li>Iterar a trav√©s de cada l√≠nea del contenido.</li>
<li>Compruebe si la l√≠nea contiene nuestro string de consulta.</li>
<li>Si es as√≠, agr√©guelo a la lista de valores que estamos devolviendo.</li>
<li>Si no lo hace, no haga nada.</li>
<li>Devuelve la lista de resultados que coinciden.</li>
</ul>
<p>Trabajaremos en cada paso, comenzando por iterar a trav√©s de las l√≠neas.</p>
<h4 id="iterando-a-trav√©s-de-las-l√≠neas-con-el-m√©todo-lines"><a class="header" href="#iterando-a-trav√©s-de-las-l√≠neas-con-el-m√©todo-lines">Iterando a trav√©s de las l√≠neas con el m√©todo <code>lines</code></a></h4>
<p>Rust tiene un m√©todo √∫til para manejar la iteraci√≥n l√≠nea por l√≠nea de strings,
convenientemente llamado <code>lines</code>, que funciona como se muestra en el listado
12-17. Tenga en cuenta que esto a√∫n no se compilar√°.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-17: Iterando a trav√©s de cada l√≠nea en
<code>contents</code></span></p>
<p>El m√©todo <code>lines</code> devuelve un iterador. Hablaremos sobre los iteradores en
profundidad en <a href="ch13-02-iterators.html">Cap√≠tulo 13</a><!-- ignore -->, pero recuerde que
vio esta forma de usar un iterador en <a href="ch03-05-control-flow.html#bucle-a-traves-de-una-coleccion-con-for">Listado 3-5</a><!-- ignore -->,
donde usamos un bucle <code>for</code> con un iterador para ejecutar alg√∫n c√≥digo en cada
elemento de una colecci√≥n.</p>
<h4 id="buscando-cada-l√≠nea-para-la-consulta"><a class="header" href="#buscando-cada-l√≠nea-para-la-consulta">Buscando cada l√≠nea para la consulta</a></h4>
<p>A continuaci√≥n, necesitamos verificar si la l√≠nea contiene el string de
consulta. Afortunadamente, los strings tienen un m√©todo √∫til llamado <code>contains</code>
que hace esto por nosotros. Agregue una llamada al m√©todo <code>contains</code> en la
funci√≥n <code>search</code>, como se muestra en el listado 12-18. Tenga en cuenta que esto
a√∫n no se compilar√°.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-18: Agregando funcionalidad para verificar si
la l√≠nea contiene el string en <code>query</code></span></p>
<p>En este punto, estamos construyendo funcionalidad. Para que compile, debemos
devolver un valor del cuerpo como indicamos en la firma de la funci√≥n.</p>
<h4 id="almacenando-l√≠neas-coincidentes"><a class="header" href="#almacenando-l√≠neas-coincidentes">Almacenando l√≠neas coincidentes</a></h4>
<p>Para terminar esta funci√≥n, necesitamos una forma de almacenar las l√≠neas
coincidentes que queremos devolver. Para eso, podemos hacer un vector mutable
antes del bucle <code>for</code> y llamar al m√©todo <code>push</code> para almacenar una <code>line</code> en el
vector. Despu√©s del bucle <code>for</code>, devolvemos el vector, como se muestra en el
listado 12-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-19: Almacenando las l√≠neas que coinciden para
poder devolverlas</span></p>
<p>Ahora la funci√≥n <code>search</code> deber√≠a devolver solo las l√≠neas que contienen
<code>query</code>, y nuestro test deber√≠a pasar. Ejecutemos el test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Nuestro test pas√≥, as√≠ que sabemos que funciona. ¬°Genial!</p>
<p>En este punto, podr√≠amos considerar oportunidades para refactorizar la
implementaci√≥n de la funci√≥n <code>search</code> mientras mantenemos las pruebas para
mantener la misma funcionalidad. El c√≥digo en la funci√≥n <code>search</code> no es tan
malo, pero no aprovecha algunas caracter√≠sticas √∫tiles de los iteradores.
Volveremos a este ejemplo en <a href="ch13-02-iterators.html">Cap√≠tulo 13</a><!-- ignore -->, donde
exploraremos los iteradores en detalle y veremos c√≥mo mejorarlo.</p>
<h4 id="usando-la-funci√≥n-search-en-la-funci√≥n-run"><a class="header" href="#usando-la-funci√≥n-search-en-la-funci√≥n-run">Usando la funci√≥n <code>search</code> en la funci√≥n <code>run</code></a></h4>
<p>Ahora que la funci√≥n <code>search</code> funciona y est√° probada, necesitamos llamar a
<code>search</code> desde nuestra funci√≥n <code>run</code>. Necesitamos pasar el valor de
<code>config.query</code> y el <code>contents</code> que <code>run</code> lee del archivo a la funci√≥n <code>search</code>.
Luego, <code>run</code> imprimir√° cada l√≠nea devuelta por <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Todav√≠a estamos usando un bucle <code>for</code> para devolver cada l√≠nea de <code>search</code> e
imprimirla.</p>
<p>Ahora todo el programa deber√≠a funcionar. Prob√©moslo con una palabra que
deber√≠a devolver exactamente una l√≠nea del poema de Emily Dickinson, &quot;frog&quot;:</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>¬°Funciona! Ahora intentemos que coincida con varias l√≠neas, como &quot;body&quot;:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Y finalmente, asegur√©monos de que no obtengamos ninguna l√≠nea cuando buscamos
una palabra que no est√° en el poema, como &quot;monomorphization&quot;:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>¬°Excelente! Hemos construido nuestra propia versi√≥n de una herramienta cl√°sica
y hemos aprendido mucho sobre c√≥mo estructurar aplicaciones. Tambi√©n hemos
aprendido un poco sobre input y output de archivos, lifetimes, testing y
an√°lisis de l√≠neas de comandos.</p>
<p>Para completar nuestro proyecto, demostraremos brevemente c√≥mo trabajar con
variables de entorno y c√≥mo imprimir en el error est√°ndar, ambas son √∫tiles
cuando se escriben programas de l√≠nea de comandos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trabajando-con-variables-de-entorno"><a class="header" href="#trabajando-con-variables-de-entorno">Trabajando con Variables de Entorno</a></h2>
<p>Mejoraremos <code>minigrep</code> agregando una caracter√≠stica extra: una opci√≥n para
b√∫squeda insensible a may√∫sculas y min√∫sculas que el usuario puede activar
mediante una variable de entorno. Podr√≠amos hacer esta caracter√≠stica una opci√≥n
de l√≠nea de comandos y requerir que los usuarios la ingresen cada vez que la
quieran aplicar, pero en lugar de eso, al hacerla una variable de entorno,
permitimos a nuestros usuarios establecer la variable de entorno una vez y
tener todas sus b√∫squedas insensibles a may√∫sculas y min√∫sculas en esa sesi√≥n de
terminal.</p>
<h3 id="escribiendo-un-test-fallido-para-la-funci√≥n-search-insensible-a-may√∫sculas-y-min√∫sculas"><a class="header" href="#escribiendo-un-test-fallido-para-la-funci√≥n-search-insensible-a-may√∫sculas-y-min√∫sculas">Escribiendo un Test Fallido para la Funci√≥n <code>search</code> Insensible a May√∫sculas y Min√∫sculas</a></h3>
<p>Primero agregaremos una nueva funci√≥n <code>search_case_insensitive</code> que ser√°
llamada cuando la variable de entorno tenga un valor. Continuaremos siguiendo el
proceso TDD, as√≠ que el primer paso es nuevamente escribir un test fallido.
Agregaremos un nuevo test para la nueva funci√≥n <code>search_case_insensitive</code> y
renombraremos nuestro viejo test de <code>one_result</code> a <code>case_sensitive</code> para
clarificar las diferencias entre los dos tests, como se muestra en el Listado
12-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<p><span class="caption">Listing 12-20: Agregando un nuevo test fallido para la
funci√≥n insensible a may√∫sculas y min√∫sculas que estamos a punto de 
agregar</span></p>
<p>Ten en cuenta que hemos editado el <code>contents</code> del viejo test tambi√©n. Hemos
agregado una nueva l√≠nea con el texto <code>&quot;Duct tape.&quot;</code> usando una D may√∫scula que
no deber√≠a coincidir con la consulta <code>&quot;duct&quot;</code> cuando estamos buscando de manera
sensible a may√∫sculas y min√∫sculas. Cambiar el viejo test de esta manera ayuda
a asegurar que no rompamos accidentalmente la funcionalidad de b√∫squeda
sensible a may√∫sculas y min√∫sculas que ya hemos implementado. Este test deber√≠a
pasar ahora y deber√≠a continuar pasando mientras trabajamos en la b√∫squeda
insensible a may√∫sculas y min√∫sculas.</p>
<p>El nuevo test para la b√∫squeda insensible a may√∫sculas y min√∫sculas usa <code>&quot;rUsT&quot;</code>
como su consulta. En la funci√≥n <code>search_case_insensitive</code> que estamos a punto
de agregar, la consulta <code>&quot;rUsT&quot;</code> deber√≠a coincidir con la l√≠nea que contiene
<code>&quot;Rust:&quot;</code> con una R may√∫scula y coincidir con la l√≠nea <code>&quot;Trust me.&quot;</code> aunque
ambas tienen diferente capitalizaci√≥n que la consulta. Este es nuestro test
fallido, y fallar√° al compilar porque a√∫n no hemos definido la funci√≥n
<code>search_case_insensitive</code>. Si√©ntete libre de agregar una implementaci√≥n
esqueleto que siempre devuelva un vector vac√≠o, similar a la forma en que lo
hicimos para la funci√≥n <code>search</code> en el Listado 12-16 para ver el test compilar
y fallar.</p>
<h3 id="implementando-la-funci√≥n-search_case_insensitive"><a class="header" href="#implementando-la-funci√≥n-search_case_insensitive">Implementando la Funci√≥n <code>search_case_insensitive</code></a></h3>
<p>La funci√≥n <code>search_case_insensitive</code>, como se muestra en el Listado 12-21,
ser√° casi la misma que la funci√≥n <code>search</code>. La √∫nica diferencia es que
convertiremos a min√∫sculas la <code>query</code> y cada <code>line</code> para que no importe la
may√∫scula o min√∫scula de los argumentos de entrada, ser√°n la misma may√∫scula o
min√∫scula cuando verifiquemos si la l√≠nea contiene la consulta.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-21: Definiendo la funci√≥n 
<code>search_case_insensitive</code> para convertir a min√∫sculas tanto la consulta como la
l√≠nea antes de compararlas</span></p>
<p>Primero, convertimos el string <code>query</code> a min√∫sculas y lo almacenamos en una
variable sombreada con el mismo nombre. Llamar a <code>to_lowercase</code> en la consulta
es necesario para que no importe si la consulta del usuario es <code>&quot;rust&quot;</code>,
<code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code> o <code>&quot;rUsT&quot;</code>, trataremos la consulta como si fuera <code>&quot;rust&quot;</code> y
y seremos insensibles a la may√∫scula o min√∫scula. Mientras que <code>to_lowercase</code>
manejar√° Unicode b√°sico, no ser√° 100% preciso. Si estuvi√©ramos escribiendo una
aplicaci√≥n real, querr√≠amos hacer un poco m√°s de trabajo aqu√≠, pero esta
secci√≥n trata sobre variables de entorno, no Unicode, as√≠ que lo dejaremos as√≠
aqu√≠.</p>
<p>Nota que <code>query</code> ahora es un <code>String</code> en lugar de un string slice, porque
llamar a <code>to_lowercase</code> crea nuevos datos en lugar de referenciar datos
existentes. Digamos que la consulta es <code>&quot;rUsT&quot;</code>, como un ejemplo: ese string 
slice no contiene una <code>u</code> o <code>t</code> en min√∫scula para que podamos usar, as√≠ que
tenemos que asignar un nuevo <code>String</code> que contenga <code>&quot;rust&quot;</code>. Cuando pasamos
<code>query</code> como un argumento al m√©todo <code>contains</code> ahora, necesitamos agregar un
ampersand porque la firma de <code>contains</code> est√° definida para tomar un string 
slice.</p>
<p>A continuaci√≥n, agregamos una llamada a <code>to_lowercase</code> en cada <code>line</code> para
convertir a min√∫sculas todos los caracteres. Ahora que hemos convertido <code>line</code>
y <code>query</code> a min√∫sculas, encontraremos coincidencias sin importar la may√∫scula
o min√∫scula de la consulta.</p>
<p>Veamos si esta implementaci√≥n pasa los tests:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>¬°Genial! Pasaron. Ahora, llamemos a la nueva funci√≥n <code>search_case_insensitive</code>
desde la funci√≥n <code>run</code>. Primero, agregaremos una opci√≥n de configuraci√≥n a la
estructura <code>Config</code> para cambiar entre la b√∫squeda sensible a may√∫sculas y
min√∫sculas y la b√∫squeda insensible a may√∫sculas y min√∫sculas. Agregar este
campo causar√° errores del compilador porque a√∫n no estamos inicializando este
campo en ning√∫n lugar:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Hemos agregado el campo <code>ignore_case</code> que contiene un booleano. A continuaci√≥n,
necesitamos la funci√≥n <code>run</code> para verificar el valor del campo <code>ignore_case</code> y
usar eso para decidir si llamar a la funci√≥n <code>search</code> o la funci√≥n
<code>search_case_insensitive</code>, como se muestra en el Listado 12-22. Esto a√∫n no se
compilar√°.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-22: Llamando a <code>search</code> o
<code>search_case_insensitive</code> en funci√≥n del valor de <code>config.ignore_case</code></span></p>
<p>Finalmente, necesitamos verificar la variable de entorno. Las funciones para
trabajar con variables de entorno est√°n en el m√≥dulo <code>env</code> en la biblioteca
est√°ndar, as√≠ que traemos ese m√≥dulo al alcance en la parte superior de
<em>src/lib.rs</em>. Luego usaremos la funci√≥n <code>var</code> del m√≥dulo <code>env</code> para verificar
si se ha establecido alg√∫n valor para una variable de entorno llamada
<code>IGNORE_CASE</code>, como se muestra en el Listado 12-23.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --snip--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-23: Comprobando si existe alg√∫n valor en una 
variable de entorno llamada <code>IGNORE_CASE</code></span></p>
<p>Aqu√≠, creamos una nueva variable <code>ignore_case</code>. Para establecer su valor,
llamamos a la funci√≥n <code>env::var</code> y le pasamos el nombre de la variable de
entorno <code>IGNORE_CASE</code>. La funci√≥n <code>env::var</code> devuelve un <code>Result</code> que ser√° la
variante <code>Ok</code> exitosa que contiene el valor de la variable de entorno si la
variable de entorno est√° configurada con alg√∫n valor. Devolver√° la variante
<code>Err</code> si la variable de entorno no est√° configurada.</p>
<p>Usaremos el m√©todo <code>is_ok</code> en el <code>Result</code> para verificar si la variable de
entorno est√° configurada, lo que significa que el programa deber√≠a hacer una
b√∫squeda insensible a may√∫sculas. Si la variable de entorno <code>IGNORE_CASE</code> no
est√° configurada en nada, <code>is_ok</code> devolver√° <code>false</code> y el programa realizar√°
una b√∫squeda sensible a may√∫sculas. No nos importa el <em>valor</em> de la variable
de entorno, solo si est√° configurada o no, as√≠ que estamos verificando
<code>is_ok</code> en lugar de usar <code>unwrap</code>, <code>expect</code> o cualquiera de los otros m√©todos
que hemos visto en <code>Result</code>.</p>
<p>Hemos pasado el valor en la variable <code>ignore_case</code> a la instancia <code>Config</code> para
que la funci√≥n <code>run</code> pueda leer ese valor y decidir si llamar a la funci√≥n
<code>search_case_insensitive</code> o <code>search</code>, como implementamos en el Listado 12-22.</p>
<p>¬°Prob√©moslo! Primero, ejecutemos el programa sin la variable de entorno
establecida y con la consulta <code>to</code>, que deber√≠a coincidir con cualquier l√≠nea
que contenga la palabra &quot;to&quot; en min√∫sculas:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>¬°Parece que a√∫n funciona! Ahora, ejecutemos el programa con <code>IGNORE_CASE</code>
establecido en <code>1</code> pero con la misma consulta <code>to</code>.</p>
<pre><code class="language-console">$ export IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Si est√°s usando PowerShell, deber√°s establecer la variable de entorno y
ejecutar el programa como comandos separados:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Esto har√° que <code>IGNORE_CASE</code> persista durante el resto de la sesi√≥n de tu
shell. Puede desestablecerse con el comando <code>Remove-Item</code>:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>Deber√≠amos obtener l√≠neas que contengan &quot;to&quot; que podr√≠an tener letras
may√∫sculas:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excelente, ¬°tambi√©n obtuvimos l√≠neas que contienen &quot;To&quot;! Nuestro programa
<code>minigrep</code> ahora puede hacer b√∫squedas insensibles a may√∫sculas y min√∫sculas
controladas por una variable de entorno. Ahora sabes c√≥mo administrar las
opciones establecidas mediante argumentos de l√≠nea de comandos o variables de
entorno.</p>
<p>Algunos programas permiten argumentos <em>y</em> variables de entorno para la misma
configuraci√≥n. En esos casos, los programas deciden que uno u otro tiene
precedencia. Para otro ejercicio por tu cuenta, intenta controlar la
sensibilidad a may√∫sculas y min√∫sculas a trav√©s de un argumento de l√≠nea de
comandos o una variable de entorno. Decide si el argumento de l√≠nea de comandos
o la variable de entorno deben tener prioridad si el programa se ejecuta con
uno configurado para ser sensible a may√∫sculas y min√∫sculas y otro configurado
para ignorar may√∫sculas y min√∫sculas.</p>
<p>El m√≥dulo <code>std::env</code> contiene muchas m√°s funciones √∫tiles para trabajar con
variables de entorno: consulta su documentaci√≥n para ver qu√© est√° disponible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="escribiendo-mensajes-de-error-est√°ndar-en-lugar-del-output-est√°ndar"><a class="header" href="#escribiendo-mensajes-de-error-est√°ndar-en-lugar-del-output-est√°ndar">Escribiendo mensajes de error est√°ndar en lugar del output est√°ndar</a></h2>
<p>En este momento, estamos escribiendo toda nuestro output en la terminal usando
la macro <code>println!</code>. En la mayor√≠a de las terminales, hay dos tipos de output:
<em>output est√°ndar</em> (<code>stdout</code>) para informaci√≥n general y <em>error est√°ndar</em>
(<code>stderr</code>) para mensajes de error. Esta distinci√≥n permite a los usuarios
elegir dirigir el output exitoso de un programa a un archivo pero aun as√≠
imprimir mensajes de error en la pantalla.</p>
<p>La macro <code>println!</code> solo es capaz de imprimir en el output est√°ndar, as√≠ que
tenemos que usar algo m√°s para imprimir en el error est√°ndar.</p>
<h3 id="revisando-donde-se-escriben-los-errores"><a class="header" href="#revisando-donde-se-escriben-los-errores">Revisando donde se escriben los errores</a></h3>
<p>Primero, observemos como el contenido impreso por <code>minigrep</code> est√° siendo
escrito en el output est√°ndar, incluyendo cualquier mensaje de error que
queramos escribir en el error est√°ndar. Haremos eso redirigiendo el output
est√°ndar a un archivo mientras causamos un error intencionalmente. No
redirigiremos el error est√°ndar, as√≠ que cualquier contenido enviado al error
est√°ndar continuar√° mostr√°ndose en la pantalla.</p>
<p>Los programas de l√≠nea de comandos se espera que env√≠en mensajes de error al
error est√°ndar as√≠ que podemos ver los mensajes de error en la pantalla incluso
si redirigimos el output est√°ndar a un archivo. Nuestro programa no se est√°
comportando bien: estamos a punto de ver que guarda los mensajes de error en un
archivo en su lugar!</p>
<p>Para demostrar este comportamiento, ejecutaremos el programa con <code>&gt;</code> y la ruta
del archivo, <em>output.txt</em>, al que queremos redirigir el output est√°ndar. No
pasaremos ning√∫n argumento, lo que deber√≠a causar un error:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>La sintaxis <code>&gt;</code> le dice a la shell que escriba el contenido del output est√°ndar
en <em>output.txt</em> en lugar de la pantalla. No vimos el mensaje de error que
esper√°bamos impreso en la pantalla, as√≠ que eso significa que debe haber
terminado en el archivo. Esto es lo que contiene <em>output.txt</em>:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>S√≠, nuestro mensaje de error est√° siendo impreso en el output est√°ndar. Es mucho
m√°s √∫til para mensajes de error como este ser impresos en el error est√°ndar as√≠
que solo los datos de una ejecuci√≥n exitosa terminen en el archivo. Cambiaremos
eso.</p>
<h3 id="imprimiendo-errores-en-el-error-est√°ndar"><a class="header" href="#imprimiendo-errores-en-el-error-est√°ndar">Imprimiendo errores en el error est√°ndar</a></h3>
<p>Usaremos el c√≥digo en el Listado 12-24 para cambiar como los mensajes de error
son impresos. Debido al refactor que hicimos anteriormente en este cap√≠tulo,
todo el c√≥digo que imprime mensajes de error est√° en una funci√≥n, <code>main</code>. La
librer√≠a est√°ndar provee la macro <code>eprintln!</code> que imprime en el flujo de error
est√°ndar, as√≠ que cambiaremos los dos lugares donde est√°bamos llamando
<code>println!</code> para imprimir errores usando <code>eprintln!</code> en su lugar.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {e}&quot;);
        process::exit(1);
    }
}</code></pre>
<p><span class="caption">Listing 12-24: Escribiendo mensajes de error en el 
error est√°ndar en lugar del output est√°ndar utilizando <code>eprintln!</code></span></p>
<p>Ahora, ejecutaremos el programa de la misma manera que antes, sin pasar ning√∫n
argumento y redirigiendo el output est√°ndar con <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Ahora podemos ver el mensaje de error en la pantalla y <em>output.txt</em> no contiene
nada, que es el comportamiento que esperamos de los programas de l√≠nea de
comandos.</p>
<p>Ejecutemos el programa otra vez con argumentos que no causen un error pero aun
as√≠ redirigiendo el output est√°ndar a un archivo, como as√≠:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>No veremos ning√∫n output en la terminal, y <em>output.txt</em> contendr√° nuestros
resultados:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Esto demuestra que ahora estamos usando el output est√°ndar para output exitoso
y el error est√°ndar para output de error como es apropiado.</p>
<h2 id="resumen-11"><a class="header" href="#resumen-11">Resumen</a></h2>
<p>En este cap√≠tulo repas√≥ algunos de los conceptos principales que has aprendido
hasta ahora y cubri√≥ como realizar operaciones de I/O comunes en Rust. Al usar
argumentos de l√≠nea de comandos, archivos, variables de ambiente, y la macro
<code>eprintln!</code> para imprimir errores, ahora est√°s preparado para escribir
aplicaciones de l√≠nea de comandos. Combinado con los conceptos de cap√≠tulos
anteriores, tu c√≥digo estar√° bien organizado, almacenar√° datos efectivamente en
las estructuras de datos apropiadas, manejar√° errores de manera agradable, y
estar√° bien testeado.</p>
<p>A continuaci√≥n, exploraremos algunas caracter√≠sticas de Rust que fueron
influenciadas por lenguajes funcionales: closures e iterators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caracter√≠sticas-de-lenguajes-funcionales-iteradores-y-closures"><a class="header" href="#caracter√≠sticas-de-lenguajes-funcionales-iteradores-y-closures">Caracter√≠sticas De Lenguajes Funcionales: Iteradores y Closures</a></h1>
<p>El dise√±o de Rust se ha inspirado en muchos lenguajes y t√©cnicas existentes, 
y una influencia significativa es la <em>programaci√≥n funcional</em>. La programaci√≥n 
en un estilo funcional a menudo incluye el uso de funciones como valores 
pas√°ndolas en argumentos, devolvi√©ndolas de otras funciones, asign√°ndolas a 
variables para su ejecuci√≥n posterior, y as√≠ sucesivamente.</p>
<p>En este cap√≠tulo, no debatiremos la cuesti√≥n de lo que es o no es la
programaci√≥n funcional, sino que discutiremos algunas caracter√≠sticas de Rust
que son similares a las caracter√≠sticas de muchos lenguajes a menudo
denominados funcionales.</p>
<p>M√°s espec√≠ficamente, cubriremos:</p>
<ul>
<li><em>Closures</em>, una construcci√≥n similar a una funci√≥n que puede almacenarse en una
variable</li>
<li><em>Iteradores</em>, una forma de procesar una serie de elementos</li>
<li>C√≥mo usar closures e iterators para mejorar el proyecto I/O en el Cap√≠tulo 12</li>
<li>¬°El rendimiento de los closures e iteradores (Spoiler alert: son m√°s r√°pidos
de lo que podr√≠as pensar!)</li>
</ul>
<p>Ya hemos cubierto algunas otras caracter√≠sticas de Rust, como el <em>pattern
matching</em> y los <em>enums</em>, que tambi√©n est√°n influenciados por el estilo
funcional. Debido a que dominar los closures e iteradores es una parte
importante de escribir c√≥digo Rust idiom√°tico y r√°pido, dedicaremos todo este
cap√≠tulo a ellos.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="closures-funciones-an√≥nimas-que-capturan-su-entorno"><a class="header" href="#closures-funciones-an√≥nimas-que-capturan-su-entorno">Closures: Funciones an√≥nimas que capturan su entorno</a></h2>
<p>Los closures de Rust son funciones an√≥nimas que puede guardar en una variable o
pasar como argumentos a otras funciones. Puede crear el closure en un lugar y
luego llamar al closure en otro lugar para evaluarlo en un contexto diferente.
A diferencia de las funciones, los closures pueden capturar valores del scope en
el que se definen. Demostraremos c√≥mo estas caracter√≠sticas de los closures
permiten la reutilizaci√≥n de c√≥digo y la personalizaci√≥n del comportamiento.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="capturando-el-entorno-con-closures"><a class="header" href="#capturando-el-entorno-con-closures">Capturando el entorno con Closures</a></h3>
<p>Primero examinaremos c√≥mo podemos usar closures para capturar valores del
entorno en el que est√°n definidos para su uso posterior. Aqu√≠ est√° el escenario:
Cada cierto tiempo, nuestra compa√±√≠a de camisetas regala una camiseta exclusiva
y de edici√≥n limitada a alguien en nuestra lista de correo como promoci√≥n. Las
personas en la lista de correo pueden agregar opcionalmente su color favorito a
su perfil. Si la persona elegida para una camiseta gratis tiene su color
favorito establecido, obtienen esa camiseta de color. Si la persona no ha
especificado un color favorito, obtienen el color que la compa√±√≠a tiene
actualmente en mayor cantidad.</p>
<p>Hay muchas formas de implementar esto. Para este ejemplo, vamos a usar un enum
llamado <code>ShirtColor</code> que tiene las variantes <code>Red</code> y <code>Blue</code> (limitando el
n√∫mero de colores disponibles para simplificar). Representamos el inventario de
la compa√±√≠a con un struct <code>Inventory</code> que tiene un campo llamado <code>shirts</code> que
contiene un <code>Vec&lt;ShirtColor&gt;</code> que representa los colores de camisetas
actualmente en stock. El m√©todo <code>giveaway</code> definido en <code>Inventory</code> obtiene la
preferencia opcional de color de camiseta del ganador de la camiseta gratis, y
devuelve el color de camiseta que la persona obtendr√°. Esta configuraci√≥n se
muestra en el Listado 13-1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref2, giveaway2
    );
}</code></pre>
<p><span class="caption">Listing 13-1: Situaci√≥n de giveaway</span></p>
<p>El <code>almac√©n</code> definido en <code>main</code> tiene dos camisetas azules y una camiseta roja
restante para distribuir para esta promoci√≥n de edici√≥n limitada. Llamamos al
m√©todo <code>giveaway</code> para un usuario con preferencia por una camiseta roja y un
usuario sin ninguna preferencia.</p>
<p>Otra vez, este c√≥digo podr√≠a implementarse de muchas maneras, y aqu√≠, para
centrarnos en los closures, nos hemos adherido a los conceptos que ya has
aprendido, excepto por el cuerpo del m√©todo <code>giveaway</code> que usa un closure. En el
m√©todo <code>giveaway</code>, obtenemos la preferencia del usuario como un par√°metro de
tipo <code>Option&lt;ShirtColor&gt;</code> y llamamos al m√©todo <code>unwrap_or_else</code> en
<code>user_preference</code>. El m√©todo <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> en <code>Option&lt;T&gt;</code></a></p>
<!-- ignore --> est√° definido por la biblioteca est√°ndar. Toma un argumento: un
<p>Closure sin ning√∫n argumento que devuelve un valor <code>T</code> (el mismo tipo almacenado
en la variante <code>Some</code> de la <code>Option&lt;T&gt;</code>, en este caso <code>ShirtColor</code>). Si la
<code>Option&lt;T&gt;</code> es la variante <code>Some</code>, <code>unwrap_or_else</code> devuelve el valor de dentro
de <code>Some</code>. Si la <code>Option&lt;T&gt;</code> es la variante <code>None</code>, <code>unwrap_or_else</code> llama al
closure y devuelve el valor devuelto por el closure.</p>
<p>Especificamos el closure <code>|| self.most_stocked()</code> como argumento a
<code>unwrap_or_else</code>. Este es un closure que no toma par√°metros en s√≠ mismo (si el
closure tuviera par√°metros, aparecer√≠an entre las dos barras verticales). El
cuerpo del closure llama a <code>self.most_stocked()</code>. Estamos definiendo el closure
aqu√≠, y la implementaci√≥n de <code>unwrap_or_else</code> evaluar√° el closure m√°s tarde si
se necesita el resultado.</p>
<p>Ejecutar este c√≥digo imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>Un aspecto interesante aqu√≠ es que hemos pasado un closure que llama a
<code>self.most_stocked()</code> en la instancia <code>Inventory</code> actual. La biblioteca est√°ndar
no necesitaba saber nada sobre los tipos <code>Inventory</code> o <code>ShirtColor</code> que
definimos, o la l√≥gica que queremos usar en este escenario. El closure captura
una referencia inmutable a la instancia <code>self</code> <code>Inventory</code> y la pasa con el
c√≥digo que especificamos al m√©todo <code>unwrap_or_else</code>. Las funciones, por otro
lado, no pueden capturar su entorno de esta manera.</p>
<h3 id="inferencia-de-tipo-de-closure-y-anotaci√≥n"><a class="header" href="#inferencia-de-tipo-de-closure-y-anotaci√≥n">Inferencia de tipo de Closure y anotaci√≥n</a></h3>
<p>Existen m√°s diferencias entre funciones y closures. Los closures no suelen
requerir que anotes los tipos de los par√°metros o el valor de retorno como lo
hacen las funciones <code>fn</code>. Las anotaciones de tipo son necesarias en las
funciones porque los tipos son parte de una interfaz expl√≠cita expuesta a tus
usuarios. Definir esta interfaz r√≠gidamente es importante para garantizar que
todos est√©n de acuerdo en qu√© tipos de valores usa y devuelve una funci√≥n. Los
closures, por otro lado, no se usan en una interfaz expuesta como esta: se
almacenan en variables y se usan sin nombrarlos y exponerlos a los usuarios de
nuestra biblioteca.</p>
<p>Los closures t√≠picamente son cortos y relevantes solo dentro de un contexto
estrecho en lugar de en cualquier escenario arbitrario. Dentro de estos
contextos limitados, el compilador puede inferir los tipos de los par√°metros y
el tipo de retorno, similar a c√≥mo puede inferir los tipos de la mayor√≠a de las
variables (hay casos raros en los que el compilador tambi√©n necesita
anotaciones de tipo de closure).</p>
<p>Como con las variables, podemos agregar anotaciones de tipo opcionales si
queremos aumentar la explicitud y la claridad a costa de ser m√°s verbosos de lo
estrictamente necesario. La anotaci√≥n de tipos para un closure se ver√≠a como la
definici√≥n que se muestra en el Listado 13-2. En este ejemplo, estamos
definiendo un closure y almacen√°ndolo en una variable en lugar de definir el
closure en el lugar donde lo pasamos como argumento como lo hicimos en el
Listado 13-1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-2: Agregando anotaciones de tipo opcionales
para los tipos de par√°metros y valor de retorno en el closure</span></p>
<p>Con la anotaci√≥n de tipo agregada, la sintaxis de los closures se parece m√°s a
la sintaxis de las funciones. Aqu√≠ definimos una funci√≥n que agrega 1 a su
par√°metro y un closure que tiene el mismo comportamiento, para comparaci√≥n.
Hemos agregado algunos espacios para alinear las partes relevantes. Esto
ilustra c√≥mo la sintaxis de los closures es similar a la sintaxis de las
funciones, excepto por el uso de tuber√≠as y la cantidad de sintaxis que es
opcional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>La primera l√≠nea muestra una definici√≥n de funci√≥n, y la segunda l√≠nea muestra
una definici√≥n de closure completamente anotada. En la tercera l√≠nea, quitamos
las anotaciones de tipo de la definici√≥n de closure. En la cuarta l√≠nea,
quitamos los corchetes, que son opcionales porque el cuerpo del closure tiene
solo una expresi√≥n. Estas son todas definiciones v√°lidas que producir√°n el mismo
comportamiento cuando se llamen. Las l√≠neas <code>add_one_v3</code> y <code>add_one_v4</code>
requieren que los closures se eval√∫en para poder compilar porque los tipos se
inferir√°n a partir de su uso. Esto es similar a <code>let v = Vec::new();</code> que
necesita anotaciones de tipo o valores de alg√∫n tipo para insertar en el <code>Vec</code>
para que Rust pueda inferir el tipo.</p>
<p>Para las definiciones de closure, el compilador infiere un tipo concreto para
cada uno de sus par√°metros y para su valor de retorno. Por ejemplo, el Listado
13-3 muestra la definici√≥n de un closure corto que solo devuelve el valor que
recibe como par√°metro. Este closure no es muy √∫til, excepto para los prop√≥sitos
de este ejemplo. Tenga en cuenta que no hemos agregado ninguna anotaci√≥n de
tipo a la definici√≥n. Debido a que no hay anotaciones de tipo, podemos llamar al
closure con cualquier tipo, lo que hemos hecho aqu√≠ con <code>String</code> la primera
vez. Si luego intentamos llamar a <code>example_closure</code> con un entero, obtendremos
un error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-3: Intentando llamar a un closure cuyos tipos
se infieren con dos tipos diferentes</span></p>
<p>El compilador nos da este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from(&quot;hello&quot;));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin &quot;closure-example&quot;) due to 1 previous error
</code></pre>
<p>La primera vez que llamamos a <code>example_closure</code> con el valor <code>String</code>, el
compilador infiere el tipo de <code>x</code> y el tipo de retorno del closure como
<code>String</code>. Esos tipos se bloquean en el closure en <code>example_closure</code>, y
obtenemos un error de tipo cuando intentamos usar un tipo diferente con el
mismo closure.</p>
<h3 id="capturando-referencias-o-moviendo-el-ownership"><a class="header" href="#capturando-referencias-o-moviendo-el-ownership">Capturando referencias o moviendo el ownership</a></h3>
<p>Los closures pueden valores desde su entorno de tres maneras, que se mapean
directamente a las tres formas en que una funci√≥n puede tomar un par√°metro:
borrowing inmutable, borrowing mutable y tomando ownership. El closure decidir√°
cu√°l de estos usar en funci√≥n de lo que haga el cuerpo de la funci√≥n con los
valores capturados.</p>
<p>En el Listado 13-4, definimos un closure que captura una referencia inmutable al
vector <code>list</code> ya que solo necesita una referencia inmutable para imprimir el
valor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    let only_borrows = || println!(&quot;From closure: {list:?}&quot;);

    println!(&quot;Before calling closure: {list:?}&quot;);
    only_borrows();
    println!(&quot;After calling closure: {list:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-4: Definiendo y llamando a un closure que
captura una referencia inmutable</span></p>
<p>Este ejemplo tambi√©n ilustra que una variable puede vincularse a una definici√≥n
de closure, y luego podemos llamar al closure usando el nombre de la variable y
par√©ntesis como si el nombre de la variable fuera un nombre de funci√≥n.</p>
<p>Debido a que podemos tener m√∫ltiples referencias inmutables a <code>list</code> al mismo
tiempo, <code>list</code> sigue siendo accesible desde el c√≥digo antes de la definici√≥n del
closure, despu√©s de la definici√≥n del closure, pero antes de que se llame al
closure, y despu√©s de que se llame al closure. Este c√≥digo se compila, se
ejecuta e imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Luego, en el Listado 13-5, cambiamos el cuerpo del closure para que agregue un
elemento al vector <code>list</code>. El closure ahora captura una referencia mutable:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;After calling closure: {list:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-5: Definiendo y llamando a un closure que
captura una referencia mutable</span></p>
<p>Este c√≥digo compila, se ejecuta e imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Nota que ya no hay un <code>println!</code> entre la definici√≥n y la llamada del closure
<code>borrows_mutably</code>: cuando se define <code>borrows_mutably</code>, captura una referencia
mutable a <code>list</code>. No usamos el closure nuevamente despu√©s de llamar al closure,
por lo que el pr√©stamo mutable termina. Entre la definici√≥n del closure y la
llamada del closure, no se permite un pr√©stamo inmutable para imprimir porque
no se permiten otros pr√©stamos cuando hay un pr√©stamo mutable. ¬°Intente agregar
un <code>println!</code> all√≠ para ver qu√© mensaje de error obtiene!</p>
<p>Si deseas forzar al closure para que tome ownership de los valores que usa en el
entorno, incluso cuando el cuerpo del closure no los necesite, puedes usar la
palabra clave <code>move</code> antes de la lista de par√°metros.</p>
<p>Esta t√©cnica es principalmente √∫til cuando se pasa un closure a un nuevo hilo
para mover los datos para que sean propiedad del nuevo hilo. Discutiremos los
hilos y por qu√© querr√≠as usarlos en detalle en el Cap√≠tulo 16 cuando hablemos
sobre la concurrencia, pero por ahora, exploremos brevemente c√≥mo generar un
nuevo hilo usando un closure que necesita la palabra clave <code>move</code>. El Listado
13-6 muestra el Listado 13-4 modificado para imprimir el vector en un nuevo
hilo en lugar de en el hilo principal:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {list:?}&quot;);

    thread::spawn(move || println!(&quot;From thread: {list:?}&quot;))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 13-6: Usando <code>move</code> para forzar que el closure del
thread tome el ownership de <code>list</code></span></p>
<p>Iniciamos un nuevo hilo, dando al hilo un closure para ejecutar como argumento.
El cuerpo del closure imprime la lista. En el Listado 13-4, el closure solo
captur√≥ <code>list</code> usando una referencia inmutable porque esa es la menor cantidad
de acceso a <code>list</code> necesaria para imprimirla. En este ejemplo, aunque el cuerpo
del closure todav√≠a solo necesita una referencia inmutable, debemos especificar
que <code>list</code> debe moverse al closure poniendo la palabra clave <code>move</code> al comienzo
de la definici√≥n del closure. El nuevo hilo podr√≠a terminar antes de que el
resto del hilo principal termine, o el hilo principal podr√≠a terminar primero.
Si el hilo principal mantuviera la propiedad de <code>list</code> pero terminara antes de
que lo hiciera el nuevo hilo y dejara caer <code>list</code>, la referencia inmutable en
el hilo ser√≠a inv√°lida. Por lo tanto, el compilador requiere que <code>list</code> se
mueva al closure dado al nuevo hilo para que la referencia sea v√°lida. ¬°Intente
eliminar la palabra clave <code>move</code> o usar <code>list</code> en el hilo principal despu√©s de
que se defina el closure para ver qu√© errores del compilador obtiene!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="moviendo-valores-capturados-fuera-de-los-closures-y-los-traits-fn"><a class="header" href="#moviendo-valores-capturados-fuera-de-los-closures-y-los-traits-fn">Moviendo valores capturados fuera de los closures y los traits <code>Fn</code></a></h3>
<p>Una vez que un closure ha capturado una referencia o capturado el ownership de
un valor del entorno donde se define el closure (afectando as√≠ lo que, si
cualquier cosa, se mueve <em>dentro</em> del closure), el c√≥digo en el cuerpo del
closure define lo que sucede con las referencias o valores cuando el closure se
eval√∫a m√°s tarde (afectando as√≠ lo que, si cualquier cosa, se mueve <em>fuera</em> del
closure). El cuerpo de un closure puede hacer cualquiera de las siguientes
acciones: mover un valor capturado fuera del closure, mutar el valor capturado,
ni mover ni mutar el valor, o no capturar nada del entorno para comenzar.</p>
<p>La forma en que un closure captura y maneja los valores del entorno afecta qu√©
traits implementa el closure, y los traits son c√≥mo las funciones y los
structs pueden especificar qu√© tipos de closures pueden usar. Los closures
implementar√°n autom√°ticamente uno, dos o los tres de estos traits <code>Fn</code>, de
manera aditiva, dependiendo de c√≥mo el cuerpo del closure maneje los valores:</p>
<ol>
<li><code>FnOnce</code> se aplica los closures que pueden ser llamados una vez. Todos los
closures implementan al menos este trait, porque todos los closures pueden
ser llamados. Un closure que mueve valores capturados fuera de su cuerpo
solo implementar√° <code>FnOnce</code> y ninguno de los otros traits <code>Fn</code>, porque solo
puede ser llamado una vez.</li>
<li><code>FnMut</code> se aplica a los closures que no mueven valores capturados fuera de
su cuerpo, pero que podr√≠an mutar los valores capturados. Estos closures
pueden ser llamados m√°s de una vez.</li>
<li><code>Fn</code> se aplica a los closures que no mueven valores capturados fuera de su
cuerpo y que no mutan los valores capturados, as√≠ como los closures que no
capturan nada de su entorno. Estos closures pueden ser llamados m√°s de una
vez sin mutar su entorno, lo cual es importante en casos como llamar a un
closure m√∫ltiples veces concurrentemente.</li>
</ol>
<p>Veamos la definici√≥n del m√©todo <code>unwrap_or_else</code> en <code>Option&lt;T&gt;</code> que utilizamos
en el Listado 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Recuerda que <code>T</code> es el tipo generic que representa el tipo del valor en la
variante <code>Some</code> de un <code>Option</code>. Ese tipo <code>T</code> tambi√©n es el tipo de retorno de
la funci√≥n <code>unwrap_or_else</code>: el c√≥digo que llama a <code>unwrap_or_else</code> en un
<code>Option&lt;String&gt;</code>, por ejemplo, obtendr√° un <code>String</code>.</p>
<p>Luego, observe que el m√©todo <code>unwrap_or_else</code> tiene el par√°metro de tipo
generic adicional <code>F</code>. El tipo <code>F</code> es el tipo del par√°metro llamado <code>f</code>, que
es el closure que proporcionamos al llamar a <code>unwrap_or_else</code>.</p>
<p>El trait bound especificado en el tipo generic <code>F</code> es <code>FnOnce() -&gt; T</code>, lo que
significa que <code>F</code> debe poder ser llamado una vez para producir un valor del
tipo <code>T</code>. Usar <code>FnOnce</code> en el trait bound expresa la restricci√≥n de que
<code>unwrap_or_else</code> solo va a llamar a <code>f</code> como m√°ximo una vez. En el cuerpo de
<code>unwrap_or_else</code>, podemos ver que si el <code>Option</code> es <code>Some</code>, <code>f</code> no se llamar√°.
Si el <code>Option</code> es <code>None</code>, <code>f</code> se llamar√° una vez. Debido a que todos los
closures implementan <code>FnOnce</code>, <code>unwrap_or_else</code> acepta todos esos tipos de 
closures y es tan flexible como puede ser.</p>
<blockquote>
<p>Nota: Las funciones tambi√©n pueden implementar los tres traits <code>Fn</code>, <code>FnMut</code>
y <code>FnOnce</code>. Si lo que queremos hacer no requiere capturar un valor del
entorno, podemos usar el nombre de una funci√≥n en lugar de un closure donde
necesitamos algo que implemente uno de los traits <code>Fn</code>. Por ejemplo, en un
valor <code>Option&lt;Vec&lt;T&gt;&gt;</code>, podr√≠amos llamar a <code>unwrap_or_else(Vec::new)</code> para
obtener un nuevo vector vac√≠o si el valor es <code>None</code>.</p>
</blockquote>
<p>Ahora veamos el m√©todo de la biblioteca est√°ndar <code>sort_by_key</code> definido en
slices, para ver c√≥mo difiere de <code>unwrap_or_else</code> y por qu√© <code>sort_by_key</code>
utiliza <code>FnMut</code> en lugar de <code>FnOnce</code> para el trait bound. El closure recibe un
argumento en forma de referencia al elemento actual en el slice que se est√°
considerando, y devuelve un valor de tipo <code>K</code> que se puede ordenar. Esta
funci√≥n es √∫til cuando desea ordenar un slice por un atributo particular de
cada elemento. En el Listado 13-7, tenemos una lista de instancias de
<code>Rectangle</code> y usamos <code>sort_by_key</code> para ordenarlas por su atributo <code>width</code>
de menor a mayor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{list:#?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-7: Usando <code>sort_by_key</code> para ordenar
rect√°ngulos por ancho</span></p>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>La raz√≥n por la que <code>sort_by_key</code> est√° definido para tomar un closure <code>FnMut</code>
es que llama al closure varias veces: una vez por cada elemento en el slice.
El closure <code>|r| r.width</code> no captura, muta ni mueve nada de su entorno, por lo
que cumple con los requisitos de los trait bound.</p>
<p>En contraste, El Listado 13-8 muestra un ejemplo de un closure que implementa
solo el trait <code>FnOnce</code>, porque mueve un valor fuera del entorno. El
compilador no nos permitir√° usar este closure con <code>sort_by_key</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;closure called&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{list:#?}&quot;);
}</code></pre>
<p><span class="caption">Listing 13-8: Intentando usar un closure <code>FnOnce</code> con
<code>sort_by_key</code></span></p>
<p>Esto es un ejemplo artificial y complicado (que no funciona) para tratar de
contar la cantidad de veces que se llama a <code>sort_by_key</code> llama a la closure al 
ordenar <code>list</code>.
Este c√≥digo intenta hacer este conteo empujando <code>value</code>‚Äîun <code>String</code> del
entorno del closure‚Äîen el vector <code>sort_operations</code>. El closure captura <code>value</code>
y luego mueve <code>value</code> fuera del closure transfiriendo la propiedad de <code>value</code>
al vector <code>sort_operations</code>. Este closure puede ser llamado una vez; tratar de
llamarlo una segunda vez no funcionar√≠a porque <code>value</code> ya no estar√≠a en el
entorno para ser empujado a <code>sort_operations</code> nuevamente. Por lo tanto, este
closure solo implementa <code>FnOnce</code>. Cuando intentamos compilar este c√≥digo,
obtenemos este error de que <code>value</code> no se puede mover fuera del closure porque
el closure debe implementar <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from(&quot;closure called&quot;);
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin &quot;rectangles&quot;) due to 1 previous error
</code></pre>
<p>El error se√±ala la l√≠nea en el cuerpo del closure que mueve <code>value</code> fuera del
entorno. Para solucionar esto, debemos cambiar el cuerpo del closure para que
no mueva valores fuera del entorno. Para contar la cantidad de veces que se
llama a la closure, mantener un contador en el entorno e incrementar su
valor en el cuerpo del closure es una forma m√°s directa de calcular eso. El
closure en el Listado 13-9 funciona con <code>sort_by_key</code> porque solo est√°
capturando una referencia mutable al contador <code>num_sort_operations</code> y, por lo
tanto, puede ser llamado m√°s de una vez:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{list:#?}, sorted in {num_sort_operations} operations&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 13-9: Usando un closure <code>FnMut</code> con <code>sort_by_key</code>
est√° permitido</span></p>
<p>Los <code>Fn</code> traits son importantes al definir o usar funciones o tipos que
hacen uso de closures. En la siguiente secci√≥n, discutiremos los iteradores.
Muchos m√©todos de iteradores toman argumentos de closure, ¬°as√≠ que tenga en
cuenta estos detalles de closure a medida que continuamos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="procesando-una-serie-de-elementos-con-iteradores"><a class="header" href="#procesando-una-serie-de-elementos-con-iteradores">Procesando una serie de elementos con Iteradores</a></h2>
<p>El patr√≥n de iterador te permite realizar alguna tarea en una secuencia de
elementos a su vez. Un iterador es responsable de la l√≥gica de iterar sobre
cada elemento y determinar cu√°ndo ha terminado la secuencia. Cuando usas
iterators, no tienes que reimplementar esa l√≥gica t√∫ mismo.</p>
<p>En rust, los iterators son <em>lazy</em>, lo que significa que no tienen efecto hasta
que llamas a m√©todos que consumen el iterador para usarlo. Por ejemplo, el
c√≥digo en el Listado 13-10 crea un iterador sobre los elementos del vector <code>v1</code>
llamando al m√©todo <code>iter</code> definido en <code>Vec&lt;T&gt;</code>. Este c√≥digo por s√≠ solo no hace
nada √∫til.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-10: Creando un iterator</span></p>
<p>El iterador es almacenado en la variable <code>v1_iter</code>. Una vez que hemos creado un
iterator, podemos usarlo de varias maneras. En el Listado 3-5 del Cap√≠tulo 3,
iteramos sobre un array usando un bucle <code>for</code> para ejecutar alg√∫n c√≥digo en cada
uno de sus elementos. Bajo el cap√≥, esto crea e impl√≠citamente consume un
iterator, pero pasamos por alto c√≥mo funciona exactamente hasta ahora.</p>
<p>En el ejemplo del Listado 13-11, separamos la creaci√≥n del iterador del uso del
iterador en el bucle <code>for</code>. Cuando el bucle <code>for</code> es llamado usando el iterator
en <code>v1_iter</code>, cada elemento en el iterador es usado en una iteraci√≥n del bucle,
lo que imprime cada valor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;Got: {val}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-11: Usando un iterador en un bucle <code>for</code></span></p>
<p>En lenguajes que no tienen iterators provistos por sus bibliotecas est√°ndar,
probablemente escribir√≠as esta misma funcionalidad comenzando una variable en
el √≠ndice 0, usando esa variable para indexar en el vector para obtener un
valor, e incrementando el valor de la variable en un bucle hasta que alcanzara
el n√∫mero total de elementos en el vector.</p>
<p>Los iterators manejan toda esa l√≥gica por ti, reduciendo el c√≥digo repetitivo
que podr√≠as potencialmente arruinar. Los iterators te dan m√°s flexibilidad para
usar la misma l√≥gica con muchos tipos diferentes de secuencias, no solo
estructuras de datos en las que puedes indexar, como los vectores. Examinemos
c√≥mo los iterators hacen eso.</p>
<h3 id="el-trait-iterator-y-el-m√©todo-next"><a class="header" href="#el-trait-iterator-y-el-m√©todo-next">El trait <code>Iterator</code> y el m√©todo <code>next</code></a></h3>
<p>Todos los iterators implementan un trait llamado <code>Iterator</code> que est√° definido
en la biblioteca est√°ndar. La definici√≥n del trait se ve as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<p>Observa que esta definici√≥n usa una nueva sintaxis: <code>type Item</code> y
<code>Self::Item</code>, que definen un <em>associated type</em> con este trait. Hablaremos sobre
los associated types en profundidad en el Cap√≠tulo 19. Por ahora, todo lo que
necesitas saber es que este c√≥digo dice que implementar el trait <code>Iterator</code>
requiere que tambi√©n definas un tipo <code>Item</code>, y este tipo <code>Item</code> es usado en el
tipo de retorno del m√©todo <code>next</code>. En otras palabras, el tipo <code>Item</code> ser√° el
tipo retornado del iterator.</p>
<p>El trait <code>Iterator</code> solo requiere que los implementadores definan un m√©todo:
el m√©todo <code>next</code>, que retorna un item del iterador a la vez envuelto en <code>Some</code>
y, cuando la iteraci√≥n ha terminado, retorna <code>None</code>.</p>
<p>Podemos llamar al m√©todo <code>next</code> en los iterators directamente; el Listado 13-12
demuestra qu√© valores son retornados de llamadas repetidas a <code>next</code> en el
iterador creado desde el vector.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-12: Llamando al m√©todo <code>next</code> en un
iterator</span></p>
<p>Nota que necesitamos hacer <code>v1_iter</code> mutable: llamar al m√©todo <code>next</code> en un
iterador cambia el estado interno que el iterador usa para mantenerse al tanto
de d√≥nde est√° en la secuencia. En otras palabras, este c√≥digo <em>consume</em>, o usa,
el iterator. Cada llamada a <code>next</code> consume un item del iterator. No necesitamos
hacer <code>v1_iter</code> mutable cuando usamos un bucle <code>for</code> porque el bucle toma
posesi√≥n de <code>v1_iter</code> y lo hace mutable detr√°s de escena.</p>
<p>Tambi√©n debemos tener en cuenta que los valores que obtenemos de las llamadas a
<code>next</code> son referencias inmutables a los valores en el vector. El m√©todo <code>iter</code>
produce un iterador sobre referencias inmutables. Si queremos crear un iterator
que tome posesi√≥n de <code>v1</code> y retorne valores pose√≠dos, podemos llamar a
<code>into_iter</code> en lugar de <code>iter</code>. De manera similar, si queremos iterar sobre
referencias mutables, podemos llamar a <code>iter_mut</code> en lugar de <code>iter</code>.</p>
<h3 id="m√©todos-que-consumen-el-iterator"><a class="header" href="#m√©todos-que-consumen-el-iterator">M√©todos que consumen el iterator</a></h3>
<p>El trait <code>Iterator</code> tiene una variedad de m√©todos con implementaciones
predeterminadas provistas por la biblioteca est√°ndar; puedes encontrar
informaci√≥n sobre estos m√©todos en la documentaci√≥n de la biblioteca est√°ndar
para el trait <code>Iterator</code>. Algunos de estos m√©todos llaman al m√©todo <code>next</code> en su
definici√≥n, por lo que se requiere que implementes el m√©todo <code>next</code> al
implementar el trait <code>Iterator</code>.</p>
<p>Los m√©todos que llaman a <code>next</code> se llaman <em>consuming adaptors</em>, porque
consumen el iterador llamando a <code>next</code>. Un ejemplo es el m√©todo <code>sum</code>, que
toma posesi√≥n del iterador y lo itera a trav√©s de los items llamando a <code>next</code>,
as√≠ consumiendo el iterator. A medida que itera a trav√©s de ellos, agrega cada
item a un total en ejecuci√≥n y retorna el total cuando la iteraci√≥n est√°
completa. El Listado 13-13 tiene una prueba que ilustra el uso del m√©todo <code>sum</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-13: Llamando al m√©todo <code>sum</code> para obtener el 
total de todos los items en el iterator</span></p>
<p>No se nos permite usar <code>v1_iter</code> despu√©s de la llamada a <code>sum</code> porque <code>sum</code>
toma el ownership del iterador en el que lo llamamos.</p>
<h3 id="m√©todos-que-producen-otros-iterators"><a class="header" href="#m√©todos-que-producen-otros-iterators">M√©todos que producen otros iterators</a></h3>
<p><em>Iterator adaptors</em> son m√©todos definidos en el trait <code>Iterator</code> que no
consumen el iterator. En cambio, producen diferentes iterators cambiando alg√∫n
aspecto del iterador original.</p>
<p>El Listado 13-14 muestra un ejemplo de llamar al m√©todo adaptador de iterator
<code>map</code> que toma un closure para llamar en cada item y produce un nuevo iterator.
El m√©todo <code>map</code> retorna un nuevo iterador que ejecuta el closure que le
pasamos en cada item y produce los items resultantes. El closure aqu√≠ crea un
nuevo iterador en el que cada item del vector ser√° incrementado en 1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-14: Llamando al iterador adaptor <code>map</code> para
crear un nuevo iterator</span></p>
<p>Como siempre, este c√≥digo producir√° un warning:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>El c√≥digo del Listado 13-14 no hace nada; el closure que hemos especificado
nunca es llamado. El warning nos recuerda por qu√©: los iterador adaptors son
perezosos, y necesitamos consumir el iterador aqu√≠.</p>
<p>Para solucionar este warning y consumir el iterator, usaremos el m√©todo
<code>collect</code>, que usamos en el Cap√≠tulo 12 con <code>env::args</code> en el Listado 12-1. Este
m√©todo consume el iterador y colecciona los valores resultantes en un tipo de
colecci√≥n.</p>
<p>En el Listado 13-15, recolectamos los resultados de iterar sobre el iterator
que es retornado de la llamada a <code>map</code> en un vector. Este vector terminar√°
conteniendo cada item del vector original incrementado en 1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-15: Llamando al m√©todo <code>map</code> para crear un 
nuevo iterador y luego llamando al m√©todo <code>collect</code> para consumir el nuevo 
iterador y crear un vector</span></p>
<p>Debido a que <code>map</code> toma un closure, podemos especificar cualquier operaci√≥n que
queramos realizar en cada item. Este es un gran ejemplo de c√≥mo los closures te
permiten personalizar alg√∫n comportamiento mientras reutilizas el comportamiento
de iteraci√≥n que el trait <code>Iterator</code> provee.</p>
<p>Puedes encadenar m√∫ltiples llamadas a iterador adaptors para realizar acciones
complejas de una manera legible. Pero debido a que todos los iterators son
perezosos, tienes que llamar a uno de los m√©todos adaptadores consumidores para
obtener resultados de las llamadas a iterador adaptors.</p>
<h3 id="usando-closures-que-capturan-su-entorno"><a class="header" href="#usando-closures-que-capturan-su-entorno">Usando Closures que Capturan su Entorno</a></h3>
<p>Muchos de los iterador adaptors toman closures como argumentos, y com√∫nmente los
closures que especificaremos como argumentos a iterador adaptors capturar√°n su
entorno.</p>
<p>Para este ejemplo, usaremos el m√©todo <code>filter</code> definido en el trait <code>Iterator</code>,
que toma un closure que toma un item y retorna un <code>bool</code>. Si el closure retorna
<code>true</code>, el valor ser√° incluido en el iterador producido. Si el closure retorna
<code>false</code>, el valor no ser√° incluido en el iterador producido.</p>
<p>En el Listado 13-16, usamos <code>filter</code> con un closure que captura la variable
<code>shoe_size</code> de su entorno para iterar sobre una colecci√≥n de instancias de la
estructura <code>Shoe</code>. Retornar√° solo los zapatos que sean del tama√±o especificado.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;sandal&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;sneaker&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;boot&quot;)
                },
            ]
        );
    }
}</code></pre>
<p><span class="caption">Listing 13-16: Usando el m√©todo <code>filter</code> con un closure
que captura <code>shoe_size</code></span></p>
<p>La funci√≥n <code>shoes_in_size</code> toma ownership de un vector de zapatos y un tama√±o de
zapato como par√°metros. Retorna un vector que contiene solo zapatos del tama√±o
especificado.</p>
<p>En el cuerpo de <code>shoes_in_size</code>, llamamos a <code>into_iter</code> para crear un iterator
que tome ownership del vector. Luego llamamos a <code>filter</code> para adaptar ese
iterador en un nuevo iterador que solo contiene elementos para los cuales el
closure retorna <code>true</code>.</p>
<p>El closure captura el par√°metro <code>shoe_size</code> del entorno y compara el valor con
el tama√±o de cada zapato, manteniendo solo los zapatos del tama√±o especificado.
Finalmente, llamando a <code>collect</code> recolectamos los valores retornados por el
iterador adaptado en un vector que es retornado por la funci√≥n.</p>
<p>El test muestra que cuando llamamos a <code>shoes_in_size</code> con un vector de zapatos
y un tama√±o de zapato, obtenemos de vuelta solo los zapatos del tama√±o
especificado:</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mejorando-nuestro-proyecto-io"><a class="header" href="#mejorando-nuestro-proyecto-io">Mejorando nuestro proyecto I/O</a></h2>
<p>Con este nuevo conocimiento sobre iteradores, podemos mejorar el proyecto I/O
en el Cap√≠tulo 12 usando iteradores para hacer que los lugares en el c√≥digo
sean m√°s claros y concisos. Veamos c√≥mo los iterators pueden mejorar nuestra
implementaci√≥n de la funci√≥n <code>Config::build</code> y la funci√≥n <code>search</code>.</p>
<h3 id="removiendo-un-clone-usando-un-iterator"><a class="header" href="#removiendo-un-clone-usando-un-iterator">Removiendo un <code>clone</code> usando un iterator</a></h3>
<p>En el Listado 12-6, agregamos c√≥digo que tom√≥ un slice de valores <code>String</code> y
cre√≥ una instancia del struct <code>Config</code> indexando en el slice y clonando
los valores, permitiendo que el struct <code>Config</code> posea esos valores. En el
Listado 13-17, hemos reproducido la implementaci√≥n de la funci√≥n <code>Config::build</code>
tal como estaba en el Listado 12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-17: Reproducci√≥n de la funci√≥n <code>Config::build</code>
del Listing 12-23</span></p>
<p>En ese momento, dijimos que no nos preocup√°ramos por las llamadas ineficientes
a <code>clone</code> porque las eliminar√≠amos en el futuro. ¬°Bueno, ese momento es ahora!</p>
<p>Necesit√°bamos <code>clone</code> aqu√≠ porque tenemos un slice con elementos <code>String</code> en el
par√°metro <code>args</code>, pero la funci√≥n <code>build</code> no posee <code>args</code>. Para retornar la
propiedad de una instancia de <code>Config</code>, tuvimos que clonar los valores de los
campos <code>query</code> y <code>file_path</code> de <code>Config</code> para que la instancia de <code>Config</code>
pueda poseer sus valores.</p>
<p>Con nuestro nuevo conocimiento sobre iteradores, podemos cambiar la funci√≥n
<code>build</code> para tomar propiedad de un iterator como su argumento en lugar de
tomar prestado un slice. Usaremos la funcionalidad del iterator en lugar del
c√≥digo que verifica la longitud del slice e indexa en ubicaciones espec√≠ficas.
Esto aclarar√° lo que la funci√≥n <code>Config::build</code> est√° haciendo porque el
iterator acceder√° a los valores.</p>
<p>Una vez que <code>Config::build</code> tome ownership del iterator y deje de usar
operaciones de indexaci√≥n que toman borrowing, podemos mover los valores
<code>String</code> del iterator dentro de <code>Config</code> en lugar de llamar a <code>clone</code> y hacer
una nueva asignaci√≥n.</p>
<h4 id="usando-el-iterator-retornado-directamente"><a class="header" href="#usando-el-iterator-retornado-directamente">Usando el iterator retornado directamente</a></h4>
<p>Abre tu proyecto I/O en <em>src/main.rs</em>, el cual deber√≠a verse as√≠:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p>Primero cambiaremos el inicio de la funci√≥n <code>main</code> que ten√≠amos en el Listado
12-24 al c√≥digo del Listado 13-18, el cual esta vez usa un iterator. Esto no
compilar√° hasta que actualicemos <code>Config::build</code> tambi√©n.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listing 13-18: Pasando el valor de retorno de <code>env::args</code>
a <code>Config::build</code></span></p>
<p>¬°La funci√≥n <code>env::args</code> retorna un iterator! En lugar de recolectar los valores
del iterator en un vector y luego pasar un slice a <code>Config::build</code>, ahora
estamos pasando ownership del iterator retornado por <code>env::args</code> directamente a
<code>Config::build</code>.</p>
<p>Luego, necesitamos actualizar la definici√≥n de <code>Config::build</code>. En el archivo
<em>src/lib.rs</em> de tu proyecto I/O, cambiemos la firma de <code>Config::build</code> para que
se vea como el Listado 13-19. Esto a√∫n no compilar√° porque necesitamos
actualizar el cuerpo de la funci√≥n.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-19: Actualizando la firma de <code>Config::build</code>
para esperar un iterator</span></p>
<p>La documentaci√≥n de la biblioteca est√°ndar para la funci√≥n <code>env::args</code> muestra
que el tipo del iterator que retorna es <code>std::env::Args</code>, y que ese tipo
implementa el trait <code>Iterator</code> y retorna valores <code>String</code>.</p>
<p>Hemos actualizado la firma de la funci√≥n <code>Config::build</code> para que el par√°metro
<code>args</code> tenga un tipo gen√©rico con los trait bounds
<code>impl Iterator&lt;Item = String&gt;</code> en lugar de <code>&amp;[String]</code>. Este uso de la sintaxis
<code>impl Trait</code> que discutimos en la secci√≥n <a href="ch10-02-traits.html#traits-como-parametros">‚ÄúTraits como par√°metros‚Äù</a></p>
<!-- ignore --> del Cap√≠tulo 10 significa que `args` puede ser cualquier tipo
<p>que implemente el trait <code>Iterator</code> y retorne items <code>String</code>.</p>
<p>Debido a que estamos tomando ownership de <code>args</code> y estaremos mutando <code>args</code>
por iterarlo, podemos agregar la palabra clave <code>mut</code> en la especificaci√≥n del
par√°metro <code>args</code> para hacerlo mutable.</p>
<h4 id="usando-los-m√©todos-del-trait-iterator-en-lugar-de-indexar"><a class="header" href="#usando-los-m√©todos-del-trait-iterator-en-lugar-de-indexar">Usando los m√©todos del trait <code>Iterator</code> en lugar de indexar</a></h4>
<p>Luego, necesitamos actualizar el cuerpo de <code>Config::build</code> para usar los
m√©todos del trait <code>Iterator</code> en lugar de indexar en el slice. En el Listado
13-20 hemos actualizado el c√≥digo del Listado 12-23 para usar el m√©todo <code>next</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file path&quot;),
        };

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-20: Cambiando el cuerpo de <code>Config::build</code> para
usar m√©todos de iterators</span></p>
<p>Recuerda que el primer valor en el valor de retorno de <code>env::args</code> es el nombre
del programa. Queremos ignorar eso y llegar al siguiente valor, as√≠ que
primero llamamos a <code>next</code> y no hacemos nada con el valor de retorno. Segundo,
llamamos a <code>next</code> para obtener el valor que queremos poner en el campo <code>query</code>
de <code>Config</code>. Si <code>next</code> retorna un <code>Some</code>, usamos un <code>match</code> para extraer el
valor. Si retorna <code>None</code>, significa que no se dieron suficientes argumentos y
retornamos temprano con un valor <code>Err</code>. Hacemos lo mismo para el valor
<code>file_path</code>.</p>
<h3 id="haciendo-el-c√≥digo-m√°s-claro-con-iterator-adaptors"><a class="header" href="#haciendo-el-c√≥digo-m√°s-claro-con-iterator-adaptors">Haciendo el c√≥digo m√°s claro con iterator adaptors</a></h3>
<p>Tambi√©n podemos aprovechar los iterators en la funci√≥n <code>search</code> de nuestro
proyecto I/O, el cual se reproduce aqu√≠ en el Listado 13-21 como estaba en el
Listado 12-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-21: La implementaci√≥n de la funci√≥n <code>search</code>
del Listing 12-19</span></p>
<p>Podemos escribir este c√≥digo de una manera m√°s concisa usando los m√©todos
adaptor del iterator. Hacerlo tambi√©n nos permite evitar tener un vector
intermedio mutable <code>results</code>. El estilo de programaci√≥n funcional prefiere
minimizar la cantidad de estado mutable para hacer el c√≥digo m√°s claro. Remover
el estado mutable podr√≠a permitir una mejora futura para hacer que la b√∫squeda
ocurra en paralelo, porque no tendr√≠amos que manejar el acceso concurrente al
vector <code>results</code>. El Listado 13-22 muestra este cambio:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a query string&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a file path&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-22: Utilizando m√©todo iterator adaptor en la
implementaci√≥n de la funci√≥n <code>search</code></span></p>
<p>Recuerda que el prop√≥sito de la funci√≥n <code>search</code> es retornar todas las l√≠neas
en <code>contents</code> que contengan <code>query</code>. Similar al ejemplo de <code>filter</code> en el
Listado 13-16, este c√≥digo usa el adaptador <code>filter</code> para mantener solo las
l√≠neas que retornan <code>true</code> para <code>line.contains(query)</code>. Luego recolectamos las
l√≠neas que coinciden en otro vector con <code>collect</code>. ¬°Mucho m√°s simple! Si√©ntete
libre de hacer el mismo cambio para usar los m√©todos del iterator en la funci√≥n
<code>search_case_insensitive</code> tambi√©n.</p>
<h3 id="escogiendo-entre-loops-o-iterators"><a class="header" href="#escogiendo-entre-loops-o-iterators">Escogiendo entre loops o iterators</a></h3>
<p>La siguiente pregunta l√≥gica es qu√© estilo deber√≠as escoger en tu propio c√≥digo
y por qu√©: la implementaci√≥n original en el Listado 13-21 o la versi√≥n usando
iterators en el Listado 13-22. La mayor√≠a de los programadores Rust prefieren
usar el estilo de iterators. Es un poco m√°s dif√≠cil de entender al principio,
pero una vez que obtienes una idea de los varios adaptadores de iterators y lo
que hacen, los iterators pueden ser m√°s f√°ciles de entender. En lugar de
manipular los varios bits de los loops y construir nuevos vectores, el c√≥digo
se enfoca en el objetivo de alto nivel del loop. Esto abstrae un poco del
c√≥digo com√∫n para que sea m√°s f√°cil ver los conceptos que son √∫nicos a este
c√≥digo, como la condici√≥n de filtrado que cada elemento en el iterator debe
pasar.</p>
<p>¬øPero son las dos implementaciones realmente equivalentes? La suposici√≥n
intuitiva podr√≠a ser que el loop m√°s bajo nivel ser√° m√°s r√°pido. Hablemos de
performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comparando-performance-bucles-vs-iteradores"><a class="header" href="#comparando-performance-bucles-vs-iteradores">Comparando Performance: Bucles vs. Iteradores</a></h2>
<p>Para determinar si usar loops o iterators, necesitas saber cu√°l implementaci√≥n
es m√°s r√°pida: la versi√≥n de la funci√≥n <code>search</code> con un <code>for</code> loop expl√≠cito o
la versi√≥n con iterators.</p>
<p>Realizamos un benchmark cargando el contenido completo de <em>The Adventures of
Sherlock Holmes</em> de Sir Arthur Conan Doyle en un <code>String</code> y buscando la palabra
<em>the</em> en el contenido. Aqu√≠ est√°n los resultados del benchmark en la versi√≥n de
<code>search</code> usando el ciclo <code>for</code> y la versi√≥n usando iterators:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>La versi√≥n del iterator fue ligeramente m√°s r√°pida! No explicaremos el c√≥digo
del benchmark aqu√≠, porque el punto no es probar que las dos versiones son
equivalentes, sino obtener una idea general de c√≥mo estas dos implementaciones
se comparan en t√©rminos de performance.</p>
<p>Para un benchmark m√°s completo, deber√≠as verificar usando varios textos de
varios tama√±os como el <code>contents</code>, diferentes palabras y palabras de diferentes
longitudes como el <code>query</code>, y todo tipo de otras variaciones. El punto es este:
los iterators, aunque son una abstracci√≥n de alto nivel, se compilan a
aproximadamente el mismo c√≥digo que si hubieras escrito el c√≥digo de m√°s bajo
nivel t√∫ mismo. Los iterators son una de las <em>abstracciones de costo cero</em> de
Rust, por lo que queremos decir que el uso de la abstracci√≥n no impone ning√∫n
costo adicional en tiempo de ejecuci√≥n. Esto es an√°logo a c√≥mo Bjarne
Stroustrup, el dise√±ador e implementador original de C++, define <em>cero costo</em> en
‚ÄúFoundations of C++‚Äù (2012):</p>
<blockquote>
<p>En general, las implementaciones de C++ obedecen el principio de cero costo:
lo que no usas, no pagas. Y adem√°s: lo que usas, no podr√≠as codificarlo a
mano mejor.</p>
</blockquote>
<p>Como otro ejemplo, el siguiente c√≥digo es tomado de un decodificador de audio.
El algoritmo de decodificaci√≥n usa la operaci√≥n matem√°tica de predicci√≥n lineal
para estimar valores futuros basados en una funci√≥n lineal de las muestras
anteriores. Este c√≥digo usa un string de iteradores para hacer algunos c√°lculos
en tres variables en el scope: un slice <code>buffer</code> de datos, un array de 12
<code>coefficients</code>, y una cantidad por la cual desplazar datos en <code>qlp_shift</code>. Hemos
declarado las variables dentro de este ejemplo, pero no les hemos dado ning√∫n
valor; aunque este c√≥digo no tiene mucho sentido fuera de su contexto, sigue
siendo un ejemplo conciso y del mundo real de c√≥mo Rust traduce ideas de alto
nivel a c√≥digo de bajo nivel.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p>Para calcular el valor de <code>prediction</code>, este c√≥digo itera a trav√©s de cada uno
de los 12 valores en <code>coefficients</code> y usa el m√©todo <code>zip</code> para emparejar los
valores de los coeficientes con los 12 valores anteriores en <code>buffer</code>. Luego,
para cada par, multiplicamos los valores juntos, sumamos todos los resultados y
desplazamos los bits en la suma <code>qlp_shift</code> bits a la derecha.</p>
<p>Calculaciones en aplicaciones como decodificadores de audio a menudo priorizan
el performance. Aqu√≠, estamos creando un iterator, usando dos adaptadores, y
luego consumiendo el valor. ¬øQu√© c√≥digo ensamblador compilar√≠a este c√≥digo Rust?
Bueno, a partir de este escrito, compila al mismo ensamblador que escribir√≠as a
mano. No hay ning√∫n ciclo correspondiente a la iteraci√≥n sobre los valores en
<code>coefficients</code>: Rust sabe que hay 12 iteraciones, por lo que ‚Äúdesenrolla‚Äù el
ciclo. <em>Desenrollar</em> es una optimizaci√≥n que elimina el overhead del c√≥digo de
control del ciclo y en su lugar genera c√≥digo repetitivo para cada iteraci√≥n del
ciclo.</p>
<p>Todos los coeficientes se almacenan en registros, lo que significa que acceder
a los valores es muy r√°pido. No hay verificaciones de l√≠mites en el acceso al
array en tiempo de ejecuci√≥n. Todas estas optimizaciones que Rust es capaz de
aplicar hacen que el c√≥digo resultante sea extremadamente eficiente. Ahora que
sabes esto, ¬°puedes usar iterators y closures sin miedo! Hacen que el c√≥digo
parezca de m√°s alto nivel, pero no imponen una penalizaci√≥n de performance en
tiempo de ejecuci√≥n por hacerlo.</p>
<h2 id="resumen-12"><a class="header" href="#resumen-12">Resumen</a></h2>
<p>Los closures e iterators son caracter√≠sticas de Rust inspiradas en ideas de
lenguajes de programaci√≥n funcionales. Contribuyen a la capacidad de Rust de
expresar claramente ideas de alto nivel a bajo nivel de performance. Las
implementaciones de closures e iterators son tales que el performance en tiempo
de ejecuci√≥n no se ve afectado. Esto es parte de la meta de Rust de esforzarse
por proveer abstracciones de costo cero.</p>
<p>Ahora que mejoramos la expresividad de nuestro proyecto I/O, veamos algunas
caracter√≠sticas m√°s de <code>cargo</code> que nos ayudar√°n a compartir el proyecto con el
mundo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m√°s-sobre-cargo-y-cratesio"><a class="header" href="#m√°s-sobre-cargo-y-cratesio">M√°s sobre Cargo y Crates.io</a></h1>
<p>Hasta ahora, s√≥lo hemos usado las caracter√≠sticas m√°s b√°sicas de Cargo para
construir, ejecutar y probar nuestro c√≥digo, pero puede hacer mucho m√°s. En este
cap√≠tulo, discutiremos algunas de sus otras caracter√≠sticas m√°s avanzadas para
mostrarle c√≥mo hacer lo siguiente:</p>
<ul>
<li>Personaliza tu compilaci√≥n a trav√©s de perfiles de lanzamiento</li>
<li>Publicar bibliotecas en <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Organizar grandes proyectos con workspaces</li>
<li>Instalar binarios de <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Extender Cargo usando comandos personalizados</li>
</ul>
<p>Cargo puede hacer a√∫n m√°s que la funcionalidad que cubrimos en este cap√≠tulo,
as√≠ que para una explicaci√≥n completa de todas sus caracter√≠sticas, consulte la
<a href="https://doc.rust-lang.org/cargo/">documentaci√≥n</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="personalizando-compilaciones-con-perfiles-de-lanzamiento"><a class="header" href="#personalizando-compilaciones-con-perfiles-de-lanzamiento">Personalizando compilaciones con perfiles de lanzamiento</a></h2>
<p>En Rust, los <em>release profiles</em> son perfiles predefinidos y personalizables con
diferentes configuraciones que permiten a un programador tener m√°s control sobre
varias opciones para compilar c√≥digo. Cada perfil se configura de forma
independiente de los dem√°s.</p>
<p>Cargo tiene dos perfiles principales: el perfil <code>dev</code> que Cargo usa cuando
ejecutas <code>cargo build</code> y el perfil <code>release</code> que Cargo usa cuando ejecutas
<code>cargo build --release</code>. El perfil <code>dev</code> est√° definido con buenos valores
predeterminados para el desarrollo, y el perfil <code>release</code> tiene buenos valores
predeterminados para las compilaciones de lanzamiento.</p>
<p>Estos nombres de perfil pueden ser familiares en la salida de tus compilaciones:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p>El perfil <code>dev</code> y <code>release</code> son estos perfiles diferentes utilizados por el
compilador.</p>
<p>Cargo tiene valores predeterminados para cada uno de los perfiles que se
aplican cuando no has agregado expl√≠citamente ninguna secci√≥n <code>[profile.*]</code> en
el archivo <em>Cargo.toml</em> del proyecto. Al agregar secciones <code>[profile.*]</code> para
cualquier perfil que desees personalizar, anular√°s cualquier subconjunto de los
valores predeterminados. Por ejemplo, aqu√≠ est√°n los valores predeterminados
para la configuraci√≥n <code>opt-level</code> para los perfiles <code>dev</code> y <code>release</code>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>El ajuste <code>opt-level</code> controla la cantidad de optimizaciones que Rust aplicar√°
a tu c√≥digo, con un rango de 0 a 3. Aplicar m√°s optimizaciones extiende el
tiempo de compilaci√≥n, por lo que si est√°s en desarrollo y compilando tu c√≥digo
con frecuencia, querr√°s menos optimizaciones para compilar m√°s r√°pido, incluso
si el c√≥digo resultante se ejecuta m√°s lento. El <code>opt-level</code> predeterminado para
<code>dev</code> es, por lo tanto, <code>0</code>. Cuando est√©s listo para lanzar tu c√≥digo, es mejor
dedicar m√°s tiempo a compilar. Solo compilar√°s en modo de lanzamiento una vez,
pero ejecutar√°s el programa compilado muchas veces, por lo que el modo de
lanzamiento intercambia un tiempo de compilaci√≥n m√°s largo por un c√≥digo que se
ejecuta m√°s r√°pido. Es por eso que el <code>opt-level</code> predeterminado para el perfil
<code>release</code> es <code>3</code>.</p>
<p>Puedes anular un ajuste predeterminado agregando un valor diferente para √©l en
<em>Cargo.toml</em>. Por ejemplo, si queremos usar el nivel de optimizaci√≥n 1 en el
perfil de desarrollo, podemos agregar estas dos l√≠neas al archivo <em>Cargo.toml</em>
del proyecto:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Este c√≥digo anula la configuraci√≥n predeterminada de <code>0</code>. Ahora, cuando
ejecutemos <code>cargo build</code>, Cargo usar√° los valores predeterminados para el perfil
<code>dev</code> m√°s nuestra personalizaci√≥n de <code>opt-level</code>. Debido a que establecimos
<code>opt-level</code> en <code>1</code>, Cargo aplicar√° m√°s optimizaciones que el valor 
predeterminado, pero no tantas como en una compilaci√≥n de lanzamiento.</p>
<p>Para la lista completa de opciones de configuraci√≥n y valores predeterminados
para cada perfil, consulta la 
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">documentaci√≥n de Cargo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="publicando-un-crate-a-cratesio"><a class="header" href="#publicando-un-crate-a-cratesio">Publicando un Crate a Crates.io</a></h2>
<p>Hasta ahora, hemos usado paquetes de <a href="https://crates.io/">crates.io</a><!-- ignore
--> como dependencias de nuestro proyecto, pero tambi√©n puedes compartir tu
c√≥digo con otras personas publicando tus propios paquetes. El registro de
paquetes en <a href="https://crates.io/">crates.io</a><!-- ignore --> distribuye el c√≥digo
fuente de tus paquetes, por lo que aloja principalmente c√≥digo que es de c√≥digo
abierto.</p>
<p>Rust y Cargo tienen caracter√≠sticas que hacen que tu paquete publicado sea m√°s
f√°cil de encontrar y usar. Hablaremos sobre algunas de estas caracter√≠sticas a
continuaci√≥n y luego explicaremos c√≥mo publicar un paquete.</p>
<h3 id="haciendo-comentarios-de-documentaci√≥n-√∫tiles"><a class="header" href="#haciendo-comentarios-de-documentaci√≥n-√∫tiles">Haciendo comentarios de documentaci√≥n √∫tiles</a></h3>
<p>Documentar adecuadamente tus paquetes ayudar√° a otros usuarios a saber c√≥mo y
cu√°ndo usarlos, por lo que vale la pena invertir el tiempo para escribir
documentaci√≥n. En el Cap√≠tulo 3, discutimos c√≥mo comentar el c√≥digo Rust usando
dos barras diagonales, <code>//</code>. Rust tambi√©n tiene un tipo particular de comentario
para la documentaci√≥n, conocido convenientemente como un <em>comentario de
documentaci√≥n</em>, que generar√° documentaci√≥n HTML. El HTML muestra el contenido
de los comentarios de documentaci√≥n para los elementos de API p√∫blicos
destinados a programadores interesados en saber c√≥mo <em>usar</em> tu paquete en
oposici√≥n a c√≥mo se <em>implementa</em> tu paquete.</p>
<p>Los comentarios de documentaci√≥n usan tres barras diagonales, <code>///</code>, en lugar
de dos y admiten la notaci√≥n Markdown para formatear el texto. Coloca los
comentarios de documentaci√≥n justo antes del elemento que est√°n documentando.
El Listado 14-1 muestra comentarios de documentaci√≥n para una funci√≥n <code>add_one</code>
en un crate llamado <code>my_crate</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p><span class="caption">Listing 14-1: Un comentario de documentaci√≥n para una
funci√≥n</span></p>
<p>Aqu√≠, damos una descripci√≥n de lo que hace la funci√≥n <code>add_one</code>, comenzamos una
secci√≥n con el encabezado <code>Examples</code> y luego proporcionamos c√≥digo que
demuestra c√≥mo usar la funci√≥n <code>add_one</code>. Podemos generar la documentaci√≥n HTML
de este comentario de documentaci√≥n ejecutando <code>cargo doc</code>. Este comando ejecuta
la herramienta <code>rustdoc</code> distribuida con Rust y coloca la documentaci√≥n HTML
generada en el directorio <em>target/doc</em>.</p>
<p>Por conveniencia, ejecutar <code>cargo doc --open</code> generar√° el HTML para la
documentaci√≥n de tu crate actual (as√≠ como la documentaci√≥n para todas las
dependencias de tu crate) y abrir√° el resultado en un navegador web. Navega
hasta la funci√≥n <code>add_one</code> y ver√°s c√≥mo se renderiza el texto en los comentarios
de documentaci√≥n, como se muestra en la Figura 14-1:</p>
<img alt="Documentaci√≥n HTML renderizada para la funci√≥n `add_one` de `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Figura 14-1: documentaci√≥n en HTML para la funci√≥n
<code>add_one</code></span></p>
<h4 id="secciones-com√∫nmente-usadas"><a class="header" href="#secciones-com√∫nmente-usadas">Secciones com√∫nmente usadas</a></h4>
<p>Hemos usado el encabezado de Markdown <code># Examples</code> en el Listado 14-1 para crear
una secci√≥n en el HTML con el t√≠tulo &quot;Examples&quot;. Aqu√≠ hay algunas otras
secciones que los autores de crates com√∫nmente usan en su documentaci√≥n:</p>
<ul>
<li><strong>Panics</strong>: Los escenarios en los que la funci√≥n documentada podr√≠a
entrar en panic. Los llamadores de la funci√≥n que no quieren que sus
programas entren en panic deben asegurarse de no llamar a la funci√≥n en
estas situaciones.</li>
<li><strong>Errores</strong>: Si la funci√≥n devuelve un <code>Result</code>, describir los tipos de
errores que podr√≠an ocurrir y qu√© condiciones podr√≠an hacer que esos errores
se devuelvan puede ser √∫til para los llamadores para que puedan escribir
c√≥digo para manejar los diferentes tipos de errores de diferentes maneras.</li>
<li><strong>Seguridad</strong>: Si la funci√≥n es <code>unsafe</code> de llamar (discutimos unsafe en
el Cap√≠tulo 19), deber√≠a haber una secci√≥n que explique por qu√© la funci√≥n es
insegura y cubra las invariantes que la funci√≥n espera que los llamadores
mantengan.</li>
</ul>
<p>La mayor√≠a de los comentarios de documentaci√≥n no necesitan todas estas
secciones, pero esta es una buena lista de verificaci√≥n para recordar los
aspectos del c√≥digo que los usuarios estar√°n interesados en saber.</p>
<h4 id="comentarios-de-documentacion-como-tests"><a class="header" href="#comentarios-de-documentacion-como-tests">Comentarios de documentacion como Tests</a></h4>
<p>Agregar bloques de c√≥digo de ejemplo en tus comentarios de documentaci√≥n puede
ayudar a demostrar c√≥mo usar tu biblioteca, y hacerlo tiene una ventaja
adicional: ¬°ejecutar <code>cargo test</code> ejecutar√° los ejemplos de c√≥digo en tu
documentaci√≥n como pruebas! Nada es mejor que la documentaci√≥n con ejemplos.
Pero nada es peor que los ejemplos que no funcionan porque el c√≥digo ha cambiado
desde que se escribi√≥ la documentaci√≥n. Si ejecutamos <code>cargo test</code> con la
documentaci√≥n para la funci√≥n <code>add_one</code> del Listado 14-1, veremos una secci√≥n en
los resultados de la prueba como esta:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>¬°Ahora si cambiamos la funci√≥n o el ejemplo para que el <code>assert_eq!</code> en el
ejemplo entre en p√°nico y ejecutamos <code>cargo test</code> nuevamente, veremos que los
doc tests capturan que el ejemplo y el c√≥digo est√°n fuera de sincronizaci√≥n
entre s√≠!</p>
<h4 id="comentando-items-contenidos"><a class="header" href="#comentando-items-contenidos">Comentando items contenidos</a></h4>
<p>El estilo de comentario de doc <code>//!</code> agrega documentaci√≥n al item que contiene
los comentarios en lugar de a los items que siguen a los comentarios.
Normalmente, usamos estos comentarios de documentaci√≥n dentro del archivo ra√≠z
del crate (<em>src/lib.rs</em> por convenci√≥n) o dentro de un m√≥dulo para documentar el
crate o el m√≥dulo en su conjunto.</p>
<p>Por ejemplo, para agregar documentaci√≥n que describe el prop√≥sito del crate
<code>my_crate</code> que contiene la funci√≥n <code>add_one</code>, agregamos comentarios de
documentaci√≥n que comienzan con <code>//!</code> al principio del archivo <em>src/lib.rs</em>,
como se muestra en el Listado 14-2:</p>
<p><span class="filename">Nombre de archivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listado 14-2: Documentaci√≥n para el crate <code>my_crate</code> como
un todo</span></p>
<p>Observa que no hay ning√∫n c√≥digo despu√©s de la √∫ltima l√≠nea que comienza con
<code>//!</code>. Debido a que comenzamos los comentarios con <code>//!</code> en lugar de <code>///</code>,
estamos documentando el item que contiene este comentario en lugar de un item
que sigue a este comentario. En este caso, ese item es el archivo <em>src/lib.rs</em>,
que es el crate root. Estos comentarios describen todo el crate.</p>
<p>Cuando ejecutamos <code>cargo doc --open</code> ahora, veremos la documentaci√≥n para el
crate <code>my_crate</code> en lugar de la documentaci√≥n para la funci√≥n <code>add_one</code>, como
se muestra en la Figura 14-2:</p>
<img alt="Documentaci√≥n HTML renderizada con un comentario para el crate como un todo" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Figura 14-2: Documentaci√≥n renderizada para <code>my_crate</code>,
incluido el comentario que describe el crate como un todo</span></p>
<p>Los comentarios de documentaci√≥n dentro de los items son √∫tiles para describir
crates y m√≥dulos en particular. √ösalos para explicar el prop√≥sito general del
contenedor para ayudar a tus usuarios a comprender la organizaci√≥n del crate.</p>
<h3 id="exportando-una-api-publica-conveniente-con-pub-use"><a class="header" href="#exportando-una-api-publica-conveniente-con-pub-use">Exportando una API publica conveniente con <code>pub use</code></a></h3>
<p>La estructura de tu API p√∫blica es una consideraci√≥n importante al publicar un
crate. Las personas que usan tu crate est√°n menos familiarizadas con la
estructura que t√∫ y podr√≠an tener dificultades para encontrar las piezas que
desean usar si tu crate tiene una gran jerarqu√≠a de m√≥dulos.</p>
<p>En el Cap√≠tulo 7, cubrimos c√≥mo hacer que los items sean p√∫blicos usando la
palabra clave <code>pub</code> y traer items a un scope con la palabra clave <code>use</code>.
Sin embargo, la estructura que tiene sentido para ti mientras desarrollas un
crate puede que no sea muy conveniente para tus usuarios. Es posible que desees
organizar tus structs en una jerarqu√≠a que contenga varios niveles, pero luego
las personas que desean usar un tipo que has definido profundamente en la
jerarqu√≠a podr√≠an tener problemas para descubrir que ese tipo existe. Tambi√©n
podr√≠an estar molestos por tener que ingresar <code>use</code>
<code>my_crate::some_module::another_module::UsefulType;</code> en lugar de <code>use</code>
<code>my_crate::UsefulType;</code>.</p>
<p>Las buenas noticias son que si la estructura <em>no</em> es conveniente para que otros
la usen desde otra biblioteca, no tienes que reorganizar tu organizaci√≥n
interna: en su lugar, puedes reexportar items para hacer una estructura p√∫blica
que sea diferente de tu estructura privada usando <code>pub use</code>. Reexportar toma un
item p√∫blico en una ubicaci√≥n y lo hace p√∫blico en otra ubicaci√≥n, como si se
definiera en la otra ubicaci√≥n en su lugar.</p>
<p>Por ejemplo, supongamos que creamos una biblioteca llamada <code>art</code> para modelar
conceptos art√≠sticos. Dentro de esta biblioteca hay dos m√≥dulos: un m√≥dulo
<code>kinds</code> que contiene dos enums llamados <code>PrimaryColor</code> y <code>SecondaryColor</code> y un
m√≥dulo <code>utils</code> que contiene una funci√≥n llamada <code>mix</code>, como se muestra en el
Listado 14-3:</p>
<p><span class="filename">Nombre de archivo: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
<p><span class="caption">Listado 14-3: Una biblioteca llamada <code>art</code> con items
organizados en los m√≥dulos <code>kinds</code> y <code>utils</code></span></p>
<p>La Figura 14-3 muestra c√≥mo se ver√≠a la p√°gina frontal de la documentaci√≥n para
este crate generada por <code>cargo doc</code>:</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Figure 14-3: P√°gina principal de la documentaci√≥n de <code>art</code>
que enumera los m√≥dulos <code>kinds</code> y <code>utils</code></span></p>
<p>Nota que los tipos <code>PrimaryColor</code> y <code>SecondaryColor</code> no est√°n listados en la
p√°gina principal. Tampoco lo est√° la funci√≥n <code>mix</code>. Para verlos, tendr√≠amos que
hacer clic en <code>kinds</code> y <code>utils</code>.</p>
<p>Otro crate que depende de esta biblioteca necesitar√≠a declarar un <code>use</code> que
traigan los items de <code>art</code> al scope, especificando la estructura de m√≥dulos
actualmente definida. El Listado 14-4 muestra un ejemplo de un crate que usa
los items <code>PrimaryColor</code> y <code>mix</code> del crate <code>art</code>:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<p><span class="caption">Listado 14-4: Un crate que utiliza los items del crate
<code>art</code> con su estructura interna exportada</span></p>
<p>El autor del c√≥digo en el Listado 14-4, que usa el crate <code>art</code>, tuvo que
averiguar que <code>PrimaryColor</code> est√° en el m√≥dulo <code>kinds</code> y <code>mix</code> est√° en el
m√≥dulo <code>utils</code>. La estructura de m√≥dulos del crate <code>art</code> es m√°s relevante para
los desarrolladores que trabajan en el crate <code>art</code> que para aquellos que lo
usan. La estructura interna no contiene ninguna informaci√≥n √∫til para alguien
que intenta comprender c√≥mo usar el crate <code>art</code>, sino que causa confusi√≥n
porque los desarrolladores que lo usan tienen que averiguar d√≥nde buscar y
deben especificar los nombres de m√≥dulo en las declaraciones <code>use</code>.</p>
<p>Para remover la estructura interna de la API p√∫blica, podemos modificar el
c√≥digo del crate <code>art</code> en el Listado 14-3 para agregar declaraciones <code>pub use</code>
para reexportar los items en el nivel superior, como se muestra en el Listado
14-5:</p>
<p><span class="filename">Nombre de archivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listado 14-5: Agregando declaraciones <code>pub use</code> para
re-exportar items</span></p>
<p>La documentaci√≥n de la API que <code>cargo doc</code> genera para este crate ahora
listar√° y enlazar√° los reexports en la p√°gina principal, como se muestra en la
Figura 14-4, haciendo que los tipos <code>PrimaryColor</code> y <code>SecondaryColor</code> y la
funci√≥n <code>mix</code> sean m√°s f√°ciles de encontrar.</p>
<img alt="Documentaci√≥n renderizada para el crate `art` con las re-exportaciones en la p√°gina principal" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Figura 14-4: La p√°gina principal de la documentaci√≥n para
<code>art</code> que lista las re-exportaciones</span></p>
<p>Los usuarios del crate <code>art</code> a√∫n pueden ver y usar la estructura interna del
Listado 14-3 como se demuestra en el Listado 14-4, o pueden usar la estructura
m√°s conveniente del Listado 14-5, como se muestra en el Listado 14-6:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
<p><span class="caption">Listado 14-6: Un programa que utiliza los items
reexportados del crate <code>art</code></span></p>
<p>En casos donde hay muchos m√≥dulos anidados, reexportar los tipos en el nivel
superior con <code>pub use</code> puede hacer una diferencia significativa en la
experiencia de las personas que usan el crate. Otro uso com√∫n de <code>pub use</code> es
reexportar definiciones de una dependencia en el crate actual para hacer que
las definiciones de ese crate sean parte de la API p√∫blica de su crate.</p>
<p>Crear una estructura de API p√∫blica es m√°s un arte que una ciencia, y puedes
iterar para encontrar la API que funcione mejor para tus usuarios. Elegir <code>pub use</code> te da flexibilidad en c√≥mo estructuras tu crate internamente y desacopla
esa estructura interna de lo que presentas a tus usuarios. Mira algo del c√≥digo
de los crates que has instalado para ver si su estructura interna difiere de su
API p√∫blica.</p>
<h3 id="configurando-una-cuenta-de-cratesio"><a class="header" href="#configurando-una-cuenta-de-cratesio">Configurando una cuenta de Crates.io</a></h3>
<p>Antes de que puedas publicar cualquier crate, necesitas crear una cuenta en
<a href="https://crates.io/">crates.io</a><!-- ignore --> y obtener un token de API. Para
hacerlo, visita la p√°gina de inicio en
<a href="https://crates.io/">crates.io</a><!-- ignore --> e inicia sesi√≥n a trav√©s de una
cuenta de GitHub. (La cuenta de GitHub es actualmente un requisito, pero el
sitio podr√≠a admitir otras formas de crear una cuenta en el futuro). Una vez
que hayas iniciado sesi√≥n, visita la configuraci√≥n de tu cuenta en
<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> y recupera tu
clave de API. Luego ejecuta el comando <code>cargo login</code> y pega tu clave de la API, 
cuando se solicitad, como se muestra a continuaci√≥n:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Este comando informar√° a Cargo de tu token de API y lo almacenar√° localmente en
<em>~/.cargo/credentials</em>. Ten en cuenta que este token es un <em>secreto</em>: no lo
compartas con nadie. Si lo compartes con alguien por cualquier motivo, debes
revocarlo y generar un nuevo token en
<a href="https://crates.io/">crates.io</a><!-- ignore -->.</p>
<h3 id="agregando-metadata-a-un-nuevo-crate"><a class="header" href="#agregando-metadata-a-un-nuevo-crate">Agregando metadata a un nuevo crate</a></h3>
<p>Supongamos que tienes un crate que deseas publicar. Antes de publicarlo,
necesitar√°s agregar algunos metadatos en la secci√≥n <code>[package]</code> del archivo
<em>Cargo.toml</em> del crate.</p>
<p>Tu crate necesitar√° un nombre √∫nico. Mientras trabajas en un crate localmente,
puedes nombrar un crate como quieras. Sin embargo, los nombres de los crates en
<a href="https://crates.io/">crates.io</a><!-- ignore --> se asignan por orden de llegada.
Una vez que se toma un nombre de crate, nadie m√°s puede publicar un crate con
ese nombre. Antes de intentar publicar un crate, busca el nombre que deseas
usar. Si el nombre ha sido usado, deber√°s encontrar otro nombre y editar el
campo <code>name</code> en el archivo <em>Cargo.toml</em> bajo la secci√≥n <code>[package]</code> para usar
el nuevo nombre para publicar, como se muestra a continuaci√≥n:</p>
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Incluso si has elegido un nombre √∫nico, cuando ejecutes <code>cargo publish</code> para
publicar el crate en este punto, obtendr√°s una advertencia y luego un error:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>Estos errores se deben a que te faltan algunos datos cruciales: se requiere una
descripci√≥n y una licencia para que las personas sepan qu√© hace tu crate y
bajo qu√© t√©rminos pueden usarlo. En <em>Cargo.toml</em>, agrega una descripci√≥n que
sea solo una o dos oraciones, porque aparecer√° con tu crate en los resultados
de b√∫squeda. Para el campo <code>license</code>, debes dar un <em>valor de identificador de
licencia</em>. La <a href="http://spdx.org/licenses/">Linux Foundation‚Äôs Software Package Data Exchange (SPDX)</a>
enumera los identificadores que puedes usar para este valor. Por ejemplo, para
especificar que has licenciado tu crate usando la Licencia MIT, agrega el
identificador <code>MIT</code>:</p>
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>Si tu deseas especificar una licencia que no aparece en el SPDX, necesitas
colocar el texto de esa licencia en un archivo, incluir el archivo en tu
proyecto y luego usar <code>license-file</code> para especificar el nombre de ese archivo
en lugar de usar la key <code>license</code>.</p>
<p>La orientaci√≥n sobre qu√© licencia es apropiada para tu proyecto est√° fuera del
alcance de este libro. Muchas personas en la comunidad de Rust licencian sus
proyectos de la misma manera que Rust, usando una licencia dual de <code>MIT OR Apache-2.0</code>. Esta pr√°ctica demuestra que tambi√©n puedes especificar m√∫ltiples
identificadores de licencia separados por <code>OR</code> para tener m√∫ltiples licencias
para tu proyecto.</p>
<p>Con un nombre √∫nico, la versi√≥n, una descripci√≥n y una licencia agregados, el
archivo <em>Cargo.toml</em> para un proyecto que est√° listo para publicar podr√≠a
verse as√≠:</p>
<p><span class="filename">Nombre de archivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">La documentaci√≥n de Cargo</a> describe otros
metadatos que puedes especificar para asegurarte de que otros puedan descubrir
y usar tu crate m√°s f√°cilmente.</p>
<h3 id="publicando-en-cratesio"><a class="header" href="#publicando-en-cratesio">Publicando en Crates.io</a></h3>
<p>Ahora que has creado una cuenta, guardado tu token de API, elegido un nombre
para tu crate y especificado los metadatos requeridos, ¬°est√°s listo para
publicar! Publicar un crate carga una versi√≥n espec√≠fica en
<a href="https://crates.io/">crates.io</a><!-- ignore --> para que otros la usen.</p>
<p>Ten cuidado, porque una publicaci√≥n es <em>permanente</em>. La versi√≥n nunca se puede
sobrescribir y el c√≥digo no se puede eliminar. Uno de los principales objetivos
de <a href="https://crates.io/">crates.io</a><!-- ignore --> es actuar como un archivo
permanente de c√≥digo para que las compilaciones de todos los proyectos que
dependen de crates de <a href="https://crates.io/">crates.io</a><!-- ignore --> sigan
funcionando. Permitir la eliminaci√≥n de versiones har√≠a imposible cumplir ese
objetivo. Sin embargo, no hay l√≠mite en la cantidad de versiones de crate que
puedes publicar.</p>
<p>Ejecuta el comando <code>cargo publish</code> otra vez. Esta vez, deber√≠a tener √©xito:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>¬°Felicidades! Ahora has compartido tu c√≥digo con la comunidad de Rust y
cualquiera puede agregar tu crate como una dependencia de su proyecto.</p>
<h3 id="publicando-una-nueva-versi√≥n-de-un-crate-existente"><a class="header" href="#publicando-una-nueva-versi√≥n-de-un-crate-existente">Publicando una Nueva Versi√≥n de un Crate Existente</a></h3>
<p>Cuando hayas realizado cambios en tu crate y est√©s listo para publicar una
nueva versi√≥n, cambia el valor <code>version</code> especificado en tu archivo
<em>Cargo.toml</em> y vuelve a publicar. Usa las
<a href="http://semver.org/">reglas de versionado sem√°ntico</a> para decidir cu√°l es el siguiente
n√∫mero de versi√≥n apropiado en funci√≥n de los tipos de cambios que hayas
realizado. Luego, ejecuta <code>cargo publish</code> para cargar la nueva versi√≥n.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="deprecando-versiones-de-cratesio-con-cargo-yank"><a class="header" href="#deprecando-versiones-de-cratesio-con-cargo-yank">Deprecando Versiones de Crates.io con <code>cargo yank</code></a></h3>
<p>Aunque no puedes eliminar versiones anteriores de un crate, puedes evitar que
cualquier proyecto futuro las agregue como una nueva dependencia. Esto es √∫til
cuando una versi√≥n de crate est√° rota por una raz√≥n u otra. En tales
situaciones, Cargo admite <em>yanking</em> una versi√≥n de crate.</p>
<p>Hacer un <em>yank</em> a una versi√≥n impide que nuevos proyectos dependan de esa
versi√≥n, pero permite que todos los proyectos existentes que dependen de ella
contin√∫en. Esencialmente, un <em>yank</em> significa que todos los proyectos con un
<em>Cargo.lock</em> no se romper√°n y que cualquier <em>Cargo.lock</em> futuro generado no
usar√° la versi√≥n <em>yanked</em>.</p>
<p>Para hacer un <em>yank</em> de una versi√≥n de un crate, en el directorio del crate que
has publicado previamente, ejecuta <code>cargo yank</code> y especifica qu√© versi√≥n
deseas <em>yank</em>. Por ejemplo, si hemos publicado un crate llamado
<code>guessing_game</code> versi√≥n 1.0.1 y queremos <em>yank</em> la versi√≥n, en el directorio
del proyecto para <code>guessing_game</code> ejecutar√≠amos:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>Al agregar <code>--undo</code> al comando, tambi√©n puedes deshacer un <em>yank</em> y permitir
que los proyectos vuelvan a depender de una versi√≥n:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>Un <em>yank</em> no borra ning√∫n c√≥digo. No puede, por ejemplo, eliminar secretos
cargados accidentalmente. Si eso sucede, debes restablecer esos secretos
inmediatamente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-workspaces"><a class="header" href="#cargo-workspaces">Cargo Workspaces</a></h2>
<p>En el Cap√≠tulo 12, construimos un paquete que inclu√≠a un <em>crate</em> binario y un
<em>crate</em> de biblioteca. A medida que su proyecto se desarrolle, es posible que
encuentre que el <em>crate</em> de biblioteca contin√∫a creciendo y que desea dividir
su paquete a√∫n m√°s en m√∫ltiples <em>crate</em> de biblioteca. Cargo ofrece una
caracter√≠stica llamada <em>workspaces</em> que puede ayudar a administrar m√∫ltiples
paquetes relacionados que se desarrollan en t√°ndem.</p>
<h3 id="creando-un-workspace"><a class="header" href="#creando-un-workspace">Creando un Workspace</a></h3>
<p>Un <em>workspace</em> es un conjunto de paquetes que comparten el mismo <em>Cargo.lock</em> y
el directorio de salida. Hagamos un proyecto usando un <em>workspace</em> - usaremos
c√≥digo trivial para que podamos concentrarnos en la estructura del
<em>workspace</em>. Hay varias formas de estructurar un <em>workspace</em>, as√≠ que solo
mostraremos una forma com√∫n. Tendremos un <em>workspace</em> que contiene un binario y
dos bibliotecas. El binario, que proporcionar√° la funcionalidad principal,
depender√° de las dos bibliotecas. Una biblioteca proporcionar√° una funci√≥n
<code>add_one</code>, y una segunda biblioteca una funci√≥n <code>add_two</code>. Estas tres cajas
ser√°n parte del mismo <em>workspace</em>. Comenzaremos creando un nuevo directorio
para el <em>workspace</em>:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Luego, en el directorio <em>add</em>, crearemos el archivo <em>Cargo.toml</em> que
configurar√° todo el <em>workspace</em>. Este archivo no tendr√° una secci√≥n <code>[package]</code>.
En su lugar, comenzar√° con una secci√≥n <code>[workspace]</code> que nos permitir√° agregar
miembros al <em>workspace</em> especificando la ruta al paquete con nuestro <em>crate</em>
binario; en este caso, esa ruta es <em>adder</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>A continuaci√≥n, crearemos el crate binario <code>adder</code> ejecutando <code>cargo new</code> 
dentro del directorio <em>add</em>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>En este punto, podemos construir el <em>workspace</em> ejecutando <code>cargo build</code>. Los
archivos en su directorio <em>add</em> deber√≠an verse as√≠:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ adder
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
</code></pre>
<p>El <em>workspace</em> tiene un directorio <em>target</em> en el nivel superior que contendr√°
los artefactos compilados. El paquete <code>adder</code> no tiene su propio directorio
<em>target</em>. Incluso si ejecut√°ramos <code>cargo build</code> desde dentro del directorio
<em>adder</em>, los artefactos compilados a√∫n terminar√≠an en <em>add/target</em> en lugar de
<em>add/adder/target</em>. Cargo estructura el directorio <em>target</em> en un <em>workspace</em>
de esta manera porque los <em>crate</em> en un <em>workspace</em> est√°n destinados a
dependerse entre s√≠. Si cada <em>crate</em> tuviera su propio directorio <em>target</em>,
cada <em>crate</em> tendr√≠a que volver a compilar cada uno de los otros <em>crate</em> en el
<em>workspace</em> para colocar los artefactos en su propio directorio <em>target</em>. Al
compartir un directorio <em>target</em>, los <em>crate</em> pueden evitar la reconstrucci√≥n
innecesaria.</p>
<h3 id="creando-el-segundo-paquete-en-el-workspace"><a class="header" href="#creando-el-segundo-paquete-en-el-workspace">Creando el Segundo Paquete en el Workspace</a></h3>
<p>A continuaci√≥n crearemos otro paquete miembro en el <em>workspace</em> y lo llamaremos
<code>add_one</code>. Cambie el <em>Cargo.toml</em> de nivel superior para especificar la ruta
<em>add_one</em> en la lista de <code>members</code>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add_one&quot;,
]
</code></pre>
<p>Luego generaremos un nuevo <em>crate</em> de biblioteca llamado <code>add_one</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
</code></pre>
<p>Tu directorio <em>add</em> deber√≠a tener estos directorios y archivos:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ add_one
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ adder
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
</code></pre>
<p>En el archivo <em>add_one/lib.rs</em>, agreguemos una funci√≥n <code>add_one</code>:</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Ahora podemos hacer que el paquete <code>adder</code> con nuestro binario dependa del 
paquete <code>add_one</code> con nuestra biblioteca. Primero, necesitaremos agregar una
dependencia de ruta en <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Filename: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = &quot;../add_one&quot; }
</code></pre>
<p>Cargo no asume que los crates en un <em>workspace</em> depender√°n entre s√≠, por lo que
necesitamos ser expl√≠citos sobre las relaciones de dependencia.</p>
<p>A continuaci√≥n, usaremos la funci√≥n <code>add_one</code> (del <em>crate</em> <code>add_one</code>) en el
crate <code>adder</code>. Abra el archivo <em>adder/src/main.rs</em> y agregue una l√≠nea <code>use</code>
en la parte superior para traer el nuevo <em>crate</em> de biblioteca <code>add_one</code> al
alcance. Luego cambie la funci√≥n <code>main</code> para llamar a la funci√≥n <code>add_one</code>, como
en el Listado 14-7.</p>
<p><span class="filename">Filename: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {num} plus one is {}!&quot;, add_one::add_one(num));
}</code></pre>
<p><span class="caption">Listing 14-7: Usando el crate de biblioteca <code>add_one</code> 
desde el crate <code>adder</code></span></p>
<p>¬°Construyamos el workspace ejecutando <code>cargo build</code> en el directorio superior
<em>add</em>!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>Para ejecutar el crate binario desde el directorio <em>add</em>, podemos especificar
qu√© paquete en el <em>workspace</em> queremos ejecutar con el argumento <code>-p</code> y el
nombre del paquete con <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Esto ejecuta el c√≥digo en <em>adder/src/main.rs</em>, que depende del crate <code>add_one</code>.</p>
<h4 id="dependiendo-de-un-paquete-externo-en-un-workspace"><a class="header" href="#dependiendo-de-un-paquete-externo-en-un-workspace">Dependiendo de un Paquete Externo en un Workspace</a></h4>
<p>Observa que el workspace tiene solo un archivo <em>Cargo.lock</em> en el nivel
superior, en lugar de tener un <em>Cargo.lock</em> en cada directorio de <em>crate</em>.
Esto asegura que todos los <em>crate</em> est√©n usando la misma versi√≥n de todas las
dependencias. Si agregamos el paquete <code>rand</code> al <em>Cargo.toml</em> de <em>adder</em> y
<em>add_one</em>, Cargo resolver√° ambos a una versi√≥n de <code>rand</code> y lo registrar√° en el
√∫nico <em>Cargo.lock</em>. Hacer que todos los <em>crate</em> en el <em>workspace</em> usen las
mismas dependencias significa que los <em>crate</em> siempre ser√°n compatibles entre
s√≠. Agreguemos el <em>crate</em> <code>rand</code> a la secci√≥n <code>[dependencies]</code> en el archivo
<em>add_one/Cargo.toml</em> para que podamos usar el <em>crate</em> <code>rand</code> en el <em>crate</em>
<code>add_one</code>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Filename: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>Ahora podemos agregar <code>use rand;</code> al archivo <em>add_one/src/lib.rs</em>, y construir
todo el <em>workspace</em> ejecutando <code>cargo build</code> en el directorio <em>add</em> traer√° e
compilar√° el <em>crate</em> <code>rand</code>. Obtendremos una advertencia porque no nos estamos
refiriendo al <code>rand</code> que trajimos al scope:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>El archivo <em>Cargo.lock</em> de nivel superior ahora contiene informaci√≥n sobre la
dependencia de <code>add_one</code> en <code>rand</code>. Sin embargo, aunque <code>rand</code> se usa en alg√∫n
lugar del <em>workspace</em>, no podemos usarlo en otros <em>crate</em> del <em>workspace</em> a
menos que agreguemos <code>rand</code> a sus archivos <em>Cargo.toml</em> tambi√©n. Por ejemplo,
si agregamos <code>use rand;</code> al archivo <em>adder/src/main.rs</em> para el paquete
<code>adder</code>, obtendremos un error:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>Para solucionar esto, edita el archivo <em>Cargo.toml</em> del paquete <code>adder</code> e
indica que <code>rand</code> es una dependencia para √©l tambi√©n. Construir el paquete
<code>adder</code> agregar√° <code>rand</code> a la lista de dependencias para <code>adder</code> en
<em>Cargo.lock</em>, pero no se descargar√°n copias adicionales de <code>rand</code>. Cargo se 
asegurara de que cada <em>crate</em> en cada paquete en el <em>workspace</em> que usa el
paquete <code>rand</code> estar√° usando la misma versi√≥n siempre y cuando se especifiquen 
como versiones compatibles de <code>rand</code>, ahorr√°ndonos espacio y asegurando que los 
<em>crate</em> en el <em>workspace</em> ser√°n compatibles entre s√≠.</p>
<h4 id="agregando-un-test-a-un-workspace"><a class="header" href="#agregando-un-test-a-un-workspace">Agregando un Test a un Workspace</a></h4>
<p>Para otra mejora, agreguemos una prueba de la funci√≥n <code>add_one::add_one</code> dentro
del <em>crate</em> <code>add_one</code>:</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}</code></pre>
<p>Ahora ejecutamos <code>cargo test</code> en el directorio superior <em>add</em> para ejecutar los 
tests una estructura de workspace como esta ejecutar√° los tests para todos los
crates en el workspace:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>La primera secci√≥n del output muestra que el test <code>it_works</code> en el crate
<code>add_one</code> pas√≥. La siguiente secci√≥n muestra que no se encontraron tests en el
crate <code>adder</code>, y luego la √∫ltima secci√≥n muestra que no se encontraron tests de
documentaci√≥n en el crate <code>add_one</code>.</p>
<p>Tambi√©n podemos ejecutar tests para un crate en particular en el workspace
desde el directorio superior usando la bandera <code>-p</code> y especificando el nombre
del crate que queremos testear:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Este output muestra que <code>cargo test</code> solo ejecut√≥ los tests para el crate
<code>add_one</code> y no ejecut√≥ los tests del crate <code>adder</code>.</p>
<p>Si tu publicas los crates en el workspace en <a href="https://crates.io/">crates.io</a>,
cada crate en el workspace necesitar√° ser publicado por separado. Como <code>cargo test</code>, podemos publicar un crate en particular en nuestro workspace usando la
bandera <code>-p</code> y especificando el nombre del crate que queremos publicar.</p>
<p>Para practicar a√∫n m√°s, agrega un crate <code>add_two</code> a este workspace de manera
similar al crate <code>add_one</code>!</p>
<p>Conforme tu proyecto crece, considera usar un workspace: es m√°s f√°cil de entender
componentes peque√±os e individuales que un gran blob de c√≥digo. Adem√°s,
mantener los crates en un workspace puede hacer que la coordinaci√≥n entre
crates sea m√°s f√°cil si se cambian a menudo al mismo tiempo.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="instalando-binarios-con-cargo-install"><a class="header" href="#instalando-binarios-con-cargo-install">Instalando Binarios con <code>cargo install</code></a></h2>
<p>El comando <code>cargo install</code> te permite instalar y usar crates binarios localmente.
Esto no est√° destinado a reemplazar los paquetes del sistema; est√° destinado a 
ser una forma conveniente para que los desarrolladores de Rust instalen 
herramientas que otros han compartido en <a href="https://crates.io/">crates.io</a><!-- 
ignore -->. Tenga en cuenta que solo puede instalar paquetes que tengan 
objetivos binarios. Un <em>objetivo binario</em> es el programa ejecutable que se crea 
si el crate tiene un archivo <em>src/main.rs</em> u otro archivo especificado como un 
binario, en oposici√≥n a un objetivo de biblioteca que no se puede ejecutar por 
s√≠ solo, pero que es adecuado para incluirlo en otros programas. Por lo general, 
las crates tienen informaci√≥n en el archivo <em>README</em> sobre si una crate es una 
biblioteca, tiene un objetivo binario, o ambos.</p>
<p>Todos los binarios instalados con <code>cargo install</code> se almacenan en la carpeta
ra√≠z de instalaci√≥n de <em>bin</em>. Si instalaste Rust usando <em>rustup.rs</em> y no tienes
configuraciones personalizadas, este directorio ser√° <em>$HOME/.cargo/bin</em>. 
Aseg√∫rese de que el directorio de instalaci√≥n est√© en su <code>$PATH</code> para poder 
ejecutar los programas que ha instalado con <code>cargo install</code>.</p>
<p>Por ejemplo, en el Cap√≠tulo 12, mencionamos que hay una implementaci√≥n de Rust
de la herramienta <code>grep</code> llamada <code>ripgrep</code> para buscar archivos. Para instalar
<code>ripgrep</code>, podemos ejecutar lo siguiente:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>La pen√∫ltima l√≠nea de la salida muestra la ubicaci√≥n y el nombre del binario
instalado, que en el caso de <code>ripgrep</code> es <code>rg</code>. Mientras el directorio de
instalaci√≥n est√© en su <code>$PATH</code>, como se mencion√≥ anteriormente, puede ejecutar
<code>rg --help</code> y comenzar a usar una herramienta m√°s r√°pida y oxidada para buscar
archivos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="extendiendo-cargo-con-comandos-personalizados"><a class="header" href="#extendiendo-cargo-con-comandos-personalizados">Extendiendo Cargo con comandos personalizados</a></h2>
<p>Cargo est√° dise√±ado para que puedas extenderlo con nuevos subcomandos sin tener
que modificar Cargo. Si un binario en tu <code>$PATH</code> se llama <code>cargo-something</code>, lo
puedes ejecutar como si fuera un subcomando de Cargo ejecutando <code>cargo something</code>. Los comandos personalizados como este tambi√©n se enumeran cuando
ejecutas <code>cargo --list</code>. ¬°Poder usar <code>cargo install</code> para instalar extensiones y
luego ejecutarlas como las herramientas integradas de Cargo es un beneficio
s√∫per conveniente del dise√±o de Cargo!</p>
<h2 id="resumen-13"><a class="header" href="#resumen-13">Resumen</a></h2>
<p>Compartir c√≥digo con Cargo y <a href="https://crates.io/">crates.io</a><!-- ignore --> es
parte de lo que hace que el ecosistema de Rust sea √∫til para muchas tareas
diferentes. La biblioteca est√°ndar de Rust es peque√±a y estable, pero los crates
son f√°ciles de compartir, usar y mejorar en una l√≠nea de tiempo diferente a la
del lenguaje. ¬°No seas t√≠mido al compartir c√≥digo que te sea √∫til en
<a href="https://crates.io/">crates.io</a><!-- ignore -->; es probable que tambi√©n sea √∫til
para otra persona!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<p>Un <em>puntero</em> es un concepto general para una variable que contiene una direcci√≥n
en memoria. Esta direcci√≥n se refiere, o ‚Äúapunta a,‚Äù alg√∫n otro dato. El tipo
m√°s com√∫n de puntero en Rust es una referencia, la cual aprendiste en el
Cap√≠tulo 4. Las referencias son indicadas por el s√≠mbolo <code>&amp;</code> y toman prestado
el valor al que apuntan. No tienen ninguna capacidad especial m√°s all√° de
referirse a datos, y no tienen sobrecarga.</p>
<p>Los <em>Smart pointers,</em> por otro lado, son estructuras de datos que act√∫an como un
puntero, pero tambi√©n tienen metadatos y capacidades adicionales. El concepto de
smart pointers no es √∫nico de Rust: los smart pointers se originaron en C++ y
existen en otros lenguajes tambi√©n. Rust tiene una variedad de smart pointers
definidos en la biblioteca est√°ndar que proveen funcionalidad m√°s all√° de la
prove√≠da por las referencias. Para explorar el concepto general, veremos un
par de ejemplos diferentes de smart pointers, incluyendo un tipo de puntero
<em>reference counting</em>. Este puntero te permite permitir que los datos tengan
m√∫ltiples propietarios al mantener un registro del n√∫mero de propietarios y,
cuando no hay propietarios restantes, limpiar los datos.</p>
<p>Rust, con su concepto de propiedad y pr√©stamo, tiene una diferencia adicional
entre referencias y smart pointers: mientras que las referencias solo toman
prestado los datos, en muchos casos, los smart pointers <em>son due√±os</em> de los
datos a los que apuntan.</p>
<p>Aunque no los llamamos as√≠ en ese momento, ya hemos encontrado algunos smart
pointers en este libro, incluyendo <code>String</code> y <code>Vec&lt;T&gt;</code> en el Cap√≠tulo 8. Ambos
estos tipos cuentan como smart pointers porque poseen algo de memoria y te
permiten manipularla. Tambi√©n tienen metadatos y capacidades o garant√≠as
adicionales. <code>String</code>, por ejemplo, almacena su capacidad como metadato y tiene
la capacidad adicional de asegurar que sus datos siempre ser√°n UTF-8 v√°lidos.</p>
<p>Los smart pointers usualmente son implementados usando structs. A diferencia de
un struct ordinaria, los smart pointers implementan los traits <code>Deref</code> y
<code>Drop</code>. El trait <code>Deref</code> permite que una instancia de la struct smart pointer se
comporte como una referencia, as√≠ que puedes escribir tu c√≥digo para trabajar
con referencias o smart pointers. El trait <code>Drop</code> te permite personalizar el
c√≥digo que se ejecuta cuando una instancia del smart pointer sale del scope. En
este cap√≠tulo, discutiremos ambos traits y demostraremos por qu√© son
importantes para los smart pointers.</p>
<p>Dado que el patr√≥n de smart pointer es un patr√≥n de dise√±o general usado
frecuentemente en Rust, este cap√≠tulo no cubrir√° todos los smart pointers
existentes. Muchas bibliotecas tienen sus propios smart pointers, e incluso
puedes escribir los tuyos. Cubriremos los smart pointers m√°s comunes en la
biblioteca est√°ndar:</p>
<ul>
<li><code>Box&lt;T&gt;</code> para asignar valores en el heap</li>
<li><code>Rc&lt;T&gt;</code>, un tipo de conteo de referencias que permite m√∫ltiples ownerships</li>
<li><code>Ref&lt;T&gt;</code> y <code>RefMut&lt;T&gt;</code>, accedidos a trav√©s de <code>RefCell&lt;T&gt;</code>, un tipo que
impone las reglas de borrowing en tiempo de ejecuci√≥n en lugar de tiempo de
compilaci√≥n</li>
</ul>
<p>Adem√°s, cubriremos el patr√≥n <em>interior mutability</em> donde un tipo inmutable
expone una API para mutar un valor interior. Tambi√©n discutiremos <em>reference
cycles</em>: c√≥mo pueden fugar memoria y c√≥mo prevenirlos.</p>
<p>¬°Vamos a profundizar en los smart pointers!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-boxt-para-apuntar-a-datos-en-el-heap"><a class="header" href="#usando-boxt-para-apuntar-a-datos-en-el-heap">Usando <code>Box&lt;T&gt;</code> para Apuntar a Datos en el Heap</a></h2>
<p>La forma m√°s sencilla de smart pointer es un <em>box</em>, cuyo tipo se escribe <code>Box&lt;T&gt;</code>.
Los boxes te permiten almacenar datos en el heap en lugar del stack. Lo que
permanece en el stack es el puntero a los datos del heap. Refi√©rete al Cap√≠tulo 4
para revisar la diferencia entre el stack y el heap.</p>
<p>Los boxes no tienen overhead de performance, m√°s all√° de almacenar sus datos en
el heap en lugar del stack. Pero tampoco tienen muchas capacidades adicionales.
Los usar√°s m√°s frecuentemente en estas situaciones:</p>
<ul>
<li>Cuando tienes un tipo cuyo tama√±o no puede ser conocido en tiempo de
compilaci√≥n y quieres usar un valor de ese tipo en un contexto que requiere un
tama√±o exacto</li>
<li>Cuando tienes una gran cantidad de datos y quieres transferir el ownership,
pero asegurarte de que los datos no ser√°n copiados cuando hagas eso</li>
<li>Cuando quieres ser due√±o de un valor y solo te importa que sea un tipo que
implemente un trait en particular, en lugar de ser de un tipo espec√≠fico</li>
</ul>
<p>Veremos la primera situaci√≥n en la secci√≥n <a href="ch15-01-box.html#habilitando-tipos-recursivos-con-boxes">‚ÄúHabilitando Tipos Recursivos con
Boxes‚Äù</a><!-- ignore -->. En el segundo
caso, transferir el ownership de una gran cantidad de datos puede tomar mucho
tiempo porque los datos son copiados en el stack. Para mejorar el performance en
esta situaci√≥n, podemos almacenar la gran cantidad de datos en el heap en un
box. Entonces, solo la peque√±a cantidad de datos de puntero es copiada en el
stack, mientras que los datos a los que apunta permanecen en un solo lugar en el
heap. El tercer caso es conocido como un <em>trait object</em>, y el Cap√≠tulo 17 dedica
una secci√≥n entera, <a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">‚ÄúUsando Trait Objects que Permiten Valores de Diferentes
Tipos,‚Äù</a><!-- ignore --> solo a ese tema. ¬°As√≠ que lo que aprendas
aqu√≠ lo aplicar√°s nuevamente en el Cap√≠tulo 17!</p>
<h3 id="usando-un-boxt-para-almacenar-datos-en-el-heap"><a class="header" href="#usando-un-boxt-para-almacenar-datos-en-el-heap">Usando un <code>Box&lt;T&gt;</code> para Almacenar Datos en el Heap</a></h3>
<p>Antes de discutir el caso de uso de almacenamiento en el heap para la sintaxis de
<code>Box&lt;T&gt;</code>, cubriremos la sintaxis y c√≥mo interactuar con valores almacenados
dentro de un <code>Box&lt;T&gt;</code>.</p>
<p>El Listado 15-1 muestra c√≥mo usar un box para almacenar un valor <code>i32</code> en el
heap:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {b}&quot;);
}</code></pre></pre>
<p><span class="caption">Listado 15-1: Almacenando un valor <code>i32</code> en el heap usando
un box</span></p>
<p>Declaramos una variable <code>b</code> para tener el valor de un <code>Box</code> que apunta al valor
<code>5</code>, el cual est√° almacenado en el heap. Este programa imprimir√° <code>b = 5</code>; en
este caso, podemos acceder a los datos en el box de forma similar a como lo
har√≠amos en el stack. Como cualquier valor owned, cuando un box sale del scope,
como <code>b</code>hace al final de <code>main</code>, ser√° desasignado. La desasignaci√≥n ocurre tanto
para el box (almacenado en el stack) como para los datos a los que apunta
(almacenados en el heap).</p>
<p>Colocar un solo valor en el heap no es muy √∫til, as√≠ que no usar√°s boxes por s√≠
solos de esta forma muy seguido. Tener valores como un solo <code>i32</code> en el stack,
donde son almacenados por defecto, es m√°s apropiado en la mayor√≠a de
situaciones. Veamos un caso donde los boxes nos permiten definir tipos que no
podr√≠amos definir si no tuvi√©ramos boxes.</p>
<h3 id="habilitando-tipos-recursivos-con-boxes"><a class="header" href="#habilitando-tipos-recursivos-con-boxes">Habilitando Tipos Recursivos con Boxes</a></h3>
<p>Un valor de <em>tipo recursivo</em> puede tener otro valor del mismo tipo como parte de
s√≠ mismo. Los tipos recursivos plantean un problema porque en tiempo de
compilaci√≥n Rust necesita saber cu√°nto espacio ocupa un tipo. Sin embargo, el
anidamiento de valores de tipos recursivos podr√≠a te√≥ricamente continuar
infinitamente, as√≠ que Rust no puede saber cu√°nto espacio necesita el valor.
Como los boxes tienen un tama√±o conocido, podemos habilitar tipos recursivos
insertando un box en la definici√≥n del tipo recursivo.</p>
<p>Como ejemplo de un tipo recursivo, exploremos la <em>cons list</em>. Este es un tipo de
dato com√∫nmente encontrado en lenguajes de programaci√≥n funcionales. El tipo de
cons list que definiremos es sencillo excepto por la recursi√≥n; por lo tanto,
los conceptos en el ejemplo con el que trabajaremos ser√°n √∫tiles en cualquier
situaci√≥n m√°s compleja que involucre tipos recursivos.</p>
<h4 id="m√°s-informaci√≥n-acerca-de-la-cons-list"><a class="header" href="#m√°s-informaci√≥n-acerca-de-la-cons-list">M√°s Informaci√≥n Acerca de la Cons List</a></h4>
<p>Una <em>cons list</em> es una estructura de datos que viene del lenguaje de
programaci√≥n Lisp y sus dialectos y est√° compuesta de pares anidados, y es la
versi√≥n de Lisp de una lista enlazada. Su nombre viene de la funci√≥n <code>cons</code>
(abreviatura de ‚Äúconstruct function‚Äù o ‚Äúfunci√≥n de construcci√≥n‚Äù) en Lisp que
construye un nuevo par a partir de sus dos argumentos. Al llamar <code>cons</code> en un
par que consiste en un valor y otro par, podemos construir cons lists hechas de
pares recursivos.</p>
<p>Por ejemplo, aqu√≠ tenemos una representaci√≥n de pseudoc√≥digo de una cons list
que contiene la lista 1, 2, 3 con cada par en par√©ntesis:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Cada item en una cons list contiene dos elementos: el valor del item actual y el
siguiente item. El √∫ltimo item en la lista contiene solo un valor llamado <code>Nil</code>
sin un siguiente item. Una cons list es producida llamando recursivamente la
funci√≥n <code>cons</code>. El nombre can√≥nico para denotar el caso base de la recursi√≥n es
<code>Nil</code>. Nota que esto no es lo mismo que el concepto de ‚Äúnull‚Äù o ‚Äúnil‚Äù en el
Cap√≠tulo 6, el cual es un valor inv√°lido o ausente.</p>
<p>La cons list no es un tipo de dato que se use com√∫nmente en Rust. La mayor√≠a de
las veces cuando tienes una lista de items en Rust, <code>Vec&lt;T&gt;</code> es una mejor
opci√≥n. Otros tipos de datos recursivos m√°s complejos <em>son</em> √∫tiles en varias
situaciones, pero al comenzar con la cons list en este cap√≠tulo, podemos
explorar c√≥mo los boxes nos permiten definir un tipo de dato recursivo sin mucha
distracci√≥n.</p>
<p>El Listado 15-2 contiene una definici√≥n de enum para una cons list. Nota que
este c√≥digo no compilar√° a√∫n porque el tipo <code>List</code> no tiene un tama√±o conocido,
lo cual demostraremos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Listado 15-2: El primer intento de definir un enum para
representar una estructura de datos de lista de cons con valores <code>i32</code></span></p>
<blockquote>
<p>Nota: Estamos implementando una const list que solo contiene valores <code>i32</code> con
el prop√≥sito de este ejemplo. Podr√≠amos haberla implementado usando gen√©ricos,
como discutimos en el Cap√≠tulo 10, para definir un tipo de cons list que
pueda almacenar valores de cualquier tipo.</p>
</blockquote>
<p>Usando el tipo <code>List</code> para almacenar la lista <code>1, 2, 3</code> se ver√≠a como el c√≥digo
en el Listado 15-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<p><span class="caption">Listado 15-3: Usando el enum <code>List</code> para almacenar la
lista <code>1, 2, 3</code></span></p>
<p>El primer valor <code>Cons</code> contiene <code>1</code> y otro valor <code>List</code>. Este valor <code>List</code> es
otro valor <code>Cons</code> que contiene <code>2</code> y otro valor <code>List</code>. Este valor <code>List</code> es
otro valor <code>Cons</code> que contiene <code>3</code> y un valor <code>List</code>, que es finalmente es
<code>Nil</code>, la variante no recursiva que se√±ala el final de la lista.</p>
<p>Si intentamos compilar el c√≥digo en el Listado 15-3, obtendremos el error que
se muestra en el Listado 15-4:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin &quot;cons-list&quot;) due to 2 previous errors
</code></pre>
<p><span class="caption">Listado 15-4: El error que obtenemos al intentar definir
un enum recursivo</span></p>
<p>El error muestra que este tipo ‚Äútiene un tama√±o infinito‚Äù. La raz√≥n es que
hemos definido <code>List</code> con una variante que es recursiva: contiene otro valor de
s√≠ mismo directamente. Como resultado, Rust no puede averiguar cu√°nto espacio
necesita para almacenar un valor de <code>List</code>. Veamos por qu√© obtenemos este error.
Primero, veremos c√≥mo Rust decide cu√°nto espacio necesita para almacenar un
valor de un tipo no recursivo.</p>
<h4 id="calculando-el-tama√±o-de-un-tipo-no-recursivo"><a class="header" href="#calculando-el-tama√±o-de-un-tipo-no-recursivo">Calculando el Tama√±o de un Tipo No Recursivo</a></h4>
<p>Recuerda el enum <code>Message</code> que definimos en el Listado 6-2 cuando discutimos
definiciones de enum en el Cap√≠tulo 6:</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Para determinar cu√°nto espacio necesita almacenar un valor de tipo <code>Message</code>,
Rust comienza con la variante que necesita la mayor cantidad de espacio. Rust
observa que <code>Message::Quit</code> no necesita ning√∫n espacio, <code>Message::Move</code> necesita
suficiente espacio para almacenar dos valores <code>i32</code> y as√≠ sucesivamente. Como
solo una variante ser√° usada, el espacio que un valor de <code>Message</code> necesita es
el espacio que necesitar√≠a la variante m√°s grande.</p>
<p>Compara esto con lo que sucede cuando Rust intenta determinar cu√°nto espacio
necesita un valor de un tipo recursivo como el enum <code>List</code> en el Listado 15-2.
El compilador comienza mirando la variante <code>Cons</code>, la cual contiene un valor de
tipo <code>i32</code> y un valor de tipo <code>List</code>. Por lo tanto, <code>Cons</code> necesita una cantidad
de espacio igual al tama√±o de un <code>i32</code> m√°s el tama√±o de un <code>List</code>. Para
averiguar cu√°nto espacio necesita el tipo <code>List</code>, el compilador mira las
variantes, comenzando con la variante <code>Cons</code>. La variante <code>Cons</code> contiene un
valor de tipo <code>i32</code> y un valor de tipo <code>List</code>, y este proceso contin√∫a
infinitamente, como se muestra en la Figura 15-1.</p>
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figura 15-1: Un <code>List</code> infinito consistente en variantes
<code>Cons</code> infinitas</span></p>
<h4 id="usando-boxt-para-obtener-un-tipo-recursivo-con-un-tama√±o-conocido"><a class="header" href="#usando-boxt-para-obtener-un-tipo-recursivo-con-un-tama√±o-conocido">Usando <code>Box&lt;T&gt;</code> para Obtener un Tipo Recursivo con un Tama√±o Conocido</a></h4>
<p>Debido a que Rust no puede determinar cu√°nto espacio necesita asignar para tipos
definidos recursivamente, el compilador muestra un error con una sugerencia
util:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>En esta sugerencia, ‚Äúindirecci√≥n‚Äù significa que en lugar de almacenar un valor
directamente, deber√≠amos cambiar la estructura de datos para almacenar el valor
indirectamente almacenando un puntero al valor en su lugar.</p>
<p>Debido a que <code>Box&lt;T&gt;</code> es un tipo de puntero, Rust siempre sabe cu√°nto espacio
necesita un <code>Box&lt;T&gt;</code>: el tama√±o de un puntero no cambia en funci√≥n de la
cantidad de datos que est√° almacenando. Esto significa que podemos poner un
<code>Box&lt;T&gt;</code> dentro de la variante <code>Cons</code> en lugar de otro valor <code>List</code> directamente.
El <code>Box&lt;T&gt;</code> apuntar√° al siguiente valor <code>List</code> que estar√° en el heap en lugar de
dentro de la variante <code>Cons</code>. Conceptualmente, todav√≠a tenemos una lista,
creada con listas que contienen otras listas, pero esta implementaci√≥n ahora es
m√°s como colocar los elementos uno al lado del otro en lugar de dentro de uno
del otro.</p>
<p>Podemos cambiar la definici√≥n del enum <code>List</code> en el Listado 15-2 y el uso de
<code>List</code> en el Listado 15-3 al c√≥digo del Listado 15-5, el cual compilar√°:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<p><span class="caption">Listado 15-5: Definici√≥n de <code>List</code> que utiliza <code>Box&lt;T&gt;</code>
para tener un tama√±o conocido</span></p>
<p>La variante <code>Cons</code> necesita el tama√±o de un <code>i32</code> m√°s el espacio para almacenar
los datos del puntero. La variante <code>Nil</code> no almacena ning√∫n valor, por lo que
necesita menos espacio que la variante <code>Cons</code>. Ahora sabemos que cualquier
valor de <code>List</code> ocupar√° el tama√±o de un <code>i32</code> m√°s el tama√±o de los datos del
puntero de un Box. Al usar un Box, hemos roto la cadena infinita y recursiva,
por lo que el compilador puede averiguar el tama√±o que necesita para almacenar
un valor de <code>List</code>. La Figura 15-2 muestra c√≥mo se ve la variante <code>Cons</code> ahora.</p>
<img alt="Una lista Cons finita" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Figura 15-2: Una <code>List</code> que no tiene un tama√±o infinito
porque <code>Cons</code> contiene una <code>Box</code></span></p>
<p>Los Boxes proporcionan indirecci√≥n y asignaci√≥n de heap; no tienen ninguna otra
capacidad especial, como veremos con los otros tipos de smart pointers.
Tampoco tienen la sobrecarga de rendimiento que estas capacidades especiales
incurran, por lo que pueden ser √∫tiles en casos como la lista cons donde la
indirecci√≥n es la √∫nica caracter√≠stica que necesitamos. Tambi√©n veremos m√°s
casos de uso para los boxes en el Cap√≠tulo 17.</p>
<p>El tipo <code>Box&lt;T&gt;</code> es un tipo de puntero inteligente porque implementa el trait
<code>Deref</code>, que permite que los valores de <code>Box&lt;T&gt;</code> se traten como referencias
normales. Cuando un <code>Box&lt;T&gt;</code> sale del scope, los datos en el heap que apunta se
limpian tambi√©n porque implementa el trait <code>Drop</code>. Estos dos traits ser√°n a√∫n
m√°s importantes para la funcionalidad proporcionada por los otros tipos de
smart pointers que discutiremos en el resto de este cap√≠tulo. Exploraremos estos
dos traits en m√°s detalle.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tratando-los-smart-pointers-como-referencias-regulares-con-el-trait-deref"><a class="header" href="#tratando-los-smart-pointers-como-referencias-regulares-con-el-trait-deref">Tratando los Smart Pointers como Referencias Regulares con el Trait <code>Deref</code></a></h2>
<p>Implementar el trait <code>Deref</code> te permite personalizar el comportamiento del
<em>operador de desreferencia</em> <code>*</code> (no confundir con el operador de multiplicaci√≥n
o el operador de glob). Al implementar <code>Deref</code> de tal manera que un smart
pointer pueda ser tratado como una referencia regular, puedes escribir c√≥digo
que opere en referencias y usar ese c√≥digo con smart pointers tambi√©n.</p>
<p>Primero veamos c√≥mo funciona el operador de desreferencia con referencias
regulares. Luego intentaremos definir un tipo personalizado que se comporte
como <code>Box&lt;T&gt;</code>, y veremos por qu√© el operador de desreferencia no funciona como
una referencia en nuestro tipo reci√©n definido. Exploraremos c√≥mo implementar
el trait <code>Deref</code> hace posible que los smart pointers trabajen de manera similar
a las referencias. Luego veremos la caracter√≠stica de <em>deref coercion</em> de Rust
y c√≥mo nos permite trabajar con referencias o smart pointers.</p>
<blockquote>
<p>Nota: Hay una gran diferencia entre el tipo <code>MyBox&lt;T&gt;</code> que estamos a punto de
construir y el tipo <code>Box&lt;T&gt;</code> real: nuestra versi√≥n no almacenar√° sus datos en
el heap. Nos estamos enfocando en este ejemplo en <code>Deref</code>, por lo que d√≥nde
se almacenan los datos es menos importante que el comportamiento similar al
de un puntero.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="siguiendo-el-puntero-al-valor"><a class="header" href="#siguiendo-el-puntero-al-valor">Siguiendo el puntero al valor</a></h3>
<p>Una referencia regular es un tipo de puntero, y una forma de pensar en un
puntero es como una flecha a un valor almacenado en otro lugar. En el Listado
15-6, creamos una referencia a un valor <code>i32</code> y luego usamos el operador de
desreferencia para seguir la referencia al valor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Listing 15-6: Utilizando el operador de dereferencia
para seguir una referencia a un valor <code>i32</code></span></p>
<p>La variable <code>x</code> contiene un valor <code>i32</code> de <code>5</code>. Establecemos <code>y</code> igual a una
referencia a <code>x</code>. Podemos afirmar que <code>x</code> es igual a <code>5</code>. Sin embargo, si
queremos hacer una afirmaci√≥n sobre el valor en <code>y</code>, tenemos que usar <code>*y</code> para
seguir la referencia al valor al que apunta (de ah√≠ <em>desreferencia</em>) para que
el compilador pueda comparar el valor real. Una vez que desreferenciamos <code>y</code>,
tenemos acceso al valor entero al que apunta <code>y</code> que podemos comparar con <code>5</code>.</p>
<p>Si intentamos escribir <code>assert_eq!(5, y);</code> en su lugar, obtendr√≠amos este error
de compilaci√≥n:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin &quot;deref-example&quot;) due to 1 previous error
</code></pre>
<p>Comparar un n√∫mero y una referencia a un n√∫mero no est√° permitido porque son
tipos diferentes. Debemos usar el operador de desreferencia para seguir la
referencia al valor al que apunta.</p>
<h3 id="usando-boxt-como-una-referencia"><a class="header" href="#usando-boxt-como-una-referencia">Usando <code>Box&lt;T&gt;</code> como una referencia</a></h3>
<p>Podemos reescribir el c√≥digo del Listado 15-6 para usar un <code>Box&lt;T&gt;</code> en lugar de
una referencia; el operador de desreferencia usado en el <code>Box&lt;T&gt;</code> en el Listado
15-7 funciona de la misma manera que el operador de desreferencia usado en la
referencia en el Listado 15-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Listing 15-7: Utilizando el operador de dereferencia
en un <code>Box&lt;i32&gt;</code></span></p>
<p>La principal diferencia entre el Listado 15-7 y el Listado 15-6 es que aqu√≠
definimos <code>y</code> como una instancia de <code>Box&lt;T&gt;</code> apuntando a una copia del valor de
<code>x</code> en lugar de ser una referencia que apunta al valor de <code>x</code>. En la √∫ltima
afirmaci√≥n, podemos usar el operador de desreferencia para seguir el puntero del
<code>Box&lt;T&gt;</code> de la misma manera que lo hicimos cuando <code>y</code> era una referencia. A
continuaci√≥n, exploraremos que es lo especial de <code>Box&lt;T&gt;</code> que nos permite el
uso del operador de desreferencia al definir nuestro propio tipo.</p>
<h3 id="definiendo-nuestro-propio-smart-pointer"><a class="header" href="#definiendo-nuestro-propio-smart-pointer">Definiendo nuestro propio Smart Pointer</a></h3>
<p>Construyamos un smart pointer similar al tipo <code>Box&lt;T&gt;</code> proporcionado por la
biblioteca est√°ndar para experimentar c√≥mo los smart pointers se comportan de
manera diferente a las referencias por defecto. Luego veremos c√≥mo agregar la
capacidad de usar el operador de desreferencia.</p>
<p>El tipo <code>Box&lt;T&gt;</code> es finalmente definido como una tupla struct con un elemento,
por lo que el Listado 15-8 define un tipo <code>MyBox&lt;T&gt;</code> de la misma manera.
Tambi√©n definiremos una funci√≥n <code>new</code> para que coincida con la funci√≥n <code>new</code>
definida en <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 15-8: Definiendo un tipo <code>MyBox&lt;T&gt;</code></span></p>
<p>Definimos un struct llamado <code>MyBox</code> y declaramos un par√°metro generic <code>T</code>,
porque queremos que nuestro tipo contenga valores de cualquier tipo. El tipo
<code>MyBox</code> es una tupla struct con un elemento de tipo <code>T</code>. La funci√≥n <code>MyBox::new</code>
toma un par√°metro de tipo <code>T</code> y devuelve una instancia de <code>MyBox</code> que contiene
el valor pasado.</p>
<p>Vamos a intentar a√±adir la funci√≥n <code>main</code> del Listado 15-7 al Listado 15-8 y
cambiarla para usar el tipo <code>MyBox&lt;T&gt;</code> que hemos definido en lugar de <code>Box&lt;T&gt;</code>.
El c√≥digo en el Listado 15-9 no se compilar√° porque Rust no sabe c√≥mo
desreferenciar <code>MyBox</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
<p><span class="caption">Listing 15-9: Intentando usar <code>MyBox&lt;T&gt;</code> de la misma
manera en que usamos referencias y <code>Box&lt;T&gt;</code></span></p>
<p>Aqu√≠ est√° el error de compilaci√≥n resultante:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin &quot;deref-example&quot;) due to 1 previous error
</code></pre>
<p>Nuestro tipo <code>MyBox&lt;T&gt;</code> no puede ser desreferenciado porque no hemos
implementado esa capacidad en nuestro tipo. Para habilitar la desreferencia con
el operador <code>*</code>, implementamos el trait <code>Deref</code>.</p>
<h3 id="tratando-un-tipo-como-una-referencia-implementando-el-trait-deref"><a class="header" href="#tratando-un-tipo-como-una-referencia-implementando-el-trait-deref">Tratando un tipo como una referencia implementando el trait <code>Deref</code></a></h3>
<p>Como discutimos en la secci√≥n del Cap√≠tulo 10
<a href="ch10-02-traits.html#implementando-un-trait-en-un-tipo">‚ÄúImplementando un Trait en un Tipo‚Äù</a><!-- ignore--> , para
implementar un trait, necesitamos proporcionar implementaciones para los m√©todos
requeridos del trait. El trait <code>Deref</code>, proporcionado por la biblioteca
est√°ndar, requiere que implementemos un m√©todo llamado <code>deref</code> que tome <code>self</code>
y devuelva una referencia al dato interno. El Listado 15-10 contiene una
implementaci√≥n de <code>Deref</code> para agregar a la definici√≥n de <code>MyBox</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 15-10: Implementando <code>Deref</code> en <code>MyBox&lt;T&gt;</code></span></p>
<p>La sintaxis <code>type Target = T;</code> define un tipo asociado que ser√° utilizado por el
trait <code>Deref</code>. Los tipos asociados son una forma ligeramente diferente de
declarar un par√°metro gen√©rico, pero no necesitas preocuparte por ellos por
ahora; los cubriremos con m√°s detalle en el Cap√≠tulo 19.</p>
<p>Rellenamos el cuerpo del m√©todo <code>deref</code> con <code>&amp;self.0</code> para que <code>deref</code> devuelva
una referencia al valor al que queremos acceder con el operador <code>*</code>. Recordemos
de la secci√≥n <a href="ch05-01-defining-structs.html#usando-structs-de-tuplas-sin-campos-nombrados-para-crear-diferentes-tipos">‚ÄúUsando Tuplas Structs sin Campos Nombrados para Crear Diferentes
Tipos‚Äù</a><!-- ignore --> del Cap√≠tulo 5 que <code>.0</code> accede al primer
valor en una tupla struct. ¬°La funci√≥n <code>main</code> en el Listado 15-9 que llama a <code>*</code>
en el valor <code>MyBox&lt;T&gt;</code> ahora compila, y las afirmaciones pasan!</p>
<p>Sin el trait <code>Deref</code>, el compilador no sabe c√≥mo desreferenciar referencias <code>&amp;</code>.
El m√©todo <code>deref</code> le da al compilador la capacidad de tomar un valor de
cualquier tipo que implemente <code>Deref</code> y llamar al m√©todo <code>deref</code> para obtener
una referencia <code>&amp;</code> que sabe c√≥mo desreferenciar.</p>
<p>Cuando ingresamos <code>*y</code> en el Listado 15-9, en realidad Rust ejecuta este c√≥digo:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust sustituye el operador <code>*</code> con una llamada al m√©todo <code>deref</code>, y luego
realiza una desreferenciaci√≥n directa, por lo que no tenemos que pensar si
necesitamos llamar al m√©todo <code>deref</code>. Esta caracter√≠stica de Rust nos permite
escribir c√≥digo que funciona de manera id√©ntica si tenemos una referencia
regular o un tipo que implementa <code>Deref</code>.</p>
<p>La raz√≥n por la cual el m√©todo <code>deref</code> devuelve una referencia a un valor, y
por qu√© la desreferenciaci√≥n simple fuera de los par√©ntesis en <code>*(y.deref())</code>
todav√≠a es necesaria, tiene que ver con el sistema de propiedad. Si el m√©todo
<code>deref</code> devolviera el valor directamente en lugar de una referencia al valor,
el valor se mover√≠a fuera de <code>self</code>. No queremos tomar posesi√≥n del valor
interno dentro de <code>MyBox&lt;T&gt;</code> en este caso o en la mayor√≠a de los casos en los
que usamos el operador de desreferencia.</p>
<p>Nota que el operador <code>*</code> es reemplazado con una llamada al m√©todo <code>deref</code> y
luego una llamada al operador <code>*</code> solo una vez, cada vez que usamos un <code>*</code> en
nuestro c√≥digo. Debido a que la sustituci√≥n del operador <code>*</code> no se repite
infinitamente, terminamos con datos de tipo <code>i32</code>, que coincide con el <code>5</code> en
<code>assert_eq!</code> en el Listado 15-9.</p>
<h3 id="coerciones-implicitas-de-deref-con-funciones-y-metodos"><a class="header" href="#coerciones-implicitas-de-deref-con-funciones-y-metodos">Coerciones implicitas de Deref con funciones y metodos</a></h3>
<p>La <em>coerci√≥n Deref</em> convierte una referencia a un tipo que implementa el trait
<code>Deref</code> en una referencia a otro tipo. Por ejemplo, la coerci√≥n Deref puede
convertir <code>&amp;String</code> en <code>&amp;str</code> porque <code>String</code> implementa el trait <code>Deref</code> de
manera que devuelve <code>&amp;str</code>. La coerci√≥n Deref es una conveniencia que Rust
realiza en los argumentos de las funciones y m√©todos, y solo funciona en tipos
que implementan el trait <code>Deref</code>. Sucede autom√°ticamente cuando pasamos una
referencia al valor de un tipo particular como argumento a una funci√≥n o m√©todo
que no coincide con el tipo de par√°metro en la definici√≥n de la funci√≥n o
m√©todo. Una secuencia de llamadas al m√©todo <code>deref</code> convierte el tipo que
proporcionamos en el tipo que necesita el par√°metro.</p>
<p>La coerci√≥n Deref se agreg√≥ a Rust para que los programadores que escriben
llamadas a funciones y m√©todos no necesiten agregar tantas referencias y
desreferencias expl√≠citas con <code>&amp;</code> y <code>*</code>. La caracter√≠stica de coerci√≥n Deref
tambi√©n nos permite escribir m√°s c√≥digo que puede funcionar para referencias o
smart pointers.</p>
<p>Para ver la coerci√≥n Deref en acci√≥n, usemos el tipo <code>MyBox&lt;T&gt;</code> que definimos
en el Listado 15-8 y la implementaci√≥n de <code>Deref</code> que agregamos en el Listado
15-10. El Listado 15-11 muestra la definici√≥n de una funci√≥n que tiene un
par√°metro de tipo string slice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hello, {name}!&quot;);
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 15-11: Una funci√≥n <code>hello</code> que tiene el par√°metro
<code>name</code> de tipo <code>&amp;str</code></span></p>
<p>Llamamos a la funci√≥n <code>hello</code> con un string slice como un argumento, como
<code>hello(&quot;Rust&quot;);</code> por ejemplo. La coerci√≥n Deref hace posible llamar a <code>hello</code>
con una referencia a un valor de tipo <code>MyBox&lt;String&gt;</code>, como se muestra en el
Listado 15-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}</code></pre></pre>
<p><span class="caption">Listing 15-12: Llamando a <code>hello</code> con una referencia a un
valor <code>MyBox&lt;String&gt;</code>, lo cual funciona debido a la coerci√≥n deref</span></p>
<p>Aqu√≠ estamos llamando a la funci√≥n <code>hello</code> con el argumento <code>&amp;m</code>, que es una
referencia a un valor <code>MyBox&lt;String&gt;</code>. Debido a que implementamos el trait
<code>Deref</code> en <code>MyBox&lt;T&gt;</code> en el Listado 15-10, Rust puede convertir <code>&amp;MyBox&lt;String&gt;</code>
en <code>&amp;String</code> llamando a <code>deref</code>. La biblioteca est√°ndar proporciona una
implementaci√≥n de <code>Deref</code> en <code>String</code> que devuelve una cadena de texto, y esto
est√° en la documentaci√≥n de la API de <code>Deref</code>. Rust llama a <code>deref</code> nuevamente
para convertir el <code>&amp;String</code> en <code>&amp;str</code>, que coincide con la definici√≥n de la
funci√≥n <code>hello</code>.</p>
<p>Si Rust no implementara la coerci√≥n Deref, tendr√≠amos que escribir el c√≥digo
en el Listado 15-13 en lugar del c√≥digo en el Listado 15-12 para llamar a
<code>hello</code> con un valor de tipo <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<p><span class="caption">Listing 15-13: El c√≥digo que tendr√≠amos que escribir si
Rust no tuviera deref coerci√≥n</span></p>
<p>El <code>(*m)</code> desreferencia el <code>MyBox&lt;String&gt;</code> en un <code>String</code>. Luego, el <code>&amp;</code> y
<code>[..]</code> toman un string slice del <code>String</code> que es igual a todo el string para
coincidir con la firma de <code>hello</code>. Este c√≥digo sin coerciones de desreferencia
es m√°s dif√≠cil de leer, escribir y entender con todos estos s√≠mbolos
involucrados. La coerci√≥n Deref permite que Rust maneje estas conversiones
autom√°ticamente.</p>
<p>Cuando el trait <code>Deref</code> est√° definido para el tipo involucrado, Rust analizar√°
los tipos y usar√° <code>Deref::deref</code> tantas veces como sea necesario para obtener
una referencia que coincida con el tipo del par√°metro. El n√∫mero de veces que
<code>Deref::deref</code> necesita ser insertado se resuelve en tiempo de compilaci√≥n, por
lo que no hay penalizaci√≥n en tiempo de ejecuci√≥n por aprovechar la coerci√≥n
Deref!</p>
<h3 id="c√≥mo-interact√∫a-la-coerci√≥n-deref-con-la-mutabilidad"><a class="header" href="#c√≥mo-interact√∫a-la-coerci√≥n-deref-con-la-mutabilidad">C√≥mo interact√∫a la coerci√≥n Deref con la mutabilidad</a></h3>
<p>Similar a c√≥mo usas el trait <code>Deref</code> para anular el operador <code>*</code> en
referencias inmutables, puedes usar el trait <code>DerefMut</code> para anular el operador
<code>*</code> en referencias mutables.</p>
<p>Rust realiza la coerci√≥n Deref cuando encuentra tipos e implementaciones de
traits en tres casos:</p>
<ul>
<li>De <code>&amp;T</code> a <code>&amp;U</code> cuando <code>T: Deref&lt;Target=U&gt;</code></li>
<li>De <code>&amp;mut T</code> a <code>&amp;mut U</code> cuando <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>De <code>&amp;mut T</code> a <code>&amp;U</code> cuando <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Los dos primeros casos son iguales entre s√≠, excepto que el segundo implementa
mutabilidad. El primer caso establece que si tienes un <code>&amp;T</code>, y <code>T</code> implementa
<code>Deref</code> a alg√∫n tipo <code>U</code>, puedes obtener un <code>&amp;U</code> de forma transparente. El
segundo caso establece que la misma coerci√≥n de desreferencia ocurre para
referencias mutables.</p>
<p>El tercer caso es m√°s complicado. Rust tambi√©n convertir√° una referencia mutable
en una inmutable. Pero lo contrario no es posible: una referencia inmutable
nunca se puede convertir en una referencia mutable. Debido a las reglas de
borrowing, si tienes una referencia mutable, esa referencia debe ser la √∫nica
referencia a ese dato (de lo contrario, el programa no se compilar√≠a). Convertir
una referencia mutable a una inmutable nunca romper√° las reglas de borrowing.
Convertir una referencia inmutable a una mutable requerir√≠a que la referencia
inmutable inicial sea la √∫nica referencia inmutable a esos datos, pero las
reglas de borrowing no garantizan eso. Por lo tanto, Rust no puede hacer la
suposici√≥n de que convertir una referencia inmutable en una mutable es posible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ejecutando-c√≥digo-al-limpiar-con-el-trait-drop"><a class="header" href="#ejecutando-c√≥digo-al-limpiar-con-el-trait-drop">Ejecutando C√≥digo al Limpiar con el Trait <code>Drop</code></a></h2>
<p>El segundo trait importante para el patr√≥n de smart pointer es <code>Drop</code>, el cual
permite personalizar qu√© pasa cuando un valor est√° a punto de salir del scope.
Puedes proveer una implementaci√≥n para el trait <code>Drop</code> en cualquier tipo, y ese
c√≥digo puede ser usado para liberar recursos como archivos o conexiones de
red.</p>
<p>Estamos introduciendo <code>Drop</code> en el contexto de smart pointers porque la
funcionalidad del trait <code>Drop</code> es casi siempre usada cuando se implementa un
smart pointer. Por ejemplo, cuando un <code>Box&lt;T&gt;</code> es dropeado, desasignar√° el
espacio en el heap al que el box apunta.</p>
<p>En algunos lenguajes, para algunos tipos, el programador debe llamar c√≥digo
para liberar memoria o recursos cada vez que terminan de usar una instancia de
esos tipos. Ejemplos incluyen manejadores de archivos, sockets, o locks. Si se
olvidan, el sistema podr√≠a sobrecargarse y colapsar. En Rust, puedes especificar
que un pedazo particular de c√≥digo sea ejecutado cada vez que un valor sale del
scope, y el compilador insertar√° este c√≥digo autom√°ticamente. Como resultado,
no necesitas ser cuidadoso sobre colocar c√≥digo de limpieza en todos lados en
un programa que una instancia de un tipo particular est√° terminada con √©l‚Äî¬°a√∫n
no se fugar√°n recursos!</p>
<p>Puedes especificar el c√≥digo a ejecutar cuando un valor sale del scope
implementando el trait <code>Drop</code>. El trait <code>Drop</code> requiere que implementes un
m√©todo llamado <code>drop</code> que toma una referencia mutable a <code>self</code>. Para ver cu√°ndo
Rust llama a <code>drop</code>, implementemos <code>drop</code> con declaraciones <code>println!</code> por
ahora. </p>
<p>Listing 15-14 muestra una estructura <code>CustomSmartPointer</code> cuya √∫nica
funcionalidad personalizada es que imprimir√° <code>Dropping CustomSmartPointer!</code>
cuando la instancia sale del scope, para mostrar cu√°ndo Rust ejecuta la
funci√≥n <code>drop</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;my stuff&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;other stuff&quot;),
    };
    println!(&quot;CustomSmartPointers created.&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 15-14: Un struct <code>CustomSmartPointer</code> que
implementa el trait <code>Drop</code> donde colocar√≠amos nuestro c√≥digo de limpieza</span></p>
<p>El trait <code>Drop</code> est√° incluido en el prelude, as√≠ que no necesitamos traerlo al
scope. Implementamos el trait <code>Drop</code> en <code>CustomSmartPointer</code> y proveemos una
implementaci√≥n para el m√©todo <code>drop</code> que llama a <code>println!</code>. El cuerpo de la
funci√≥n <code>drop</code> es donde colocar√≠as cualquier l√≥gica que quisieras correr cuando
una instancia de tu tipo sale del scope. Estamos imprimiendo un texto aqu√≠ para
demostrar visualmente cu√°ndo Rust llamar√° a <code>drop</code>.</p>
<p>En <code>main</code>, creamos dos instancias de <code>CustomSmartPointer</code> y luego imprimimos
<code>CustomSmartPointers created</code>. Al final de <code>main</code>, nuestras instancias de
<code>CustomSmartPointer</code> saldr√°n del scope, y Rust llamar√° al c√≥digo que colocamos
en el m√©todo <code>drop</code>, imprimiendo nuestro mensaje final. Nota que no necesitamos
llamar al m√©todo <code>drop</code> expl√≠citamente.</p>
<p>Cuando ejecutemos este programa, veremos el siguiente output:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust autom√°ticamente llam√≥ a <code>drop</code> para nosotros cuando nuestras instancias
salieron del scope, llamando al c√≥digo que especificamos. Las variables son
dropeadas en el orden inverso a su creaci√≥n, as√≠ que <code>d</code> fue dropeada antes que
<code>c</code>. El prop√≥sito de este ejemplo es darte una gu√≠a visual de c√≥mo funciona el
m√©todo <code>drop</code>; usualmente especificar√≠as el c√≥digo de limpieza que tu tipo
necesita correr en lugar de un mensaje de impresi√≥n.</p>
<h3 id="droppeando-un-valor-temprano-con-stdmemdrop"><a class="header" href="#droppeando-un-valor-temprano-con-stdmemdrop">Droppeando un valor temprano con <code>std::mem::drop</code></a></h3>
<p>Desafortunadamente, no es sencillo deshabilitar la funcionalidad autom√°tica de
<code>drop</code>. Deshabilitar <code>drop</code> usualmente no es necesario; el punto entero del
trait <code>Drop</code> es que se encarga autom√°ticamente. Ocasionalmente, sin embargo,
podr√≠as querer limpiar un valor temprano. Un ejemplo es cuando usas smart
pointers que manejan locks: podr√≠as querer forzar el m√©todo <code>drop</code> que libera
el lock para que otro c√≥digo en el mismo scope pueda adquirir el lock. Rust no
te deja llamar al m√©todo <code>drop</code> del trait <code>Drop</code> manualmente; en lugar de eso
tienes que llamar a la funci√≥n <code>std::mem::drop</code> provista por la librer√≠a
est√°ndar si quieres forzar a un valor a ser dropeado antes del final de su
scope.</p>
<p>Si intentamos llamar manualmente al m√©todo <code>drop</code> del trait <code>Drop</code> modificando 
la funci√≥n <code>main</code> del Listado 15-14, como se muestra en el Listado 15-15, 
obtendremos un error del compilador:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}</code></pre>
<p><span class="caption">Listing 15-15: Intento de llamar manualmente al m√©todo
<code>drop</code> del trait <code>Drop</code> para limpiar de forma anticipada</span></p>
<p>When we try to compile this code, we‚Äôll get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin &quot;drop-example&quot;) due to 1 previous error
</code></pre>
<p>Este mensaje de error indica que no se nos permite llamar a <code>drop</code> 
expl√≠citamente. El mensaje de error usa el t√©rmino <em>destructor</em>, que es el 
t√©rmino general de programaci√≥n para una funci√≥n que limpia una instancia. 
Un <em>destructor</em> es an√°logo a un <em>constructor</em>, que crea una instancia. 
La funci√≥n <code>drop</code> en Rust es un destructor particular.</p>
<p>Rust no nos deja llamar a <code>drop</code> expl√≠citamente porque Rust llamar√≠a
autom√°ticamente a <code>drop</code> en el valor al final de <code>main</code>. Esto causar√≠a un error
de <em>double free</em> porque Rust intentar√≠a limpiar el mismo valor dos veces.</p>
<p>No podemos desactivar la inserci√≥n autom√°tica de <code>drop</code> cuando un valor sale
del scope, y no podemos llamar expl√≠citamente al m√©todo <code>drop</code>. As√≠ que, si
necesitamos forzar a un valor a ser limpiado temprano, usamos la funci√≥n
<code>std::mem::drop</code>.</p>
<p>La funci√≥n <code>std::mem::drop</code> es diferente del m√©todo <code>drop</code> en el trait <code>Drop</code>.
La llamamos pasando como argumento el valor que queremos forzar a dropear. La
funci√≥n est√° en el prelude, as√≠ que podemos modificar <code>main</code> en el Listado
15-15 para llamar a la funci√≥n <code>drop</code>, como se muestra en el Listado 15-16:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 15-16: Llamando a <code>std::mem::drop</code> para eliminar
expl√≠citamente un valor antes de que salga del scope</span></p>
<p>Ejecutar este c√≥digo imprimir√° lo siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>El texto <code>Dropping CustomSmartPointer with data `some data`!</code> es impreso
entre el texto <code>CustomSmartPointer created.</code> y <code>CustomSmartPointer dropped before the end of main.</code>, mostrando que el c√≥digo del m√©todo <code>drop</code> es llamado
para dropear <code>c</code> en ese punto.</p>
<p>Puedes utilizar c√≥digo especificado en una implementaci√≥n del trait <code>Drop</code> de
varias maneras para hacer la limpieza conveniente y segura: por ejemplo,
¬°podr√≠as usarlo para crear tu propio allocator de memoria! Con el trait <code>Drop</code>
y el sistema de ownership de Rust, no tienes que recordar limpiar porque Rust
lo hace autom√°ticamente.</p>
<p>Tampoco tienes que preocuparte por problemas que surjan de limpiar 
accidentalmente valores que a√∫n est√°n en uso: el sistema de ownership que
asegura que las referencias siempre sean v√°lidas tambi√©n asegura que <code>drop</code> sea
llamado solo una vez cuando el valor ya no est√° siendo usado.</p>
<p>Ahora que hemos examinado <code>Box&lt;T&gt;</code> y algunas de las caracter√≠sticas de los
smart pointers, veamos algunos otros smart pointers definidos en la librer√≠a
est√°ndar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-el-smart-pointer-de-conteo-de-referencias"><a class="header" href="#rct-el-smart-pointer-de-conteo-de-referencias"><code>Rc&lt;T&gt;</code>, el Smart Pointer de Conteo de Referencias</a></h2>
<p>En la mayor√≠a de los casos, el ownership es claro: sabes exactamente qu√©
variable es due√±a de un valor dado. Sin embargo, hay casos en los que un solo
valor puede tener m√∫ltiples propietarios. Por ejemplo, en estructuras de datos
de gr√°ficos, m√∫ltiples aristas pueden apuntar al mismo nodo, y ese nodo es
conceptualmente propiedad de todas las aristas que apuntan a √©l. Un nodo no
deber√≠a ser limpiado a menos que no tenga aristas apuntando a √©l y, por lo
tanto, no tenga propietarios.</p>
<p>Debes habilitar el ownership m√∫ltiple expl√≠citamente usando el tipo de Rust
<code>Rc&lt;T&gt;</code>, el cual es una abreviaci√≥n para <em>reference counting</em>. El tipo <code>Rc&lt;T&gt;</code>
lleva la cuenta del n√∫mero de referencias a un valor para determinar si el valor
a√∫n est√° en uso. Si hay cero referencias a un valor, el valor puede ser limpiado
sin que ninguna referencia se vuelva inv√°lida.</p>
<p>Imagina <code>Rc&lt;T&gt;</code> como una TV en una sala familiar. Cuando una persona entra a
ver TV, la enciende. Otros pueden entrar a la sala y ver la TV. Cuando la √∫ltima
persona sale de la sala, apaga la TV porque ya no est√° siendo usada. Si alguien
apaga la TV mientras otros a√∫n la est√°n viendo, ¬°habr√≠a un alboroto de los
televidentes restantes!</p>
<p>Usamos el tipo <code>Rc&lt;T&gt;</code> cuando queremos asignar algunos datos en el heap para
que m√∫ltiples partes de nuestro programa puedan leer y no podemos determinar en
tiempo de compilaci√≥n cu√°l parte terminar√° usando los datos por √∫ltimo. Si
supi√©ramos cu√°l parte terminar√≠a de √∫ltimo, podr√≠amos hacer que esa parte sea
due√±a de los datos, y las reglas normales de ownership aplicadas en tiempo de
compilaci√≥n tomar√≠an efecto.</p>
<p>Nota que <code>Rc&lt;T&gt;</code> es solo para uso en escenarios de un solo hilo. Cuando
discutamos concurrencia en el Cap√≠tulo 16, cubriremos c√≥mo hacer conteo de
referencias en programas multihilo.</p>
<h3 id="usando-rct-para-compartir-datos"><a class="header" href="#usando-rct-para-compartir-datos">Usando <code>Rc&lt;T&gt;</code> para Compartir Datos</a></h3>
<p>Volvamos a nuestro ejemplo de la lista cons en el Listado 15-5. Recuerda que lo
definimos usando <code>Box&lt;T&gt;</code>. Esta vez, crearemos dos listas que comparten
ownership de una tercera lista. Conceptualmente, esto se ve similar a la Figura
15-3:</p>
<img alt="Dos listas que comparten ownership de una tercera lista" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Figura 15-3: Dos listas, <code>b</code> y <code>c</code>, comparten ownership de
una tercera lista, <code>a</code></span></p>
<p>Crearemos la lista <code>a</code> que contiene 5 y luego 10. Luego haremos dos listas m√°s:
<code>b</code> que comienza con 3 y <code>c</code> que comienza con 4. Ambas listas <code>b</code> y <code>c</code> luego
continuar√°n a la primera lista <code>a</code> que contiene 5 y 10. En otras palabras,
ambas listas compartir√°n la primera lista que contiene 5 y 10.</p>
<p>Intentar implementar este escenario usando nuestra definici√≥n de <code>List</code> con
<code>Box&lt;T&gt;</code> no funcionar√°, como se muestra en el Listado 15-17:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<p><span class="caption">Listado 15-17: Demostrando que no se nos permite tener dos
listas que usen <code>Box&lt;T&gt;</code> y traten de compartir ownership de una tercera
lista</span></p>
<p>Cuando intentamos compilar este c√≥digo, obtenemos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin &quot;cons-list&quot;) due to 1 previous error
</code></pre>
<p>Las variantes <code>Cons</code> poseen los datos que contienen, as√≠ que cuando creamos la
lista <code>b</code>, <code>a</code> es movida a <code>b</code> y <code>b</code> posee <code>a</code>. Luego, cuando intentamos usar
<code>a</code> nuevamente cuando creamos <code>c</code>, no se nos permite porque <code>a</code> ha sido movida.</p>
<p>Podr√≠amos cambiar la definici√≥n de <code>Cons</code> para que contenga referencias en su
lugar, pero entonces tendr√≠amos que especificar par√°metros de lifetime. Al
especificar par√°metros de lifetime, estar√≠amos especificando que cada elemento
en la lista vivir√° al menos tanto como la lista entera. Este es el caso para
los elementos y listas en el Listado 15-17, pero no en todos los escenarios.</p>
<p>En su lugar, cambiaremos nuestra definici√≥n de <code>List</code> para usar <code>Rc&lt;T&gt;</code> en
lugar de <code>Box&lt;T&gt;</code>, como se muestra en el Listado 15-18. Cada variante <code>Cons</code>
ahora contendr√° un valor y un <code>Rc&lt;T&gt;</code> apuntando a una <code>List</code>. Cuando creamos
<code>b</code>, en lugar de tomar ownership de <code>a</code>, clonaremos el <code>Rc&lt;List&gt;</code> que <code>a</code> est√°
sosteniendo, aumentando as√≠ el n√∫mero de referencias de uno a dos y permitiendo
que <code>a</code> y <code>b</code> compartan ownership de los datos en ese <code>Rc&lt;List&gt;</code>. Tambi√©n
clonaremos <code>a</code> cuando creamos <code>c</code>, aumentando el n√∫mero de referencias de dos a
tres. Cada vez que llamamos a <code>Rc::clone</code>, el conteo de referencias a los datos
dentro del <code>Rc&lt;List&gt;</code> aumentar√°, y los datos no ser√°n limpiados a menos que no
haya referencias a √©l.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<p><span class="caption">Listado 15-18: Una definici√≥n de <code>List</code> que utiliza
<code>Rc&lt;T&gt;</code></span></p>
<p>Necesitamos agregar una declaraci√≥n <code>use</code> para traer <code>Rc&lt;T&gt;</code> al scope porque no
est√° en el <a href="ch02-00-guessing-game-tutorial.html#prelude-meaning">prelude</a>. En <code>main</code>, creamos la lista que contiene 5 y 10 y la
almacenamos en un nuevo <code>Rc&lt;List&gt;</code> en <code>a</code>. Luego cuando creamos <code>b</code> y <code>c</code>,
llamamos a la funci√≥n <code>Rc::clone</code> y pasamos una referencia al <code>Rc&lt;List&gt;</code> en <code>a</code>
como argumento.</p>
<p>Podr√≠amos llamar a <code>Rc::clone()</code> directamente con <code>a</code>, como en <code>Rc::clone(&amp;a)</code>.
pero Rust tiene una convenci√≥n para llamar a <code>Rc::clone</code> en este caso. La
implementaci√≥n de <code>Rc::clone</code> no hace una copia profunda de todos los datos
como la mayor√≠a de las implementaciones de <code>clone</code> de los tipos hacen. La
llamada a <code>Rc::clone</code> solo incrementa el conteo de referencias, lo cual no
toma mucho tiempo. Copias profundas de datos pueden tomar mucho tiempo. Al usar
<code>Rc::clone</code> para conteo de referencias, podemos distinguir visualmente entre
las copias profundas y los tipos de clones que incrementan el conteo de
referencias. Cuando busquemos problemas de performance en el c√≥digo, solo
necesitamos considerar las copias profundas y podemos ignorar las llamadas a
<code>Rc::clone</code>.</p>
<h3 id="clonando-un-rct-incrementa-el-conteo-de-referencias"><a class="header" href="#clonando-un-rct-incrementa-el-conteo-de-referencias">Clonando un <code>Rc&lt;T&gt;</code> Incrementa el Conteo de Referencias</a></h3>
<p>Vamos a modificar nuestro ejemplo de trabajo en el Listado 15-18 para que
podamos ver los conteos de referencias cambiando a medida que creamos y
descartamos referencias al <code>Rc&lt;List&gt;</code> en <code>a</code>.</p>
<p>En el Listado 15-19, cambiaremos <code>main</code> para que tenga un scope interno alrededor
de la lista <code>c</code>; luego podemos ver c√≥mo el conteo de referencias cambia cuando
<code>c</code> sale del scope.</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}</code></pre></pre>
<p><span class="caption">Listado 15-19: Imprimiendo el conteo de referencias</span></p>
<p>En este punto del programa donde cambia el recuento de referencias, imprimimos
el recuento de referencias utilizando la funci√≥n <code>Rc::strong_count</code>. Esta
funci√≥n se llama <code>strong_count</code> en lugar de <code>count</code> porque el tipo <code>Rc&lt;T&gt;</code>
tambi√©n tiene un <code>weak_count</code>; veremos para qu√© se usa <code>weak_count</code> en la
secci√≥n <a href="ch15-06-reference-cycles.html#previniendo-ciclos-de-referencia-convirtiendo-un-rct-en-un-weakt">‚ÄúPreviniendo Ciclos de Referencias: Convirtiendo un <code>Rc&lt;T&gt;</code> en un
<code>Weak&lt;T&gt;</code>‚Äù</a><!-- ignore -->.</p>
<p>Este c√≥digo imprime lo siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>Podemos ver que el <code>Rc&lt;List&gt;</code> en <code>a</code> tiene un recuento de referencias de 1;
luego, cada vez que llamamos a <code>clone</code> el recuento aumenta en 1. Cuando <code>c</code> sale
del scope, el recuento disminuye en 1. No tenemos que llamar a una funci√≥n para
disminuir el recuento de referencias como tenemos que llamar a <code>Rc::clone</code> para
aumentar el recuento de referencias: la implementaci√≥n del trait <code>Drop</code>
disminuye el recuento de referencias autom√°ticamente cuando un valor <code>Rc&lt;T&gt;</code>
sale del scope.</p>
<p>Lo que no podemos ver en este ejemplo es que cuando <code>b</code> y luego <code>a</code> salen del
scope al final de <code>main</code>, el recuento es entonces 0, y el <code>Rc&lt;List&gt;</code> se limpia
completamente. Usando <code>Rc&lt;T&gt;</code> permite que un solo valor tenga m√∫ltiples
propietarios, y el recuento asegura que el valor permanezca v√°lido siempre que
cualquiera de los propietarios a√∫n exista.</p>
<p>A trav√©s de referencias inmutables, <code>Rc&lt;T&gt;</code> permite que comparta datos entre
m√∫ltiples partes de su programa para lectura solamente. Si <code>Rc&lt;T&gt;</code> le permitiera
tener m√∫ltiples referencias mutables tambi√©n, podr√≠a violar una de las reglas
de pr√©stamo discutidas en el Cap√≠tulo 4: m√∫ltiples pr√©stamos mutables al mismo
lugar pueden causar carreras de datos e inconsistencias. ¬°Pero poder mutar datos
es muy √∫til! En la siguiente secci√≥n, discutiremos el patr√≥n de mutabilidad
interior y el tipo <code>RefCell&lt;T&gt;</code> que puede usar en conjunto con un <code>Rc&lt;T&gt;</code> para
trabajar con esta restricci√≥n de inmutabilidad.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-y-el-patr√≥n-de-mutabilidad-interior"><a class="header" href="#refcellt-y-el-patr√≥n-de-mutabilidad-interior"><code>RefCell&lt;T&gt;</code> y el Patr√≥n de Mutabilidad Interior</a></h2>
<p>La mutabilidad interna es un patr√≥n de dise√±o en Rust que te permite mutar datos
incluso cuando hay referencias inmutables a esos datos; normalmente, esta acci√≥n
est√° prohibida por las reglas de borrowing. Para mutar datos, el patr√≥n utiliza
c√≥digo <code>unsafe</code> dentro de una estructura de datos para flexibilizar las reglas
habituales de Rust que rigen la mutabilidad y el borrowing. El c√≥digo unsafe
indica al compilador que estamos verificando las reglas manualmente en lugar de
confiar en que el compilador las verifique por nosotros; discutiremos el c√≥digo
unsafe con m√°s detalle en el Cap√≠tulo 19.</p>
<p>Podemos utilizar tipos que utilizan el patr√≥n de mutabilidad interna solo cuando
podemos asegurar que las reglas de borrowing se seguir√°n en tiempo de ejecuci√≥n,
aunque el compilador no pueda garantizarlo. El c√≥digo <code>unsafe</code> involucrado se
envuelve entonces en una API segura, y el tipo externo sigue siendo inmutable.</p>
<p>Vamos a explorar este concepto al examinar el tipo <code>RefCell&lt;T&gt;</code> que sigue el
patr√≥n de mutabilidad interna.</p>
<h3 id="cumpliendo-las-reglas-de-borrowing-en-tiempo-de-ejecuci√≥n-con-refcellt"><a class="header" href="#cumpliendo-las-reglas-de-borrowing-en-tiempo-de-ejecuci√≥n-con-refcellt">Cumpliendo las reglas de borrowing en tiempo de ejecuci√≥n con <code>RefCell&lt;T&gt;</code></a></h3>
<p>A diferencia de <code>Rc&lt;T&gt;</code>, el tipo <code>RefCell&lt;T&gt;</code> representa un √∫nico ownership
sobre los datos que contiene. Entonces, ¬øqu√© hace que <code>RefCell&lt;T&gt;</code> sea diferente
de un tipo como <code>Box&lt;T&gt;</code>? Recuerda las reglas de borrowing que aprendiste en el
Cap√≠tulo 4:</p>
<ul>
<li>En cualquier momento dado, puedes tener <em>o bien</em> una referencia mutable <em>o
bien</em> cualquier n√∫mero de referencias inmutables.</li>
<li>Las referencias siempre deben ser v√°lidas.</li>
</ul>
<p>Con referencias y <code>Box&lt;T&gt;</code>, las invariantes de las reglas de borrowing se hacen
cumplir en tiempo de compilaci√≥n. Con <code>RefCell&lt;T&gt;</code>, estas invariantes se hacen
cumplir <em>en tiempo de ejecuci√≥n</em>. Con referencias, si rompes estas reglas,
obtendr√°s un error de compilaci√≥n. Con <code>RefCell&lt;T&gt;</code>, si rompes estas reglas, tu
programa entrar√° en panic y saldr√°.</p>
<p>La ventaja de comprobar las reglas de borrowing en tiempo de compilaci√≥n es que
los errores se detectar√°n antes en el proceso de desarrollo, y no hay impacto en
el rendimiento en tiempo de ejecuci√≥n porque todo el an√°lisis se completa de
antemano. Por estas razones, comprobar las reglas de borrowing en tiempo de
compilaci√≥n es la mejor opci√≥n en la mayor√≠a de los casos, por lo que esta es la
opci√≥n predeterminada de Rust.</p>
<p>La ventaja de comprobar las reglas de borrowing en tiempo de ejecuci√≥n es que
se permiten ciertos escenarios seguros de memoria, donde habr√≠an sido
rechazados por las comprobaciones en tiempo de compilaci√≥n. El an√°lisis est√°tico,
como el compilador de Rust, es inherentemente conservador. Algunas propiedades
del c√≥digo son imposibles de detectar analizando el c√≥digo: el ejemplo m√°s
famoso es el Problema de la Parada, que est√° fuera del alcance de este libro,
pero es un tema interesante para investigar.</p>
<p>Debido a que algunos an√°lisis son imposibles, si el compilador de Rust no puede
estar seguro de que el c√≥digo cumple con las reglas de ownership, podr√≠a
rechazar un programa correcto; de esta manera, es conservador. Si Rust aceptara
un programa incorrecto, los usuarios no podr√≠an confiar en las garant√≠as que
Rust hace. Sin embargo, si Rust rechaza un programa correcto, el programador se
ver√° perjudicado, pero no puede ocurrir nada catastr√≥fico. El tipo <code>RefCell&lt;T&gt;</code>
es √∫til cuando est√°s seguro de que tu c√≥digo sigue las reglas de borrowing, pero
el compilador no puede entenderlo y garantizarlo.</p>
<p>Similar a <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> solo se usa en escenarios de un solo hilo y te
dar√° un error de tiempo de compilaci√≥n si intentas usarlo en un contexto
multihilo. Hablaremos de c√≥mo obtener la funcionalidad de <code>RefCell&lt;T&gt;</code> en un
programa multihilo en el Cap√≠tulo 16.</p>
<p>Aqu√≠ tienes un resumen de las razones para elegir <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> o
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> permite m√∫ltiples propietarios de los mismos datos; <code>Box&lt;T&gt;</code> y
<code>RefCell&lt;T&gt;</code> tienen un √∫nico propietario.</li>
<li><code>Box&lt;T&gt;</code> permite borrowing inmutable o mutable verificado en tiempo de
compilaci√≥n; <code>Rc&lt;T&gt;</code> permite solo borrowing inmutable verificado en tiempo de
compilaci√≥n; <code>RefCell&lt;T&gt;</code> permite borrowing inmutable o mutable verificado en
tiempo de ejecuci√≥n.</li>
<li>Debido a que <code>RefCell&lt;T&gt;</code> permite borrowing mutable verificado en tiempo de
ejecuci√≥n, puedes mutar el valor dentro de la <code>RefCell&lt;T&gt;</code> incluso cuando la
<code>RefCell&lt;T&gt;</code> es inmutable.</li>
</ul>
<p>Mutar el valor dentro de un valor inmutable es el patr√≥n de <em>mutabilidad
interior</em>. Veamos una situaci√≥n en la que la mutabilidad interior es √∫til y
examinemos c√≥mo es posible.</p>
<h3 id="mutabilidad-interior-un-borrow-mutable-a-un-valor-inmutable"><a class="header" href="#mutabilidad-interior-un-borrow-mutable-a-un-valor-inmutable">Mutabilidad Interior: Un Borrow Mutable a un Valor Inmutable</a></h3>
<p>Una consecuencia de las reglas de borrowing es que cuando tienes un valor
inmutable, no puedes pedir prestado una referencia mutable a trav√©s de ese
valor. Por ejemplo, este c√≥digo no compilar√°:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>Si intentas compilar este c√≥digo, obtendr√°s el siguiente error:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin &quot;borrowing&quot;) due to 1 previous error
</code></pre>
<p>Sin embargo, hay situaciones en las que ser√≠a √∫til que un valor se mute a s√≠
mismo en sus m√©todos, pero parezca inmutable para otro c√≥digo. El c√≥digo fuera
de los m√©todos del valor no podr√≠a mutar el valor. Usar <code>RefCell&lt;T&gt;</code> es una
forma de obtener la capacidad de tener mutabilidad interior, pero <code>RefCell&lt;T&gt;</code>
no evita las reglas de borrowing por completo: el comprobador de pr√©stamos en el
compilador permite esta mutabilidad interior, y las reglas de borrowing se
comprueban en tiempo de ejecuci√≥n en su lugar. Si violas las reglas, obtendr√°s
un <code>panic!</code> en lugar de un error del compilador.</p>
<p>Vamos a trabajar a trav√©s de un ejemplo pr√°ctico donde podemos usar <code>RefCell&lt;T&gt;</code>
para mutar un valor inmutable y ver por qu√© es √∫til.</p>
<h4 id="un-caso-de-uso-para-la-mutabilidad-interior-mock-objects"><a class="header" href="#un-caso-de-uso-para-la-mutabilidad-interior-mock-objects">Un Caso de Uso para la Mutabilidad Interior: Mock Objects</a></h4>
<p>A veces durante el testing, un programador usar√° un tipo en lugar de otro para
observar un comportamiento particular y afirmar que se implementa correctamente.
Este tipo de marcador de posici√≥n se llama <em>test double</em>. Piensa en ello en el
sentido de un &quot;doble de riesgo&quot; en la realizaci√≥n de pel√≠culas, donde una
persona entra y sustituye a un actor para hacer una escena particularmente
dif√≠cil. Los test doubles se sustituyen por otros tipos cuando se ejecutan las
pruebas. Los <em>objetos simulados</em> son tipos espec√≠ficos de test doubles que
registran lo que sucede durante una prueba para que puedas afirmar que se
produjeron las acciones correctas.</p>
<p>Rust no tiene objetos en el mismo sentido que otros lenguajes tienen objetos, y
Rust no tiene funcionalidad de objetos simulados integrada en la biblioteca
est√°ndar como lo hacen otros lenguajes. Sin embargo, definitivamente puedes
crear una struct que sirva para los mismos prop√≥sitos que un objeto
simulado.</p>
<p>Aqu√≠ est√° el escenario que vamos a probar: crearemos una biblioteca que realiza
un seguimiento de un valor en relaci√≥n con un valor m√°ximo, y env√≠a mensajes
en funci√≥n de la proximidad del valor actual al valor m√°ximo. Esta biblioteca
podr√≠a usarse para realizar un seguimiento de la cuota de un usuario para el
n√∫mero de llamadas a la API que se le permite realizar, por ejemplo.</p>
<p>El objetivo de nuestra biblioteca es proporcionar la funcionalidad de realizar
un seguimiento de qu√© tan cerca est√° un valor de su m√°ximo y que mensajes se
deben enviar en qu√© momentos. Se espera que las aplicaciones que utilicen
nuestra biblioteca proporcionen el mecanismo para enviar los mensajes: la
aplicaci√≥n podr√≠a poner un mensaje en la interfaz de la aplicaci√≥n, enviar un
correo electr√≥nico, enviar un mensaje de texto o algo m√°s. La biblioteca no
necesita saber ese detalle. Todo lo que necesita es algo que implemente un
trait que proporcionaremos llamado <code>Messenger</code>. El listado 15-20 muestra el
c√≥digo de la biblioteca:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        }
    }
}</code></pre>
<p><span class="caption">Listing 15-20: Una biblioteca para realizar un seguimiento
de qu√© tan cerca est√° un valor a su valor m√°ximo y emitir advertencias
cuando el valor alcanza ciertos niveles.</span></p>
<p>Una parte importante de este c√≥digo es el trait <code>Messenger</code>, que tiene un m√©todo
llamado <code>send</code> que toma una referencia inmutable a <code>self</code> y el texto del
mensaje. Este trait es la interfaz que nuestro objeto simulado necesita
implementar para que el simulado se pueda usar de la misma manera que un objeto
real. La otra parte importante es que queremos probar el comportamiento del
m√©todo <code>set_value</code> en el <code>LimitTracker</code>. Podemos cambiar lo que pasamos para el
par√°metro <code>value</code>, pero <code>set_value</code> no devuelve nada para que podamos hacer
afirmaciones. Queremos poder decir que si creamos un <code>LimitTracker</code> con algo
que implemente el trait <code>Messenger</code> y un valor particular para <code>max</code>, cuando
pasemos diferentes n√∫meros para <code>value</code>, se le dice al mensajero que env√≠e los
mensajes apropiados.</p>
<p>Necesitamos un objeto simulado que, en lugar de enviar un email o un mensaje de
texto cuando llamamos a <code>send</code>, solo haga un seguimiento de los mensajes que se
le dice que env√≠e. Podemos crear una nueva instancia del objeto simulado,
crear un <code>LimitTracker</code> que use el objeto simulado, llamar al m√©todo
<code>set_value</code> en <code>LimitTracker</code> y luego verificar que el objeto simulado tenga los
mensajes que esperamos. El listado 15-21 muestra un intento de implementar un
objeto simulado para hacer precisamente eso, pero el borrow checker
no lo permite:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<p><span class="caption">Listing 15-21: Un intento de implementar un <code>MockMessenger</code>
que no es permitido por el borrow checker</span></p>
<p>Este c√≥digo de test define un struct <code>MockMessenger</code> que tiene un campo
<code>sent_messages</code> que es una <code>Vec</code> de <code>String</code> valores. Definimos una funci√≥n
asociada <code>new</code> para que sea conveniente crear nuevos valores <code>MockMessenger</code>
que comiencen con una lista vac√≠a de mensajes. Luego implementamos el trait
<code>Messenger</code> para <code>MockMessenger</code> para que podamos darle un <code>MockMessenger</code> a un
<code>LimitTracker</code>. En la definici√≥n del m√©todo <code>send</code>, tomamos el mensaje pasado
como par√°metro y lo almacenamos en la lista <code>MockMessenger</code> de <code>sent_messages</code>.</p>
<p>En el test, estamos testeando qu√© sucede cuando el <code>LimitTracker</code> se le dice que
establezca <code>value</code> en algo que es m√°s del 75 por ciento del valor <code>max</code>. En
primer lugar, creamos un nuevo <code>MockMessenger</code>, que comenzar√° con una lista
vac√≠a de mensajes. Luego creamos un nuevo <code>LimitTracker</code> y le damos una
referencia al nuevo <code>MockMessenger</code> y un valor <code>max</code> de 100. Llamamos al m√©todo
<code>set_value</code> en el <code>LimitTracker</code> con un valor de 80, que es m√°s del 75 por
ciento de 100. Luego afirmamos que la lista de mensajes que el <code>MockMessenger</code>
est√° realizando un seguimiento deber√≠a tener ahora un mensaje en ella.</p>
<p>Sin embargo, hay un problema con este test, como se muestra aqu√≠:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference
   |
2  |     fn send(&amp;mut self, msg: &amp;str);
   |             ~~~~~~~~~

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>No podemos modificar <code>sent_messages</code> para realizar un seguimiento de los
mensajes, porque el m√©todo <code>send</code> toma una referencia inmutable a <code>self</code>.
Tampoco podemos tomar la sugerencia del texto de error para usar <code>&amp;mut self</code>
en su lugar, porque entonces la firma de <code>send</code> no coincidir√≠a con la firma en
la definici√≥n del trait <code>Messenger</code> (si√©ntase libre de intentarlo y ver qu√©
mensaje de error obtiene).</p>
<p>Esta es una situaci√≥n en la que la mutabilidad interior puede ayudar.
Almacenaremos los <code>sent_messages</code> dentro de un <code>RefCell&lt;T&gt;</code>, y luego el m√©todo
<code>send</code> podr√° modificar <code>sent_messages</code> para almacenar los mensajes que hemos
visto. El listado 15-22 muestra c√≥mo se ve eso:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<p><span class="caption">Listing 15-22: Usando <code>RefCell&lt;T&gt;</code> para mutar un valor
interno mientras el valor externo se considera inmutable.</span></p>
<p>El campo <code>sent_messages</code> ahora es de tipo <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> en lugar de
<code>Vec&lt;String&gt;</code>. En la funci√≥n <code>new</code>, creamos una nueva instancia de
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> alrededor del vector vac√≠o.</p>
<p>En la implementaci√≥n del m√©todo <code>send</code>, el primer par√°metro sigue siendo un
inmutable borrow de <code>self</code>, que coincide con la definici√≥n del trait. Llamamos
a <code>borrow_mut</code> en el <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> en <code>self.sent_messages</code> para obtener
una referencia mutable al valor dentro del <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, que es el
vector. Luego podemos llamar a <code>push</code> en la referencia mutable al vector para
hacer un seguimiento de los mensajes enviados durante el test.</p>
<p>La √∫ltima modificaci√≥n que debemos hacer est√° en la afirmaci√≥n: para ver cu√°ntos
elementos hay en el vector interno, llamamos a <code>borrow</code> en el
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> para obtener una referencia inmutable al vector.</p>
<p>Ahora que has visto c√≥mo usar <code>RefCell&lt;T&gt;</code>, ¬°profundicemos en c√≥mo funciona!</p>
<h4 id="haciendo-un-seguimiento-del-borrowing-en-runtime-con-refcellt"><a class="header" href="#haciendo-un-seguimiento-del-borrowing-en-runtime-con-refcellt">Haciendo un seguimiento del borrowing en runtime con <code>RefCell&lt;T&gt;</code></a></h4>
<p>Cuando creamos referencias inmutables y mutables, usamos la sintaxis <code>&amp;</code> y
<code>&amp;mut</code>, respectivamente. Con <code>RefCell&lt;T&gt;</code>, usamos los m√©todos <code>borrow</code> y
<code>borrow_mut</code>, que son parte de la API segura que pertenece a <code>RefCell&lt;T&gt;</code>. El
m√©todo <code>borrow</code> devuelve el tipo de smart pointer <code>Ref&lt;T&gt;</code>, y <code>borrow_mut</code>
devuelve el tipo de smart pointer <code>RefMut&lt;T&gt;</code>. Ambos tipos implementan <code>Deref</code>,
por lo que podemos tratarlos como referencias regulares.</p>
<p><code>RefCell&lt;T&gt;</code> realiza un seguimiento de cu√°ntos smart pointers <code>Ref&lt;T&gt;</code> y
<code>RefMut&lt;T&gt;</code> est√°n actualmente activos. Cada vez que llamamos a <code>borrow</code>, el
<code>RefCell&lt;T&gt;</code> aumenta su recuento de cu√°ntos borrowing inmutables est√°n activos.
Cuando un valor <code>Ref&lt;T&gt;</code> sale del scope, el recuento de borrowing inmutables
disminuye en uno. Al igual que las reglas de borrowing en tiempo de compilaci√≥n,
<code>RefCell&lt;T&gt;</code> nos permite tener muchos borrowing inmutables o un borrowing
mutable en un momento dado.</p>
<p>Si intentamos romper estas reglas, en lugar de obtener un error del compilador
como lo har√≠amos con las referencias, la implementaci√≥n de <code>RefCell&lt;T&gt;</code> se
bloquear√° en tiempo de ejecuci√≥n. El listado 15-23 muestra una modificaci√≥n de
la implementaci√≥n de <code>send</code> en el listado 15-22. Estamos tratando
deliberadamente de crear dos borrowing mutables activos para el mismo scope
para ilustrar que <code>RefCell&lt;T&gt;</code> nos impide hacer esto en tiempo de ejecuci√≥n.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 15-23: Creando dos referencias mutables en el
mismo scope para ver que <code>RefCell&lt;T&gt;</code> lanzar√° un panic</span></p>
<p>Creamos una variable <code>one_borrow</code> para el smart pointer <code>RefMut&lt;T&gt;</code> devuelto
desde <code>borrow_mut</code>. Luego creamos otro borrowing mutable de la misma manera en
la variable <code>two_borrow</code>. Esto hace dos referencias mutables en el mismo scope,
lo cual no est√° permitido. Cuando ejecutamos los tests para nuestra librer√≠a, el
c√≥digo en el listado 15-23 se compilar√° sin errores, pero el test fallar√°:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Observa que el c√≥digo entr√≥ en panic con el mensaje <code>already borrowed: BorrowMutError</code>. As√≠ es como <code>RefCell&lt;T&gt;</code> maneja las violaciones de las reglas
de borrowing en tiempo de ejecuci√≥n.</p>
<p>Elegir capturar errores de borrowing en tiempo de ejecuci√≥n en lugar de en
tiempo de compilaci√≥n, como lo hemos hecho aqu√≠, significa que potencialmente
encontrar√≠as errores en tu c√≥digo m√°s tarde en el proceso de desarrollo:
posiblemente no hasta que tu c√≥digo se implemente en producci√≥n. Adem√°s, tu
c√≥digo incurrir√≠a en una peque√±a penalizaci√≥n de rendimiento en tiempo de
ejecuci√≥n como resultado de realizar un seguimiento de los borrows en tiempo de
ejecuci√≥n en lugar de en tiempo de compilaci√≥n. Sin embargo, usar <code>RefCell&lt;T&gt;</code>
hace posible escribir un objeto simulado que pueda modificarse para realizar un
seguimiento de los mensajes que ha visto mientras lo est√°s usando en un
contexto donde solo se permiten valores inmutables. Puedes usar <code>RefCell&lt;T&gt;</code>
a pesar de sus compensaciones para obtener m√°s funcionalidad de la que
proporcionan las referencias regulares.</p>
<h3 id="teniendo-m√∫ltiples-propietarios-de-datos-mutables-combinando-rct-y-refcellt"><a class="header" href="#teniendo-m√∫ltiples-propietarios-de-datos-mutables-combinando-rct-y-refcellt">Teniendo m√∫ltiples propietarios de datos mutables combinando <code>Rc&lt;T&gt;</code> y <code>RefCell&lt;T&gt;</code></a></h3>
<p>Una forma com√∫n de usar <code>RefCell&lt;T&gt;</code> es en combinaci√≥n con <code>Rc&lt;T&gt;</code>. Recuerda
que <code>Rc&lt;T&gt;</code> te permite tener m√∫ltiples propietarios de algunos datos, pero solo
te da acceso inmutable a esos datos. Si tienes un <code>Rc&lt;T&gt;</code> que contiene un
<code>RefCell&lt;T&gt;</code>, puedes obtener un valor que puede tener m√∫ltiples propietarios y
que puedes mutar.</p>
<p>Por ejemplo, recuerda el ejemplo de la lista de cons en el Listado 15-18 donde
usamos <code>Rc&lt;T&gt;</code> para permitir que m√∫ltiples listas compartan propiedad de otra
lista. Debido a que <code>Rc&lt;T&gt;</code> contiene solo valores inmutables, no podemos cambiar
ninguno de los valores en la lista una vez que los hemos creado. Agreguemos
<code>RefCell&lt;T&gt;</code> para obtener la capacidad de cambiar los valores en las listas.
El listado 15-24 muestra que al usar un <code>RefCell&lt;T&gt;</code> en la definici√≥n de <code>Cons</code>,
podemos modificar el valor almacenado en todas las listas:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {a:?}&quot;);
    println!(&quot;b after = {b:?}&quot;);
    println!(&quot;c after = {c:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 15-24: Usando <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> para crear una
<code>List</code> que podemos modificar.</span></p>
<p>Creamos un valor que es una instancia de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> y lo almacenamos en
una variable llamada <code>value</code> para que podamos acceder a √©l directamente m√°s
tarde. Luego creamos una <code>List</code> en <code>a</code> con una variante <code>Cons</code> que contiene
<code>value</code>. Necesitamos clonar <code>value</code> para que tanto <code>a</code> como <code>value</code> tengan
ownership del valor interno <code>5</code> en lugar de transferir el ownership de <code>value</code>
a <code>a</code> o tener <code>a</code> pedir prestado de <code>value</code>.</p>
<p>Envolvemos la lista <code>a</code> en un <code>Rc&lt;T&gt;</code> para que cuando creemos las listas <code>b</code> y
<code>c</code>, ambas puedan referirse a <code>a</code>, que es lo que hicimos en el listado 15-18.</p>
<p>Despu√©s de haber creado las listas en <code>a</code>, <code>b</code> y <code>c</code>, queremos agregar 10 al
valor en <code>value</code>. Hacemos esto llamando a <code>borrow_mut</code> en <code>value</code>, que usa la
caracter√≠stica de dereferenciaci√≥n autom√°tica que discutimos en el cap√≠tulo 5
(ver la secci√≥n <a href="ch05-03-method-syntax.html#donde-esta-el-operador--">‚Äú¬øD√≥nde est√° el operador <code>-&gt;</code>?‚Äù</a><!--
ignore -->) para desreferenciar el <code>Rc&lt;T&gt;</code> al valor interno <code>RefCell&lt;T&gt;</code>.
El m√©todo <code>borrow_mut</code> devuelve un smart pointer <code>RefMut&lt;T&gt;</code>, y usamos el
operador de desreferenciaci√≥n en √©l y cambiamos el valor interno.</p>
<p>Cuando imprimimos <code>a</code>, <code>b</code> y <code>c</code>, podemos ver que todos tienen el valor
modificado de 15 en lugar de 5:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>¬°Esta t√©cnica es bastante genial! Al usar <code>RefCell&lt;T&gt;</code>, tenemos un valor
<code>List</code> externamente inmutable. Pero podemos usar los m√©todos en <code>RefCell&lt;T&gt;</code>
que proporcionan acceso a su mutabilidad interior para que podamos modificar
nuestros datos cuando sea necesario. Las comprobaciones en tiempo de ejecuci√≥n
de las reglas de borrowing nos protegen de las condiciones de carrera en los
datos y, a veces, vale la pena intercambiar un poco de velocidad por esta
flexibilidad en nuestras estructuras de datos. ¬°Ten en cuenta que <code>RefCell&lt;T&gt;</code>
no funciona para c√≥digo multihilo! <code>Mutex&lt;T&gt;</code> es la versi√≥n segura para hilos
de <code>RefCell&lt;T&gt;</code> y discutiremos <code>Mutex&lt;T&gt;</code> en el cap√≠tulo 16.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referencias-circulares-pueden-fugar-memoria"><a class="header" href="#referencias-circulares-pueden-fugar-memoria">Referencias Circulares Pueden Fugar Memoria</a></h2>
<p>Las garant√≠as de seguridad de memoria de Rust hacen dif√≠cil, pero no imposible,
crear accidentalmente memoria que nunca se limpia (conocido como una <em>fuga de
memoria</em>). Prevenir fugas de memoria completamente no es una de las garant√≠as de
Rust, lo que significa que las fugas de memoria son seguras en Rust. Podemos ver
que Rust permite fugas de memoria usando <code>Rc&lt;T&gt;</code> y <code>RefCell&lt;T&gt;</code>: es posible
crear referencias donde los elementos se refieren entre s√≠ en un ciclo. Esto
crea fugas de memoria porque el recuento de referencias de cada elemento en el
ciclo nunca alcanzar√° 0, y los valores nunca ser√°n descartados.</p>
<h3 id="creando-una-referencia-circular"><a class="header" href="#creando-una-referencia-circular">Creando una Referencia Circular</a></h3>
<p>Vamos a ver c√≥mo podr√≠a ocurrir una referencia circular y c√≥mo prevenirla, 
comenzando con la definici√≥n del enum <code>List</code> y un m√©todo <code>tail</code> en el Listado
15-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<p><span class="caption">Listing 15-25: Una definici√≥n de lista enlazada 
que contiene un <code>RefCell&lt;T&gt;</code> para poder modificar a que se refiere una
variante <code>Cons</code></span></p>
<p>Estamos usando otra variaci√≥n de la definici√≥n de <code>List</code> del Listado 15-5. El
segundo elemento en la variante <code>Cons</code> es ahora <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, lo que
significa que en lugar de tener la capacidad de modificar el valor <code>i32</code> como lo
hicimos en el Listado 15-24, queremos modificar el valor <code>List</code> al que una
variante <code>Cons</code> est√° apuntando. Tambi√©n estamos agregando un m√©todo <code>tail</code> para
que sea conveniente para nosotros acceder al segundo elemento si tenemos una
variante <code>Cons</code>.</p>
<p>En el Listado 15-26, estamos agregando una funci√≥n <code>main</code> que usa las
definiciones en el Listado 15-25. Este c√≥digo crea una lista en <code>a</code> y una lista
en <code>b</code> que apunta a la lista en <code>a</code>. Luego modifica la lista en <code>a</code> para que
apunte a <code>b</code>, creando un ciclo de referencia. Hay declaraciones <code>println!</code> a lo
largo del camino para mostrar cu√°les son los recuentos de referencia en varios
puntos de este proceso.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}</code></pre></pre>
<p><span class="caption">Listing 15-26: Creando un ciclo de referencia de dos 
valores <code>List</code> que se apuntan mutuamente.</span></p>
<p>Creamos una instancia <code>Rc&lt;List&gt;</code> que contiene un valor <code>List</code> en la variable
<code>a</code> con una lista inicial de <code>5, Nil</code>. Luego creamos una instancia <code>Rc&lt;List&gt;</code>
que contiene otro valor <code>List</code> en la variable <code>b</code> que contiene el valor 10 y
apunta a la lista en <code>a</code>.</p>
<p>Modificamos <code>a</code> para que apunte a <code>b</code> en lugar de <code>Nil</code>, creando un ciclo. 
Hacemos eso usando el m√©todo <code>tail</code> para obtener una referencia al 
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> en <code>a</code>, que ponemos en la variable <code>link</code>. Luego usamos el 
m√©todo <code>borrow_mut</code> en el <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> para cambiar el valor interno de 
un <code>Rc&lt;List&gt;</code> que contiene un valor <code>Nil</code> al <code>Rc&lt;List&gt;</code> en <code>b</code>.</p>
<p>Cuando ejecutamos este c√≥digo, manteniendo el √∫ltimo <code>println!</code> comentado por
el momento, obtendremos este output:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>El recuento de referencia de las instancias <code>Rc&lt;List&gt;</code> en <code>a</code> y <code>b</code> son 2
despu√©s de cambiar la lista en <code>a</code> para que apunte a <code>b</code>. Al final de <code>main</code>,
Rust descarta la variable <code>b</code>, que disminuye el recuento de referencia de la
instancia <code>Rc&lt;List&gt;</code> de <code>b</code> de 2 a 1. La memoria que <code>Rc&lt;List&gt;</code> tiene en el
heap no se descartar√° en este punto, porque su recuento de referencia es 1, 
no 0. Luego Rust descarta <code>a</code>, que disminuye el recuento de referencia de la
instancia <code>Rc&lt;List&gt;</code> de <code>a</code> de 2 a 1 tambi√©n. La memoria asignada a la lista
no se recoger√° nunca. Para visualizar este ciclo de referencia, hemos creado
un diagrama en la Figura 15-4.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Figure 15-4: Un ciclo de referencia de las listas <code>a</code> 
y <code>b</code> apunt√°ndose mutuamente.</span></p>
<p>Si descomentas el √∫ltimo <code>println!</code> y ejecutas el programa, Rust intentar√°
imprimir este ciclo con <code>a</code> apuntando a <code>b</code> apuntando a <code>a</code> y as√≠ sucesivamente
hasta que desborda el stack.</p>
<p>En comparaci√≥n con un programa del mundo real, las consecuencias de crear un
ciclo de referencia en este ejemplo no son muy graves: justo despu√©s de crear
el ciclo de referencia, el programa termina. Sin embargo, si un programa m√°s
complejo asignara mucha memoria en un ciclo y la mantuviera durante mucho
tiempo, el programa usar√≠a m√°s memoria de la que necesitaba y podr√≠a
abrumar el sistema, causando que se quede sin memoria disponible.</p>
<p>Crear ciclos de referencia no es algo f√°cil de hacer, pero tampoco es imposible.
Si tienes valores <code>RefCell&lt;T&gt;</code> que contienen valores <code>Rc&lt;T&gt;</code> o combinaciones
similares de tipos con mutabilidad interior y recuento de referencias anidados,
debes asegurarte de no crear ciclos; no puedes confiar en Rust para atraparlos.
Crear un ciclo de referencia ser√≠a un error de l√≥gica en tu programa que 
deber√≠as usar pruebas automatizadas, revisiones de c√≥digo y otras pr√°cticas de 
desarrollo de software para minimizar.</p>
<p>Otra soluci√≥n para evitar ciclos de referencia es reorganizar tus estructuras
de datos para que algunas referencias expresen propiedad y algunas referencias
no expresen ownership. Como resultado, puedes tener ciclos compuestos por
algunas relaciones de ownership y algunas relaciones de no ownership, y solo
las relaciones de ownership afectan si un valor puede ser descartado. En el
Listado 15-25, siempre queremos que las variantes <code>Cons</code> posean su lista, por
lo que no es posible reorganizar la estructura de datos. Veamos un ejemplo
usando gr√°ficos compuestos por nodos padres y nodos hijos para ver cu√°ndo las
relaciones de no ownership son una forma apropiada de evitar ciclos de
referencia.</p>
<h3 id="previniendo-ciclos-de-referencia-convirtiendo-un-rct-en-un-weakt"><a class="header" href="#previniendo-ciclos-de-referencia-convirtiendo-un-rct-en-un-weakt">Previniendo ciclos de referencia: convirtiendo un <code>Rc&lt;T&gt;</code> en un <code>Weak&lt;T&gt;</code></a></h3>
<p>Hasta ahora, hemos demostrado que llamar a <code>Rc::clone</code> aumenta el <code>strong_count</code>
de una instancia <code>Rc&lt;T&gt;</code>, y una instancia <code>Rc&lt;T&gt;</code> solo se limpia si su
<code>strong_count</code> es 0. Tambi√©n puedes crear una <em>referencia d√©bil</em> al valor
dentro de una instancia <code>Rc&lt;T&gt;</code> llamando a <code>Rc::downgrade</code> y pasando una
referencia a la <code>Rc&lt;T&gt;</code>. Las referencias fuertes son c√≥mo puedes compartir el
ownership de una instancia <code>Rc&lt;T&gt;</code>. Las referencias d√©biles no expresan una
relaci√≥n de ownership, y su recuento no afecta cu√°ndo se limpia una instancia
<code>Rc&lt;T&gt;</code>. No causar√°n un ciclo de referencia porque cualquier ciclo que involucre
algunas referencias d√©biles se romper√° una vez que el recuento de referencias
fuertes de los valores involucrados sea 0.</p>
<p>Cuando llamas a <code>Rc::downgrade</code>, obtienes un smart pointer de tipo <code>Weak&lt;T&gt;</code>. 
En lugar de aumentar el <code>strong_count</code> en la instancia de <code>Rc&lt;T&gt;</code> en 1, llamar a 
<code>Rc::downgrade</code> aumenta el <code>weak_count</code> en 1. El tipo <code>Rc&lt;T&gt;</code> utiliza el 
<code>weak_count</code> para realizar un seguimiento de cu√°ntas referencias <code>Weak&lt;T&gt;</code> 
existen, de manera similar al <code>strong_count</code>. La diferencia es que el 
<code>weak_count</code> no necesita ser 0 para que se limpie la instancia de <code>Rc&lt;T&gt;</code>.</p>
<p>Dado que el valor al que apunta <code>Weak&lt;T&gt;</code> puede haber sido eliminado, para
hacer cualquier cosa con el valor al que apunta un <code>Weak&lt;T&gt;</code>, debes asegurarte
de que el valor a√∫n exista. Haz esto llamando al m√©todo <code>upgrade</code> en una
instancia <code>Weak&lt;T&gt;</code>, que devolver√° un <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Si el valor <code>Rc&lt;T&gt;</code> a√∫n
no se ha eliminado, <code>upgrade</code> devolver√° <code>Some</code>, y si el valor <code>Rc&lt;T&gt;</code> se ha
eliminado, <code>upgrade</code> devolver√° <code>None</code>. Porque <code>upgrade</code> devuelve un
<code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust se asegurar√° de que se manejen los casos <code>Some</code> y <code>None</code>,
y no habr√° un puntero no v√°lido.</p>
<p>Como ejemplo, en lugar de usar una lista cuyos elementos solo conocen al
siguiente elemento, crearemos un √°rbol cuyos elementos conocen a sus elementos
hijos <em>y</em> a sus elementos padres.</p>
<h4 id="creando-una-estructura-de-datos-de-√°rbol-un-node-con-nodos-hijos"><a class="header" href="#creando-una-estructura-de-datos-de-√°rbol-un-node-con-nodos-hijos">Creando una estructura de datos de √°rbol: un <code>Node</code> con nodos hijos</a></h4>
<p>Para comenzar, construiremos un √°rbol con nodos que conocen a sus nodos hijos.
Crearemos una estructura llamada <code>Node</code> que contenga su propio valor <code>i32</code> as√≠
como referencias a sus nodos hijos <code>Node</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>Queremos que un <code>Node</code> sea propietario de sus hijos, y queremos compartir
ese ownership con variables para que podamos acceder a cada <code>Node</code> en el √°rbol
directamente. Para hacer esto, definimos los elementos <code>Vec&lt;T&gt;</code> para ser
valores de tipo <code>Rc&lt;Node&gt;</code>. Tambi√©n queremos modificar qu√© nodos son hijos de
otro nodo, por lo que tenemos un <code>RefCell&lt;T&gt;</code> en <code>children</code> alrededor del
<code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>A continuaci√≥n, usaremos la definici√≥n de nuestro struct y crearemos una
instancia <code>Node</code> llamada <code>leaf</code> con el valor 3 y sin hijos, y otra instancia
llamada <code>branch</code> con el valor 5 y <code>leaf</code> como uno de sus hijos, como se muestra
en el Listado 15-26:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<p><span class="caption">Listing 15-27: Creando un nodo <code>leaf</code> sin hijos y un nodo
<code>branch</code> con <code>leaf</code> como uno de sus hijos</span></p>
<p>Clonamos el <code>Rc&lt;Node&gt;</code> en <code>leaf</code> y lo almacenamos en <code>branch</code>, lo que significa
que el <code>Node</code> en <code>leaf</code> ahora tiene dos propietarios: <code>leaf</code> y <code>branch</code>. Podemos
ir de <code>branch</code> a <code>leaf</code> a trav√©s de <code>branch.children</code>, pero no hay forma de
ir de <code>leaf</code> a <code>branch</code>. La raz√≥n es que <code>leaf</code> no tiene referencia a <code>branch</code>
y no sabe que est√°n relacionados. Queremos que <code>leaf</code> sepa que <code>branch</code> es su
padre. Lo haremos a continuaci√≥n.</p>
<h4 id="agregando-una-referencia-de-un-hijo-a-su-padre"><a class="header" href="#agregando-una-referencia-de-un-hijo-a-su-padre">Agregando una referencia de un hijo a su padre</a></h4>
<p>Para hacer que el nodo hijo sea consciente de su padre, necesitamos agregar un
campo <code>parent</code> a nuestra definici√≥n de struct <code>Node</code>. El problema est√° en
decidir qu√© tipo de <code>parent</code> deber√≠a ser. Sabemos que no puede contener un
<code>Rc&lt;T&gt;</code>, porque eso crear√≠a un ciclo de referencia con <code>leaf.parent</code> apuntando
a <code>branch</code> y <code>branch.children</code> apuntando a <code>leaf</code>, lo que har√≠a que sus valores
<code>strong_count</code> nunca fueran 0.</p>
<p>Si pensamos en las relaciones de otra manera, un nodo padre deber√≠a ser
propietario de sus nodos hijos: si se elimina un nodo padre, sus nodos hijos
tambi√©n deber√≠an eliminarse. Sin embargo, un hijo no deber√≠a ser propietario de
su padre: si eliminamos un nodo hijo, el padre a√∫n deber√≠a existir. ¬°Este es un
caso para las referencias d√©biles!</p>
<p>Entonces en lugar de <code>Rc&lt;T&gt;</code>, usaremos <code>Weak&lt;T&gt;</code> como tipo de dato para <code>parent</code>
, espec√≠ficamente <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Ahora nuestra definici√≥n de struct
<code>Node</code> se ve as√≠:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>Un nodo podr√° referirse a su nodo padre, pero no ser√° propietario de √©l. En
el Listado 15-28, actualizamos <code>main</code> para usar esta nueva definici√≥n, por lo
que el nodo <code>leaf</code> tendr√° una forma de referirse a su nodo padre, <code>branch</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}</code></pre></pre>
<p><span class="caption">Listing 15-28: Un nodo <code>leaf</code> con una referencia d√©bil a 
su nodo padre <code>branch</code></span></p>
<p>La creaci√≥n del nodo <code>leaf</code> se ve similar al Listado 15-27 con la excepci√≥n del
campo <code>parent</code>: <code>leaf</code> comienza sin un padre, por lo que creamos una nueva
instancia de referencia <code>Weak&lt;Node&gt;</code> vac√≠a.</p>
<p>En este punto, cuando intentamos obtener una referencia al padre de <code>leaf</code>
usando el m√©todo <code>upgrade</code>, obtenemos un valor <code>None</code>. Vemos esto en el output
de la primera instrucci√≥n <code>println!</code>:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Cuando creamos el nodo <code>branch</code>, tambi√©n tendr√° una nueva referencia 
<code>Weak&lt;Node&gt;</code> en el campo <code>parent</code>, porque <code>branch</code> no tiene un nodo padre.
Todav√≠a tenemos <code>leaf</code> como uno de los hijos de <code>branch</code>. Una vez que tenemos
la instancia <code>Node</code> en <code>branch</code>, podemos modificar <code>leaf</code> para darle una
referencia <code>Weak&lt;Node&gt;</code> a su padre. Usamos el m√©todo <code>borrow_mut</code> en el
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> en el campo <code>parent</code> de <code>leaf</code>, y luego usamos la
funci√≥n <code>Rc::downgrade</code> para crear una referencia <code>Weak&lt;Node&gt;</code> a <code>branch</code> desde
el <code>Rc&lt;Node&gt;</code> en <code>branch</code>.</p>
<p>Cuando imprimimos el padre de <code>leaf</code> nuevamente, esta vez obtendremos una
variante <code>Some</code> que contiene <code>branch</code>: ¬°ahora <code>leaf</code> puede acceder a su padre!
Cuando imprimimos <code>leaf</code>, tambi√©n evitamos el ciclo que eventualmente termin√≥
en un desbordamiento de pila como ten√≠amos en el Listado 15-26; las referencias
<code>Weak&lt;Node&gt;</code> se imprimen como <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>La falta de output infinito indica que este c√≥digo no cre√≥ un ciclo de
referencia. Tambi√©n podemos decir esto mirando los valores que obtenemos al
llamar a <code>Rc::strong_count</code> y <code>Rc::weak_count</code>.</p>
<h4 id="visualizando-cambios-en-strong_count-y-weak_count"><a class="header" href="#visualizando-cambios-en-strong_count-y-weak_count">Visualizando cambios en <code>strong_count</code> y <code>weak_count</code></a></h4>
<p>Veamos c√≥mo cambian los valores <code>strong_count</code> y <code>weak_count</code> de las instancias
<code>Rc&lt;Node&gt;</code> al crear y modificar <code>branch</code>. El Listado 15-29 muestra el c√≥digo
que usamos para crear <code>branch</code> en un nuevo scope interno y examinar los valores
de referencia <code>strong_count</code> y <code>weak_count</code>. Al hacerlo, podemos ver qu√©
sucede cuando se crea <code>branch</code> y luego se elimina cuando sale del scope. Las
modificaciones se muestran en el Listado 15-29:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<p><span class="caption">Listing 15-29: Creando <code>branch</code> en un scope interno y
examinando los recuentos de referencias fuertes y d√©biles</span></p>
<p>Despu√©s de crear <code>leaf</code>, el <code>Rc&lt;Node&gt;</code> tiene un <code>strong_count</code> de 1 y un
<code>weak_count</code> de 0. En el scope interno, creamos <code>branch</code> y lo asociamos con
<code>leaf</code>, momento en el que cuando imprimimos los conteos, el <code>Rc&lt;Node&gt;</code> en
<code>branch</code> tendr√° un <code>strong_count</code> de 1 y un <code>weak_count</code> de 1 (porque
<code>leaf.parent</code> apunta a <code>branch</code> con un <code>Weak&lt;Node&gt;</code>). Cuando imprimimos los
conteos en <code>leaf</code>, veremos que tendr√° un <code>strong_count</code> de 2, porque <code>branch</code>
ahora tiene un clon del <code>Rc&lt;Node&gt;</code> de <code>leaf</code> almacenado en <code>branch.children</code>,
pero a√∫n tendr√° un <code>weak_count</code> de 0.</p>
<p>Cuando el scope interno termina, <code>branch</code> sale del scope y el recuento fuerte
del <code>Rc&lt;Node&gt;</code> en <code>branch</code> se reduce a 0, por lo que su <code>Node</code> se elimina. El
recuento d√©bil de 1 de <code>leaf.parent</code> no tiene ninguna consecuencia sobre si se
elimina o no <code>Node</code>, ¬°as√≠ que no obtenemos fugas de memoria!</p>
<p>Si intentamos acceder al padre de <code>leaf</code> despu√©s del final del scope, 
obtendremos <code>None</code> nuevamente. Al final del programa, el <code>Rc&lt;Node&gt;</code> en <code>leaf</code>
tiene un recuento fuerte de 1 y un recuento d√©bil de 0, porque la variable
<code>leaf</code> es nuevamente la √∫nica referencia al <code>Rc&lt;Node&gt;</code>.</p>
<p>Toda la l√≥gica que gestiona los recuentos y la eliminaci√≥n de valores est√°
incorporada en <code>Rc&lt;T&gt;</code> y <code>Weak&lt;T&gt;</code> y sus implementaciones del trait <code>Drop</code>. Al
especificar que la relaci√≥n de un hijo con su padre debe ser una referencia
<code>Weak&lt;T&gt;</code> en la definici√≥n de <code>Node</code>, puede tener nodos padres que apunten a
nodos hijos y viceversa sin crear un ciclo de referencia y fugas de memoria.</p>
<h2 id="resumen-14"><a class="header" href="#resumen-14">Resumen</a></h2>
<p>Este cap√≠tulo cubri√≥ c√≥mo usar smart pointers para hacer diferentes garant√≠as y
compensaciones de las que Rust hace de forma predeterminada con referencias
regulares. El tipo <code>Box&lt;T&gt;</code> tiene un tama√±o conocido y apunta a datos
asignados en el heap. El tipo <code>Rc&lt;T&gt;</code> realiza un seguimiento del n√∫mero de
referencias a los datos en el heap para que los datos puedan tener m√∫ltiples
propietarios. El tipo <code>RefCell&lt;T&gt;</code> con su mutabilidad interior nos da un tipo
que podemos usar cuando necesitamos un tipo inmutable, pero necesitamos cambiar
un valor interno de ese tipo; tambi√©n hace cumplir las reglas de borrowing en
tiempo de ejecuci√≥n en lugar de en tiempo de compilaci√≥n.</p>
<p>Tambi√©n se discutieron los traits <code>Deref</code>, <code>Drop</code>,que habilitan gran parte
de la funcionalidad de los smart pointers. Exploramos los ciclos de referencia
que pueden causar fugas de memoria y c√≥mo prevenirlos usando <code>Weak&lt;T&gt;</code>.</p>
<p>Si este cap√≠tulo ha despertado tu inter√©s y quieres implementar tus propios
smart pointers, consulta <a href="https://doc.rust-lang.org/nomicon/index.html">‚ÄúThe Rustonomicon‚Äù</a> para obtener m√°s
informaci√≥n √∫til.</p>
<p>A continuaci√≥n, hablaremos sobre la concurrencia en Rust. Incluso aprender√°s
sobre algunos nuevos smart pointers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrencia-sin-miedo"><a class="header" href="#concurrencia-sin-miedo">Concurrencia sin miedo</a></h1>
<p>Manejar la programaci√≥n concurrente de forma segura y eficiente es otro de los
principales objetivos de Rust. La <em>programaci√≥n concurrente</em>, donde diferentes
partes de un programa se ejecutan de forma independiente, y la <em>programaci√≥n
paralela</em>, donde diferentes partes de un programa se ejecutan al mismo tiempo,
son cada vez m√°s importantes a medida que m√°s computadoras aprovechan sus
m√∫ltiples procesadores. Hist√≥ricamente, la programaci√≥n en estos contextos ha
sido dif√≠cil y propensa a errores: ¬°Rust espera cambiar eso!</p>
<p>Inicialmente, el equipo de Rust pens√≥ que garantizar la seguridad de la memoria
y prevenir los problemas de concurrencia eran dos desaf√≠os separados que se
resolver√≠an con diferentes m√©todos. Con el tiempo, el equipo descubri√≥ que los
sistemas de propiedad y tipos son un conjunto de herramientas poderosas para
ayudar a administrar la seguridad de la memoria <em>y</em> los problemas de
concurrencia. Al aprovechar la propiedad y la comprobaci√≥n de tipos, muchos
errores de concurrencia son errores de tiempo de compilaci√≥n en Rust en lugar
de errores de tiempo de ejecuci√≥n. Por lo tanto, en lugar de hacer que pase
mucho tiempo tratando de reproducir las circunstancias exactas en las que se
produce un error de concurrencia en tiempo de ejecuci√≥n, el c√≥digo incorrecto
se negar√° a compilar y presentar√° un error que explica el problema. Como
resultado, puede corregir su c√≥digo mientras lo est√° trabajando en lugar de
potencialmente despu√©s de que se haya enviado a producci√≥n. Hemos apodado este
aspecto de Rust como <em>concurrencia sin miedo</em>. La concurrencia sin miedo le
permite escribir c√≥digo que no tiene errores sutiles y es f√°cil de refactorizar
sin introducir nuevos bugs.</p>
<blockquote>
<p>Nota: Para simplificar, nos referiremos a muchos de los problemas como
<em>concurrentes</em> en lugar de ser m√°s precisos al decir <em>concurrentes y/o
paralelos</em>. Si este libro tratara sobre concurrencia y/o paralelismo, ser√≠amos
m√°s espec√≠ficos. Para este cap√≠tulo, por favor sustituya mentalmente
<em>concurrente y/o paralelo</em> cada vez que usemos <em>concurrente</em>.</p>
</blockquote>
<p>Muchos lenguajes son dogm√°ticos sobre las soluciones que ofrecen para manejar
problemas concurrentes. Por ejemplo, Erlang tiene una funcionalidad elegante
para la concurrencia de paso de mensajes, pero solo tiene formas oscuras de
compartir estado entre hilos. Soportar solo un subconjunto de soluciones
posibles es una estrategia razonable para los lenguajes de m√°s alto nivel,
porque un lenguaje de m√°s alto nivel promete beneficios al renunciar a cierto
control para obtener abstracciones. Sin embargo, se espera que los lenguajes de
nivel inferior proporcionen la soluci√≥n con el mejor rendimiento en cualquier
situaci√≥n dada y tengan menos abstracciones sobre el hardware. Por lo tanto,
Rust ofrece una variedad de herramientas para modelar problemas de la manera
que sea apropiada para su situaci√≥n y requisitos.</p>
<p>Aqu√≠ est√°n los temas que cubriremos en este cap√≠tulo:</p>
<ul>
<li>C√≥mo crear hilos para ejecutar m√∫ltiples piezas de c√≥digo al mismo tiempo</li>
<li><em>Message-passing</em> concurrencia, donde los canales env√≠an mensajes entre hilos</li>
<li><em>Shared-state</em> concurrencia, donde m√∫ltiples hilos tienen acceso a alguna
pieza de datos</li>
<li>Los traits <code>Sync</code> y <code>Send</code>, que extienden las garant√≠as de concurrencia de
Rust a los tipos definidos por el usuario, as√≠ como a los tipos proporcionados
por la biblioteca est√°ndar</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-threads-para-ejecutar-c√≥digo-simult√°neamente"><a class="header" href="#usando-threads-para-ejecutar-c√≥digo-simult√°neamente">Usando Threads para Ejecutar C√≥digo Simult√°neamente</a></h2>
<p>En la mayor√≠a de los sistemas operativos actuales, el c√≥digo de un programa
ejecutado se ejecuta en un <em>proceso</em>, y el sistema operativo administrar√°
m√∫ltiples procesos a la vez. Dentro de un programa, tambi√©n puede tener partes
independientes que se ejecutan simult√°neamente. Las caracter√≠sticas que ejecutan
estas partes independientes se llaman <em>threads</em>. Por ejemplo, un servidor web
podr√≠a tener m√∫ltiples hilos para que pudiera responder a m√°s de una solicitud
al mismo tiempo.</p>
<p>Dividir la computaci√≥n en su programa en m√∫ltiples hilos para ejecutar m√∫ltiples
tareas al mismo tiempo puede mejorar el rendimiento, pero tambi√©n agrega
complejidad. Debido a que los hilos pueden ejecutarse simult√°neamente, no hay
ninguna garant√≠a inherente sobre el orden en que las partes de su c√≥digo en
diferentes hilos se ejecutar√°n. Esto puede conducir a problemas, como:</p>
<ul>
<li>Race conditions, donde los hilos est√°n accediendo a datos o recursos en
un orden inconsistente</li>
<li>Deadlocks, donde dos hilos est√°n esperando el uno al otro, evitando que ambos
hilos contin√∫en</li>
<li>Bugs que ocurren solo en ciertas situaciones y son dif√≠ciles de reproducir
y arreglar de manera confiable</li>
</ul>
<p>Rust intenta mitigar los efectos negativos de usar hilos, pero la programaci√≥n
en un contexto multihilo a√∫n requiere un pensamiento cuidadoso y requiere una
estructura de c√≥digo que sea diferente de la de los programas que se ejecutan en
un solo hilo.</p>
<p>Los lenguajes de programaci√≥n implementan hilos de varias maneras diferentes, y
muchos sistemas operativos proporcionan una API que el lenguaje puede llamar
para crear nuevos hilos. La biblioteca est√°ndar de Rust utiliza un modelo <em>1:1</em>
de implementaci√≥n de hilos, mediante el cual un programa utiliza un hilo del
sistema operativo por un hilo de lenguaje. Hay crates que implementan otros
modelos de enhebrado que hacen diferentes compensaciones al modelo 1:1.</p>
<h3 id="creando-un-nuevo-hilo-con-spawn"><a class="header" href="#creando-un-nuevo-hilo-con-spawn">Creando un Nuevo Hilo con <code>spawn</code></a></h3>
<p>Para crear un nuevo hilo, llamamos a la funci√≥n <code>thread::spawn</code> y pasamos un
closure (hablamos sobre closures en el Cap√≠tulo 13) que contiene el c√≥digo que
queremos ejecutar en el nuevo hilo. El ejemplo en el Listado 16-1 imprime
algunos textos desde un hilo principal y otros textos desde un nuevo hilo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {i} from the spawned thread!&quot;);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {i} from the main thread!&quot;);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p><span class="caption">Listing 16-1: Creando un nuevo hilo para imprimir una cosa
mientras el hilo principal imprime algo m√°s</span></p>
<p>Nota que cuando el hilo principal de un programa Rust se completa, todos los
hilos creados se apagan, independientemente de si han terminado de ejecutarse o
no. La salida de este programa podr√≠a ser un poco diferente cada vez, pero se
ver√° similar a lo siguiente:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>Las llamadas a <code>thread::sleep</code> fuerzan a un hilo a detener su ejecuci√≥n durante
una corta duraci√≥n, permitiendo que se ejecute un hilo diferente. Los hilos
probablemente se turnar√°n, pero eso no est√° garantizado: depende de c√≥mo su
sistema operativo programe los hilos. En esta ejecuci√≥n, el hilo principal
imprimi√≥ primero, a pesar de que la instrucci√≥n de impresi√≥n del hilo creado
aparece primero en el c√≥digo. Y aunque le dijimos al hilo creado que imprimiera
hasta que <code>i</code> sea 9, solo lleg√≥ a 5 antes de que el hilo principal se apagara.</p>
<p>Si ejecutas este c√≥digo y solo ves el output del hilo principal, o no ves
ninguna superposici√≥n, intenta aumentar los n√∫meros en los rangos para crear
m√°s oportunidades para que el sistema operativo cambie entre los hilos.</p>
<h3 id="esperando-a-que-todos-los-hilos-terminen-usando-join-handles"><a class="header" href="#esperando-a-que-todos-los-hilos-terminen-usando-join-handles">Esperando a que todos los hilos terminen usando <code>join</code> Handles</a></h3>
<p>El c√≥digo en el Listado 16-1 no solo detiene el hilo creado prematuramente la
mayor√≠a de las veces debido a que el hilo principal termina, sino que debido a
que no hay garant√≠a sobre el orden en que se ejecutan los hilos, ¬°tampoco
podemos garantizar que el hilo creado se ejecute en absoluto!</p>
<p>Podemos solucionar el problema de que el hilo creado no se ejecute o termine
prematuramente guardando el valor de retorno de <code>thread::spawn</code> en una variable.
El tipo de retorno de <code>thread::spawn</code> es <code>JoinHandle</code>. Un <code>JoinHandle</code> es un
valor de propiedad que, cuando llamamos al m√©todo <code>join</code> en √©l, esperar√° a que
su hilo termine. El Listado 16-2 muestra c√≥mo usar el <code>JoinHandle</code> del hilo que
creamos en el Listado 16-1 y llamar a <code>join</code> para asegurarnos de que el hilo
creado termine antes de que <code>main</code> salga:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {i} from the spawned thread!&quot;);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {i} from the main thread!&quot;);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 16-2: Guardando un <code>JoinHandle</code> devuelto por
<code>thread::spawn</code> para garantizar que el hilo se ejecute hasta completarse</span></p>
<p>Llamar a <code>join</code> en el handle bloquea el hilo que est√° actualmente en ejecuci√≥n
hasta que el hilo representado por el handle termine. Bloquear un hilo significa
que ese hilo se impide realizar un trabajo o salir. Debido a que hemos puesto la
llamada a <code>join</code> despu√©s del bucle <code>for</code> del hilo principal, ejecutar el Listado
16-2 deber√≠a producir una salida similar a esta:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>Los dos hilos contin√∫an altern√°ndose, pero el hilo principal espera debido a la
llamada a <code>handle.join()</code> y no termina hasta que el hilo creado haya terminado.</p>
<p>Pero veamos que sucede cuando movemos la llamada a <code>handle.join()</code> antes del
bucle <code>for</code> en <code>main</code>, como esto:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {i} from the spawned thread!&quot;);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {i} from the main thread!&quot;);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p>El hilo principal ahora espera a que el hilo creado termine antes de comenzar su
bucle <code>for</code>, para que el output no se intercale m√°s. La salida ahora se ver√°
as√≠:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Peque√±os detalles, como d√≥nde se llama a <code>join</code>, pueden afectar si sus hilos se
ejecutan al mismo tiempo.</p>
<h3 id="usando-move-closures-con-threads"><a class="header" href="#usando-move-closures-con-threads">Usando <code>move</code> Closures con Threads</a></h3>
<p>A menudo usamos la keyword <code>move</code> con closures pasadas a <code>thread::spawn</code> porque
el closure tomar√° posesi√≥n de los valores que usa del entorno, transfiriendo as√≠
el ownership de esos valores de un hilo a otro. En la secci√≥n <a href="ch13-01-closures.html#capturando-referencias-o-moviendo-el-ownership">&quot;Capturando
referencias o moviendo la propiedad&quot;</a><!-- ignore --> del Cap√≠tulo 13,
discutimos <code>move</code> en el contexto de las closures. Ahora, nos concentraremos m√°s
en la interacci√≥n entre <code>move</code> y <code>thread::spawn</code>.</p>
<p>Observa en el Listado 16-1 que el closure que pasamos a <code>thread::spawn</code> no tiene
argumentos: no estamos usando ning√∫n dato del hilo principal en el c√≥digo del
hilo creado. Para usar datos del hilo principal en el hilo creado, el closure
del hilo creado debe capturar los valores que necesita. El Listado 16-3 muestra
un intento de crear un vector en el hilo principal y usarlo en el hilo creado.
Sin embargo, esto a√∫n no funcionar√°, como ver√°s en un momento.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {v:?}&quot;);
    });

    handle.join().unwrap();
}</code></pre>
<p><span class="caption">Listing 16-3: Intentando usar un vector creado por el hilo
principal en otro hilo</span></p>
<p>El closure usa <code>v</code>, por lo que capturar√° <code>v</code> y lo har√° parte del entorno del
closure. Debido a que <code>thread::spawn</code> ejecuta este closure en un nuevo hilo,
deber√≠amos poder acceder a <code>v</code> dentro de ese nuevo hilo. Pero cuando compilamos
este ejemplo, obtenemos el siguiente error:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {v:?}&quot;);
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Here's a vector: {v:?}&quot;);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin &quot;threads&quot;) due to 1 previous error
</code></pre>
<p>Rust <em>infiere</em> c√≥mo capturar <code>v</code>, y porque <code>println!</code> solo necesita una
referencia a <code>v</code>, el closure intenta pedir prestado <code>v</code>. Sin embargo, hay un
problema: Rust no puede decir cu√°nto tiempo se ejecutar√° el hilo creado, por lo
que no sabe si la referencia a <code>v</code> siempre ser√° v√°lida.</p>
<p>El Listado 16-4 proporciona un escenario que es m√°s probable que tenga una
referencia a <code>v</code> que no sea v√°lida:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {v:?}&quot;);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
<p><span class="caption">Listing 16-4: Un hilo con un closure que intenta capturar
una referencia a <code>v</code> desde un hilo principal que deja de tener <code>v</code></span></p>
<p>Si Rust nos permitiera ejecutar este c√≥digo, existe la posibilidad de que el
hilo creado se ponga inmediatamente en segundo plano sin ejecutarse en absoluto.
El hilo creado tiene una referencia a <code>v</code> dentro, pero el hilo principal
inmediatamente deja caer <code>v</code>, usando la funci√≥n <code>drop</code> que discutimos en el
Cap√≠tulo 15. Luego, cuando el hilo creado comienza a ejecutarse, <code>v</code> ya no es
v√°lido, por lo que una referencia a √©l tambi√©n es inv√°lida. ¬°Oh no!</p>
<p>Para solucionar el error en el Listado 16-3, podemos seguir el consejo del mensaje
de error:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>Al agregar la keyword <code>move</code> antes del closure, forzamos al closure a tomar
ownership de los valores que est√° usando en lugar de permitir que Rust infiera
que deber√≠a pedir prestado los valores. La modificaci√≥n al Listado 16-3 que se
muestra en el Listado 16-5 se compilar√° y ejecutar√° como lo pretendemos:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {v:?}&quot;);
    });

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 16-5: Usando la keyword <code>move</code> para forzar a un
closure a tomar ownership de los valores que utiliza</span></p>
<p>Podr√≠amos sentir la tentaci√≥n de intentar lo mismo para arreglar el c√≥digo en el
Listado 16-4 donde el hilo principal llam√≥ a <code>drop</code> usando un closure <code>move</code>.
Sin embargo, esta soluci√≥n no funcionar√° porque lo que el Listado 16-4 est√°
intentando hacer est√° prohibido por una raz√≥n diferente. Si agreg√°ramos <code>move</code>
al closure, mover√≠amos <code>v</code> al entorno del closure, y ya no podr√≠amos llamar a
<code>drop</code> en el hilo principal. En su lugar, obtendr√≠amos este error del
compilador:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Here's a vector: {v:?}&quot;);
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin &quot;threads&quot;) due to 1 previous error
</code></pre>
<p>Las reglas de ownership de Rust nos han salvado de nuevo! Obtenemos un error del
c√≥digo en el Listado 16-3 porque Rust es conservador y solo pide prestado <code>v</code>
para el hilo, lo que significa que el hilo principal podr√≠a te√≥ricamente
invalidar la referencia del hilo creado. Al decirle a Rust que mueva la
propiedad de <code>v</code> al hilo creado, le garantizamos a Rust que el hilo principal no
usar√° <code>v</code> nunca m√°s. Si cambiamos el Listado 16-4 de la misma manera, entonces
estamos violando las reglas de ownership cuando intentamos usar <code>v</code> en el hilo
principal. La keyword <code>move</code> anula la conservadora predeterminada de Rust de
pedir prestado; no nos permite violar las reglas de ownership.</p>
<p>Con una comprensi√≥n b√°sica de los hilos y la API de hilos, veamos qu√© podemos
<em>hacer</em> con los hilos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-el-pasaje-de-mensajes-para-transferir-datos-entre-hilos"><a class="header" href="#usando-el-pasaje-de-mensajes-para-transferir-datos-entre-hilos">Usando el Pasaje de Mensajes para Transferir Datos entre Hilos</a></h2>
<p>Un enfoque cada vez m√°s popular para garantizar una concurrencia segura es
<em>message passing</em>, donde los hilos o actores se comunican envi√°ndose mensajes
que contienen datos. Aqu√≠ est√° la idea en un eslogan de <a href="https://golang.org/doc/effective_go.html#concurrency">la documentaci√≥n del
lenguaje Go</a>: ‚ÄúNo se
comunica compartiendo memoria; en su lugar, comparta memoria comunic√°ndose‚Äù.</p>
<p>Para lograr la concurrencia mediante el env√≠o de mensajes, la biblioteca
est√°ndar de Rust proporciona una implementaci√≥n de <em>canales</em>. Un canal es un
concepto de programaci√≥n general por el cual se env√≠an datos de un hilo a
otro.</p>
<p>Puede imaginar un canal en programaci√≥n como un canal direccional de agua, como
un arroyo o un r√≠o. Si pones algo como un patito de goma en un r√≠o, viajar√°
aguas abajo hasta el final de la v√≠a fluvial.</p>
<p>Un canal tiene dos partes: un transmisor y un receptor. La mitad del
transmisor es la ubicaci√≥n aguas arriba donde pones patitos de goma en el r√≠o,
y la mitad del receptor es donde termina el patito de goma aguas abajo. Una
parte de su c√≥digo llama a m√©todos en el transmisor con los datos que desea
enviar, y otra parte verifica el extremo receptor para ver si llegan mensajes.
Se dice que un canal est√° <em>cerrado</em> si se elimina la mitad del transmisor o
del receptor.</p>
<p>Aqu√≠, iremos desarrollando un programa que tiene un hilo para generar valores
y enviarlos por un canal, y otro hilo que recibir√° los valores e imprimir√°
por pantalla. Enviaremos valores simples entre hilos usando un canal para
ilustrar la caracter√≠stica. Una vez que est√© familiarizado con la t√©cnica,
podr√≠a usar canales para cualquier hilo que necesite comunicarse entre s√≠,
como un sistema de chat o un sistema donde muchos hilos realizan partes de un
c√°lculo y env√≠an las partes a un hilo que agrega los resultados.</p>
<p>Primero, en el Listado 16-6, crearemos un canal pero no haremos nada con √©l.
Tenga en cuenta que esto a√∫n no se compilar√° porque Rust no puede determinar qu√©
tipo de valores queremos enviar por el canal.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<p><span class="caption">Listing 16-6: Creando un canal y asignando las dos mitades
a <code>tx</code> y <code>rx</code></span></p>
<p>Creamos un nuevo canal usando la funci√≥n <code>mpsc::channel</code>; <code>mpsc</code> significa
<em>multiple producer, single consumer</em> (m√∫ltiples productores, un solo
consumidor). En resumen, la forma en que la biblioteca est√°ndar de Rust
implementa los canales significa que un canal puede tener m√∫ltiples extremos
de <em>env√≠o</em> que producen valores, pero solo un extremo de <em>recepci√≥n</em> que
consume esos valores. Imag√≠nese varios arroyos que fluyen juntos en un gran
r√≠o: todo lo que se env√≠a por cualquiera de los arroyos terminar√° en un r√≠o al
final. Comenzaremos con un solo productor por ahora, pero agregaremos
m√∫ltiples productores cuando hagamos que este ejemplo funcione.</p>
<p>La funci√≥n <code>mpsc::channel</code> devuelve una tupla, donde el primer elemento es el
extremo de env√≠o, y el segundo elemento es el extremo de recepci√≥n. Las
abreviaturas <code>tx</code> y <code>rx</code> se usan tradicionalmente en muchos campos para
<em>transmisor</em> y <em>receptor</em> respectivamente, por lo que nombramos nuestras
variables de esa manera para indicar cada extremo. Estamos usando una
sentencia <code>let</code> con un patr√≥n que deconstruye las tuplas; discutiremos el uso
de patrones en las sentencias <code>let</code> y la deconstrucci√≥n en el Cap√≠tulo 18. Por
ahora, sepa que usar una sentencia <code>let</code> de esta manera es un enfoque
conveniente para extraer las piezas de la tupla devuelta por <code>mpsc::channel</code>.</p>
<p>Movamos el extremo de env√≠o a un hilo generado y hagamos que env√≠e un string
para que el hilo generado se comunique con el hilo principal, como se muestra
en el Listado 16-7. Esto es como poner un patito de goma en el r√≠o aguas arriba
o enviar un mensaje de chat de un hilo a otro.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<p><span class="caption">Listing 16-7: Moviendo <code>tx</code> a un hilo generado y enviar
‚Äúhi‚Äù</span></p>
<p>Nuevamente, estamos usando <code>thread::spawn</code> para crear un nuevo hilo y luego
usando <code>move</code> para mover <code>tx</code> al cierre para que el hilo generado posea <code>tx</code>.
El hilo generado necesita poseer el transmisor para poder enviar mensajes a
trav√©s del canal. El transmisor tiene un m√©todo <code>send</code> que toma el valor que
queremos enviar. El m√©todo <code>send</code> devuelve un tipo <code>Result&lt;T, E&gt;</code>, por lo que
si el receptor se ha eliminado y no hay ning√∫n lugar para enviar un valor, la
operaci√≥n de env√≠o devolver√° un error. En este ejemplo, estamos llamando a
<code>unwrap</code> para que se produzca un p√°nico en caso de error. Pero en una
aplicaci√≥n real, lo manejar√≠amos correctamente: vuelva al Cap√≠tulo 9 para
revisar las estrategias para el manejo adecuado de errores.</p>
<p>En el Listado 16-8, recibiremos el valor enviado en el hilo principal. Esto es
como recibir el patito de goma en el r√≠o aguas abajo o recibir un mensaje de
chat.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {received}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 16-8: Recibiendo el valor ‚Äúhi‚Äù en el hilo thread
e imprimi√©ndolo</span></p>
<p>El receptor tiene dos m√©todos √∫tiles: <code>recv</code> y <code>try_recv</code>. Estamos usando
<code>recv</code>, abreviatura de <em>receive</em> (recibir), que bloquear√° la ejecuci√≥n del
hilo principal y esperar√° hasta que se env√≠e un valor por el canal. Una vez que
se env√≠a un valor, <code>recv</code> lo devolver√° en un <code>Result&lt;T, E&gt;</code>. Cuando el
transmisor se cierra, <code>recv</code> devolver√° un error para indicar que no se
enviar√°n m√°s valores.</p>
<p>El m√©todo <code>try_recv</code> no bloquea, sino que en su lugar devuelve un <code>Result&lt;T, E&gt;</code> inmediatamente: un valor <code>Ok</code> que contiene un mensaje si hay uno
disponible y un valor <code>Err</code> si no hay mensajes esta vez. Usar <code>try_recv</code> es
√∫til si este hilo tiene otro trabajo que hacer mientras espera mensajes:
podr√≠amos escribir un bucle que llame a <code>try_recv</code> cada cierto tiempo, maneje
un mensaje si hay uno disponible y, de lo contrario, haga otro trabajo por un
tiempo hasta que vuelva a verificar.</p>
<p>Hemos usado <code>recv</code> en este ejemplo por simplicidad; no tenemos otro trabajo
para que haga el hilo principal que esperar mensajes, por lo que bloquear el
hilo principal es apropiado.</p>
<p>Cuando ejecutamos el c√≥digo en el Listado 16-8, veremos el valor impreso desde
el hilo principal:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>¬°Perfecto!</p>
<h3 id="canales-y-transferencia-de-ownership"><a class="header" href="#canales-y-transferencia-de-ownership">Canales y transferencia de Ownership</a></h3>
<p>Las reglas de ownership juegan un papel vital en el env√≠o de mensajes porque
ayudan a escribir c√≥digo concurrente seguro. Prevenir errores en la
programaci√≥n concurrente es la ventaja de pensar en el ownership en todos sus
programas Rust. Hagamos un experimento para mostrar c√≥mo los canales y el
ownership funcionan juntos para evitar problemas: intentaremos usar un valor
<code>val</code> en el hilo generado <em>despu√©s</em> de haberlo enviado por el canal. Intente
compilar el c√≥digo en el Listado 16-9 para ver por qu√© este c√≥digo no est√°
permitido:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {val}&quot;);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {received}&quot;);
}</code></pre>
<p><span class="caption">Listing 16-9: Attempting to use <code>val</code> after we‚Äôve sent it
down the channel</span></p>
<p>Aqu√≠, intentamos imprimir <code>val</code> despu√©s de haberlo enviado por el canal a
trav√©s de <code>tx.send</code>. Permitir esto ser√≠a una mala idea: una vez que el valor
se ha enviado a otro hilo, ese hilo podr√≠a modificarlo o eliminarlo antes de
que intentemos usar el valor nuevamente. Potencialmente, las modificaciones de
otro hilo podr√≠an causar errores o resultados inesperados debido a datos
inconsistentes o inexistentes. Sin embargo, Rust nos da un error si intentamos
compilar el c√≥digo en el Listado 16-9:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from(&quot;hi&quot;);
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {val}&quot;);
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
   |
9  |         tx.send(val.clone()).unwrap();
   |                    ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin &quot;message-passing&quot;) due to 1 previous error
</code></pre>
<p>Nuestro error de concurrencia ha causado un error en tiempo de compilaci√≥n. La
funci√≥n <code>send</code> toma la propiedad de su par√°metro, y cuando se mueve el valor,
el receptor se hace cargo de √©l. Esto nos impide usar accidentalmente el valor
nuevamente despu√©s de enviarlo; el sistema de propiedad verifica que todo
est√© bien.</p>
<h3 id="enviando-m√∫ltiples-valores-y-viendo-al-receptor-esperando"><a class="header" href="#enviando-m√∫ltiples-valores-y-viendo-al-receptor-esperando">Enviando m√∫ltiples valores y viendo al receptor esperando</a></h3>
<p>El c√≥digo en el Listado 16-8 compil√≥ y se ejecut√≥, pero no nos mostr√≥
claramente que dos hilos separados estaban hablando entre s√≠ a trav√©s del
canal. En el Listado 16-10 hemos realizado algunas modificaciones que
demostrar√°n que el c√≥digo en el Listado 16-8 se est√° ejecutando
concurrentemente: el hilo generado ahora enviar√° varios mensajes y se
pausar√° durante un segundo entre cada mensaje.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {received}&quot;);
    }
}</code></pre>
<p><span class="caption">Listing 16-10: Enviando m√∫ltiples mensajes y pausando
entre cada uno</span></p>
<p>Esta vez, el hilo generado tiene un vector de strings que queremos enviar al
hilo principal. Iteramos sobre ellos, enviando cada uno individualmente, y
pausamos entre cada uno llamando a la funci√≥n <code>thread::sleep</code> con un valor
<code>Duration</code> de 1 segundo.</p>
<p>En el hilo principal, ya no estamos llamando expl√≠citamente a la funci√≥n
<code>recv</code>: en su lugar, estamos tratando <code>rx</code> como un iterator. Para cada valor
recibido, lo imprimimos. Cuando el canal est√° cerrado, la iteraci√≥n terminar√°.</p>
<p>Al ejecutar el c√≥digo del Listado 16-10, deber√≠a ver el siguiente resultado con
una pausa de 1 segundo entre cada l√≠nea:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Debido a que no tenemos ning√∫n c√≥digo que pause o retrase el bucle <code>for</code> en el
hilo principal, podemos decir que el hilo principal est√° esperando recibir
valores del hilo generado.</p>
<h3 id="creando-m√∫ltiples-productores-clonando-el-transmisor"><a class="header" href="#creando-m√∫ltiples-productores-clonando-el-transmisor">Creando m√∫ltiples productores clonando el transmisor</a></h3>
<p>Anteriormente mencionamos que <code>mpsc</code> era un acr√≥nimo de <em>multiple producer,
single consumer</em> (m√∫ltiples productores, un solo consumidor). Pongamos <code>mpsc</code>
en uso y expandamos el c√≥digo en el Listado 16-10 para crear m√∫ltiples hilos
que env√≠en valores al mismo receptor. Podemos hacerlo clonando el transmisor,
como se muestra en el Listado 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;more&quot;),
            String::from(&quot;messages&quot;),
            String::from(&quot;for&quot;),
            String::from(&quot;you&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {received}&quot;);
    }

    // --snip--
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 16-11: Env√≠o de m√∫ltiples mensajes de m√∫ltiples
productores</span></p>
<p>Esta vez, antes de crear el primer hilo generado, llamamos a <code>clone</code> en el
transmisor, lo que nos dar√° un nuevo transmisor que podemos pasar al primer
hilo generado. Pasamos el transmisor original a un segundo hilo generado. Esto
nos da dos hilos, cada uno enviando mensajes diferentes al receptor.</p>
<p>Cuando ejecutamos el c√≥digo, tu output deber√≠a verse as√≠:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Es posible que veas los valores en otro orden seg√∫n tu sistema. Esto es lo que 
hace que la concurrencia sea tan interesante como dif√≠cil. Si experimentas con
<code>thread::sleep</code>, d√°ndole varios valores en los diferentes hilos, cada ejecuci√≥n
ser√° m√°s no determinista y crear√° una salida diferente cada vez.</p>
<p>Ahora que hemos visto c√≥mo funcionan los canales, veamos un m√©todo diferente de
concurrencia.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrencia-con-estado-compartido"><a class="header" href="#concurrencia-con-estado-compartido">Concurrencia con Estado Compartido</a></h2>
<p>El paso de mensajes es una buena manera de manejar la concurrencia, pero no es
la √∫nica. Otro m√©todo ser√≠a que varios hilos accedan a los mismos datos
compartidos. Considere esta parte del eslogan de la documentaci√≥n del lenguaje
Go nuevamente: &quot;no se comunique compartiendo memoria&quot;.</p>
<p>¬øQu√© significar√≠a comunicarse compartiendo memoria? Adem√°s, ¬øpor qu√© los
entusiastas del paso de mensajes advierten que no se debe usar el intercambio de
memoria?</p>
<p>En cierto modo, los canales en cualquier lenguaje de programaci√≥n son similares
al ownership √∫nico, porque una vez que transfieres un valor por un canal, ya
no debes usar ese valor. La concurrencia de memoria compartida es como el
ownership m√∫ltiple: varios hilos pueden acceder a la misma ubicaci√≥n de memoria
al mismo tiempo. Como viste en el Cap√≠tulo 15, donde los punteros inteligentes
hicieron posible el ownership m√∫ltiple, el ownership m√∫ltiple puede agregar
complejidad porque estos propietarios diferentes necesitan administraci√≥n. El
sistema de tipos y las reglas de ownership de Rust ayudan mucho a obtener esta
administraci√≥n correcta. Para un ejemplo, veamos los mutex, uno de los
primitivos de concurrencia m√°s comunes para la memoria compartida.</p>
<h3 id="usando-mutexes-para-permitir-el-acceso-a-los-datos-de-un-hilo-a-la-vez"><a class="header" href="#usando-mutexes-para-permitir-el-acceso-a-los-datos-de-un-hilo-a-la-vez">Usando Mutexes para permitir el acceso a los datos de un hilo a la vez</a></h3>
<p><em>Mutex</em> es una abreviatura de <em>exclusi√≥n mutua</em>, como en, un mutex permite que
solo un hilo acceda a algunos datos en un momento dado. Para acceder a los
datos en un mutex, un hilo primero debe se√±alar que desea acceso solicitando
adquirir el <em>lock</em> del mutex. El lock es una estructura de datos que forma
parte del mutex que realiza un seguimiento de qui√©n tiene actualmente acceso
exclusivo a los datos. Por lo tanto, el mutex se describe como <em>guardando</em> los
datos que contiene a trav√©s del sistema de bloqueo.</p>
<p>Los Mutexes tienen la reputaci√≥n de ser dif√≠ciles de usar porque debes
recordar dos reglas:</p>
<ul>
<li>Debes intentar adquirir el bloqueo antes de utilizar los datos.</li>
<li>Cuando hayas terminado con los datos que protege el mutex, debes desbloquear
los datos para que otros hilos puedan adquirir el bloqueo.</li>
</ul>
<p>Para una met√°fora del mundo real para un mutex, imagina un panel de discusi√≥n
en una conferencia con un solo micr√≥fono. Antes de que un panelista pueda
hablar, debe preguntar o se√±alar que desea usar el micr√≥fono. Cuando obtienen
el micr√≥fono, pueden hablar todo el tiempo que quieran y luego entregar el
micr√≥fono al siguiente panelista que solicite hablar. Si un panelista olvida
entregar el micr√≥fono cuando haya terminado con √©l, nadie m√°s puede hablar. Si
la administraci√≥n del micr√≥fono compartido sale mal, ¬°el panel no funcionar√°
como estaba previsto!</p>
<p>La gesti√≥n de mutexes puede ser incre√≠blemente dif√≠cil de hacer bien, raz√≥n por
la cual tanta gente est√° entusiasmada con los canales. Sin embargo, gracias al
sistema de tipos y las reglas de ownership de Rust, no puedes bloquear y
desbloquear incorrectamente.</p>
<h4 id="la-api-de-mutext"><a class="header" href="#la-api-de-mutext">La API de <code>Mutex&lt;T&gt;</code></a></h4>
<p>Como un ejemplo de como usar un mutex, comencemos usando un mutex en un
contexto de un solo hilo, como se muestra en el Listado 16-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {m:?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 16-12: Explorando la API de <code>Mutex&lt;T&gt;</code> en un
contexto de un solo hilo para simplificar</span></p>
<p>Como con muchos tipos, creamos un <code>Mutex&lt;T&gt;</code> usando la funci√≥n asociada <code>new</code>.
Para acceder a los datos dentro del mutex, usamos el m√©todo <code>lock</code> para
adquirir el bloqueo. Esta llamada bloquear√° el hilo actual para que no pueda
hacer ning√∫n trabajo hasta que sea nuestro turno de tener el bloqueo.</p>
<p>La llamada a <code>lock</code> fallar√≠a si otro hilo que tiene el bloqueo se bloquea. En
ese caso, nadie nunca podr√≠a obtener el bloqueo, por lo que hemos elegido
<code>unwrap</code> y hacer que este hilo se bloquee si estamos en esa situaci√≥n.</p>
<p>Despu√©s de que hayamos adquirido el bloqueo, podemos tratar el valor de
retorno llamado <code>num</code> en este caso, como una referencia mutable a los datos
internos. El sistema de tipos garantiza que adquirimos un bloqueo antes de
usar el valor en <code>m</code>. El tipo de <code>m</code> es <code>Mutex&lt;i32&gt;</code>, no <code>i32</code>, por lo que
<em>debemos</em> llamar a <code>lock</code> para poder usar el valor <code>i32</code> interno. No podemos
olvidar; el sistema de tipos no nos permitir√° acceder al <code>i32</code> interno de
otra manera.</p>
<p>Como puedes sospechar, <code>Mutex&lt;T&gt;</code> es un smart pointer. M√°s precisamente, la
llamada a <code>lock</code> <em>devuelve</em> un smart pointer llamado <code>MutexGuard</code>, envuelto en
un <code>LockResult</code> que manejamos con la llamada a <code>unwrap</code>. El smart pointer
<code>MutexGuard</code> implementa <code>Deref</code> para apuntar a nuestros datos internos; el
smart pointer tambi√©n tiene una implementaci√≥n de <code>Drop</code> que libera el bloqueo
autom√°ticamente cuando un <code>MutexGuard</code> sale del scope, lo que sucede al final
del scope interno. Como resultado, no corremos el riesgo de olvidar liberar
el bloqueo y bloquear el mutex para que otros hilos no puedan usarlo, porque
la liberaci√≥n del bloqueo ocurre autom√°ticamente.</p>
<p>Despu√©s de eliminar el bloqueo, podemos imprimir el valor mutex y ver que
pudimos cambiar el valor interno <code>i32</code> a 6.</p>
<h4 id="compartir-un-mutext-entre-varios-hilos"><a class="header" href="#compartir-un-mutext-entre-varios-hilos">Compartir un <code>Mutex&lt;T&gt;</code> entre varios hilos</a></h4>
<p>Ahora, intentemos compartir un valor entre m√∫ltiples hilos usando <code>Mutex&lt;T&gt;</code>.
Activaremos 10 hilos y haremos que cada uno incremente un valor de contador en
1, por lo que el contador va de 0 a 10. El siguiente ejemplo en el Listado
16-13 tendr√° un error del compilador, y usaremos ese error para aprender m√°s
sobre el uso de <code>Mutex&lt;T&gt;</code> y c√≥mo Rust nos ayuda a usarlo correctamente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre>
<p><span class="caption">Listing 16-13: Diez hilos cada uno incrementa un contador
custodiado por un <code>Mutex&lt;T&gt;</code></span></p>
<p>Creamos una variable <code>counter</code> para contener un <code>i32</code> dentro de un <code>Mutex&lt;T&gt;</code>,
como hicimos en el Listado 16-12. A continuaci√≥n, creamos 10 hilos iterando
sobre un rango de n√∫meros. Usamos <code>thread::spawn</code> y damos a todos los hilos el
mismo closure: uno que mueve el contador al hilo, adquiere un bloqueo en el
<code>Mutex&lt;T&gt;</code> llamando al m√©todo <code>lock</code>, y luego agrega 1 al valor en el mutex.
Cuando un hilo termina de ejecutar su closure, <code>num</code> saldr√° del scope y
liberar√° el bloqueo para que otro hilo pueda adquirirlo.</p>
<p>En el hilo principal, recopilamos todos los identificadores de uni√≥n. Luego,
como hicimos en el Listado 16-2, llamamos a <code>join</code> en cada identificador para
asegurarnos de que todos los hilos terminen. En ese momento, el hilo principal
adquirir√° el bloqueo e imprimir√° el resultado de este programa.</p>
<p>Sugerimos que este ejemplo no se compilar√≠a ¬°Ahora descubramos por qu√©!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin &quot;shared-state&quot;) due to 1 previous error
</code></pre>
<p>El mensaje de error indica que el valor de <code>counter</code> se movi√≥ en la anterior
iteraci√≥n del bucle. El compilador nos est√° diciendo que no podemos mover la
propiedad de <code>counter</code> a m√∫ltiples hilos. Arreglemos el error del compilador
con un m√©todo de m√∫ltiples propietarios que discutimos en el Cap√≠tulo 15.</p>
<h4 id="ownership-multiple-con-m√∫ltiples-hilos"><a class="header" href="#ownership-multiple-con-m√∫ltiples-hilos">Ownership Multiple con m√∫ltiples hilos</a></h4>
<p>En el cap√≠tulo 15, le dimos a un valor m√∫ltiples due√±os al usar el
smart pointer <code>Rc&lt;T&gt;</code> para crear un valor de recuento de referencia.
Hagamos lo mismo aqu√≠ y veamos qu√© sucede. Envolveremos el <code>Mutex&lt;T&gt;</code> en
<code>Rc&lt;T&gt;</code> en el Listado 16-14 y clonaremos el <code>Rc&lt;T&gt;</code> antes de mover el
ownership al hilo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre>
<p><span class="caption">Listing 16-14: Intentando usar <code>Rc&lt;T&gt;</code> para permitir
m√∫ltiples hilos para poseer <code>Mutex&lt;T&gt;</code></span></p>
<p>Una vez m√°s, compilamos y obtenemos... ¬°diferentes errores! El compilador nos
est√° ense√±ando mucho.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:677:1

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin &quot;shared-state&quot;) due to 1 previous error
</code></pre>
<p>Wow, ¬°ese mensaje de error es muy extenso! Aqu√≠ est√° la parte importante en la
que debemos enfocarnos: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. El compilador tambi√©n nos est√° diciendo la raz√≥n por la que:
<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;` </code>. Hablaremos de
<code>Send</code> en la siguiente secci√≥n: es uno de los traits que asegura que los tipos
que usamos con hilos est√°n destinados a su uso en situaciones concurrentes.</p>
<p>Desafortunadamente, <code>Rc&lt;T&gt;</code> no es seguro para compartir entre hilos. Cuando
<code>Rc&lt;T&gt;</code> administra el recuento de referencia, agrega al recuento para cada
llamada a <code>clone</code> y resta del recuento cuando se descarta cada clon. Pero no
usa ning√∫n primitivo de concurrencia para asegurarse de que los cambios en el
recuento no puedan ser interrumpidos por otro hilo. Esto podr√≠a conducir a
recuentos incorrectos: errores sutiles que podr√≠an a su vez conducir a fugas
de memoria o que un valor se descarte antes de que hayamos terminado con √©l.
Lo que necesitamos es un tipo exactamente como <code>Rc&lt;T&gt;</code> pero que haga cambios en
el recuento de referencia de una manera segura para hilos.</p>
<h4 id="recuento-de-referencia-at√≥mico-con-arct"><a class="header" href="#recuento-de-referencia-at√≥mico-con-arct">Recuento de referencia at√≥mico con <code>Arc&lt;T&gt;</code></a></h4>
<p>Afortunadamente, <code>Arc&lt;T&gt;</code> <em>es</em> un tipo como <code>Rc&lt;T&gt;</code> que es seguro de usar en
situaciones concurrentes. La <em>a</em> significa <em>at√≥mico</em>, lo que significa que es
un tipo de recuento de referencia at√≥mico. Los √°tomos son un tipo adicional de
primitiva de concurrencia que no cubriremos en detalle aqu√≠: consulte la
documentaci√≥n de la biblioteca est√°ndar para <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a></p>
<!-- ignore --> para m√°s detalles. En este punto, solo necesita saber que los
<p>√Åtomos funcionan como tipos primitivos, pero son seguros para compartir entre
hilos.</p>
<p>Entonces podr√≠as preguntarte por qu√© todos los tipos primitivos no son at√≥micos
y por qu√© los tipos de biblioteca est√°ndar no se implementan para usar <code>Arc&lt;T&gt;</code>
de forma predeterminada. La raz√≥n es que la seguridad de los hilos conlleva una
penalizaci√≥n de rendimiento que solo desea pagar cuando realmente lo necesita.
Si solo est√° realizando operaciones en valores dentro de un solo hilo, su
c√≥digo puede ejecutarse m√°s r√°pido si no tiene que hacer cumplir las garant√≠as
que proporcionan los √°tomos.</p>
<p>Volvamos a nuestro ejemplo: <code>Arc&lt;T&gt;</code> y <code>Rc&lt;T&gt;</code> tienen la misma API, por lo que
arreglamos nuestro programa cambiando la l√≠nea <code>use</code>, la llamada a <code>new</code> y la
llamada a <code>clone</code>. El c√≥digo en el Listado 16-15 finalmente se compilar√° y
ejecutar√°:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Listing 16-15: Usando un <code>Arc&lt;T&gt;</code> para envolver <code>Mutex&lt;T&gt;</code>
para poder compartir el ownership a trav√©s de m√∫ltiples hilos</span></p>
<p>Este c√≥digo imprimir√° lo siguiente:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>¬°Lo hicimos! Contamos de 0 a 10, lo que puede no parecer muy impresionante,
pero nos ense√±√≥ mucho sobre <code>Mutex&lt;T&gt;</code> y la seguridad de los hilos. Tambi√©n
podr√≠a usar la estructura de este programa para realizar operaciones m√°s
complicadas que simplemente incrementar un contador. Usando esta estrategia,
puede dividir un c√°lculo en partes independientes, dividir esas partes en
hilos y luego usar un <code>Mutex&lt;T&gt;</code> para que cada hilo actualice el resultado
final con su parte.</p>
<p>Nota que si est√°s haciendo operaciones num√©ricas simples, hay tipos m√°s
simples que los tipos <code>Mutex&lt;T&gt;</code> proporcionados por el <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code>
m√≥dulo de la biblioteca est√°ndar</a><!-- ignore -->. Estos tipos
proporcionan acceso seguro y concurrente a tipos primitivos. Elegimos usar
<code>Mutex&lt;T&gt;</code> con un tipo primitivo para este ejemplo para que pudi√©ramos
concentrarnos en c√≥mo funciona <code>Mutex&lt;T&gt;</code>.</p>
<h3 id="similitudes-entre-refcelltrct-y-mutextarct"><a class="header" href="#similitudes-entre-refcelltrct-y-mutextarct">Similitudes entre <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> y <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>Es posible que hayas notado que <code>counter</code> es inmutable, pero podr√≠amos obtener
una referencia mutable al valor dentro de √©l; esto significa que <code>Mutex&lt;T&gt;</code>
proporciona mutabilidad interior, como lo hace la familia <code>Cell</code>. De la misma
manera que usamos <code>RefCell&lt;T&gt;</code> en el Cap√≠tulo 15 para permitirnos mutar
contenidos dentro de un <code>Rc&lt;T&gt;</code>, usamos <code>Mutex&lt;T&gt;</code> para mutar contenidos dentro
de un <code>Arc&lt;T&gt;</code>.</p>
<p>Un detalle a tener en cuenta es que Rust no puede protegerte de todos los 
errores l√≥gicos al usar <code>Mutex&lt;T&gt;</code>. Recuerda en el Cap√≠tulo 15 que usar <code>Rc&lt;T&gt;</code>
ven√≠a con el riesgo de crear ciclos de referencia, donde dos valores <code>Rc&lt;T&gt;</code>
se refieren entre s√≠, causando fugas de memoria. De manera similar, <code>Mutex&lt;T&gt;</code>
viene con el riesgo de crear <em>deadlocks</em>. Estos ocurren cuando una operaci√≥n
necesita bloquear dos recursos y dos hilos han adquirido cada uno de los
bloqueos, lo que los hace esperar el uno al otro para siempre. Si est√°
interesado en los deadlocks, intente crear un programa Rust que tenga un
deadlock; luego investigue las estrategias de mitigaci√≥n de deadlock para
mutexes en cualquier lenguaje y pruebe implementarlas en Rust. La documentaci√≥n 
de la API de la biblioteca est√°ndar para <code>Mutex&lt;T&gt;</code> y <code>MutexGuard</code> ofrece
informaci√≥n √∫til.</p>
<p>Terminaremos este cap√≠tulo hablando sobre los traits <code>Send</code> y <code>Sync</code> y c√≥mo
podemos usarlos con tipos personalizados.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrencia-extensible-con-los-traits-sync-y-send"><a class="header" href="#concurrencia-extensible-con-los-traits-sync-y-send">Concurrencia extensible con los traits <code>Sync</code> y <code>Send</code></a></h2>
<p>Curiosamente, el lenguaje Rust tiene <em>muy</em> pocas caracter√≠sticas de
concurrencia. Casi todas las caracter√≠sticas de concurrencia de las que hemos
hablado hasta ahora en este cap√≠tulo han sido parte de la biblioteca est√°ndar,
no del lenguaje. Sus opciones para manejar la concurrencia no se limitan al
lenguaje o a la biblioteca est√°ndar; puede escribir sus propias caracter√≠sticas
de concurrencia o usar las escritas por otros.</p>
<p>Sin embargo, dos conceptos de concurrencia est√°n integrados en el lenguaje: los
traits <code>Sync</code> y <code>Send</code> de <code>std::marker</code>.</p>
<h3 id="permitiendo-la-transferencia-de-ownership-entre-hilos-con-send"><a class="header" href="#permitiendo-la-transferencia-de-ownership-entre-hilos-con-send">Permitiendo la transferencia de Ownership entre hilos con <code>Send</code></a></h3>
<p>El trait <code>Send</code> indica que la propiedad de un valor se puede transferir entre
hilos. Casi todos los tipos son <code>Send</code>, con algunas excepciones notables, como
<code>Rc&lt;T&gt;</code>, que no es <code>Send</code> porque si clonara un valor de <code>Rc&lt;T&gt;</code> y tratara de
transferir la propiedad del clon a otro hilo, ambos hilos podr√≠an actualizar el
recuento de referencias al mismo tiempo. Por esta raz√≥n, <code>Rc&lt;T&gt;</code> est√°
implementado para su uso en situaciones de un solo hilo donde no desea pagar la
penalizaci√≥n de rendimiento segura para subprocesos.</p>
<p>Por lo tanto, el sistema de tipos y los l√≠mites de los traits de Rust garantizan
que nunca pueda enviar accidentalmente un valor <code>Rc&lt;T&gt;</code> a trav√©s de hilos de
forma insegura. Cuando intentamos hacer esto en el Listado 16-14, obtuvimos el
error <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. Cuando cambiamos a
<code>Arc&lt;T&gt;</code>, que es <code>Send</code>, el c√≥digo se compil√≥.</p>
<p>Cualquier tipo compuesto enteramente de tipos <code>Send</code> se marca autom√°ticamente
como <code>Send</code> tambi√©n. Casi todos los tipos primitivos son <code>Send</code>, aparte de los
punteros sin procesar, que discutiremos en el Cap√≠tulo 19.</p>
<h3 id="permitiendo-el-acceso-desde-m√∫ltiples-hilos-con-sync"><a class="header" href="#permitiendo-el-acceso-desde-m√∫ltiples-hilos-con-sync">Permitiendo el acceso desde m√∫ltiples hilos con <code>Sync</code></a></h3>
<p>El trait <code>Sync</code> indica que es seguro que el tipo que implementa <code>Sync</code> se
referencie desde m√∫ltiples hilos. En otras palabras, cualquier tipo <code>T</code> es
<code>Sync</code> si <code>&amp;T</code> (una referencia inmutable a <code>T</code>) es <code>Send</code>, lo que significa que
la referencia se puede enviar de forma segura a otro hilo. De manera similar a
<code>Send</code>, los tipos primitivos son <code>Sync</code>, y los tipos compuestos enteramente de
tipos que son <code>Sync</code> tambi√©n son <code>Sync</code>.</p>
<p>El smart pointer <code>Rc&lt;T&gt;</code> tampoco es <code>Sync</code> por las mismas razones por las que
no es <code>Send</code>. El tipo <code>RefCell&lt;T&gt;</code> (del que hablamos en el Cap√≠tulo 15) y la
familia de tipos relacionados <code>Cell&lt;T&gt;</code> no son <code>Sync</code>. La implementaci√≥n de la
comprobaci√≥n de pr√©stamos que hace <code>RefCell&lt;T&gt;</code> en tiempo de ejecuci√≥n no es
segura para subprocesos. El smart pointer <code>Mutex&lt;T&gt;</code> es <code>Sync</code> y se puede usar
para compartir el acceso con m√∫ltiples hilos como viste en la secci√≥n <a href="ch16-03-shared-state.html#compartir-un-mutext-entre-varios-hilos">‚ÄúCompartir
un <code>Mutex&lt;T&gt;</code> entre m√∫ltiples
hilos‚Äù</a><!-- ignore -->.</p>
<h3 id="implementar-send-y-sync-manualmente-es-inseguro"><a class="header" href="#implementar-send-y-sync-manualmente-es-inseguro">Implementar <code>Send</code> y <code>Sync</code> manualmente es inseguro</a></h3>
<p>Debido a que los tipos que est√°n compuestos de los traits <code>Send</code> y <code>Sync</code> se
automatizan tambi√©n <code>Send</code> y <code>Sync</code>, no tenemos que implementar esos traits
manualmente. Como marcadores de traits, ni siquiera tienen ning√∫n m√©todo para
implementar. Son √∫tiles para hacer cumplir invariantes relacionados con la
concurrencia.</p>
<p>Implementar manualmente estos traits implica implementar c√≥digo inseguro de
Rust. Hablaremos sobre el uso de c√≥digo inseguro de Rust en el Cap√≠tulo 19; por
ahora, la informaci√≥n importante es que la construcci√≥n de nuevos tipos
concurrentes que no est√°n compuestos de partes <code>Send</code> y <code>Sync</code> requiere un
pensamiento cuidadoso para mantener las garant√≠as de seguridad. <a href="https://doc.rust-lang.org/nomicon/index.html">‚ÄúThe
Rustonomicon‚Äù</a> tiene m√°s informaci√≥n sobre estas garant√≠as y c√≥mo
mantenerlas.</p>
<h2 id="resumen-15"><a class="header" href="#resumen-15">Resumen</a></h2>
<p>No es la √∫ltima vez que ver√°s la concurrencia en este libro: el proyecto del
Cap√≠tulo 20 usar√° los conceptos de este cap√≠tulo en una situaci√≥n m√°s realista
que los ejemplos m√°s peque√±os que se discuten aqu√≠.</p>
<p>Como se mencion√≥ anteriormente, debido a que muy poco de c√≥mo Rust maneja la
concurrencia es parte del lenguaje, muchas soluciones de concurrencia se
implementan como cajones. Estos evolucionan m√°s r√°pido que la biblioteca
est√°ndar, as√≠ que aseg√∫rese de buscar en l√≠nea las cajas actuales de √∫ltima
generaci√≥n para usar en situaciones de m√∫ltiples subprocesos.</p>
<p>La biblioteca est√°ndar de Rust proporciona canales para el paso de mensajes y
tipos de smart pointer, como <code>Mutex&lt;T&gt;</code> y <code>Arc&lt;T&gt;</code>, que son seguros de usar en
contextos concurrentes. El sistema de tipos y el borrow checker garantizan que
el c√≥digo que usa estas soluciones no terminar√° con carreras de datos o
referencias no v√°lidas. Una vez que haya compilado su c√≥digo, puede estar
seguro de que se ejecutar√° felizmente en m√∫ltiples hilos sin los tipos de
errores dif√≠ciles de rastrear comunes en otros lenguajes. La programaci√≥n
concurrente ya no es un concepto del que tener miedo: ¬°adelante y haga que sus
programas sean concurrentes, sin miedo!</p>
<p>A continuaci√≥n, hablaremos sobre las formas idiom√°ticas de modelar problemas y
estructurar soluciones a medida que sus programas Rust se vuelven m√°s grandes.
Adem√°s, discutiremos c√≥mo los ideales de Rust se relacionan con los que
puede estar familiarizado con la programaci√≥n orientada a objetos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-como-un-lenguaje-de-programaci√≥n-orientado-a-objetos"><a class="header" href="#rust-como-un-lenguaje-de-programaci√≥n-orientado-a-objetos">Rust como un Lenguaje de Programaci√≥n Orientado a Objetos</a></h1>
<p>La programaci√≥n orientada a objetos (POO) es una forma de modelar programas. Los
objetos como concepto program√°tico fueron introducidos en el lenguaje de
programaci√≥n Simula en la d√©cada de 1960. Esos objetos influyeron en la
arquitectura de programaci√≥n de Alan Kay en la que los objetos se env√≠an
mensajes entre s√≠. Para describir esta arquitectura, acu√±√≥ el t√©rmino
<em>programaci√≥n orientada a objetos</em> en 1967. Muchas definiciones en competencia
describen lo que es POO, y por algunas de estas definiciones Rust es
orientado a objetos, pero por otras no lo es. En este cap√≠tulo, exploraremos
ciertas caracter√≠sticas que com√∫nmente se consideran orientadas a objetos y c√≥mo
esas caracter√≠sticas se traducen a Rust idiom√°tico. Luego le mostraremos c√≥mo
implementar un patr√≥n de dise√±o orientado a objetos en Rust y discutiremos los
compromisos de hacerlo en lugar de implementar una soluci√≥n utilizando algunas
de las fortalezas de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="caracter√≠sticas-de-lenguajes-orientados-a-objetos"><a class="header" href="#caracter√≠sticas-de-lenguajes-orientados-a-objetos">Caracter√≠sticas de lenguajes orientados a objetos</a></h2>
<p>No hay consenso en la comunidad de programaci√≥n sobre qu√© caracter√≠sticas debe
tener un lenguaje para ser considerado orientado a objetos. Rust est√°
influenciado por muchos paradigmas de programaci√≥n, incluido OOP; por ejemplo,
exploramos las caracter√≠sticas que provienen de la programaci√≥n funcional en el
Cap√≠tulo 13. Es discutible que los lenguajes OOP compartan ciertas
caracter√≠sticas comunes, a saber, objetos, encapsulaci√≥n y herencia. Veamos qu√©
significa cada una de esas caracter√≠sticas y si Rust la admite.</p>
<h3 id="los-objetos-contienen-datos-y-comportamiento"><a class="header" href="#los-objetos-contienen-datos-y-comportamiento">Los objetos contienen datos y comportamiento</a></h3>
<p>El libro <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> de
Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides (Addison-Wesley
Professional, 1994), coloquialmente conocido como el libro <em>Gang of Four</em>, es un
cat√°logo de patrones de dise√±o orientados a objetos. Define OOP de esta manera:</p>
<blockquote>
<p>Los programas orientados a objetos est√°n compuestos por objetos. Un <em>objeto</em>
empaqueta tanto datos como los procedimientos que operan en esos datos. Los
procedimientos se denominan t√≠picamente <em>m√©todos</em> u <em>operaciones</em>.</p>
</blockquote>
<p>Usando esta definici√≥n, Rust es orientado a objetos: los structs y los
enums tienen datos, y los bloques <code>impl</code> proporcionan m√©todos en structs y
enums. Aunque los structs y los enums con m√©todos no se llaman objetos,
proporcionan la misma funcionalidad, seg√∫n la definici√≥n de objetos del
Gang of Four‚Äôs.</p>
<h3 id="encapsulacion-que-oculta-los-detalles-de-implementacion"><a class="header" href="#encapsulacion-que-oculta-los-detalles-de-implementacion">Encapsulacion que oculta los detalles de implementacion</a></h3>
<p>Otro aspecto com√∫nmente asociado con OOP es la idea de <em>encapsulaci√≥n</em>, que
significa que los detalles de implementaci√≥n de un objeto no son accesibles al
c√≥digo que usa ese objeto. Por lo tanto, la √∫nica forma de interactuar con un
objeto es a trav√©s de su API p√∫blica; el c√≥digo que usa el objeto no deber√≠a
poder acceder a los detalles internos del objeto y cambiar los datos o el
comportamiento directamente. Esto permite al programador cambiar y refactorizar
los detalles internos de un objeto sin necesidad de cambiar el c√≥digo que usa
el objeto.</p>
<p>Hemos discutido c√≥mo controlar la encapsulaci√≥n en el Cap√≠tulo 7: podemos usar
la palabra clave <code>pub</code> para decidir qu√© m√≥dulos, tipos, funciones y m√©todos en
nuestro c√≥digo deben ser p√∫blicos, y por defecto todo lo dem√°s es privado. Por
ejemplo, podemos definir un struct <code>AveragedCollection</code> que tiene un campo que
contiene un vector de valores <code>i32</code>. El struct tambi√©n puede tener un campo que
contiene el promedio de los valores en el vector, lo que significa que el
promedio no tiene que calcularse a pedido cada vez que alguien lo necesite. En
otras palabras, <code>AveragedCollection</code> almacenar√° en cach√© el promedio calculado
para nosotros. El Listado 17-1 tiene la definici√≥n del struct
<code>AveragedCollection</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
<p><span class="caption">Listing 17-1: Un struct <code>AveragedCollection</code> que
mantiene una lista de enteros y el promedio de los elementos en la colecci√≥n
</span></p>
<p>El struct est√° marcado como <code>pub</code> para que otro c√≥digo pueda usarlo, pero los
campos dentro del struct permanecen privados. Esto es importante en este caso
porque queremos asegurarnos de que cada vez que se agrega o elimina un valor de
la lista, el promedio tambi√©n se actualiza. Hacemos esto implementando los
m√©todos p√∫blicos <code>add</code>, <code>remove</code> y <code>average</code> en el struct, como se muestra en
el Listado 17-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
<p><span class="caption">Listing 17-2: Implementaciones de los m√©todos p√∫blicos
<code>add</code>, <code>remove</code>, y <code>average</code> en <code>AveragedCollection</code></span></p>
<p>Los m√©todos p√∫blicos <code>add</code>, <code>remove</code>, y <code>average</code> son las √∫nicas formas de
acceder o modificar los datos en una instancia de <code>AveragedCollection</code>. Cuando
se agrega un elemento a <code>list</code> usando el m√©todo <code>add</code> o se elimina usando el
m√©todo <code>remove</code>, las implementaciones de cada uno llaman al m√©todo privado
<code>update_average</code> que maneja la actualizaci√≥n del campo <code>average</code> tambi√©n.</p>
<p>Dejamos los campos <code>list</code> y <code>average</code> privados para que no haya forma de que el
c√≥digo externo agregue o elimine elementos de <code>list</code> directamente; de lo
contrario, el campo <code>average</code> podr√≠a quedar fuera de sincronizaci√≥n cuando
<code>list</code> cambia. El m√©todo <code>average</code> devuelve el valor en el campo <code>average</code>,
permitiendo que el c√≥digo externo lea el <code>average</code> pero no lo modifique.</p>
<p>Debido a que hemos encapsulado la implementaci√≥n de <code>AveragedCollection</code>, podemos
cambiar f√°cilmente los aspectos, como la estructura de datos, en el futuro. Por
ejemplo, podr√≠amos usar un <code>HashSet&lt;i32&gt;</code> en lugar de un <code>Vec&lt;i32&gt;</code> para el
campo <code>list</code>. Mientras las firmas de los m√©todos p√∫blicos <code>add</code>, <code>remove</code>, y
<code>average</code> permanezcan iguales, el c√≥digo que usa <code>AveragedCollection</code> no
necesitar√≠a cambiar para compilar. Si hicimos <code>list</code> p√∫blica en su lugar, esto 
no ser√≠a necesariamente cierto: <code>HashSet&lt;i32&gt;</code> y <code>Vec&lt;i32&gt;</code> tienen diferentes 
m√©todos para agregar y eliminar elementos, por lo que el c√≥digo externo 
probablemente tendr√≠a que cambiar si estuviera modificando <code>list</code> directamente.</p>
<p>Si la encapsulaci√≥n es un aspecto requerido para que un lenguaje se considere
orientado a objetos, entonces Rust cumple con ese requisito. La opci√≥n de usar
<code>pub</code> o no para diferentes partes del c√≥digo permite la encapsulaci√≥n de los
detalles de implementaci√≥n.</p>
<h3 id="herencia-como-un-sistema-de-tipos-y-como-code-sharing"><a class="header" href="#herencia-como-un-sistema-de-tipos-y-como-code-sharing">Herencia como un sistema de tipos y como Code Sharing</a></h3>
<p><em>Herencia</em> es un mecanismo mediante el cual un objeto puede heredar elementos de
la definici√≥n de otro objeto, obteniendo as√≠ los datos y el comportamiento del
objeto padre sin tener que definirlos nuevamente.</p>
<p>Si se considera que un lenguaje debe tener herencia para ser un lenguaje
orientado a objetos, entonces Rust no cumple con esta definici√≥n. No existe
una forma de definir un struct que herede los campos y las implementaciones de
m√©todos de un struct padre sin usar una macro.</p>
<p>Sin embargo, si est√°s acostumbrado a tener la herencia en tu caja de
programaci√≥n, puedes usar otras soluciones en Rust, dependiendo de tu raz√≥n
para recurrir a la herencia en primer lugar.</p>
<p>Elegir√≠as la herencia por dos razones principales. Una es reutilizar el c√≥digo:
puedes implementar un comportamiento particular para un tipo, y la herencia te
permite reutilizar esa implementaci√≥n para un tipo diferente. Puedes hacer esto
de una manera limitada en el c√≥digo Rust usando implementaciones de m√©todos
predeterminados de un trait, que viste en el Listado 10-14 cuando agregamos una
implementaci√≥n predeterminada del m√©todo <code>summarize</code> en el trait <code>Summary</code>.
Cualquier tipo que implemente el trait <code>Summary</code> tendr√≠a el m√©todo <code>summarize</code>
disponible sin ning√∫n c√≥digo adicional. Esto es similar a una clase padre que
tiene una implementaci√≥n de un m√©todo y una clase hija heredada que tambi√©n
tiene la implementaci√≥n del m√©todo. Tambi√©n podemos anular la implementaci√≥n
predeterminada del m√©todo <code>summarize</code> cuando implementamos el trait <code>Summary</code>,
lo que es similar a una clase hija anulando la implementaci√≥n de un m√©todo
heredado de una clase padre.</p>
<p>La otra raz√≥n para usar la herencia est√° relacionada con el sistema de tipos:
permitir que un tipo hijo se use en los mismos lugares que el tipo padre. Esto
es tambi√©n llamado <em>polimorfismo</em>, lo que significa que puedes sustituir
m√∫ltiples objetos entre s√≠ en tiempo de ejecuci√≥n si comparten ciertas
caracter√≠sticas.</p>
<blockquote>
<h3 id="polimorfismo"><a class="header" href="#polimorfismo">Polimorfismo</a></h3>
<p>Para muchas personas, el polimorfismo es sin√≥nimo de herencia. Pero en
realidad es un concepto m√°s general que se refiere al c√≥digo que puede
trabajar con datos de m√∫ltiples tipos. Para la herencia, esos tipos son
generalmente subclases.</p>
<p>En cambio, Rust utiliza generics para abstraerse sobre diferentes tipos
posibles y los trait bounds para imponer restricciones sobre lo que
esos tipos deben proporcionar. Esto se llama a veces <em>polimorfismo param√©trico
acotado</em>.</p>
</blockquote>
<p>En los √∫ltimos tiempos, la herencia ha perdido popularidad como soluci√≥n de
dise√±o de programas en muchos lenguajes de programaci√≥n porque a menudo est√° en
riesgo de compartir m√°s c√≥digo del necesario. Las subclases no siempre deben
compartir todas las caracter√≠sticas de su clase padre, pero lo har√°n con la
herencia. Esto puede hacer que el dise√±o de un programa sea menos flexible.
Tambi√©n introduce la posibilidad de llamar a m√©todos en subclases que no tienen
sentido o que causan errores porque los m√©todos no se aplican a la subclase.
Adem√°s, algunos lenguajes solo permitir√°n una herencia √∫nica (lo que significa
que una subclase solo puede heredar de una clase), lo que restringe a√∫n m√°s la
flexibilidad del dise√±o de un programa.</p>
<p>Por estas razones, Rust toma un enfoque diferente utilizando trait objects en
lugar de herencia. Veamos c√≥mo los trait objects permiten el polimorfismo en
Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-trait-objects-que-permiten-valores-de-diferentes-tipos"><a class="header" href="#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">Usando Trait Objects que permiten valores de diferentes tipos</a></h2>
<p>En el cap√≠tulo 8, mencionamos que una limitaci√≥n de los vectores es que pueden
almacenar elementos de un solo tipo. Creamos una soluci√≥n en el Listado 8-9
donde definimos un enum <code>SpreadsheetCell</code> que ten√≠a variantes para almacenar
enteros, flotantes y texto. Esto significaba que pod√≠amos almacenar diferentes
tipos de datos en cada celda y aun as√≠ tener un vector que representara una
fila de celdas. Esta es una soluci√≥n perfectamente buena cuando nuestros
elementos intercambiables son un conjunto fijo de tipos que conocemos cuando
se compila nuestro c√≥digo.</p>
<p>Sin embargo, a veces queremos que los usuarios de nuestra biblioteca puedan
ampliar el conjunto de tipos que pueden almacenar en una estructura de datos.
Para mostrar c√≥mo podr√≠amos lograr esto, crearemos una herramienta de
interfaz gr√°fica de usuario (GUI) de ejemplo que itera a trav√©s de una lista
de elementos, llamando a un m√©todo <code>draw</code> en cada uno para dibujarlo en la
pantalla, una t√©cnica com√∫n para las herramientas de GUI. Crearemos una
caja de biblioteca llamada <code>gui</code> que contiene la estructura de una biblioteca
GUI. Esta caja podr√≠a incluir algunos tipos para que las personas los usen,
como <code>Button</code> o <code>TextField</code>. Adem√°s, los usuarios de <code>gui</code> querr√°n crear sus
propios tipos que se puedan dibujar: por ejemplo, un programador podr√≠a
agregar una <code>Image</code> y otro podr√≠a agregar un <code>SelectBox</code>.</p>
<p>No implementaremos una biblioteca GUI completamente desarrollada para este
ejemplo, pero mostraremos c√≥mo encajar√≠an las piezas. En el momento de
escribir la biblioteca, no podemos conocer y definir todos los tipos que
otros programadores podr√≠an querer crear. Pero s√≠ sabemos que <code>gui</code> necesita
hacer un seguimiento de muchos valores de diferentes tipos, y necesita llamar
a un m√©todo <code>draw</code> en cada uno de estos valores de diferentes tipos. No
necesita saber exactamente qu√© suceder√° cuando llamemos al m√©todo <code>draw</code>, solo
que el valor tendr√° ese m√©todo disponible para que lo llamemos.</p>
<p>Para hacer esto en un lenguaje con herencia, podr√≠amos definir una clase
llamada <code>Component</code> que tenga un m√©todo llamado <code>draw</code> en ella. Las otras
clases, como <code>Button</code>, <code>Image</code> y <code>SelectBox</code>, heredar√≠an de <code>Component</code> y,
por lo tanto, heredar√≠an el m√©todo <code>draw</code>. Cada uno podr√≠a anular el m√©todo
<code>draw</code> para definir su comportamiento personalizado, pero el marco podr√≠a
tratar todos los tipos como si fueran instancias de <code>Component</code> y llamar a
<code>draw</code> en ellos. Pero como Rust no tiene herencia, necesitamos otra forma de
estructurar la biblioteca <code>gui</code> para permitir a los usuarios extenderla con
nuevos tipos.</p>
<h3 id="definir-un-trait-para-un-comportamiento-com√∫n"><a class="header" href="#definir-un-trait-para-un-comportamiento-com√∫n">Definir un Trait para un comportamiento com√∫n</a></h3>
<p>Para implementar el comportamiento que queremos que tenga <code>gui</code>, definiremos
un trait llamado <code>Draw</code> que tendr√° un m√©todo llamado <code>draw</code>. Luego podemos
definir un vector que tome un <em>objeto de trait</em>. Un objeto de trait apunta
tanto a una instancia de un tipo que implementa nuestro trait especificado
como a una tabla utilizada para buscar m√©todos de trait en ese tipo en tiempo
de ejecuci√≥n. Creamos un objeto de trait especificando alg√∫n tipo de puntero,
como una referencia <code>&amp;</code> o un puntero inteligente <code>Box&lt;T&gt;</code>, luego la palabra
clave <code>dyn</code> y luego especificando el trait relevante. (Hablaremos sobre la
raz√≥n por la que los objetos de trait deben usar un puntero en el Cap√≠tulo 19
en la secci√≥n <a href="ch19-04-advanced-types.html#tipos-de-tamano-dinamico-y-el-trait-sized">‚ÄúTipos de tama√±o din√°mico y el
trait <code>Sized</code>.‚Äù</a><!-- ignore -->) Podemos usar objetos de
trait en lugar de un tipo gen√©rico o concreto. Donde sea que usemos un objeto
de trait, el sistema de tipos de Rust se asegurar√° en tiempo de compilaci√≥n que
cualquier valor utilizado en ese contexto implemente el trait del objeto de
trait. En consecuencia, no necesitamos conocer todos los tipos posibles en
tiempo de compilaci√≥n.</p>
<p>Hemos mencionado que, en Rust, nos abstenemos de llamar a los structs y enums
‚Äúobjetos‚Äù para distinguirlos de los objetos de otros lenguajes. En un struct o
enum, los datos en los campos del struct y el comportamiento en los bloques
<code>impl</code> est√°n separados, mientras que en otros lenguajes, los datos y el
comportamiento combinados en un solo concepto a menudo se etiquetan como un
objeto. Sin embargo, los objetos de trait son m√°s como objetos en otros
lenguajes en el sentido de que combinan datos y comportamiento. Pero los
objetos de trait difieren de los objetos tradicionales en que no podemos
agregar datos a un objeto de trait. Los objetos de trait no son tan √∫tiles en
general como los objetos en otros lenguajes: su prop√≥sito espec√≠fico es
permitir la abstracci√≥n a trav√©s del comportamiento com√∫n.</p>
<p>El Listado 17-3 muestra c√≥mo definir un trait llamado <code>Draw</code> con un m√©todo
llamado <code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
<p><span class="caption">Listing 17-3: Definici√≥n del trait <code>Draw</code></span></p>
<p>Esta sintaxis deber√≠a verse familiar de nuestras discusiones sobre c√≥mo
definir traits en el Cap√≠tulo 10. A continuaci√≥n viene una sintaxis nueva: el
Listado 17-4 define un struct llamado <code>Screen</code> que contiene un vector llamado
<code>components</code>. Este vector es de tipo <code>Box&lt;dyn Draw&gt;</code>, que es un objeto de
trait; es un sustituto de cualquier tipo dentro de una <code>Box</code> que implementa el
trait <code>Draw</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
<p><span class="caption">Listing 17-4: Definici√≥n del struct <code>Screen</code> con un campo
<code>components</code> que contiene un vector de trait objects que implementan el trait
<code>Draw</code></span></p>
<p>En el struct <code>Screen</code> hemos definido un m√©todo llamado <code>run</code> que llamar√° al
m√©todo <code>draw</code> en cada uno de sus <code>components</code>, como se muestra en el Listado
17-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-5: Un m√©todo <code>run</code> en <code>Screen</code> que llama al
m√©todo <code>draw</code> en cada componente</span></p>
<p>Esto funciona de manera diferente a la definici√≥n de un struct que usa un
par√°metro de tipo generic con trait bound. Un par√°metro de tipo generic
solo se puede sustituir con un tipo concreto a la vez, mientras que los
trait objects permiten que varios tipos concretos llenen el trait object
en tiempo de ejecuci√≥n. Por ejemplo, podr√≠amos haber definido el struct
<code>Screen</code> usando un par√°metro de tipo generic y un trait bound como en el
Listado 17-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-6: Una implementaci√≥n alternativa del struct
<code>Screen</code> y su m√©todo <code>run</code> usando generics y trait bounds</span></p>
<p>Esto nos restringe a una instancia de <code>Screen</code> que tiene una lista de
componentes de tipo <code>Button</code> o de tipo <code>TextField</code>. Si solo tendr√°
colecciones homog√©neas, usar generics y trait bounds es preferible porque las
definiciones se monomorfizar√°n en tiempo de compilaci√≥n para usar los tipos
concretos.</p>
<p>Por otro lado, con el m√©todo que utiliza trait objects, una instancia de
<code>Screen</code> puede contener un <code>Vec&lt;T&gt;</code> que contiene una <code>Box&lt;Button&gt;</code> as√≠ como
una <code>Box&lt;TextField&gt;</code>. Veamos c√≥mo funciona esto, y luego hablaremos sobre las
implicaciones de rendimiento en tiempo de ejecuci√≥n.</p>
<h3 id="implementando-el-trait"><a class="header" href="#implementando-el-trait">Implementando el trait</a></h3>
<p>Ahora agregaremos algunos tipos que implementen el trait <code>Draw</code>.
Proporcionaremos el tipo <code>Button</code>. Nuevamente, implementar una biblioteca GUI
est√° m√°s all√° del alcance de este libro, por lo que el m√©todo <code>draw</code> no tendr√°
ninguna implementaci√≥n √∫til en su cuerpo. Para imaginar c√≥mo podr√≠a ser la
implementaci√≥n, un struct <code>Button</code> podr√≠a tener campos para <code>width</code>, <code>height</code>
y <code>label</code>, como se muestra en el Listado 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}</code></pre>
<p><span class="caption">Listing 17-7: Un <code>Button</code> que implementa el trait
<code>Draw</code></span></p>
<p>Los campos <code>width</code>, <code>height</code> y <code>label</code> en <code>Button</code> ser√°n diferentes de los
campos en otros componentes; por ejemplo, un tipo <code>TextField</code> podr√≠a tener
esos mismos campos m√°s un campo <code>placeholder</code>. Cada uno de los tipos que
queremos dibujar en la pantalla implementar√° el trait <code>Draw</code> pero usar√°
c√≥digo diferente en el m√©todo <code>draw</code> para definir c√≥mo dibujar ese tipo
particular, como lo hace <code>Button</code> aqu√≠ (sin el c√≥digo GUI real, como se
mencion√≥). El tipo <code>Button</code>, por ejemplo, podr√≠a tener un bloque <code>impl</code>
adicional que contenga m√©todos relacionados con lo que sucede cuando un
usuario hace clic en el bot√≥n. Este tipo de m√©todos no se aplicar√°n a tipos
como <code>TextField</code>.</p>
<p>Si alguien que utiliza nuestra biblioteca decide implementar un struct
<code>SelectBox</code> que tiene campos <code>width</code>, <code>height</code> y <code>options</code>, tambi√©n
implementar√° el trait <code>Draw</code> en el tipo <code>SelectBox</code>, como se muestra en el
Listado 17-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Listing 17-8: Otro crate usando <code>gui</code> e implementando
el trait <code>Draw</code> en un struct <code>SelectBox</code></span></p>
<p>El usuario de nuestra biblioteca ahora puede escribir su funci√≥n <code>main</code> para
crear una instancia de <code>Screen</code>. A la instancia de <code>Screen</code>, pueden agregar
un <code>SelectBox</code> y un <code>Button</code> colocando cada uno en una <code>Box&lt;T&gt;</code> para
convertirse en un trait object. Luego pueden llamar al m√©todo <code>run</code> en la
instancia de <code>Screen</code>, que llamar√° a <code>draw</code> en cada uno de los componentes.
El Listado 17-9 muestra esta implementaci√≥n:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Listing 17-9: Usando trait objects para almacenar valores
de diferentes tipos que implementan el mismo trait</span></p>
<p>Cuando escribimos la biblioteca, no sab√≠amos que alguien podr√≠a agregar el tipo
<code>SelectBox</code>, pero nuestra implementaci√≥n de <code>Screen</code> pudo operar en el nuevo
tipo y dibujarlo porque <code>SelectBox</code> implementa el trait <code>Draw</code>, lo que significa
que implementa el m√©todo <code>draw</code>.</p>
<p>Este concepto, de preocuparnos solo por los mensajes a los que responde un valor
en lugar del tipo concreto del valor, es similar al concepto de <em>duck typing</em> en
lenguajes de tipado din√°mico: si camina como un pato y grazna como un pato,
¬°entonces debe ser un pato! En la implementaci√≥n de <code>run</code> en <code>Screen</code> en el
Listado 17-5, <code>run</code> no necesita saber cu√°l es el tipo concreto de cada
componente. No verifica si un componente es una instancia de un <code>Button</code> o de
un <code>SelectBox</code>, simplemente llama al m√©todo <code>draw</code> en el componente. Al
especificar <code>Box&lt;dyn Draw&gt;</code> como el tipo de los valores en el vector
<code>components</code>, hemos definido que <code>Screen</code> necesita valores a los que podamos
llamar el m√©todo <code>draw</code>.</p>
<p>La ventaja de utilizar trait objects y el sistema de tipos de Rust para escribir
c√≥digo similar al c√≥digo que utiliza duck typing es que nunca tenemos que
verificar si un valor implementa un m√©todo en particular en tiempo de ejecuci√≥n
o preocuparnos por obtener errores si un valor no implementa un m√©todo, pero lo
llamamos de todos modos. Rust no compilar√° nuestro c√≥digo si los valores no
implementan los traits que necesitan los trait objects.</p>
<p>Por ejemplo, el Listado 17-10 muestra lo que sucede si intentamos crear una
<code>Screen</code> con un <code>String</code> como componente:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;Hi&quot;))],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Listing 17-10: Intentando utilizar un tipo que no
implementa the trait del trait object</span></p>
<p>Obtendremos este error porque <code>String</code> no implementa el trait <code>Draw</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;Hi&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin &quot;gui&quot;) due to 1 previous error
</code></pre>
<p>Este error nos indica que o bien estamos pasando algo a <code>Screen</code> que no
quer√≠amos pasar y, por lo tanto, deber√≠amos pasar un tipo diferente o deber√≠amos
implementar <code>Draw</code> en <code>String</code> para que <code>Screen</code> pueda llamar a <code>draw</code> en √©l.</p>
<h3 id="los-trait-objects-realizan-dynamic-dispatch"><a class="header" href="#los-trait-objects-realizan-dynamic-dispatch">Los trait objects realizan <em>dynamic dispatch</em></a></h3>
<p>Recuerda que en la secci√≥n <a href="ch10-01-syntax.html#rendimiento-de-codigo-usando-genericos">‚ÄúPerformance of Code Using
Generics‚Äù</a><!-- ignore --> del Cap√≠tulo 10
hablamos sobre el proceso de monomorfizaci√≥n que realiza el compilador cuando
usamos <em>trait bounds</em> en los gen√©ricos: el compilador genera implementaciones
no gen√©ricas de funciones y m√©todos para cada tipo concreto que usamos en lugar
de un par√°metro de tipo gen√©rico. El c√≥digo que resulta de la monomorfizaci√≥n
est√° realizando <em>static dispatch</em>, que es cuando el compilador sabe qu√© m√©todo
est√°s llamando en tiempo de compilaci√≥n. Esto se opone al <em>dynamic dispatch</em>,
que es cuando el compilador no puede decir en tiempo de compilaci√≥n qu√© m√©todo
est√°s llamando. En los casos de dynamic dispatch, el compilador emite c√≥digo que
en tiempo de ejecuci√≥n determinar√° qu√© m√©todo llamar.</p>
<p>Cuando usamos trait objects, Rust debe usar dynamic dispatch. El compilador no
conoce todos los tipos que podr√≠an usarse con el c√≥digo que est√° llamando a
trait objects, por lo que no sabe qu√© m√©todo implementado en qu√© tipo llamar. En
cambio, en tiempo de ejecuci√≥n, Rust usa los punteros dentro del trait object
para saber qu√© m√©todo llamar. Esta b√∫squeda incurre en un costo de tiempo de
ejecuci√≥n que no ocurre con el static dispatch. Dynamic dispatch tambi√©n evita
que el compilador elija la opci√≥n de <em>inline</em> del c√≥digo de un m√©todo, lo que a
su vez evita algunas optimizaciones. Sin embargo, obtuvimos flexibilidad
adicional en el c√≥digo que escribimos en el Listado 17-5 y pudimos admitir en
el Listado 17-9, por lo que es un compromiso a considerar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implementando-un-patr√≥n-de-dise√±o-orientado-a-objetos"><a class="header" href="#implementando-un-patr√≥n-de-dise√±o-orientado-a-objetos">Implementando un patr√≥n de dise√±o orientado a objetos</a></h2>
<p>El <em>state pattern</em> es un patr√≥n de dise√±o orientado a objetos. La esencia del
patr√≥n es que definimos un conjunto de estados que un valor puede tener
internamente. Los estados est√°n representados por un conjunto de <em>state
objects</em>, y el comportamiento del valor cambia seg√∫n su estado. Vamos a
trabajar a trav√©s de un ejemplo de un struct de publicaci√≥n de blog que
tiene un campo para mantener su estado, que ser√° un state object del conjunto
&quot;borrador&quot;, &quot;revisi√≥n&quot; o &quot;publicado&quot;.</p>
<p>Los state objects comparten funcionalidad: en Rust, por supuesto, usamos
structs y traits en lugar de objetos y herencia. Cada state object es
responsable de su propio comportamiento y de gobernar cu√°ndo debe cambiar a
otro estado. El valor que contiene un state object no sabe nada sobre el
comportamiento diferente de los estados o cu√°ndo hacer la transici√≥n entre
estados.</p>
<p>La ventaja de usar el state pattern es que, cuando los requisitos comerciales
del programa cambian, no necesitaremos cambiar el c√≥digo del valor que
contiene el estado o el c√≥digo que usa el valor. Solo necesitaremos actualizar
el c√≥digo dentro de uno de los state objects para cambiar sus reglas o quiz√°s
agregar m√°s state objects.</p>
<p>Primero, vamos a implementar el state pattern de una manera m√°s tradicional
orientada a objetos, luego usaremos un enfoque que es un poco m√°s natural en
Rust. Vamos a profundizar en la implementaci√≥n incremental de un flujo de
trabajo de publicaci√≥n de blog usando el state pattern.</p>
<p>La funcionalidad final se ver√° as√≠:</p>
<ol>
<li>Un post de blog que comienza como un borrador vac√≠o.</li>
<li>Cuando se completa el borrador, se solicita una revisi√≥n de la publicaci√≥n.</li>
<li>Cuando se aprueba la publicaci√≥n, se publica.</li>
<li>Solo las publicaciones de blog publicadas devuelven contenido para imprimir,
por lo que las publicaciones no aprobadas no pueden publicarse
accidentalmente.</li>
</ol>
<p>Cualquier otro cambio que se intente realizar en una publicaci√≥n no deber√≠a
tener ning√∫n efecto. Por ejemplo, si intentamos aprobar un borrador de blog
antes de haber solicitado una revisi√≥n, la publicaci√≥n deber√≠a seguir siendo
un borrador no publicado.</p>
<p>El Listado 17-11 muestra este flujo de trabajo en forma de c√≥digo: este es un
ejemplo de uso de la API que implementaremos en una crate de biblioteca
llamada <code>blog</code>. Esto a√∫n no se compilar√° porque no hemos implementado el crate
de biblioteca <code>blog</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}</code></pre>
<p><span class="caption">Listing 17-11: C√≥digo que demuestra el comportamiento
deseado que queremos que tenga nuestro crate <code>blog</code></span></p>
<p>Queremos permitir que el usuario cree una nueva publicaci√≥n de blog en borrador
con <code>Post::new</code>. Queremos permitir que se agregue texto a la publicaci√≥n del
blog. Si intentamos obtener el contenido de la publicaci√≥n inmediatamente,
antes de la aprobaci√≥n, no deber√≠amos obtener ning√∫n texto porque la publicaci√≥n
sigue siendo un borrador. Hemos agregado <code>assert_eq!</code> en el c√≥digo con fines de
demostraci√≥n. Una excelente prueba unitaria para esto ser√≠a afirmar que una
publicaci√≥n de blog en borrador devuelve un string vac√≠o del m√©todo <code>content</code>,
pero no vamos a escribir pruebas para este ejemplo.</p>
<p>A continuaci√≥n, queremos permitir una solicitud de revisi√≥n de la publicaci√≥n
y queremos que <code>content</code> devuelva un string vac√≠o mientras espera la revisi√≥n.
Cuando la publicaci√≥n reciba la aprobaci√≥n, deber√≠a publicarse, lo que significa
que el texto de la publicaci√≥n se devolver√° cuando se llame a <code>content</code>.</p>
<p>Observa que el √∫nico tipo con el que estamos interactuando desde el crate es
el tipo <code>Post</code>. Este tipo utilizar√° el state pattern y contendr√° un valor que
ser√° uno de los tres state objects que representan los diversos estados
en los que puede estar una publicaci√≥n: borrador, esperando revisi√≥n o
publicado. El cambio de un estado a otro se administrar√° internamente dentro
del tipo <code>Post</code>. Los estados cambian en respuesta a los m√©todos llamados por
los usuarios de nuestra biblioteca en la instancia <code>Post</code>, pero no tienen que
administrar los cambios de estado directamente. Adem√°s, los usuarios no pueden
cometer un error con los estados, como publicar una publicaci√≥n antes de que
se revise.</p>
<h3 id="definiendo-post-y-creando-una-nueva-instancia-en-el-estado-de-borrador"><a class="header" href="#definiendo-post-y-creando-una-nueva-instancia-en-el-estado-de-borrador">Definiendo <code>Post</code> y creando una nueva instancia en el estado de borrador</a></h3>
<p>¬°Comencemos con la implementaci√≥n de la biblioteca! Sabemos que necesitamos
un struct <code>Post</code> p√∫blico que contenga alg√∫n contenido, por lo que comenzaremos
con la definici√≥n del struct y una funci√≥n p√∫blica <code>new</code> asociada para crear
una instancia de <code>Post</code>, como se muestra en el Listado 17-12. Tambi√©n haremos
un trait privado <code>State</code> que definir√° el comportamiento que todos los objetos
de estado para un <code>Post</code> deben tener.</p>
<p>Luego, <code>Post</code> contendr√° un trait object de <code>Box&lt;dyn State&gt;</code> dentro de un campo
privado llamado <code>state</code> para mantener el state object. Ver√°s por qu√©
<code>Option&lt;T&gt;</code> es necesario en un momento.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<p><span class="caption">Listing 17-12: Definici√≥n de un struct <code>Post</code> y una
funci√≥n <code>new</code> que crea una nueva instancia de <code>Post</code>, un trait <code>State</code>, y un
struct <code>Draft</code></span></p>
<p>El trait <code>State</code> define el comportamiento compartido por los diferentes estados
de una publicaci√≥n. Los state objects son <code>Draft</code>, <code>PendingReview</code> y
<code>Published</code>, y todos implementar√°n el trait <code>State</code>. Por ahora, el trait no
tiene ning√∫n m√©todo, y comenzaremos definiendo solo el estado <code>Draft</code> porque
ese es el estado en el que queremos que comience una publicaci√≥n.</p>
<p>Cuando creamos un nuevo <code>Post</code>, estableceremos su campo <code>state</code> como un valor
<code>Some</code> que contiene un <code>Box</code> que apunta a una nueva instancia del struct
<code>Draft</code>. Esto asegura que cada vez que creemos una nueva instancia de <code>Post</code>,
comenzar√° como un borrador. Debido a que el campo <code>state</code> de <code>Post</code> es privado,
¬°no hay forma de crear un <code>Post</code> en ning√∫n otro estado! En la funci√≥n
<code>Post::new</code>, establecemos el campo <code>content</code> en un nuevo <code>String</code> vac√≠o.</p>
<h3 id="almacenando-el-texto-del-contenido-del-post"><a class="header" href="#almacenando-el-texto-del-contenido-del-post">Almacenando el texto del contenido del post</a></h3>
<p>Vimos en el Listado 17-11 que queremos poder llamar a un m√©todo llamado
<code>add_text</code> y pasarle un <code>&amp;str</code> que luego se agregar√° como el contenido de texto
de la publicaci√≥n del blog. Implementaremos esto como un m√©todo, en lugar de
exponer el campo <code>content</code> como <code>pub</code>, para que m√°s tarde podamos implementar
un m√©todo que controlar√° c√≥mo se lee el campo <code>content</code>. El m√©todo <code>add_text</code>
es bastante sencillo, as√≠ que agreguemos la implementaci√≥n en el Listado 17-13
al bloque <code>impl Post</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Listing 17-13: Implementando el m√©todo <code>add_text</code> para
agregar texto al campo <code>content</code> de una publicaci√≥n</span></p>
<p>El m√©todo <code>add_text</code> toma una referencia mutable a <code>self</code> porque estamos
cambiando la instancia de <code>Post</code> en la que estamos llamando <code>add_text</code>. Luego
llamamos a <code>push_str</code> en el <code>String</code> en <code>content</code> y pasamos el argumento <code>text</code>
para agregar al <code>content</code> guardado. Este comportamiento no depende del estado
en el que se encuentre la publicaci√≥n, por lo que no es parte del state pattern.
El m√©todo <code>add_text</code> no interact√∫a con el campo <code>state</code> en absoluto, pero es
parte del comportamiento que queremos admitir.</p>
<h3 id="asegurando-que-el-contenido-de-un-post-en-borrador-est√©-vac√≠o"><a class="header" href="#asegurando-que-el-contenido-de-un-post-en-borrador-est√©-vac√≠o">Asegurando que el contenido de un post en borrador est√© vac√≠o</a></h3>
<p>Incluso despu√©s de que hayamos llamado <code>add_text</code> y agregado alg√∫n contenido a
nuestra publicaci√≥n, todav√≠a queremos que el m√©todo <code>content</code> devuelva un slice
de string vac√≠o porque la publicaci√≥n todav√≠a est√° en el estado de borrador,
como se muestra en la l√≠nea 7 del Listado 17-11. Por ahora, implementemos el
m√©todo <code>content</code> con lo m√°s simple que cumplir√° con este requisito: siempre
devolver un string slice vac√≠o. Lo cambiaremos m√°s tarde una vez que
implementemos la capacidad de cambiar el estado de una publicaci√≥n para que
pueda publicarse. Hasta ahora, las publicaciones solo pueden estar en el estado
de borrador, por lo que el contenido de la publicaci√≥n siempre debe estar
vac√≠o. El Listado 17-14 muestra esta implementaci√≥n de marcador de posici√≥n:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Listing 17-14: Agregando una implementaci√≥n provisional
para el m√©todo <code>content</code> en <code>Post</code> que siempre devuelve un string slice vac√≠o
</span></p>
<p>Con este m√©todo <code>content</code> a√±adido, todo en el Listado 17-11 hasta la l√≠nea 7
funciona como se pretend√≠a.</p>
<h3 id="solicitar-una-revisi√≥n-de-los-cambios-de-publicaci√≥n-de-su-estado"><a class="header" href="#solicitar-una-revisi√≥n-de-los-cambios-de-publicaci√≥n-de-su-estado">Solicitar una revisi√≥n de los cambios de publicaci√≥n de su estado</a></h3>
<p>A continuaci√≥n, necesitamos agregar funcionalidad para solicitar una revisi√≥n
de una publicaci√≥n, lo que deber√≠a cambiar su estado de <code>Draft</code> a
<code>PendingReview</code>. El Listado 17-15 muestra este c√≥digo:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Listing 17-15: Implementando los m√©todos <code>request_review</code>
en <code>Post</code> y el trait <code>State</code></span></p>
<p>Agregamos un m√©todo p√∫blico llamado <code>request_review</code> a <code>Post</code> que toma una
referencia mutable a <code>self</code>. Luego llamamos a un m√©todo interno <code>request_review</code>
en el estado actual de <code>Post</code>, y este segundo m√©todo <code>request_review</code> consume
el estado actual y devuelve un nuevo estado.</p>
<p>Agregamos el m√©todo <code>request_review</code> al trait <code>State</code>; todos los tipos que
implementan el trait ahora deber√°n implementar el m√©todo <code>request_review</code>.
Tenga en cuenta que en lugar de tener <code>self</code>, <code>&amp;self</code> o <code>&amp;mut self</code> como el
primer par√°metro del m√©todo, tenemos <code>self: Box&lt;Self&gt;</code>. Esta sintaxis significa
que el m√©todo solo es v√°lido cuando se llama en un <code>Box</code> que contiene el tipo.
Esta sintaxis toma posesi√≥n de <code>Box&lt;Self&gt;</code>, invalidando el estado anterior para
que el valor de estado de <code>Post</code> pueda transformarse en un nuevo estado.</p>
<p>Para consumir el antiguo estado, el m√©todo <code>request_review</code> debe tomar
ownership del valor de estado. Aqu√≠ es donde entra en juego la <code>Option</code> en el
campo <code>state</code> de <code>Post</code>: llamamos al m√©todo <code>take</code> para sacar el valor <code>Some</code>
del campo <code>state</code> y dejar un <code>None</code> en su lugar, porque Rust no nos permite
tener campos no poblados en los structs. Esto nos permite mover el valor
<code>state</code> fuera de <code>Post</code> en lugar de pedir borrowing. Luego estableceremos el
valor <code>state</code> de la publicaci√≥n en el resultado de esta operaci√≥n.</p>
<p>Necesitamos establecer <code>state</code> como <code>None</code> temporalmente en lugar de
establecerlo directamente con c√≥digo como
<code>self.state = self.state.request_review();</code> para obtener la propiedad del
valor <code>state</code>. Esto asegura que <code>Post</code> no pueda usar el valor <code>state</code> antiguo
despu√©s de que lo hayamos transformado en un nuevo estado.</p>
<p>El m√©todo <code>request_review</code> en <code>Draft</code> devuelve una nueva instancia de un nuevo
struct llamado <code>PendingReview</code>, que representa el estado cuando un post est√°
esperando una revisi√≥n. El struct <code>PendingReview</code> tambi√©n implementa
el m√©todo <code>request_review</code>, pero no hace ninguna transformaci√≥n. En cambio,
devuelve a s√≠ mismo, porque cuando solicitamos una revisi√≥n en una publicaci√≥n
que ya est√° en el estado <code>PendingReview</code>, debe permanecer en el estado
<code>PendingReview</code>.</p>
<p>Ahora podemos comenzar a ver las ventajas del state pattern: el m√©todo
<code>request_review</code> en <code>Post</code> es el mismo sin importar su valor <code>state</code>. Cada
estado es responsable de sus propias reglas.</p>
<p>Dejaremos el m√©todo <code>content</code> en <code>Post</code> tal como est√°, devolviendo un string
slice vac√≠o. Ahora podemos tener un <code>Post</code> en el estado <code>PendingReview</code> as√≠
como en el estado <code>Draft</code>, pero queremos el mismo comportamiento en el estado
<code>PendingReview</code>. ¬°El Listado 17-11 ahora funciona hasta la l√≠nea 10!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="agregando-approve-para-cambiar-el-comportamiento-de-content"><a class="header" href="#agregando-approve-para-cambiar-el-comportamiento-de-content">Agregando <code>approve</code> para cambiar el comportamiento de <code>content</code></a></h3>
<p>El m√©todo <code>approve</code> ser√° similar al m√©todo <code>request_review</code>: establecer√° el
valor de <code>state</code> al estado que el estado actual indique que deber√≠a tener
cuando ese estado sea aprobado, como se muestra en el Listado 17-16:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Listing 17-16: Implementando el m√©todo <code>approve</code> en
<code>Post</code> y el trait <code>State</code></span></p>
<p>Agregamos el m√©todo <code>approve</code> al trait <code>State</code> y agregamos un nuevo struct
que implementa el trait <code>State</code>, el estado <code>Published</code>.</p>
<p>De manera similar a c√≥mo funciona <code>request_review</code> en <code>PendingReview</code>, si
llamamos al m√©todo <code>approve</code> en un estado <code>Draft</code>, no tendr√° efecto porque
<code>approve</code> devolver√° <code>self</code>. Cuando llamamos a <code>approve</code> en <code>PendingReview</code>,
devuelve una nueva instancia de <code>Published</code> struct. El struct <code>Published</code>
implementa el trait <code>State</code>, y para ambos el m√©todo <code>request_review</code> y el
m√©todo <code>approve</code>, devuelve a s√≠ mismo, porque la publicaci√≥n debe permanecer
en el estado <code>Published</code> en esos casos.</p>
<p>Ahora debemos actualizar el m√©todo <code>content</code> en <code>Post</code>. Queremos que el valor
devuelto por <code>content</code> dependa del estado actual de <code>Post</code>, por lo que vamos
a hacer que <code>Post</code> delegue a un m√©todo <code>content</code> definido en su <code>state</code>, como
se muestra en el Listado 17-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 17-17: Actualizando el m√©todo <code>content</code> en <code>Post</code>
para delegar en un m√©todo <code>content</code> en <code>State</code></span></p>
<p>Debido a que el objetivo es mantener todas estas reglas dentro de los structs
que implementan <code>State</code>, llamamos a un m√©todo <code>content</code> en el valor en <code>state</code>
y pasamos la instancia de publicaci√≥n (es decir, <code>self</code>) como argumento. Luego
devolvemos el valor devuelto del uso del m√©todo <code>content</code> en el valor <code>state</code>.</p>
<p>Llamamos al m√©todo <code>as_ref</code> en un <code>Option</code> porque queremos una referencia al
valor dentro del <code>Option</code> en lugar del ownership del valor. Debido a que
<code>state</code> es un <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, cuando llamamos a <code>as_ref</code>, se
devuelve una <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>. Si no llamamos a <code>as_ref</code>, obtendr√≠amos
un error porque no podemos mover <code>state</code> fuera del <code>&amp;self</code> prestado del
par√°metro de la funci√≥n.</p>
<p>Luego llamamos al m√©todo <code>unwrap</code>, el cual sabemos que nunca generar√° un error,
porque los m√©todos en <code>Post</code> aseguran que <code>state</code> siempre contendr√° un valor
<code>Some</code> cuando esos m√©todos finalicen. Este es uno de los casos que mencionamos
en la secci√≥n <a href="ch09-03-to-panic-or-not-to-panic.html#casos-en-los-que-tienes-mas-informacion-que-el-compilador">‚ÄúCasos en los que tienes m√°s informaci√≥n que el
compilador‚Äù</a><!-- ignore --> del Cap√≠tulo 9 cuando
sabemos que un valor <code>None</code> nunca es posible, aunque el compilador no puede
entender eso.</p>
<p>En este punto, cuando llamamos a <code>content</code> en el <code>&amp;Box&lt;dyn State&gt;</code>, la coerci√≥n
de dereferencia entrar√° en vigencia en el <code>&amp;</code> y el <code>Box</code>, por lo que el m√©todo
<code>content</code> se llamar√° en el tipo que implementa el trait <code>State</code>. Eso significa
que debemos agregar <code>content</code> a la definici√≥n del trait <code>State</code>, y all√≠ es
donde pondremos la l√≥gica para qu√© contenido devolver dependiendo de qu√©
estado tengamos, como se muestra en el Listado 17-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<p><span class="caption">Listing 17-18: Agregando el m√©todo <code>content</code> al trait
<code>State</code></span></p>
<p>Agregamos una implementaci√≥n predeterminada para el m√©todo <code>content</code> que
devuelve un string slice vac√≠o. Eso significa que no necesitamos implementar
<code>content</code> en los structs <code>Draft</code> y <code>PendingReview</code>. El struct <code>Published</code>
anular√° el m√©todo <code>content</code> y devolver√° el valor en <code>post.content</code>.</p>
<p>Es importante destacar que necesitamos anotaciones de lifetime en este m√©todo,
como discutimos en el Cap√≠tulo 10. Estamos tomando una referencia a un <code>post</code>
como argumento y devolviendo una referencia a una parte de ese <code>post</code>, por lo
que el lifetime de la referencia devuelta est√° relacionado con el tiempo
de vida del argumento <code>post</code>.</p>
<p>¬°Y hemos terminado! ¬°Todo lo que se muestra en el Listado 17-11 ahora funciona!
Hemos implementado el patr√≥n de estado con las reglas del flujo de trabajo de
la publicaci√≥n de blog. La l√≥gica relacionada con las reglas vive en los
objetos de estado en lugar de estar dispersa en <code>Post</code>.</p>
<blockquote>
<h4 id="por-qu√©-no-un-enum"><a class="header" href="#por-qu√©-no-un-enum">¬øPor qu√© no un enum?</a></h4>
<p>Puede que te hayas preguntado por qu√© no usamos un <code>enum</code> con los diferentes
estados posibles de la publicaci√≥n como variantes. Esa es ciertamente una
soluci√≥n posible, ¬°pru√©bala y compara los resultados finales para ver cu√°l
prefieres! Una desventaja de usar un enum es que cada lugar que verifica el
valor del enum necesitar√° una expresi√≥n <code>match</code> o similar para manejar cada
variante posible. Esto podr√≠a ser m√°s repetitivo que esta soluci√≥n de trait
object.</p>
</blockquote>
<h3 id="trade-offs-del-state-pattern"><a class="header" href="#trade-offs-del-state-pattern">Trade-offs del State Pattern</a></h3>
<p>Hemos demostrado que Rust es capaz de implementar el State Pattern orientado a
objetos para encapsular los diferentes tipos de comportamiento que un post
deber√≠a tener en cada estado. Los m√©todos en <code>Post</code> no saben nada sobre los
diferentes comportamientos. La forma en que organizamos el c√≥digo, solo
tenemos que mirar en un solo lugar para conocer las diferentes formas en que
un post publicado puede comportarse: la implementaci√≥n del trait <code>State</code> en el
struct <code>Published</code>.</p>
<p>Si cre√°ramos una implementaci√≥n alternativa que no usara el State Pattern,
en su lugar podr√≠amos usar expresiones <code>match</code> en los m√©todos de <code>Post</code> o
incluso en el c√≥digo <code>main</code> que verifica el estado del post y cambia el
comportamiento en esos lugares. ¬°Eso significar√≠a que tendr√≠amos que mirar en
varios lugares para comprender todas las implicaciones de un post que se
encuentra en el estado publicado! ¬°Esto solo aumentar√≠a cuanto m√°s estados
agreg√°ramos: cada una de esas expresiones <code>match</code> necesitar√≠a otra opci√≥n!</p>
<p>Con el State Pattern, los m√©todos <code>Post</code> y los lugares donde usamos <code>Post</code> no
necesitan expresiones <code>match</code>, y para agregar un nuevo estado, solo
necesitar√≠amos agregar un nuevo struct e implementar los m√©todos del trait en
ese struct.</p>
<p>La implementaci√≥n utilizando el State Pattern es f√°cil de extender para agregar
m√°s funcionalidad. Para ver la simplicidad de mantener el c√≥digo que usa el
State Pattern, prueba algunas de estas sugerencias:</p>
<ul>
<li>Agrega un m√©todo <code>reject</code> que cambia el estado de un post de <code>PendingReview</code>
a <code>Draft</code>.</li>
<li>Requiere dos llamadas a <code>approve</code> antes de que el estado pueda cambiar a
<code>Published</code>.</li>
<li>Permite a los usuarios agregar contenido de texto solo cuando un post est√° en
el estado <code>Draft</code>. Sugerencia: haz que el objeto de estado sea responsable de
lo que podr√≠a cambiar sobre el contenido, pero no sea responsable de modificar
el <code>Post</code>.</li>
</ul>
<p>Un inconveniente del State Pattern es que, debido a que los estados implementan
las transiciones entre estados, algunos de los estados est√°n acoplados entre s√≠.
Si agregamos otro estado entre <code>PendingReview</code> y <code>Published</code>, como <code>Scheduled</code>,
tendr√≠amos que cambiar el c√≥digo en <code>PendingReview</code> para hacer la transici√≥n a
<code>Scheduled</code> en su lugar. Ser√≠a menos trabajo si <code>PendingReview</code> no necesitara
cambiar con la adici√≥n de un nuevo estado, pero eso significar√≠a cambiar a
otro patr√≥n de dise√±o.</p>
<p>Otro inconveniente es que hemos duplicado algo de l√≥gica. Para eliminar parte
de la duplicaci√≥n, podr√≠amos intentar hacer implementaciones predeterminadas
para los m√©todos <code>request_review</code> y <code>approve</code> en el trait <code>State</code> que devuelvan
<code>self</code>; sin embargo, esto violar√≠a la seguridad del objeto, porque el trait no
sabe exactamente cu√°l ser√° el <code>self</code> concreto. Queremos poder usar <code>State</code> como
un objeto de trait, por lo que sus m√©todos deben ser seguros para el objeto.</p>
<p>Otra duplicaci√≥n incluye las implementaciones similares de los m√©todos
<code>request_review</code> y <code>approve</code> en <code>Post</code>. Ambos m√©todos delegan a la
implementaci√≥n del mismo m√©todo en el valor del campo <code>state</code> de <code>Option</code> y
establecen el nuevo valor del campo <code>state</code> en el resultado. Si tuvi√©ramos
muchos m√©todos en <code>Post</code> que siguieran este patr√≥n, podr√≠amos considerar
definir un macro para eliminar la repetici√≥n (ver la secci√≥n <a href="ch19-06-macros.html#macros">‚ÄúMacros‚Äù</a>
en el Cap√≠tulo 19).</p>
<p>Al implementar el State Pattern exactamente como se define en lenguajes
orientados a objetos, no estamos aprovechando al m√°ximo las fortalezas de Rust.
Veamos algunos cambios que podemos hacer en el crate <code>blog</code> que pueden hacer
que los estados y transiciones no v√°lidos sean errores de tiempo de
compilaci√≥n.</p>
<h4 id="codificando-estados-y-comportamiento-como-tipos"><a class="header" href="#codificando-estados-y-comportamiento-como-tipos">Codificando estados y comportamiento como tipos</a></h4>
<p>Vamos a mostrarte c√≥mo replantear el State Pattern para obtener un conjunto
diferente de compensaciones. En lugar de encapsular los estados y las
transiciones por completo para que el c√≥digo externo no tenga conocimiento de
ellos, codificaremos los estados en diferentes tipos. En consecuencia, el
sistema de verificaci√≥n de tipos de Rust evitar√° los intentos de usar
publicaciones borradores donde solo se permiten publicaciones publicadas
emitiendo un error del compilador.</p>
<p>Consideremos la primera parte de <code>main</code> en el Listado 17-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
</span>}</code></pre>
<p>Todav√≠a permitimos la creaci√≥n de nuevas publicaciones en el estado de borrador
usando <code>Post::new</code> y la capacidad de agregar texto al contenido de la
publicaci√≥n. Pero en lugar de tener un m√©todo <code>content</code> en una publicaci√≥n en
borrador que devuelva un string vac√≠o, haremos que las publicaciones en
borrador no tengan el m√©todo <code>content</code> en absoluto. De esa manera, si
intentamos obtener el contenido de una publicaci√≥n en borrador, obtendremos un
error del compilador que nos dice que el m√©todo no existe. Como resultado,
ser√° imposible mostrar accidentalmente el contenido de la publicaci√≥n en
borrador en producci√≥n, porque ese c√≥digo ni siquiera se compilar√°. El Listado
17-9 muestra la definici√≥n de un struct <code>Post</code> y un struct <code>DraftPost</code>, as√≠
como m√©todos en cada uno:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<p><span class="caption">Listing 17-19: Un <code>Post</code> con un m√©todo <code>content</code> y un
<code>DraftPost</code> sin un m√©todo <code>content</code></span></p>
<p>Tanto los structs <code>Post</code> como <code>DraftPost</code> tienen un campo privado <code>content</code>
que almacena el texto de la publicaci√≥n del blog. Los structs ya no tienen el
campo <code>state</code> porque estamos moviendo la codificaci√≥n del estado a los tipos
de los structs. El struct <code>Post</code> representar√° una publicaci√≥n publicada, y
tiene un m√©todo <code>content</code> que devuelve el <code>content</code>.</p>
<p>Todav√≠a tenemos una funci√≥n <code>Post::new</code>, pero en lugar de devolver una
instancia de <code>Post</code>, devuelve una instancia de <code>DraftPost</code>. Debido a que
<code>content</code> es privado y no hay funciones que devuelvan <code>Post</code>, no es posible
crear una instancia de <code>Post</code> en este momento.</p>
<p>El struct <code>DraftPost</code> tiene un m√©todo <code>add_text</code>, por lo que podemos agregar
texto al campo <code>content</code> como antes. Sin embargo, ten en cuenta que <code>DraftPost</code>
no tiene un m√©todo <code>content</code> definido. Entonces, ahora el programa garantiza
que todas las publicaciones comienzan como publicaciones en borrador, y las
publicaciones en borrador no tienen su contenido disponible para mostrar.
Cualquier intento de evitar estas restricciones dar√° como resultado un error
del compilador.</p>
<h4 id="implementando-transiciones-como-transformaciones-en-diferentes-tipos"><a class="header" href="#implementando-transiciones-como-transformaciones-en-diferentes-tipos">Implementando transiciones como transformaciones en diferentes tipos</a></h4>
<p>Entonces, ¬øc√≥mo obtenemos una publicaci√≥n publicada? Queremos hacer cumplir
la regla de que una publicaci√≥n en borrador debe ser revisada y aprobada antes
de que pueda publicarse. Una publicaci√≥n en el estado de revisi√≥n pendiente
todav√≠a no debe mostrar ning√∫n contenido. Implementemos estas restricciones
agregando otro struct, <code>PendingReviewPost</code>, definiendo el m√©todo <code>request_review</code>
en <code>DraftPost</code> para devolver un <code>PendingReviewPost</code>, y definiendo un m√©todo
<code>approve</code> en <code>PendingReviewPost</code> para devolver un <code>Post</code>, como se muestra en
el Listado 17-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-20: Un <code>PendingReviewPost</code> que se crea
llamando a <code>request_review</code> en <code>DraftPost</code> y un m√©todo <code>approve</code> que convierte
un <code>PendingReviewPost</code> en un <code>Post</code> publicado</span></p>
<p>Los m√©todos <code>request_review</code> y <code>approve</code> toman ownership de <code>self</code>, consumiendo
as√≠ las instancias de <code>DraftPost</code> y <code>PendingReviewPost</code> y transform√°ndolas en
un <code>PendingReviewPost</code> y un <code>Post</code> publicado, respectivamente. De esta manera,
no tendremos ninguna instancia de <code>DraftPost</code> persistente despu√©s de haber
llamado a <code>request_review</code> en ellas, y as√≠ sucesivamente. El struct
<code>PendingReviewPost</code> no tiene un m√©todo <code>content</code> definido en √©l, por lo que
intentar leer su contenido da como resultado un error del compilador, como con
<code>DraftPost</code>. Debido a que la √∫nica forma de obtener una instancia de <code>Post</code>
publicada que tiene un m√©todo <code>content</code> definido es llamar al m√©todo <code>approve</code>
en un <code>PendingReviewPost</code>, y la √∫nica forma de obtener un <code>PendingReviewPost</code>
es llamar al m√©todo <code>request_review</code> en un <code>DraftPost</code>, ahora hemos codificado
el workflow de la publicaci√≥n del blog en el sistema de tipos.</p>
<p>Pero tambi√©n debemos hacer algunos cambios peque√±os en <code>main</code>. Los m√©todos
<code>request_review</code> y <code>approve</code> devuelven nuevas instancias en lugar de modificar
el struct en el que se llaman, por lo que debemos agregar m√°s asignaciones de
sombreado <code>let post =</code> para guardar las instancias devueltas. Tampoco podemos
tener las afirmaciones sobre el contenido de las publicaciones en borrador y
revisi√≥n pendiente sean strings vac√≠os, ni los necesitamos: ya no podemos
compilar el c√≥digo que intenta usar el contenido de las publicaciones en esos
estados. El c√≥digo actualizado en <code>main</code> se muestra en el Listado 17-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}</code></pre>
<p><span class="caption">Listing 17-21: Modificaciones a <code>main</code> para usar la nueva
implementaci√≥n del workflow de la publicaci√≥n del blog</span></p>
<p>Las modificaciones que hicimos a <code>main</code> para reasignar <code>post</code> significan que
esta implementaci√≥n ya no sigue el patr√≥n de estado orientado a objetos: las
transformaciones entre los estados ya no est√°n encapsuladas completamente
dentro de la implementaci√≥n de <code>Post</code>. Sin embargo, nuestra ganancia es que
los estados inv√°lidos ahora son imposibles debido al sistema de tipos y la
comprobaci√≥n de tipos que ocurre en tiempo de compilaci√≥n. Esto garantiza que
ciertos errores, como la visualizaci√≥n del contenido de una publicaci√≥n no
publicada, se descubrir√°n antes de que lleguen a producci√≥n.</p>
<p>Prueba las tareas sugeridas al comienzo de esta secci√≥n en el crate <code>blog</code> tal
como est√° despu√©s del Listado 17-21 para evaluar el dise√±o de esta versi√≥n del
c√≥digo. Ten en cuenta que es posible que algunas de las tareas ya est√©n
completadas en este dise√±o.</p>
<p>Hemos visto que aunque Rust es capaz de implementar patrones de dise√±o
orientados a objetos, tambi√©n est√°n disponibles en Rust otros patrones, como
la codificaci√≥n del estado en el sistema de tipos. Estos patrones tienen
diferentes compensaciones. Aunque es posible que est√©s muy familiarizado con
los patrones orientados a objetos, repensar el problema para aprovechar las
caracter√≠sticas de Rust puede proporcionar beneficios, como prevenir algunos
errores en tiempo de compilaci√≥n. Los patrones orientados a objetos no siempre
ser√°n la mejor soluci√≥n en Rust debido a ciertas caracter√≠sticas, como el
ownership, que los lenguajes orientados a objetos no tienen.</p>
<h2 id="resumen-16"><a class="header" href="#resumen-16">Resumen</a></h2>
<p>Sin importar si consideras a Rust como un lenguaje orientado a objetos despu√©s
de leer este cap√≠tulo, ahora sabes que puedes usar objetos de tipo trait para
obtener algunas caracter√≠sticas orientadas a objetos en Rust. La
despatronizaci√≥n din√°mica puede brindarle a tu c√≥digo cierta flexibilidad a
cambio de un poco de rendimiento en tiempo de ejecuci√≥n. Puedes usar esta
flexibilidad para implementar patrones orientados a objetos que pueden ayudar
a la mantenibilidad de tu c√≥digo. Rust tambi√©n tiene otras caracter√≠sticas,
como el ownership, que los lenguajes orientados a objetos no tienen. Un patr√≥n
orientado a objetos no siempre ser√° la mejor manera de aprovechar las
fortalezas de Rust, pero es una opci√≥n disponible.</p>
<p>A continuaci√≥n, veremos los patterns, que son otra de las caracter√≠sticas de
Rust que permiten mucha flexibilidad. Hemos visto brevemente los patterns a lo
largo del libro, pero a√∫n no hemos visto su capacidad total. ¬°Vamos all√°!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns-and-matching"><a class="header" href="#patterns-and-matching">Patterns and Matching</a></h1>
<p>Los <em>Patterns</em> (Patrones) son una sintaxis especial en Rust para hacer coincidir
la estructura de los tipos, tanto complejos como simples. El uso de patrones en
conjunci√≥n con expresiones <code>match</code> y otros constructos le brinda m√°s control
sobre el flujo de control de un programa. Un patr√≥n consta de alguna
combinaci√≥n de los siguientes:</p>
<ul>
<li>Literales</li>
<li>Arrays, Enums, Structs, o Tuplas desestructuradas</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<p>Algunos ejemplos de patrones incluyen <code>x</code>, <code>(a, 3)</code> y <code>Some(Color::Red)</code>. En
los contextos en los que los patrones son v√°lidos, estos componentes describen
la forma de los datos. Nuestro programa luego compara los valores con los
patrones para determinar si tiene la forma correcta de datos para continuar
ejecutando un c√≥digo en particular.</p>
<p>Para usar un patr√≥n, lo comparamos con alg√∫n valor. Si el patr√≥n coincide con el
valor, usamos las partes de valor en nuestro c√≥digo. Recuerde las expresiones
<code>match</code> en el Cap√≠tulo 6 que usaron patrones, como el ejemplo de la m√°quina
clasificadora de monedas. Si el valor se ajusta a la forma del patr√≥n, podemos
usar las piezas con nombre. Si no lo hace, el c√≥digo asociado con el patr√≥n no
se ejecutar√°.</p>
<p>Este cap√≠tulo es una referencia sobre todo lo relacionado con los patrones.
Cubriremos los lugares v√°lidos para usar patrones, la diferencia entre patrones
refutables e irrefutables, y los diferentes tipos de sintaxis de patrones que
puede ver. Al final del cap√≠tulo, sabr√° c√≥mo usar patrones para expresar muchos
conceptos de una manera clara.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="todos-los-lugares-donde-se-pueden-usar-patterns"><a class="header" href="#todos-los-lugares-donde-se-pueden-usar-patterns">Todos los lugares donde se pueden usar Patterns</a></h2>
<p>Los Patterns aparecen en varios lugares en Rust, ¬°y los has estado usando mucho
sin darte cuenta! Esta secci√≥n discute todos los lugares donde los Patterns son
v√°lidos.</p>
<h3 id="opciones-de-match"><a class="header" href="#opciones-de-match">Opciones de <code>match</code></a></h3>
<p>Como se discuti√≥ en el Cap√≠tulo 6, usamos Patterns en las opciones de las
expresiones <code>match</code>. Formalmente, las expresiones <code>match</code> se definen como la
palabra clave <code>match</code>, un valor para hacer coincidir y una o m√°s opciones de
coincidencia que consisten en un patr√≥n y una expresi√≥n para ejecutar si el
valor coincide con el patr√≥n de esa opci√≥n, as√≠:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>Por ejemplo, aqu√≠ est√° la expresi√≥n <code>match</code> del Listado 6-5 que coincide con un
valor <code>Option&lt;i32&gt;</code> en la variable <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>Los patterns en esta expresi√≥n <code>match</code> son el <code>None</code> y el <code>Some(i)</code> a la
izquierda de cada flecha.</p>
<p>Un requisito para las expresiones <code>match</code> es que deben ser <em>exhaustivas</em> en el
sentido de que todas las posibilidades para el valor en la expresi√≥n <code>match</code>
deben tenerse en cuenta. Una forma de asegurarse de haber cubierto todas las
posibilidades es tener un patr√≥n de captura para el √∫ltimo brazo: por ejemplo,
un nombre de variable que coincida con cualquier valor nunca puede fallar y,
por lo tanto, cubre todos los casos restantes.</p>
<p>El patr√≥n espec√≠fico <code>_</code> coincidir√° con cualquier cosa, pero nunca se une a una
variable, por lo que a menudo se usa en la √∫ltima opci√≥n de coincidencia. El
patr√≥n <code>_</code> puede ser √∫til cuando desea ignorar cualquier valor no especificado,
por ejemplo. Cubriremos el patr√≥n <code>_</code> con m√°s detalle en la secci√≥n <a href="ch18-03-pattern-syntax.html#ignorando-valores-en-un-patron">‚ÄúIgnorar
valores en un patr√≥n‚Äù</a><!-- ignore --> m√°s adelante
en este cap√≠tulo.</p>
<h3 id="expresiones-condicionales-if-let"><a class="header" href="#expresiones-condicionales-if-let">Expresiones condicionales <code>if let</code></a></h3>
<p>En el cap√≠tulo 6 discutimos c√≥mo usar expresiones <code>if let</code> principalmente como
una forma m√°s corta de escribir el equivalente de un <code>match</code> que solo coincide
con un caso. Opcionalmente, <code>if let</code> puede tener un <code>else</code> correspondiente que
contenga c√≥digo para ejecutar si el patr√≥n en el <code>if let</code> no coincide.</p>
<p>El Listado 18-1 muestra que tambi√©n es posible mezclar y combinar expresiones
<code>if let</code>, <code>else if</code> y <code>else if let</code>. Hacerlo nos da m√°s flexibilidad que una
expresi√≥n <code>match</code> en la que solo podemos expresar un valor para comparar con
los patrones. Adem√°s, Rust no requiere que las condiciones en una serie de
brazos <code>if let</code>, <code>else if</code>, <code>else if let</code> se relacionen entre s√≠.</p>
<p>El c√≥digo en el Listado 18-1 determina de qu√© color hacer su fondo en funci√≥n
de una serie de comprobaciones para varias condiciones. Para este ejemplo,
hemos creado variables con valores codificados que un programa real podr√≠a
recibir de la entrada del usuario.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {color}, as the background&quot;);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-1: Combinando
<code>if let</code>, <code>else if</code>, <code>else if let</code>, y <code>else</code></span></p>
<p>Si el usuario especifica un color favorito, ese color se usa como fondo. Si no
se especifica un color favorito y hoy es martes, el color de fondo es verde.
De lo contrario, si el usuario especifica su edad como una cadena y podemos
analizarla como un n√∫mero con √©xito, el color es p√∫rpura o naranja dependiendo
del valor del n√∫mero. Si ninguna de estas condiciones se aplica, el color de
fondo es azul.</p>
<p>Una estructura condicional nos permite cumplir con requisitos complejos.
Con los valores codificados que tenemos aqu√≠, este ejemplo imprimir√° <code>Using purple as the background color</code>.</p>
<p>Puedes ver que <code>if let</code> tambi√©n puede introducir variables con shadowing de la
misma manera que lo hacen las opciones <code>match</code>: la l√≠nea <code>if let Ok(age) = age</code> introduce una nueva variable <code>age</code> que contiene el valor dentro de la
variante <code>Ok</code>. Esto significa que necesitamos colocar la condici√≥n <code>if age &gt; 30</code>
dentro de ese bloque: no podemos combinar estas dos condiciones en <code>if let Ok (age) = age &amp;&amp; age &gt; 30</code>. El <code>age</code> sombreado que queremos comparar con 30 no es
v√°lido hasta que comience el nuevo alcance con la llave de apertura.</p>
<p>La desventaja de usar expresiones <code>if let</code> es que el compilador no verifica la
exhaustividad, mientras que con las expresiones <code>match</code> s√≠ lo hace. Si
omiti√©ramos el √∫ltimo bloque <code>else</code> y, por lo tanto, no manej√°ramos algunos
casos, el compilador no nos alertar√≠a sobre el posible bug de l√≥gica.</p>
<h3 id="bucles-condicionales-while-let"><a class="header" href="#bucles-condicionales-while-let">Bucles condicionales <code>while let</code></a></h3>
<p>Similar en su construcci√≥n a <code>if let</code>, el bucle condicional <code>while let</code> permite
que un bucle <code>while</code> se ejecute mientras un patr√≥n contin√∫e coincidiendo. En
el Listado 18-2 codificamos un bucle <code>while let</code> que usa un vector como una
pila e imprime los valores en el vector en el orden opuesto en el que se
pusieron.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{top}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-2: Utilizando un bucle <code>while let</code> para
imprimir valores mientras <code>stack.pop()</code> devuelva <code>Some</code></span></p>
<p>Este ejemplo imprime 3, 2 y luego 1. El m√©todo <code>pop</code> toma el √∫ltimo elemento
del vector y devuelve <code>Some(value)</code>. Si el vector est√° vac√≠o, <code>pop</code> devuelve
<code>None</code>. El bucle <code>while</code> contin√∫a ejecutando el c√≥digo en su bloque siempre que
<code>pop</code> devuelva <code>Some</code>. Cuando <code>pop</code> devuelve <code>None</code>, el bucle se detiene.
Podemos usar <code>while let</code> para sacar todos los elementos de nuestra pila.</p>
<h3 id="bucles-for"><a class="header" href="#bucles-for">Bucles <code>for</code></a></h3>
<p>En un bucle <code>for</code>, el valor que sigue directamente a la palabra clave <code>for</code> es
un pattern. Por ejemplo, en <code>for x in y</code> el <code>x</code> es el pattern. El Listado 18-3
demuestra c√≥mo usar un pattern en un bucle <code>for</code> para destruir, o romper, una
tupla como parte del bucle <code>for</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{value} is at index {index}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-3: Usando un pattern en un bucle <code>for</code> para
desestructurar una tupla</span></p>
<p>El c√≥digo en el Listado 18-3 imprimir√° lo siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>Adaptamos un iterator usando el m√©todo <code>enumerate</code> para que produzca un valor y
el √≠ndice de ese valor, colocado en una tupla. El primer valor producido es la
tupla <code>(0, 'a')</code>. Cuando este valor se corresponde con el pattern <code>(index, value)</code>, <code>index</code> ser√° <code>0</code> y <code>value</code> ser√° <code>'a'</code>, imprimiendo la primera l√≠nea
del output.</p>
<h3 id="sentencias-let"><a class="header" href="#sentencias-let">Sentencias <code>let</code></a></h3>
<p>Antes de este cap√≠tulo, solo hab√≠amos discutido expl√≠citamente el uso de
patterns con <code>match</code> e <code>if let</code>, pero de hecho, tambi√©n hemos usado patterns
en otros lugares, incluyendo en las sentencias <code>let</code>. Por ejemplo, considera
esta asignaci√≥n de variable directa con <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Cada vez que has utilizado una declaraci√≥n <code>let</code> como esta, has estado usando
patterns, aunque es posible que no te hayas dado cuenta. M√°s formalmente, una
sentencia <code>let</code> se ve as√≠:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>En declaraciones como <code>let x = 5;</code>, con un nombre de variable en el slot
<code>PATTERN</code>, el nombre de la variable es solo una forma particularmente simple de
un pattern. Rust compara la expresi√≥n con el pattern y asigna cualquier nombre
que encuentre. Entonces, en el ejemplo <code>let x = 5;</code>, <code>x</code> es un pattern que
significa ‚Äúvincula lo que coincide aqu√≠ a la variable <code>x</code>‚Äù. Debido a que el
nombre <code>x</code> es todo el pattern, este pattern significa efectivamente ‚Äúvincula
todo a la variable <code>x</code>, sea cual sea el valor‚Äù.</p>
<p>Para ver m√°s claramente el aspecto de coincidencia de patrones de <code>let</code>,
considera el Listado 18-4, que usa un pattern con <code>let</code> para destruir una
tupla.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-4: Usando un pattern para desestructurar una
tupla y crear tres variables a la vez</span></p>
<p>Aqu√≠, emparejamos una tupla con un pattern. Rust compara el valor <code>(1, 2, 3)</code>
con el pattern <code>(x, y, z)</code> y ve que el valor y el pattern coinciden, por lo que
Rust asigna <code>1</code> a <code>x</code>, <code>2</code> a <code>y</code> y <code>3</code> a <code>z</code>. Puedes pensar que este pattern de
tupla anida tres patterns de variable individuales dentro de √©l.</p>
<p>Si el n√∫mero de elementos en el pattern no coincide con el n√∫mero de elementos
en la tupla, el tipo general no coincidir√° y obtendremos un error del
compilador. Por ejemplo, el Listado 18-5 muestra un intento de destruir una
tupla con tres elementos en dos variables, lo cual no funcionar√°.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-5: Al construir incorrectamente un pattern
cuyas variables no coinciden con el n√∫mero de elementos en la tupla</span></p>
<p>Intentar compilar este c√≥digo resulta en este error de tipo:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin &quot;patterns&quot;) due to 1 previous error
</code></pre>
<p>Para solucionar el error, podr√≠amos ignorar uno o m√°s valores en la tupla
utilizando <code>_</code> o <code>..</code>, como ver√°s en la secci√≥n <a href="ch18-03-pattern-syntax.html#ignorando-valores-en-un-patron">‚ÄúIgnorando valores en un
pattern‚Äù</a><!-- ignore -->. Si el problema es que
tenemos demasiadas variables en el pattern, la soluci√≥n es hacer que los tipos
coincidan eliminando variables para que el n√∫mero de variables sea igual al
n√∫mero de elementos en la tupla.</p>
<h3 id="par√°metros-de-funci√≥n"><a class="header" href="#par√°metros-de-funci√≥n">Par√°metros de funci√≥n</a></h3>
<p>Los par√°metros de funci√≥n tambi√©n pueden ser patterns. El c√≥digo del Listado
18-6, que declara una funci√≥n llamada <code>foo</code> que toma un par√°metro llamado <code>x</code>
de tipo <code>i32</code>, deber√≠a ser familiar a estas alturas.</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 18-6: La firma de una funci√≥n que utiliza
patterns en los par√°metros</span></p>
<p>¬°La parte <code>x</code> es un pattern! Como hicimos con <code>let</code>, podr√≠amos hacer coincidir
una tupla en los argumentos de una funci√≥n con el pattern. El Listado 18-7
divide los valores en una tupla a medida que la pasamos a una funci√≥n.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({x}, {y})&quot;);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<p><span class="caption">Listing 18-7: Una funci√≥n con par√°metros que desetructura
una tupla</span></p>
<p>Este c√≥digo imprime <code>Current location: (3, 5)</code>. El valor <code>(3, 5)</code> coincide con
el pattern <code>(x, y)</code>, por lo que <code>x</code> es <code>3</code> y <code>y</code> es <code>5</code>.</p>
<p>Tambi√©n podemos usar patterns en las listas de par√°metros de closures, de la
misma manera que en las listas de par√°metros de funciones. Porque los closures
son similares a las funciones, como se discuti√≥ en el Cap√≠tulo 13.</p>
<p>Hasta ahora, has visto varias formas de usar patrones, pero los patrones no
funcionar√°n de la misma manera en todos los lugares donde podemos usarlos. En
algunos casos, los patrones deben ser irrefutables; en otras circunstancias,
pueden ser refutables. Discutiremos estos dos conceptos a continuaci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refutabilidad-si-un-pattern-puede-fallar-al-hacer-match"><a class="header" href="#refutabilidad-si-un-pattern-puede-fallar-al-hacer-match">Refutabilidad: Si un Pattern Puede Fallar al Hacer Match</a></h2>
<p>Los patterns se dividen en dos formas: refutables e irrefutables. Los patterns
que coinciden con cualquier valor posible son <em>irrefutables</em>. Un ejemplo ser√≠a
<code>x</code> en la declaraci√≥n <code>let x = 5;</code> porque <code>x</code> coincide con cualquier cosa y,
por lo tanto, no puede fallar al hacer match. Los patterns que pueden fallar al
hacer match para algunos valores posibles son <em>refutables</em>. Un ejemplo ser√≠a
<code>Some(x)</code> en la expresi√≥n <code>if let Some(x) = a_value</code> porque si el valor en la
variable <code>a_value</code> es <code>None</code> en lugar de <code>Some</code>, el pattern <code>Some(x)</code> no
coincidir√°.</p>
<p>Los par√°metros de funciones, las declaraciones <code>let</code> y los bucles <code>for</code> solo
pueden aceptar patterns irrefutables, porque el programa no puede hacer nada
significativo cuando los valores no coinciden. Las expresiones <code>if let</code> y
<code>while let</code> aceptan patterns refutables e irrefutables, pero el compilador
advierte contra los patterns irrefutables porque, por definici√≥n, est√°n
destinados a manejar posibles fallas: la funcionalidad de una condicional est√°
en su capacidad de realizar de manera diferente dependiendo del √©xito o el
fracaso.</p>
<p>En general, no deber√≠a preocuparse por la distinci√≥n entre patterns refutables
e irrefutables; sin embargo, debe estar familiarizado con el concepto de
refutabilidad para poder responder cuando lo vea en un mensaje de error. En
esos casos, deber√° cambiar el pattern o la construcci√≥n que est√° utilizando el
pattern, seg√∫n el comportamiento previsto del c√≥digo.</p>
<p>Veamos un ejemplo de lo que sucede cuando intentamos usar un pattern refutable
donde Rust requiere un pattern irrefutable y viceversa. El Listado 18-8 muestra
una declaraci√≥n <code>let</code>, pero para el pattern hemos especificado <code>Some(x)</code>, un
pattern refutable. Como puede imaginar, este c√≥digo no se compilar√°.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-8: Intentando utilizar un pattern refutable con
<code>let</code></span></p>
<p>Si <code>some_option_value</code> fuera un valor <code>None</code>, no coincidir√≠a con el pattern
<code>Some(x)</code>, lo que significa que el pattern es refutable. Sin embargo, la 
declaraci√≥n <code>let</code> solo puede aceptar un pattern irrefutable porque no hay nada
v√°lido que el c√≥digo pueda hacer con un valor <code>None</code>. En tiempo de compilaci√≥n,
Rust se quejar√° de que hemos intentado usar un pattern refutable donde se
requiere un pattern irrefutable:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin &quot;patterns&quot;) due to 1 previous error
</code></pre>
<p>Debido a que no hemos cubierto (¬°y no pudimos cubrir!) Cada valor v√°lido con el
pattern <code>Some(x)</code>, Rust produce un error del compilador.</p>
<p>Si tenemos un pattern refutable donde se necesita un patr√≥n irrefutable, 
podemos solucionarlo cambiando el c√≥digo que utiliza el patr√≥n: en lugar de 
usar <code>let</code>, podemos usar <code>if let</code>. Entonces, si el pattern no coincide, el 
c√≥digo simplemente omitir√° el c√≥digo entre llaves, d√°ndole una forma de 
continuar v√°lidamente. El Listado 18-9 muestra c√≥mo solucionar el c√≥digo del 
Listado 18-8.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{x}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-9: Usando <code>if let</code> y un bloque con patterns 
refutables en lugar de <code>let</code></span></p>
<p>¬°Le hemos dado una soluci√≥n al c√≥digo! Este c√≥digo es perfectamente v√°lido ahora.
Sin embargo, significa que no podemos usar un pattern irrefutable sin recibir un
error. Si le damos a <code>if let</code> un pattern que siempre coincidir√°, como <code>x</code>, como
se muestra en el Listado 18-10, el compilador dar√° una advertencia.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{x}&quot;);
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-10: Intentando usar un pattern irrefutable
con <code>if let</code></span></p>
<p>Rust se queja de que no tiene sentido usar <code>if let</code> con un pattern 
irrefutable:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin &quot;patterns&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>Por esta raz√≥n, las opciones del match deben usar patterns refutables, excepto
por la √∫ltima opci√≥n, que debe coincidir con cualquier valor restante con un
pattern irrefutable. Rust nos permite usar un pattern irrefutable en un <code>match</code>
con solo un brazo, pero esta sintaxis no es particularmente √∫til y podr√≠a
reemplazarse con una declaraci√≥n <code>let</code> m√°s simple.</p>
<p>Ahora que sabes d√≥nde usar patterns y la diferencia entre patterns refutables e
irrefutables, cubramos toda la sintaxis que podemos usar para crear patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sintaxis-de-los-patterns"><a class="header" href="#sintaxis-de-los-patterns">Sintaxis de los Patterns</a></h2>
<p>En esta secci√≥n, reunimos toda la sintaxis v√°lida en los patterns y discutimos
por qu√© y cu√°ndo podr√≠a querer usar cada uno.</p>
<h3 id="coincidiendo-con-literales"><a class="header" href="#coincidiendo-con-literales">Coincidiendo con literales</a></h3>
<p>Como viste en el Cap√≠tulo 6, puedes hacer coincidir patterns contra literales
directamente. El siguiente c√≥digo da algunos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo imprime <code>one</code> porque el valor en <code>x</code> es 1. Esta sintaxis es √∫til
cuando quieres que tu c√≥digo tome una acci√≥n si obtiene un valor concreto
particular.</p>
<h3 id="coincidiendo-con-variables-nombradas"><a class="header" href="#coincidiendo-con-variables-nombradas">Coincidiendo con variables nombradas</a></h3>
<p>Las variables nombradas son patterns irrefutables que coinciden con cualquier
valor, y las hemos usado muchas veces en el libro. Sin embargo, hay una
complicaci√≥n cuando usas variables nombradas en expresiones <code>match</code>. Debido a
que <code>match</code> inicia un nuevo alcance, las variables declaradas como parte de un
pattern dentro de la expresi√≥n <code>match</code> ocultar√°n aquellas con el mismo nombre
fuera del constructo <code>match</code>, como es el caso de todas las variables. En el
Listado 18-11, declaramos una variable llamada <code>x</code> con el valor <code>Some(5)</code> y una
variable <code>y</code> con el valor <code>10</code>. Luego creamos una expresi√≥n <code>match</code> en el valor
<code>x</code>. Mira los patterns en las opciones <code>match</code> y <code>println!</code> al final, e intenta
averiguar qu√© imprimir√° el c√≥digo antes de ejecutar este c√≥digo o leer m√°s.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {y}&quot;),
        _ =&gt; println!(&quot;Default case, x = {x:?}&quot;),
    }

    println!(&quot;at the end: x = {x:?}, y = {y}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-11: Una expresi√≥n <code>match</code> con una opci√≥n que
introduce una variable sombreada (shadowing) <code>y</code></span></p>
<p>Vamos a repasar lo que sucede cuando se ejecuta la expresi√≥n <code>match</code>. El pattern
en la primera opci√≥n de <code>match</code> no coincide con el valor definido de <code>x</code>, por
lo que el c√≥digo contin√∫a.</p>
<p>El pattern en la segunda opci√≥n de <code>match</code> introduce una nueva variable
llamada <code>y</code> que coincidir√° con cualquier valor dentro de un valor <code>Some</code>.
Debido a que estamos en un nuevo scope dentro de la expresi√≥n <code>match</code>, esta
es una nueva variable <code>y</code>, no la que declaramos al principio con el valor 10.
Este nuevo enlace <code>y</code> coincidir√° con cualquier valor dentro de un <code>Some</code>, que
es lo que tenemos en <code>x</code>. Por lo tanto, este nuevo <code>y</code> se vincula al valor
interno de <code>Some</code> en <code>x</code>. Ese valor es <code>5</code>, por lo que la expresi√≥n para esa
opci√≥n se ejecuta e imprime <code>Matched, y = 5</code>.</p>
<p>Si <code>x</code> hubiera sido un <code>None</code> en lugar de <code>Some(5)</code>, los patterns en las dos
primeras opciones no habr√≠an coincidido, por lo que el valor habr√≠a coincidido
con el guion bajo. No introdujimos la variable <code>x</code> en el pattern de la opci√≥n
del guion bajo, por lo que el <code>x</code> en la expresi√≥n sigue siendo el <code>x</code> externo
que no ha sido sombreado. En este caso hipot√©tico, el <code>match</code> imprimir√≠a
<code>Default case, x = None</code>.</p>
<p>Cuando la expresi√≥n <code>match</code> termina, su scope termina, y tambi√©n lo hace el
scope del <code>y</code> interno. El √∫ltimo <code>println!</code> produce <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Para crear una expresi√≥n <code>match</code> que compare los valores del <code>x</code> e <code>y</code> externos
en lugar de introducir una variable sombreada, necesitar√≠amos usar una
condici√≥n de guardia de <code>match</code>. Hablaremos de las guardias de <code>match</code> m√°s
adelante en la secci√≥n <a href="ch18-03-pattern-syntax.html#condicionales-adicionales-con-match-guards">‚ÄúCondicionales adicionales con <code>match</code> guards‚Äù</a><!-- ignore --></p>
<h3 id="m√∫ltiples-patterns"><a class="header" href="#m√∫ltiples-patterns">M√∫ltiples Patterns</a></h3>
<p>En las expresiones <code>match</code>, puedes coincidir con m√∫ltiples patrones usando la
sintaxis <code>|</code>, que es el operador <em>or</em> del pattern. Por ejemplo, en el siguiente
c√≥digo hacemos coincidir el valor de <code>x</code> con las opciones de <code>match</code>, el primero
de los cuales tiene una opci√≥n <em>or</em>, lo que significa que si el valor de <code>x</code>
coincide con cualquiera de los valores en esa opci√≥n, se ejecutar√° el c√≥digo de
esa opci√≥n:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo imprime <code>one or two</code>.</p>
<h3 id="coincidiendo-con-rangos-de-valores-con-"><a class="header" href="#coincidiendo-con-rangos-de-valores-con-">Coincidiendo con rangos de valores con <code>..=</code></a></h3>
<p>La sintaxis <code>..=</code> nos permite emparejar un rango inclusivo de valores. En el
siguiente c√≥digo, cuando un patr√≥n coincide con cualquiera de los valores
dentro del rango dado, esa opci√≥n se ejecutar√°:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;one through five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Si <code>x</code> es 1, 2, 3, 4 o 5, la primera opci√≥n coincidir√°. Esta sintaxis es m√°s
conveniente para m√∫ltiples valores de coincidencia que usar el operador <code>|</code>
para expresar la misma idea; si us√°ramos <code>|</code> tendr√≠amos que especificar <code>1 | 2 | 3 | 4 | 5</code>. Especificar un rango es mucho m√°s corto, especialmente si
queremos coincidir, digamos, cualquier n√∫mero entre 1 y 1.000.</p>
<p>El compilador verifica que el rango no est√© vac√≠o en tiempo de compilaci√≥n, y
debido a que los √∫nicos tipos para los que Rust puede decir si un rango est√°
vac√≠o o no son los valores num√©ricos y <code>char</code>, los rangos solo est√°n permitidos
con valores num√©ricos o <code>char</code>.</p>
<p>Aqu√≠ tienes un ejemplo que utiliza rangos de valores <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
        'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust puede determinar que <code>'c'</code> se encuentra dentro del rango especificado en
el primer pattern y se muestra por pantalla <code>early ASCII letter</code>.</p>
<h3 id="desestructurando-para-separar-valores"><a class="header" href="#desestructurando-para-separar-valores">Desestructurando para separar valores</a></h3>
<p>Podemos usar patterns para desestructurar structs, enums y tuplas para utilizar
diferentes partes de estos valores. Veamos cada uno de ellos.</p>
<h4 id="desestructurando-structs"><a class="header" href="#desestructurando-structs">Desestructurando Structs</a></h4>
<p>El Listado 18-12 muestra un struct <code>Point</code> con dos campos, <code>x</code> e <code>y</code>, que
podemos desestructurar usando un pattern con una declaraci√≥n <code>let</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<p><span class="caption">Listing 18-12: Desestructurando los campos de un struct
en variables separadas</span></p>
<p>Este c√≥digo crear las variables <code>a</code> y <code>b</code> que coinciden con los valores de los
campos <code>x</code> e <code>y</code> del struct <code>p</code>. Este ejemplo muestra que los nombres de las
variables en el pattern no tienen que coincidir con los nombres de los campos
del struct. Sin embargo, es com√∫n que los nombres de las variables coincidan
con los nombres de los campos para facilitar recordar qu√© variables provienen
de qu√© campos. Debido a este uso com√∫n, y porque escribir <code>let Point { x: x, y: y } = p;</code> contiene mucha duplicaci√≥n, Rust tiene una abreviatura para los
patterns que coinciden con los campos de los structs: solo necesitas listar el
nombre del campo del struct, y las variables creadas a partir del pattern
tendr√°n los mismos nombres. El Listado 18-13 se comporta de la misma manera que
el c√≥digo del Listado 18-12, pero las variables creadas en el pattern <code>let</code> son
<code>x</code> e <code>y</code> en lugar de <code>a</code> y <code>b</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<p><span class="caption">Listing 18-13: Desestructurando los campos de un struct
utilizando la forma abreviada de los campos struct</span></p>
<p>Este c√≥digo crea las variables <code>x</code> e <code>y</code> que coinciden con los campos <code>x</code> e <code>y</code>
del struct <code>p</code>. El resultado es que las variables <code>x</code> e <code>y</code> contienen los
valores de los campos <code>x</code> e <code>y</code> del struct.</p>
<p>Tambi√©n podemos desestructurar y con valores literales como parte del pattern
del struct en lugar de crear variables para todos los campos. Hacerlo nos
permite probar algunos de los campos para valores particulares mientras
creamos variables para desestructurar los otros campos.</p>
<p>En el Listado 18-14, tenemos una expresi√≥n <code>match</code> que separa los valores de
<code>Point</code> en tres casos: puntos que se encuentran directamente en el eje <code>x</code> (lo
cual es cierto cuando <code>y = 0</code>), en el eje <code>y</code> (<code>x = 0</code>), o ninguno.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {x}&quot;),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {y}&quot;),
        Point { x, y } =&gt; {
            println!(&quot;On neither axis: ({x}, {y})&quot;);
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-14: Desestructurar y coincidir valores
literales en un solo pattern</span></p>
<p>El primer bloque coincidir√° con cualquier punto que se encuentre en el eje <code>x</code>
especificando que el campo <code>y</code> debe coincidir con el valor <code>0</code>. El pattern a√∫n
crea una variable <code>x</code> que podemos usar en el c√≥digo de este bloque.</p>
<p>De manera similar, el segundo bloque coincide con cualquier punto en el eje <code>y</code>,
especificando que el campo <code>x</code> coincida si su valor es <code>0</code> y crea una variable
<code>y</code> para el valor del campo <code>y</code>. El tercer bloque no especifica literales, por
lo que coincide con cualquier otro <code>Point</code> y crea variables para ambos campos
<code>x</code> e <code>y</code>.</p>
<p>En este ejemplo, el valor <code>p</code> coincide con el segundo bloque debido a que <code>x</code>
contiene un <code>0</code>, por lo que este c√≥digo imprimir√° <code>On the y axis at 7</code>.</p>
<p>Recuerda que una expresi√≥n <code>match</code> detiene la verificaci√≥n de los bloques una
vez que ha encontrado el primer patr√≥n que coincide, por lo que, aunque <code>Point { x: 0, y: 0 }</code> est√° en el eje <code>x</code> y en el eje <code>y</code>, este c√≥digo solo imprimir√°
<code>On the x axis at 0</code>.</p>
<h4 id="desestructurando-enums"><a class="header" href="#desestructurando-enums">Desestructurando Enums</a></h4>
<p>Hemos desestructurado enums en este libro (por ejemplo, el Listado 6-5 en el
Cap√≠tulo 6), pero a√∫n no hemos discutido expl√≠citamente que el pattern para
desestructurar un enum corresponde a la forma en que se define los datos
almacenados dentro del enum. Como ejemplo, en el Listado 18-15 usamos el enum
<code>Message</code> del Listado 6-2 y escribimos un <code>match</code> con patterns que desestructuran
cada valor interno.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;);
        }
        Message::Move { x, y } =&gt; {
            println!(&quot;Move in the x direction {x} and in the y direction {y}&quot;);
        }
        Message::Write(text) =&gt; {
            println!(&quot;Text message: {text}&quot;);
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!(&quot;Change the color to red {r}, green {g}, and blue {b}&quot;)
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-15: Desestructurando variantes enum que
contienen diferentes tipos de valores</span></p>
<p>Este c√≥digo imprimir√° <code>Change the color to red 0, green 160, and blue 255</code>.
Prueba cambiar el valor de <code>msg</code> para ver el c√≥digo de las otras opciones.</p>
<p>Para variantes de enum sin ning√∫n dato, como <code>Message::Quit</code>, no podemos
desestructurar el valor m√°s all√°. Solo podemos coincidir con el valor literal
<code>Message::Quit</code>, y no hay variables en ese pattern.</p>
<p>Para variantes de enum similares a structs, como <code>Message::Move</code>, podemos
usar un pattern similar al que especificamos para coincidir con structs. Despu√©s
del nombre de la variante, colocamos llaves y luego enumeramos los campos con
variables para que desarmemos las piezas para usar en el c√≥digo de esta opci√≥n.
Aqu√≠ usamos la forma abreviada como lo hicimos en el Listado 18-13.</p>
<p>Para variantes de enum similares a tuplas, como <code>Message::Write</code> que contiene
una tupla con un elemento y <code>Message::ChangeColor</code> que contiene una tupla con
tres elementos, el pattern es similar al pattern que especificamos para
coincidir con tuplas. El n√∫mero de variables en el pattern debe coincidir con
el n√∫mero de elementos en la variante que estamos coincidiendo.</p>
<h4 id="desestructurando-structs-y-enums-anidados"><a class="header" href="#desestructurando-structs-y-enums-anidados">Desestructurando Structs y Enums Anidados</a></h4>
<p>So far, our examples have all been matching structs or enums one level deep,
but matching can work on nested items too! For example, we can refactor the
code in Listing 18-15 to support RGB and HSV colors in the <code>ChangeColor</code>
message, as shown in Listing 18-16.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(&quot;Change color to red {r}, green {g}, and blue {b}&quot;);
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(&quot;Change color to hue {h}, saturation {s}, value {v}&quot;)
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-16: Matching on nested enums</span></p>
<p>El pattern de la primera opci√≥n en la expresi√≥n <code>match</code> coincide con la
variante de enum <code>Message::ChangeColor</code> que contiene una variante
<code>Color::Rgb</code>; luego el pattern se une a los tres valores internos <code>i32</code>. El
pattern de la segunda opci√≥n tambi√©n coincide con una variante de enum
<code>Message::ChangeColor</code>, pero el enum interno coincide con <code>Color::Hsv</code> en su
lugar. Podemos especificar estas condiciones complejas en una expresi√≥n
<code>match</code>, incluso cuando est√°n involucrados dos enums.</p>
<h4 id="desestructurando-structs-y-tuplas"><a class="header" href="#desestructurando-structs-y-tuplas">Desestructurando Structs y Tuplas</a></h4>
<p>Podemos mezclar, combinar y anidar los patrones de desestructuraci√≥n de formas
a√∫n m√°s complejas. El siguiente ejemplo muestra una desestructuraci√≥n
complicada donde anidamos structs y tuplas dentro de una tupla y
desestructuramos todos los valores primitivos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo nos permite descomponer tipos complejos en sus partes componentes
para que podamos usar los valores que nos interesan por separado.</p>
<p>El uso de patrones para desestructurar es una forma conveniente de utilizar
partes de valores, como el valor de cada campo en un struct, por separado.</p>
<h3 id="ignorando-valores-en-un-patron"><a class="header" href="#ignorando-valores-en-un-patron">Ignorando valores en un patron</a></h3>
<p>Has visto que a veces es √∫til ignorar valores en un pattern, como en la √∫ltima
opci√≥n de un <code>match</code>, para obtener una opci√≥n que no hace nada, pero que abarca
todos los posibles valores restantes. Hay varias formas de ignorar valores
completos o partes en un pattern: usando el pattern <code>_</code> (que has visto), usando
el pattern <code>_</code> dentro de otro pattern, usando un nombre que comienza con un
guion bajo y usando <code>..</code> para ignorar las partes restantes de un valor.
Exploraremos c√≥mo y por qu√© usar cada uno de estos patterns.</p>
<h4 id="ignorando-un-valor-completo-con-_"><a class="header" href="#ignorando-un-valor-completo-con-_">Ignorando un Valor Completo con <code>_</code></a></h4>
<p>Hemos utilizado el guion bajo como un pattern comod√≠n que coincide con
cualquier valor pero no se enlaza con √©l. Esto es especialmente √∫til como la
√∫ltima opci√≥n en una expresi√≥n <code>match</code>, pero tambi√©n podemos usarlo en
cualquier pattern, incluyendo los par√°metros de una funci√≥n, como se muestra en
el Listado 18-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {y}&quot;);
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<p><span class="caption">Listing 18-17: Utilizando <code>_</code> en la firma de una
funci√≥n</span></p>
<p>Este c√≥digo ignorar√° completamente el valor <code>3</code> pasado como primer argumento,
e imprimir√° <code>This code only uses the y parameter: 4</code>.</p>
<p>En la mayor√≠a de los casos, cuando ya no necesitas un par√°metro de una funci√≥n,
deber√≠as cambiar la firma de la funci√≥n para que no incluya el par√°metro no
utilizado. Ignorar un par√°metro de una funci√≥n puede ser especialmente √∫til en
casos en los que, por ejemplo, est√°s implementando un trait cuando necesitas
una firma de tipo espec√≠fico, pero el cuerpo de la funci√≥n en tu implementaci√≥n
no necesita uno de los par√°metros. Luego evitas obtener una advertencia del
compilador sobre par√°metros de funci√≥n no utilizados, como lo har√≠as si
utilizaras un nombre en su lugar.</p>
<h4 id="ignorando-partes-de-un-valor-con-un-_-anidado"><a class="header" href="#ignorando-partes-de-un-valor-con-un-_-anidado">Ignorando partes de un valor con un <code>_</code> anidado</a></h4>
<p>En este caso, el pattern <code>_</code> se utiliza dentro de otro pattern para ignorar
solo una parte del valor. Esto puede ser √∫til cuando queremos probar solo una
parte del valor, pero no tenemos uso para las otras partes en el c√≥digo
correspondiente que queremos ejecutar. El Listado 18-18 muestra un c√≥digo
encargado de gestionar el valor de una configuraci√≥n. Los requisitos
son que el usuario no debe poder sobrescribir una personalizaci√≥n existente de
una configuraci√≥n, pero puede eliminar la configuraci√≥n y asignarle un valor si
actualmente no est√° establecida.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Can't overwrite an existing customized value&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;setting is {setting_value:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-18: Utilizando un guion bajo dentro de patterns
que coinciden con variantes <code>Some</code> cuando no necesitamos usar el valor dentro
del <code>Some</code></span></p>
<p>Este c√≥digo imprimir√° <code>setting is None</code> y luego <code>setting is Some(5)</code>. En la
primera opci√≥n de <code>match</code>, no necesitamos hacer coincidir ni usar los valores
dentro de ninguna de las variantes <code>Some</code>, pero si necesitamos comprobar en
el caso en el que tanto <code>setting_value</code> como <code>new_setting_value</code> son la
variante <code>Some</code>. En ese caso, imprimimos la raz√≥n por la que no cambiamos
<code>setting_value</code>, y no lo cambiamos.</p>
<p>En todos los dem√°s casos (si <code>setting_value</code> o <code>new_setting_value</code> son <code>None</code>)
expresados por el pattern <code>_</code> en la segunda opci√≥n, queremos permitir que
<code>new_setting_value</code> se convierta en <code>setting_value</code>.</p>
<p>Tambi√©n podemos usar guiones bajos en m√∫ltiples lugares dentro de un solo
pattern para ignorar valores particulares. El Listado 18-19 muestra un ejemplo
de ignorar el segundo y cuarto valores en una tupla de cinco elementos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Some numbers: {first}, {third}, {fifth}&quot;)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-19: Ignorando m√∫ltiples partes de una tupla</span></p>
<p>Este c√≥digo imprimir√° <code>Some numbers: 2, 8, 32</code>, y los valores 4 y 16 ser√°n
ignorados.</p>
<h4 id="ignorando-una-variable-no-utilizada-comenzando-su-nombre-con-_"><a class="header" href="#ignorando-una-variable-no-utilizada-comenzando-su-nombre-con-_">Ignorando una variable no utilizada comenzando su nombre con <code>_</code></a></h4>
<p>Si creas una variable, pero no la utilizas en ning√∫n lugar, Rust generalmente
emitir√° una advertencia porque una variable no utilizada podr√≠a causar un bug.
Sin embargo, a veces es √∫til poder crear una variable que a√∫n no se utilizar√°,
como cuando est√°s prototipando o simplemente comenzando un proyecto. En esta
situaci√≥n, puedes decirle a Rust que no te advierta sobre la variable no
utilizada comenzando el nombre de la variable con un guion bajo. En el Listado
18-20, creamos dos variables no utilizadas, pero cuando compilamos este c√≥digo,
solo deber√≠amos obtener una advertencia sobre una de ellas.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<p><span class="caption">Listing 18-20: Comenzar el nombre de una variable con un
guion bajo para evitar recibir advertencias de variables no utilizadas</span></p>
<p>Aqu√≠ recibimos una advertencia sobre no utilizar la variable <code>y</code>, pero no
recibimos una advertencia sobre no utilizar <code>_x</code>.</p>
<p>Es importante destacar que hay una diferencia sutil entre usar solo <code>_</code> y usar
un nombre que comienza con un guion bajo. La sintaxis <code>_x</code> todav√≠a enlaza el
valor a la variable, mientras que <code>_</code> no enlaza en absoluto. Para mostrar un
caso en el que esta distinci√≥n importa, el Listado 18-21 nos proporcionar√° un
error.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_s) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{s:?}&quot;);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-21: Una variable no utilizada que comienza con
un guion bajo a√∫n vincula el valor, lo que puede tomar ownership del
valor</span></p>
<p>Recibiremos un error porque el valor de <code>s</code> se mueve a <code>_s</code>, lo que invalida
usar <code>s</code> nuevamente. Sin embargo, usar solo el guion bajo no vincula el valor
en ning√∫n momento. El Listado 18-22 se compilar√° sin errores porque <code>s</code> no se
mueve a <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{s:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-22: Usar un guion bajo no vincula el
valor</span></p>
<p>Este c√≥digo funciona bien porque nunca vinculamos <code>s</code> a nada; no se mueve.</p>
<h4 id="ignorando-las-partes-restantes-de-un-valor-con-"><a class="header" href="#ignorando-las-partes-restantes-de-un-valor-con-">Ignorando las partes restantes de un valor con <code>..</code></a></h4>
<p>Con los valores que tiene muchas partes, podemos usar la sintaxis <code>..</code> para
usar partes espec√≠ficas e ignorar el resto, evitando la necesidad de enumerar
guiones bajos para cada valor ignorado. El pattern <code>..</code> ignora cualquier parte
de un valor que no hayamos coincidido expl√≠citamente en el resto del pattern.
En el Listado 18-23, tenemos un struct <code>Point</code> que contiene una coordenada en
el espacio tridimensional. En la expresi√≥n <code>match</code>, queremos operar solo en la
coordenada <code>x</code> e ignorar los valores en los campos <code>y</code> y <code>z</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x is {x}&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-23: Ignorando todos los campos de un <code>Point</code>
excepto <code>x</code> mediante el uso de <code>..</code></span></p>
<p>Listamos el valor <code>x</code> y luego simplemente incluimos el pattern <code>..</code>. Esto es
m√°s r√°pido que tener que listar <code>y: _</code> y <code>z: _</code>, particularmente cuando
estamos trabajando con structs que tienen muchos campos en situaciones en las
que solo uno o dos campos son relevantes.</p>
<p>La sintaxis <code>..</code> se expandir√° a tantos valores como sea necesario. El Listado
18-24 muestra c√≥mo usar <code>..</code> con una tupla.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {first}, {last}&quot;);
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-24: Coincidir solo con el primer y √∫ltimo
valor en una tupla e ignorar todos los dem√°s valores</span></p>
<p>En este c√≥digo, el primer y √∫ltimo valor se coinciden con <code>first</code> y <code>last</code>. El
<code>..</code> coincidir√° con cualquier n√∫mero de valores entre el primero y el √∫ltimo.</p>
<p>Sin embargo, el uso de <code>..</code> debe ser inequ√≠voco. Si no est√° claro qu√© valores
deben coincidir y cu√°les deben ignorarse, Rust nos dar√° un error. El Listado
18-25 muestra un ejemplo de usar <code>..</code> de manera ambigua, por lo que no se
compilar√°.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {second}&quot;)
        },
    }
}</code></pre>
<p><span class="caption">Listing 18-25: Un intento de usar <code>..</code> de manera
ambigua</span></p>
<p>Cuando compilamos este ejemplo, obtenemos este error:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin &quot;patterns&quot;) due to 1 previous error
</code></pre>
<p>Es imposible para Rust determinar cu√°ntos valores en la tupla ignorar antes de
hacer coincidir un valor con <code>second</code> y luego cu√°ntos valores m√°s ignorar
despu√©s. Este c√≥digo podr√≠a significar que queremos ignorar <code>2</code>, vincular
<code>second</code> a <code>4</code> y luego ignorar <code>8</code>, <code>16</code> y <code>32</code>; o que queremos ignorar <code>2</code> y
<code>4</code>, vincular <code>second</code> a <code>8</code> y luego ignorar <code>16</code> y <code>32</code>; y as√≠ sucesivamente.
El nombre de la variable <code>second</code> no significa nada especial para Rust, por lo
que obtenemos un error del compilador porque usar <code>..</code> en dos lugares como este
es ambiguo.</p>
<h3 id="condicionales-adicionales-con-match-guards"><a class="header" href="#condicionales-adicionales-con-match-guards">Condicionales adicionales con Match Guards</a></h3>
<p>Un <em>match guard</em> es una condici√≥n adicional <code>if</code>, especificada despu√©s del
pattern en una opci√≥n <code>match</code>, que tambi√©n debe coincidir para que se elija
esa opci√≥n. Los match guards son √∫tiles para expresar ideas m√°s complejas que
las que permite un pattern solo.</p>
<p>La condici√≥n puede utilizar variables creadas en el pattern. El Listado 18-26
muestra un <code>match</code> donde la primera opci√≥n tiene el pattern <code>Some(x)</code> y tambi√©n
tiene un match guard de <code>if x % 2 == 0</code> (que ser√° verdadero si el n√∫mero es
par).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;The number {x} is even&quot;),
        Some(x) =&gt; println!(&quot;The number {x} is odd&quot;),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-26: Agregando un match guard a un
pattern</span></p>
<p>Este ejemplo imprimir√° <code>The number 4 is even</code>. Cuando <code>num</code> se compara con el
pattern en la primera opci√≥n, coincide, porque <code>Some(4)</code> coincide con <code>Some(x)</code>.
Luego, el match guard verifica si el resto de dividir <code>x</code> por 2 es igual a 0,
y porque lo es, se selecciona la primera opci√≥n.</p>
<p>Si <code>num</code> hubiera sido <code>Some(5)</code>, el match guard en la primera opci√≥n habr√≠a
sido falso porque el resto de 5 dividido por 2 es 1, que no es igual a 0. Rust
entonces pasar√≠a a la segunda opci√≥n, que coincidir√≠a porque la segunda opci√≥n
no tiene un match guard y, por lo tanto, coincide con cualquier variante <code>Some</code>.</p>
<p>No hay forma de expresar la condici√≥n <code>if x % 2 == 0</code> dentro de un pattern, por
lo que el match guard nos da la capacidad de expresar esta l√≥gica. La
desventaja de esta expresividad adicional es que el compilador no intenta
verificar la exhaustividad cuando est√°n involucradas las expresiones de match
guard.</p>
<p>En el Listado 18-11, mencionamos que podr√≠amos usar match guards para resolver
nuestro problema de shadowing de pattern. Recordemos que creamos una nueva
variable dentro del pattern en la expresi√≥n <code>match</code> en lugar de usar la
variable fuera del <code>match</code>. Esa nueva variable significaba que no pod√≠amos
probar contra el valor de la variable externa. El Listado 18-27 muestra c√≥mo
podemos usar un match guard para solucionar este problema.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {n}&quot;),
        _ =&gt; println!(&quot;Default case, x = {x:?}&quot;),
    }

    println!(&quot;at the end: x = {x:?}, y = {y}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 18-27: Utilizando un match guard para probar
la igualdad con una variable externa</span></p>
<p>Este c√≥digo imprimir√° <code>Default case, x = Some(5)</code>. El pattern en la segunda
opci√≥n no introduce una nueva variable <code>y</code> que sombree la variable externa <code>y</code>,
por lo que podemos usar la variable externa <code>y</code> en el match guard. En lugar de
especificar el pattern como <code>Some(y)</code>, que habr√≠a sombreado la variable externa
<code>y</code>, especificamos <code>Some(n)</code>. Esto crea una nueva variable <code>n</code> que no sombrea
nada porque no hay una variable <code>n</code> fuera del <code>match</code>.</p>
<p>El match guard <code>if n == y</code> no es un pattern y, por lo tanto, no introduce nuevas
variables. Este <code>y</code> <em>es</em> el <code>y</code> externo en lugar de un nuevo <code>y</code> sombreado, y
podemos buscar un valor que tenga el mismo valor que el <code>y</code> externo comparando
<code>n</code> con <code>y</code>.</p>
<p>Tambi√©n puedes usar el operador <em>or</em> <code>|</code> en un match guard para especificar
m√∫ltiples patterns; la condici√≥n del match guard se aplicar√° a todos los
patterns. El Listado 18-28 muestra la precedencia al combinar un pattern que
usa <code>|</code> con un match guard. La parte importante de este ejemplo es que el
match guard <code>if y</code> se aplica a <code>4</code>, <code>5</code> y <em>6</em>, aunque podr√≠a parecer que <code>if y</code>
solo se aplica a <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-28: Combinando m√∫ltiples patterns con un match
guard</span></p>
<p>La condici√≥n de match establece que la opci√≥n solo coincide si el valor de <code>x</code>
es igual a <code>4</code>, <code>5</code> o <code>6</code> <em>y</em> si <code>y</code> es <code>true</code>. Cuando se ejecuta este c√≥digo,
el pattern de la primera opci√≥n coincide porque <code>x</code> es <code>4</code>, pero el match guard
<code>if y</code> es falso, por lo que no se elige la primera opci√≥n. El c√≥digo pasa a la
segunda opci√≥n, que coincide, y este programa imprime <code>no</code>. La raz√≥n es que la
condici√≥n <code>if</code> se aplica a todo el pattern <code>4 | 5 | 6</code>, no solo al √∫ltimo valor
<code>6</code>. En otras palabras, la precedencia de un match guard en relaci√≥n con un
pattern se comporta as√≠:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>en lugar de esto:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Despu√©s de ejecutar el c√≥digo, el comportamiento de precedencia es evidente: si
el match guard se aplicara solo al √∫ltimo valor en la lista de valores
especificados usando el operador <code>|</code>, la opci√≥n habr√≠a coincidido y el programa
habr√≠a impreso <code>yes</code>.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>El operador <code>@</code>, conocido como <em>at</em>, nos permite crear una variable que almacena
un valor al mismo tiempo que lo comprobamos para una coincidencia de pattern.
En el Listado 18-29, queremos probar que el campo <code>id</code> de un <code>Message::Hello</code>
est√° dentro del rango <code>3..=7</code>. Tambi√©n queremos vincular el valor a la variable
<code>id_variable</code> para poder usarlo en el c√≥digo asociado con la opci√≥n. Podr√≠amos
nombrar esta variable <code>id</code>, igual que el campo, pero para este ejemplo usaremos
un nombre diferente.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Found an id in range: {id_variable}&quot;),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {id}&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-29: Usando <code>@</code> para enlazar un valor en un
pattern mientras tambi√©n lo testeamos</span></p>
<p>Este ejemplo imprimir√° <code>Found an id in range: 5</code>. Al especificar <code>id_variable  @</code> antes del rango <code>3..=7</code>, estamos capturando cualquier valor que coincida con
el rango mientras tambi√©n probamos que el valor coincidi√≥ con el pattern de
rango.</p>
<p>En la segunda opci√≥n, donde solo tenemos especificado un rango en el patr√≥n,
el c√≥digo asociado a la opci√≥n no tiene una variable que contenga el valor real
del campo <code>id</code>. El campo <code>id</code> podr√≠a haber sido <code>10</code>, <code>11</code> o <code>12</code>, pero el
c√≥digo asociado al pattern no sabe cu√°l es. El c√≥digo del pattern no puede usar
el valor del campo <code>id</code> porque no hemos guardado el valor <code>id</code> en una variable.</p>
<p>En la √∫ltima opci√≥n, donde hemos especificado una variable sin un rango, s√≠
tenemos el valor disponible para usar en el c√≥digo de la opci√≥n en una variable
llamada <code>id</code>. La raz√≥n es que hemos usado la sintaxis de campo de struct
shorthand. Pero no hemos aplicado ninguna prueba al valor en el campo <code>id</code> en
esta opci√≥n, como hicimos con las dos primeras opciones: cualquier valor
coincidir√≠a con este pattern.</p>
<p>Usar <code>@</code> nos permite probar un valor y guardarlo en una variable dentro de un
mismo pattern.</p>
<h2 id="resumen-17"><a class="header" href="#resumen-17">Resumen</a></h2>
<p>Los patterns en Rust son muy √∫tiles para distinguir entre diferentes tipos de
datos. Cuando se usan en expresiones <code>match</code>, Rust garantiza que tus patterns
cubran todos los valores posibles, o tu programa no se compilar√°. Los patterns
en las declaraciones <code>let</code> y en los par√°metros de las funciones hacen que esos
constructos sean m√°s √∫tiles, permitiendo la deconstrucci√≥n de valores en partes
m√°s peque√±as al mismo tiempo que se asignan a variables. Podemos crear patterns
simples o complejos para adaptarse a nuestras necesidades.</p>
<p>A continuaci√≥n, para el pen√∫ltimo cap√≠tulo del libro, exploraremos algunos
aspectos avanzados de varias caracter√≠sticas de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caracter√≠sticas-avanzadas"><a class="header" href="#caracter√≠sticas-avanzadas">Caracter√≠sticas Avanzadas</a></h1>
<p>Por ahora, has aprendido las partes m√°s com√∫nmente usadas del lenguaje de
programaci√≥n Rust. Antes de hacer otro proyecto en el Cap√≠tulo 20, veremos
algunos aspectos del lenguaje que podr√≠as encontrar de vez en cuando, pero
que no usar√°s todos los d√≠as. Puede usar este cap√≠tulo como referencia para
cuando encuentre algo desconocido. Las caracter√≠sticas cubiertas aqu√≠ son
√∫tiles en situaciones muy espec√≠ficas. Aunque es posible que no alcances
a menudo, queremos asegurarnos de que tengas un dominio de todas las
caracter√≠sticas que Rust tiene para ofrecer.</p>
<p>En este cap√≠tulo, cubriremos:</p>
<ul>
<li>Unsafe Rust: c√≥mo optar por algunas de las garant√≠as de Rust y asumir la
responsabilidad de mantener manualmente esas garant√≠as</li>
<li>Traits avanzados: tipos asociados, par√°metros de tipo predeterminados,
sintaxis completamente calificada, supertraits y el patr√≥n newtype en
relaci√≥n con los traits</li>
<li>Tipos avanzados: m√°s sobre el pattern newtype, tipo alias, el tipo never y
tipos de tama√±o din√°mico</li>
<li>Funciones y closures avanzados: punteros a funciones y devoluci√≥n de
closures</li>
<li>Macros: formas de definir c√≥digo que define m√°s c√≥digo en tiempo de
compilaci√≥n</li>
</ul>
<p>¬°Es una panoplia de caracter√≠sticas de Rust con algo para todos! ¬°Vamos a
sumergirnos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<p>Todo el c√≥digo que hemos discutido hasta ahora ha tenido las garant√≠as de
seguridad de memoria de Rust aplicadas en tiempo de compilaci√≥n. Sin embargo,
Rust tiene un segundo lenguaje oculto dentro de √©l que no hace cumplir estas
garant√≠as de seguridad de memoria: se llama <em>unsafe Rust</em> y funciona como
Rust regular, pero nos da superpoderes adicionales.</p>
<p>Unsafe Rust existe porque, por naturaleza, el an√°lisis est√°tico es
conservador. Cuando el compilador intenta determinar si el c√≥digo cumple o no
con las garant√≠as, es mejor que rechace algunos programas v√°lidos que aceptar
algunos programas no v√°lidos. Aunque el c√≥digo <em>podr√≠a</em> estar bien, si el
compilador de Rust no tiene suficiente informaci√≥n para estar seguro, rechazar√°
el c√≥digo. En estos casos, puede usar c√≥digo inseguro para decirle al
compilador: &quot;Conf√≠a en m√≠, s√© lo que estoy haciendo&quot;. Sin embargo, debes tener
cuidado, ya que el uso de Unsafe Rust conlleva riesgos: si usas c√≥digo inseguro
de manera incorrecta, pueden ocurrir problemas debido a la inseguridad de la
memoria, como la desreferenciaci√≥n de puntero nulo.</p>
<p>Otra raz√≥n por la que Rust tiene un alter ego inseguro es que el hardware
inform√°tico subyacente es inherentemente inseguro. Si Rust no le permitiera
realizar operaciones inseguras, no podr√≠a realizar ciertas tareas. Rust
necesita permitirle realizar programaci√≥n de sistemas de bajo nivel, como
interactuar directamente con el sistema operativo o incluso escribir su propio
sistema operativo. Trabajar con programaci√≥n de sistemas de bajo nivel es uno
de los objetivos del lenguaje. Veamos qu√© podemos hacer con Rust inseguro y
c√≥mo hacerlo.</p>
<h3 id="superpoderes-unsafe"><a class="header" href="#superpoderes-unsafe">Superpoderes Unsafe</a></h3>
<p>Para cambiar a Unsafe Rust, use la palabra clave <code>unsafe</code> y luego comience un
nuevo bloque que contenga el c√≥digo inseguro. Puede tomar cinco acciones en
Rust inseguro que no puede en Rust seguro, que llamamos <em>superpoderes
Unsafe</em>. Esos superpoderes incluyen la capacidad de:</p>
<ul>
<li>Desreferenciar un puntero crudo</li>
<li>Llamar a una funci√≥n o m√©todo inseguro</li>
<li>Acceder o modificar una variable est√°tica mutable</li>
<li>Implementar un trait inseguro</li>
<li>Acceder a los campos de un <code>union</code></li>
</ul>
<p>Es importante entender que <code>unsafe</code> no desactiva el borrow checker ni
deshabilita ninguna otra de las comprobaciones de seguridad de Rust: si usa una
referencia en c√≥digo inseguro, a√∫n se verificar√°. La palabra clave <code>unsafe</code>
solo le da acceso a estas cinco funciones que luego no son verificadas por el
compilador para la seguridad de la memoria. A√∫n obtendr√° cierto grado de
seguridad dentro de un bloque inseguro.</p>
<p>Adem√°s, <code>unsafe</code> no significa que el c√≥digo dentro del bloque sea
necesariamente peligroso o que definitivamente tendr√° problemas de seguridad de
memoria: la intenci√≥n es que, como programador, se asegurar√° de que el c√≥digo
dentro de un bloque <code>unsafe</code> acceda a la memoria de una manera v√°lida.</p>
<p>Las personas son falibles y pueden cometer errores, pero al requerir que estas
cinco operaciones inseguras est√©n dentro de bloques anotados con <code>unsafe</code>,
sabr√° que cualquier error relacionado con la seguridad de la memoria debe estar
dentro de un bloque <code>unsafe</code>. Mantenga los bloques <code>unsafe</code> peque√±os; lo
agradecer√° m√°s tarde cuando investigue bugs de memoria.</p>
<p>Para aislar el c√≥digo inseguro tanto como sea posible, es mejor encerrar el
c√≥digo inseguro dentro de una abstracci√≥n segura y proporcionar una API segura,
que discutiremos m√°s adelante en el cap√≠tulo cuando examinemos las funciones y
m√©todos inseguros. Partes de la biblioteca est√°ndar se implementan como
abstracciones seguras sobre c√≥digo inseguro que ha sido auditado. Envolver el
c√≥digo inseguro en una abstracci√≥n segura evita que los usos de <code>unsafe</code> se
filtren en todos los lugares que usted o sus usuarios puedan querer usar la
funcionalidad implementada con c√≥digo <code>unsafe</code>, porque usar una abstracci√≥n
segura es seguro.</p>
<p>Veamos cada uno de los cinco superpoderes unsafe a su vez. Tambi√©n
veremos algunas abstracciones que proporcionan una interfaz segura al c√≥digo
inseguro.</p>
<h3 id="desreferenciaci√≥n-de-un-puntero-crudo"><a class="header" href="#desreferenciaci√≥n-de-un-puntero-crudo">Desreferenciaci√≥n de un puntero crudo</a></h3>
<p>En el Cap√≠tulo 4, en la secci√≥n <a href="ch04-02-references-and-borrowing.html#referencias-colgantes"><code>Referencias y punteros</code></a></p>
<!-- ignore--> mencionamos que el compilador garantiza que las referencias siempre son v√°lidas.
<p>Unsafe Rust tiene dos nuevos tipos llamados <em>punteros crudos</em> que son similares
a las referencias. Al igual que con las referencias, los punteros crudos pueden
ser inmutables o mutables y
se escriben como <code>*const T</code> y <code>*mut T</code>, respectivamente. El asterisco no es el
operador de desreferencia; es parte del nombre del tipo. En el contexto de los
punteros crudos, <em>inmutable</em> significa que el puntero no se puede asignar
directamente despu√©s de ser desreferenciado.</p>
<p>A Diferencia de las referencias y los smart pointers, los punteros crudos:</p>
<ul>
<li>Son permitidos ignorar las reglas de borrowing al tener tanto punteros
inmutables como mutables o m√∫ltiples punteros mutables al mismo lugar</li>
<li>No se garantiza que apunten a una memoria v√°lida</li>
<li>Se les permite ser nulos</li>
<li>No implementan ninguna limpieza autom√°tica</li>
</ul>
<p>Al optar por no hacer que Rust haga cumplir estas garant√≠as, puede renunciar a
la seguridad garantizada a cambio de un mayor rendimiento o la capacidad de
interactuar con otro lenguaje o hardware donde las garant√≠as de Rust no se
aplican.</p>
<p>El Listing 19-1 muestra c√≥mo crear un puntero crudo inmutable y mutable a
partir de referencias.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-1: Creando punteros crudos a partir de
referencias</span></p>
<p>Observa que no incluimos la palabra clave <code>unsafe</code> en este c√≥digo. Podemos
crear punteros crudos en c√≥digo seguro; simplemente no podemos desreferenciar
punteros crudos fuera de un bloque <code>unsafe</code>, como ver√°s en un momento.</p>
<p>Hemos creado punteros crudos utilizando <code>as</code> para convertir una referencia
inmutable y una mutable en sus tipos de puntero crudo correspondientes. Como
los creamos directamente a partir de referencias garantizadas como v√°lidas,
sabemos que estos punteros crudos particulares son v√°lidos, pero no podemos
hacer esa suposici√≥n sobre cualquier puntero crudo.</p>
<p>Para demostrar esto, a continuaci√≥n crearemos un puntero crudo cuya validez
no podemos estar tan seguros. El Listado 19-2 muestra c√≥mo crear un puntero
crudo a una ubicaci√≥n arbitraria en la memoria. Intentar usar memoria arbitraria
es indefinido: puede haber datos en esa direcci√≥n o no, el compilador puede
optimizar el c√≥digo para que no haya acceso a la memoria, o el programa puede
generar un error con un fallo de segmentaci√≥n. Por lo general, no hay una buena
raz√≥n para escribir c√≥digo como este, pero es posible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-2: Creando un puntero crudo a una direcci√≥n de
memoria arbitraria</span></p>
<p>Recuerda que podemos crear punteros crudos en c√≥digo seguro, pero no podemos
<em>desreferenciar</em> punteros crudos y leer la memoria a la que apuntan fuera de un
bloque <code>unsafe</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        println!(&quot;r2 is: {}&quot;, *r2);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-3: Desreferenciando punteros crudos dentro de
un bloque <code>unsafe</code></span></p>
<p>Crear un puntero no causa da√±o; solo cuando intentamos acceder al valor al que
apunta que podr√≠amos terminar tratando con un valor no v√°lido.</p>
<p>Tambi√©n ten en cuenta que en los Listados 19-1 y 19-3, creamos <code>*const i32</code> y
<code>*mut i32</code> punteros crudos que apuntaban a la misma ubicaci√≥n de memoria, donde
se almacena <code>num</code>. Si en su lugar intent√°ramos crear una referencia inmutable y
mutable a <code>num</code>, el c√≥digo no se compilar√≠a porque las reglas de ownership de
Rust no permiten una referencia mutable al mismo tiempo que cualquier referencia
inmutable. Con punteros crudos, podemos crear un puntero mutable y un puntero
inmutable a la misma ubicaci√≥n y cambiar los datos a trav√©s del puntero mutable,
potencialmente creando una carrera de datos. ¬°Ten cuidado!</p>
<p>Con todos estos peligros, ¬øpor qu√© usar√≠as punteros crudos? Un caso de uso
importante es cuando se interact√∫a con c√≥digo C, como ver√°s en la siguiente
secci√≥n, <a href="ch19-01-unsafe-rust.html#llamando-a-una-funcion-o-metodo-inseguro">‚ÄúLlamando a una funci√≥n o m√©todo
inseguro‚Äù</a>.<!-- ignore --> Otro caso es
cuando se construyen abstracciones seguras que el borrow checker no entiende.
Presentaremos funciones inseguras y luego veremos un ejemplo de una abstracci√≥n
segura que usa c√≥digo inseguro.</p>
<h3 id="llamando-a-una-funcion-o-metodo-inseguro"><a class="header" href="#llamando-a-una-funcion-o-metodo-inseguro">Llamando a una funcion o metodo inseguro</a></h3>
<p>El segundo tipo de operaci√≥n que solo se puede realizar en un bloque unsafe es
llamar a una funci√≥n o m√©todo inseguro. Podemos crear funciones inseguras y
m√©todos inseguros que se ven exactamente como funciones y m√©todos regulares,
pero tienen un <code>unsafe</code> adicional antes del resto de la definici√≥n. La palabra
clave <code>unsafe</code> en este contexto indica que la funci√≥n tiene requisitos que
debemos cumplir cuando llamamos a esta funci√≥n porque Rust no puede garantizar
que hayamos cumplido con estos requisitos. Al llamar a una funci√≥n insegura
dentro de un bloque <code>unsafe</code>, estamos diciendo que hemos le√≠do la documentaci√≥n
de esta funci√≥n y asumimos la responsabilidad de cumplir con los contratos de
la funci√≥n.</p>
<p>Aqu√≠ hay un ejemplo de una funci√≥n insegura llamada <code>dangerous</code> que no hace
nada en su cuerpo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>Debemos llamar a la funci√≥n <code>dangerous</code> dentro de un bloque <code>unsafe</code> separado.
Si intentamos llamar a esta funci√≥n sin un bloque <code>unsafe</code>, obtendremos un<br />
error:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin &quot;unsafe-example&quot;) due to 1 previous error
</code></pre>
<p>Con el bloque <code>unsafe</code>, le estamos indicando a Rust que hemos le√≠do la
documentaci√≥n de la funci√≥n, entendemos c√≥mo usarla correctamente y hemos
verificado que estamos cumpliendo con el contrato de la funci√≥n.</p>
<p>Los cuerpos de las funciones <code>unsafe</code> son similares a los bloques <code>unsafe</code>,
por lo que para realizar otras operaciones <code>unsafe</code> dentro de una funci√≥n
<code>unsafe</code>, no necesitamos agregar otro bloque <code>unsafe</code>.</p>
<h4 id="creando-una-abstracci√≥n-segura-sobre-c√≥digo-inseguro"><a class="header" href="#creando-una-abstracci√≥n-segura-sobre-c√≥digo-inseguro">Creando una abstracci√≥n segura sobre c√≥digo inseguro</a></h4>
<p>Solo porque una funci√≥n contiene c√≥digo inseguro no significa que debamos
marcar toda la funci√≥n como insegura. De hecho, envolver el c√≥digo inseguro en
una funci√≥n segura es una abstracci√≥n com√∫n. Como ejemplo, estudiemos la
funci√≥n <code>split_at_mut</code> de la biblioteca est√°ndar, que requiere algo de c√≥digo
inseguro. Exploraremos c√≥mo podr√≠amos implementarlo. Este m√©todo seguro est√°
definido en slices mutables: toma un slice y lo divide en dos al dividir
el slice en el √≠ndice dado como argumento. El Listado 19-4 muestra c√≥mo usar
<code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-4: Usando la funci√≥n segura
<code>split_at_mut</code></span></p>
<p>No podemos implementar esta funci√≥n utilizando solo Rust seguro. Un intento
podr√≠a ser algo como el Listado 19-5, que no se compilar√°. Para simplificar,
implementaremos <code>split_at_mut</code> como una funci√≥n en lugar de un m√©todo y solo
para slices de valores <code>i32</code> en lugar de para un tipo gen√©rico <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 19-5: Un intento de implementaci√≥n de
<code>split_at_mut</code> usando solo Rust seguro</span></p>
<p>Esta funci√≥n primero obtiene la longitud total del slice. Luego verifica si el
√≠ndice dado como par√°metro est√° dentro del slice al verificar si es menor o
igual a la longitud. La aserci√≥n significa que si pasamos un √≠ndice que es
mayor que la longitud para dividir el slice, la funci√≥n entrar√° en panic
antes de intentar usar ese √≠ndice.</p>
<p>Luego, devolvemos dos slices mutables en una tupla: uno desde el inicio del
slice original hasta el √≠ndice <code>mid</code> y otro desde <code>mid</code> hasta el final del
slice.</p>
<p>Cuando intentamos compilar el c√≥digo en el Listado 19-5, obtendremos un error:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin &quot;unsafe-example&quot;) due to 1 previous error
</code></pre>
<p>El borrow checker de Rust no puede entender que estamos tomando prestado
diferentes partes del slice; solo sabe que estamos tomando prestado el mismo
slice dos veces. Tomar prestadas diferentes partes de un slice es
fundamentalmente correcto porque los dos slices no se superponen, pero Rust no
es lo suficientemente inteligente como para saber esto. Cuando sabemos que el
c√≥digo est√° bien, pero Rust no lo sabe, es hora de recurrir al c√≥digo inseguro.</p>
<p>El Listado 19-6 muestra c√≥mo usar un bloque <code>unsafe</code>, un puntero sin procesar
y algunas llamadas a funciones inseguras para hacer que la implementaci√≥n de
<code>split_at_mut</code> funcione.</p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-6: Usando c√≥digo inseguro en la implementaci√≥n
de la funci√≥n <code>split_at_mut</code></span></p>
<p>Recordemos la secci√≥n <a href="ch04-03-slices.html#el-tipo-slice">‚ÄúThe Slice Type‚Äù</a><!-- ignore --> del
Cap√≠tulo 4 que los slices son un puntero a algunos datos y la longitud del
slice. Usamos el m√©todo <code>len</code> para obtener la longitud del slice y el m√©todo
<code>as_mut_ptr</code> para acceder al puntero sin procesar de un slice. En este caso,
porque tenemos un slice mutable a valores <code>i32</code>, <code>as_mut_ptr</code> devuelve un
puntero sin procesar con el tipo <code>*mut i32</code>, que hemos almacenado en la
variable <code>ptr</code>.</p>
<p>Mantenemos la afirmaci√≥n de que el √≠ndice <code>mid</code> est√° dentro del slice. Luego
llegamos al c√≥digo inseguro: la funci√≥n <code>slice::from_raw_parts_mut</code> toma un
puntero sin procesar y una longitud, y crea un slice. Usamos esta funci√≥n para
crear un slice que comienza desde <code>ptr</code> y es <code>mid</code> elementos de largo. Luego
llamamos al m√©todo <code>add</code> en <code>ptr</code> con <code>mid</code> como argumento para obtener un
puntero sin procesar que comienza en <code>mid</code>, y creamos un slice usando ese
puntero y el n√∫mero restante de elementos despu√©s de <code>mid</code> como la longitud.</p>
<p>La funci√≥n <code>slice::from_raw_parts_mut</code> es insegura porque toma un puntero sin
procesar y debe confiar en que este puntero es v√°lido. El m√©todo <code>add</code> en
punteros sin procesar tambi√©n es inseguro porque debe confiar en que la
ubicaci√≥n del desplazamiento tambi√©n es un puntero v√°lido. Por lo tanto,
tuvimos que poner un bloque <code>unsafe</code> alrededor de nuestras llamadas a
<code>slice::from_raw_parts_mut</code> y <code>add</code> para poder llamarlas. Al mirar el c√≥digo y
al agregar la afirmaci√≥n de que <code>mid</code> debe ser menor o igual a <code>len</code>, podemos
decir que todos los punteros sin procesar utilizados dentro del bloque
<code>unsafe</code> ser√°n punteros v√°lidos a datos dentro del slice. Este es un uso
aceptable y apropiado de <code>unsafe</code>.</p>
<p>Tenga en cuenta que no necesitamos marcar la funci√≥n resultante <code>split_at_mut</code>
como <code>unsafe</code>, y podemos llamar a esta funci√≥n desde Rust seguro. Hemos creado
una abstracci√≥n segura para el c√≥digo inseguro con una implementaci√≥n de la
funci√≥n que usa c√≥digo <code>unsafe</code> de manera segura, porque crea solo punteros
v√°lidos a partir de los datos a los que esta funci√≥n tiene acceso.</p>
<p>Por el contrario, el uso de <code>slice::from_raw_parts_mut</code> en el Listado 19-7
probablemente se bloquear√° cuando se use el slice. Este c√≥digo toma una
ubicaci√≥n de memoria arbitraria y crea un slice de 10,000 elementos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-7: Creando un slice a partir de una ubicaci√≥n
de memory arbitraria</span></p>
<p>No somos propietarios de la memoria en esta ubicaci√≥n arbitraria, y no hay
garant√≠a de que el slice que este c√≥digo crea contenga valores <code>i32</code> v√°lidos.
Intentar usar <code>values</code> como si fuera un slice v√°lido da como resultado un
comportamiento indefinido.</p>
<h4 id="usando-funciones-extern-para-llamar-c√≥digo-externo"><a class="header" href="#usando-funciones-extern-para-llamar-c√≥digo-externo">Usando funciones <code>extern</code> para llamar c√≥digo externo</a></h4>
<p>A veces, tu c√≥digo en Rust necesita interactuar con c√≥digo escrito en otro
lenguaje. Para esto, Rust tiene la palabra clave <code>extern</code> que facilita la
creaci√≥n y el uso de una <em>Foreign Function Interface (FFI)</em>. Una FFI es una
forma para que un lenguaje de programaci√≥n defina funciones y permita que un
lenguaje de programaci√≥n diferente (extranjero) llame a esas funciones.</p>
<p>El Listado 19-8 demuestra c√≥mo configurar una integraci√≥n con la funci√≥n <code>abs</code>
de la biblioteca est√°ndar de C. Las funciones declaradas dentro de bloques
<code>extern</code> siempre son inseguras de llamar desde el c√≥digo Rust. La raz√≥n es que
otros lenguajes no hacen cumplir las reglas y garant√≠as de Rust, y Rust no
puede verificarlas, por lo que la responsabilidad recae en el programador para
garantizar la seguridad.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}</code></pre></pre>
<p><span class="caption">Listing 19-8: Declarando y llamando a una funci√≥n <code>extern</code>
definida en otro lenguaje</span></p>
<p>Dentro del bloque <code>extern &quot;C&quot;</code> en el Listado 19-8, enumeramos los nombres y
las firmas de las funciones externas que queremos llamar. El nombre y la firma
de la funci√≥n <code>abs</code> se definen en el est√°ndar C y son parte de la biblioteca
est√°ndar de C. La firma de la funci√≥n <code>abs</code> es <code>int abs(int)</code>, lo que significa
que toma un argumento <code>int</code> y devuelve un <code>int</code>. La funci√≥n <code>abs</code> devuelve el
valor absoluto de su argumento.</p>
<blockquote>
<h4 id="llamando-a-funciones-rust-desde-otros-lenguajes"><a class="header" href="#llamando-a-funciones-rust-desde-otros-lenguajes">Llamando a funciones Rust desde otros lenguajes</a></h4>
<p>Tambi√©n podemos usar <code>extern</code> para crear una interfaz que permita que otros
lenguajes llamen funciones Rust. En lugar de crear un bloque <code>extern</code>, podemos
agregar la palabra clave <code>extern</code> y especificar la ABI a usar justo antes de
la palabra clave <code>fn</code> para la funci√≥n relevante. Tambi√©n necesitamos agregar
una anotaci√≥n <code>#[no_mangle]</code> para decirle al compilador de Rust que no
cambie el nombre de esta funci√≥n. <em>Mangling</em> es cuando un compilador cambia
el nombre que le hemos dado a una funci√≥n a un nombre diferente que contiene
m√°s informaci√≥n para otras partes del proceso de compilaci√≥n para consumir,
, pero es menos legible para los humanos. Cada compilador de lenguaje de
programaci√≥n mangla los nombres de manera ligeramente diferente, por lo que
para que una funci√≥n Rust sea nombrable por otros lenguajes, debemos
deshabilitar el mangling del compilador de Rust.</p>
<p>En el siguiente ejemplo, hacemos que la funci√≥n <code>call_from_c</code> sea accesible
desde el c√≥digo C, despu√©s de que se compile a una biblioteca compartida y
se vincule desde C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Este uso de <code>extern</code> no requiere <code>unsafe</code>.</p>
</blockquote>
<h3 id="acceder-o-modificar-una-variable-est√°tica-mutable"><a class="header" href="#acceder-o-modificar-una-variable-est√°tica-mutable">Acceder o modificar una variable est√°tica mutable</a></h3>
<p>En este libro, a√∫n no hemos hablado de <em>variables globales</em>, las cuales Rust
admite, pero pueden ser problem√°ticas con las reglas de ownership de Rust. Si
dos hilos acceden a la misma variable global mutable, puede causar una
condici√≥n de carrera.</p>
<p>En Rust, las variables globales son llamadas variables <em>static</em>. El Listado
19-9 muestra un ejemplo de declaraci√≥n y uso de una variable static con un
string slice como valor.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {HELLO_WORLD}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 19-9: Definici√≥n y uso de una variable static
inmutable</span></p>
<p>Las static variables son similares a las constantes, que discutimos en la
secci√≥n <a href="ch03-01-variables-and-mutability.html#constantes">&quot;Diferencias entre variables y
constantes&quot;</a> en el Cap√≠tulo 3. Los
nombres de las variables static est√°n en <code>SCREAMING_SNAKE_CASE</code> por convenci√≥n.
Las variables static solo pueden almacenar referencias con el lifetime
<code>'static</code>, lo que significa que el compilador de Rust puede calcular el
lifetime y no estamos obligados a anotarlo expl√≠citamente. Acceder a una
variable static inmutable es seguro.</p>
<p>Una diferencia sutil entre constantes y variables static inmutables es que los
valores en una variable static tienen una direcci√≥n fija en la memoria. Usar el
valor siempre acceder√° a los mismos datos. Las constantes, por otro lado,
pueden duplicar sus datos cada vez que se usan. Otra diferencia es que las
variables static pueden ser mutables. Acceder y modificar variables static
mutables es <em>inseguro</em>. El Listado 19-10 muestra c√≥mo declarar, acceder y
modificar una variable static mutable llamada <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {COUNTER}&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listing 19-10: Leer o escribir en una variable static
mutable es inseguro</span></p>
<p>Como con las variables regulares, especificamos la mutabilidad usando la
palabra clave <code>mut</code>. Cualquier c√≥digo que lea o escriba desde <code>COUNTER</code> debe
estar dentro de un bloque <code>unsafe</code>. Este c√≥digo se compila e imprime <code>COUNTER: 3</code> como esperar√≠amos porque es de un solo hilo. Tener m√∫ltiples hilos accediendo
a <code>COUNTER</code>, probablemente habr√≠a condiciones de carrera.</p>
<p>Con datos mutables que son accesibles globalmente, es dif√≠cil asegurarse de que
no haya carreras de datos, por lo que Rust considera que las variables static
mutables son inseguras. Cuando sea posible, es preferible usar las t√©cnicas de
concurrencia y los smart pointers seguros para los hilos que discutimos en el
Cap√≠tulo 16, para que el compilador verifique que los datos a los que se accede
desde diferentes hilos se hagan de manera segura.</p>
<h3 id="implementando-un-trait-inseguro"><a class="header" href="#implementando-un-trait-inseguro">Implementando un trait inseguro</a></h3>
<p>Podemos usar <code>unsafe</code> para implementar un trait inseguro. Un trait se considera
inseguro cuando al menos uno de sus m√©todos tiene alg√∫n invariante que el
compilador no puede verificar. Declaramos que un trait es <code>unsafe</code> agregando la
palabra clave <code>unsafe</code> antes de <code>trait</code> y marcando la implementaci√≥n del trait
como <code>unsafe</code> tambi√©n, como se muestra en el Listado 19-11.</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}</code></pre></pre>
<p><span class="caption">Listing 19-11: Definiendo e implementando un trait
inseguro</span></p>
<p>Al utilizar <code>unsafe impl</code>, estamos prometiendo que mantendremos las invariantes
que el compilador no puede verificar.</p>
<p>Como ejemplo, recordemos los marcadores de traits <code>Sync</code> y <code>Send</code> que
discutimos en la secci√≥n <a href="ch16-04-extensible-concurrency-sync-and-send.html#concurrencia-extensible-con-los-traits-sync-y-send">&quot;Concurrencia extensible con los traits <code>Sync</code> y
<code>Send</code>&quot;</a> en el Cap√≠tulo
16: el compilador implementa estos traits autom√°ticamente si nuestros tipos se
componen √∫nicamente de tipos <code>Send</code> y <code>Sync</code>. Si implementamos un tipo que
contiene un tipo que no es <code>Send</code> o <code>Sync</code>, como punteros crudos, y queremos
marcar ese tipo como <code>Send</code> o <code>Sync</code>, debemos usar <code>unsafe</code>. Rust no puede
verificar que nuestro tipo cumpla con las garant√≠as de que se puede enviar
seguramente a trav√©s de hilos o acceder desde m√∫ltiples hilos; por lo tanto,
debemos hacer esas comprobaciones manualmente e indicarlo con <code>unsafe</code>.</p>
<h3 id="acceder-a-los-campos-de-una-union"><a class="header" href="#acceder-a-los-campos-de-una-union">Acceder a los campos de una union</a></h3>
<p>La √∫ltima acci√≥n que solo se puede realizar con <code>unsafe</code> es acceder a los
campos de una <em>union</em>. Una <code>union</code> es similar a una <code>struct</code>, pero solo un
campo declarado se usa en una instancia particular en un momento dado. Las
unions se usan principalmente para interactuar con unions en c√≥digo C. Acceder
a los campos de la union es inseguro porque Rust no puede garantizar el tipo de
los datos que se almacenan actualmente en la instancia de la union. Puedes
aprender m√°s sobre las uniones en <a href="https://doc.rust-lang.org/reference/items/unions.html">la Referencia de Rust</a>.</p>
<h3 id="cu√°ndo-usar-c√≥digo-inseguro"><a class="header" href="#cu√°ndo-usar-c√≥digo-inseguro">Cu√°ndo usar c√≥digo inseguro</a></h3>
<p>Utilizar <code>unsafe</code> para llevar a cabo una de las cinco acciones (superpoderes)
que se acaban de mencionar no est√° mal ni se desaconseja. Sin embargo, es m√°s
dif√≠cil obtener c√≥digo <code>unsafe</code> correcto porque el compilador no puede ayudar a
mantener la seguridad de la memoria. Cuando tengas una raz√≥n para usar c√≥digo
<code>unsafe</code>, puedes hacerlo, y tener la anotaci√≥n <code>unsafe</code> expl√≠cita hace que sea
m√°s f√°cil rastrear la fuente de los problemas cuando ocurren.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="traits-avanzados"><a class="header" href="#traits-avanzados">Traits Avanzados</a></h2>
<p>Primero cubrimos los traits en la secci√≥n <a href="ch10-02-traits.html#traits-definiendo-comportamiento-compartido">&quot;Traits: Defining Shared
Behavior&quot;</a><!-- ignore --> del Cap√≠tulo 10, pero
no discutimos los detalles m√°s avanzados. Ahora que conoces m√°s Rust, podemos
entrar en los detalles m√°s minuciosos.</p>
<h3 id="especificando-tipos-de-marcador-en-definiciones-de-traits-con-tipos-asociados"><a class="header" href="#especificando-tipos-de-marcador-en-definiciones-de-traits-con-tipos-asociados">Especificando Tipos de Marcador en Definiciones de Traits con Tipos Asociados</a></h3>
<p>Los <em>tipos asociados</em> conectan un marcador de tipo con un trait de modo que los
m√©todos de definici√≥n de trait puedan usar estos marcadores de tipo en sus
firmas. El implementador de un trait especificar√° el tipo concreto que se
utilizar√° en lugar del tipo de marcador para la implementaci√≥n particular. De
esa manera, podemos definir un trait que use algunos tipos sin necesidad de
saber exactamente cu√°les son esos tipos hasta que se implemente el trait.</p>
<p>Hemos descrito la mayor√≠a de las caracter√≠sticas avanzadas en este cap√≠tulo
como poco necesarias. Los tipos asociados est√°n en alg√∫n lugar en el medio: se
utilizan con menos frecuencia que las caracter√≠sticas explicadas en el resto
del libro, pero con m√°s frecuencia que muchas de las otras caracter√≠sticas
discutidas en este cap√≠tulo.</p>
<p>Un ejemplo de un trait con un tipo asociado es el trait <code>Iterator</code> que la
biblioteca est√°ndar proporciona. El tipo asociado se llama <code>Item</code> y representa
el tipo de los valores que el tipo que implementa el trait <code>Iterator</code> est√°
iterando. La definici√≥n del trait <code>Iterator</code> es como se muestra en el Listado
19-12.</p>
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<p><span class="caption">Listing 19-12: La definici√≥n del trait <code>Iterator</code> que
tiene un tipo asociado <code>Item</code></span></p>
<p>El tipo <code>Item</code> es un marcador de tipo, y la definici√≥n del m√©todo <code>next</code> muestra
que devolver√° valores del tipo <code>Option&lt;Self::Item&gt;</code>. Los implementadores del
trait <code>Iterator</code> especificar√°n el tipo concreto para <code>Item</code>, y el m√©todo <code>next</code>
devolver√° una <code>Option</code> que contiene un valor de ese tipo concreto.</p>
<p>Los tipos asociados pueden parecer un concepto similar a los generics, ya que
estos √∫ltimos nos permiten definir una funci√≥n sin especificar qu√© tipos puede
manejar. Para examinar la diferencia entre los dos conceptos, veremos una
implementaci√≥n del trait <code>Iterator</code> en un tipo llamado <code>Counter</code> que especifica
que el tipo <code>Item</code> es <code>u32</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Esta sintaxis parece comparable a la de los generics. Entonces, ¬øpor qu√© no
definir simplemente el trait <code>Iterator</code> con generics, como se muestra en el
Listado 19-13?</p>
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<p><span class="caption">Listing 19-13: Una definici√≥n hipot√©tica del trait
<code>Iterator</code> usando generics</span></p>
<p>La diferencia es que cuando usamos generics, como en el Listado 19-13, debemos
anotar los tipos en cada implementaci√≥n; porque tambi√©n podemos implementar
<code>Iterator&lt;String&gt; for Counter</code> o cualquier otro tipo, podr√≠amos tener
m√∫ltiples implementaciones de <code>Iterator</code> para <code>Counter</code>. En otras palabras,
cuando un trait tiene un par√°metro gen√©rico, puede implementarse para un tipo
m√∫ltiples veces, cambiando los tipos concretos de los par√°metros gen√©ricos de
tipo cada vez. Cuando usamos el m√©todo <code>next</code> en <code>Counter</code>, tendr√≠amos que
proporcionar anotaciones de tipo para indicar qu√© implementaci√≥n de <code>Iterator</code>
queremos usar.</p>
<p>Con los tipos asociados, no necesitamos anotar los tipos porque no podemos
implementar un trait en un tipo m√∫ltiples veces. En el Listado 19-12 con la
definici√≥n que usa tipos asociados, solo podemos elegir cu√°l ser√° el tipo de
<code>Item</code> una vez, porque solo puede haber un <code>impl Iterator for Counter</code>. No
tenemos que especificar que queremos un iterador de valores <code>u32</code> en todas
partes que llamamos a <code>next</code> en <code>Counter</code>.</p>
<p>Los tipos asociados tambi√©n forman parte del contrato del trait: los
implementadores del trait deben proporcionar un tipo para que se use en lugar
del marcador de tipo. Los tipos asociados a menudo tienen un nombre que
describe c√≥mo se usar√° el tipo, y documentar el tipo asociado en la
documentaci√≥n de la API es una buena pr√°ctica.</p>
<h3 id="par√°metros-generics-predeterminados-y-sobrecarga-de-operadores"><a class="header" href="#par√°metros-generics-predeterminados-y-sobrecarga-de-operadores">Par√°metros Generics Predeterminados y Sobrecarga de Operadores</a></h3>
<p>Cuando utilizamos par√°metros de tipo generic, podemos especificar un tipo
concreto predeterminado para el tipo generic. Esto elimina la necesidad de que
los implementadores del trait especifiquen un tipo concreto si el tipo
predeterminado funciona. Especificas un tipo predeterminado al declarar un tipo
generic con la sintaxis <code>&lt;TipoMarcador=TipoConcreto&gt;</code>.</p>
<p>Un ejemplo excelente de una situaci√≥n en la que esta t√©cnica es √∫til es con la
sobrecarga de operadores, en la que personalizas el comportamiento de un
operador (como <code>+</code>) en situaciones particulares.</p>
<p>Rust no te permite crear tus propios operadores o sobrecargar operadores
arbitrarios. Pero puedes sobrecargar las operaciones y los traits
correspondientes enumerados en <code>std::ops</code> implementando los traits asociados
con el operador. Por ejemplo, en el Listado 19-14 sobrecargamos el operador <code>+</code>
para agregar dos instancias de <code>Point</code> juntas. Hacemos esto implementando el
trait <code>Add</code> en un struct <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<p><span class="caption">Listing 19-14: Implementando el trait <code>Add</code> para
sobrecargar el operador <code>+</code> para instancias <code>Point</code></span></p>
<p>El m√©todo <code>add</code> suma los valores <code>x</code> de dos instancias <code>Point</code> y los valores <code>y</code>
de dos instancias <code>Point</code> para crear una nueva instancia <code>Point</code>. El trait <code>Add</code>
tiene un tipo asociado llamado <code>Output</code> que determina el tipo devuelto desde el
m√©todo <code>add</code>.</p>
<p>El tipo generic predeterminado en este c√≥digo est√° dentro del trait <code>Add</code>. Aqu√≠
est√° su definici√≥n:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>Este c√≥digo deber√≠a resultar familiar en general: un trait con un m√©todo y un
tipo asociado. La nueva parte es <code>Rhs=Self</code>: esta sintaxis se llama <em>par√°metros
de tipo predeterminados</em>. El par√°metro de tipo generic <code>Rhs</code> (abreviatura de
‚Äúlado derecho‚Äù) define el tipo del par√°metro <code>rhs</code> en el m√©todo <code>add</code>. Si no
especificamos un tipo concreto para <code>Rhs</code> cuando implementamos el trait <code>Add</code>,
el tipo de <code>Rhs</code> ser√° predeterminado a <code>Self</code>, que ser√° el tipo en el que
estamos implementando <code>Add</code>.</p>
<p>Cuando implementamos <code>Add</code> para <code>Point</code>, utilizamos el valor predeterminado para
<code>Rhs</code> porque queremos agregar dos <code>Point</code> instancias. Veamos un ejemplo de
implementaci√≥n del trait <code>Add</code> donde queremos personalizar el tipo <code>Rhs</code> en
lugar de usar el predeterminado.</p>
<p>Tenemos dos structs, <code>Millimeters</code> y <code>Meters</code>, que contienen valores en
unidades diferentes. Este envoltorio ligero de un tipo existente en otro struct
se conoce como el <em>patr√≥n newtype</em>, que describimos con m√°s detalle en la
secci√≥n <a href="ch19-03-advanced-traits.html#usando-el-pattern-newtype-para-implementar-traits-externos-en-tipos-externos">‚ÄúUsando el Patr√≥n Newtype para Implementar Traits Externos en Tipos
Externos‚Äù</a>. Queremos agregar valores en mil√≠metros a valores en metros
y que la implementaci√≥n de <code>Add</code> haga la conversi√≥n correctamente. Podemos
implementar <code>Add</code> para <code>Millimeters</code> con <code>Meters</code> como <code>Rhs</code>, como se muestra en
el Listado 19-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<p><span class="caption">Listing 19-15: Implementando el trait <code>Add</code> en
<code>Millimeters</code> para sumar <code>Millimeters</code> a <code>Meters</code></span></p>
<p>Para agregar <code>Millimeters</code> y <code>Meters</code>, especificamos <code>impl Add&lt;Meters&gt;</code> para
establecer el valor del par√°metro de tipo <code>Rhs</code> en lugar de usar el
predeterminado de <code>Self</code>.</p>
<p>Se utilizan los par√°metros de tipo predeterminados en dos casos principales:</p>
<ul>
<li>Para extender un tipo sin romper el c√≥digo existente</li>
<li>Para permitir la personalizaci√≥n en casos espec√≠ficos que la mayor√≠a de los
usuarios no necesitar√°n</li>
</ul>
<p>El trait <code>Add</code> de la biblioteca est√°ndar es un ejemplo del segundo prop√≥sito:
normalmente, agregar√°s dos tipos similares, pero el trait <code>Add</code> proporciona la
capacidad de personalizar m√°s all√° de eso. El uso de un par√°metro de tipo
predeterminado en la definici√≥n del trait <code>Add</code> significa que no tienes que
especificar el par√°metro extra la mayor parte del tiempo. En otras palabras, no
se necesita un poco de boilerplate de implementaci√≥n, lo que facilita el uso del
trait.</p>
<p>El primer prop√≥sito es similar al segundo, pero al rev√©s: si quieres agregar un
par√°metro de tipo a un trait existente, puedes darle un valor predeterminado
para permitir la extensi√≥n de la funcionalidad del trait sin romper el c√≥digo
de implementaci√≥n existente.</p>
<h3 id="sintaxis-completamente-calificada-para-la-desambiguaci√≥n-llamando-m√©todos-con-el-mismo-nombre"><a class="header" href="#sintaxis-completamente-calificada-para-la-desambiguaci√≥n-llamando-m√©todos-con-el-mismo-nombre">Sintaxis Completamente Calificada para la Desambiguaci√≥n: Llamando M√©todos con el Mismo Nombre</a></h3>
<p>Nada en Rust impide que un trait tenga un m√©todo con el mismo nombre que el
m√©todo de otro trait, ni Rust te impide implementar ambos traits en un solo
tipo. Tambi√©n es posible implementar un m√©todo directamente en el tipo con el
mismo nombre que los m√©todos de los traits.</p>
<p>Cuando llamas a m√©todos con el mismo nombre, necesitar√°s decirle a Rust cu√°l
quieres usar. Considera el c√≥digo en el Listado 19-16 donde hemos definido dos
traits, <code>Pilot</code> y <code>Wizard</code>, que ambos tienen un m√©todo llamado <code>fly</code>. Luego
implementamos ambos traits en un tipo <code>Human</code> que ya tiene un m√©todo llamado
<code>fly</code> implementado en √©l. Cada m√©todo <code>fly</code> hace algo diferente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 19-16: Se definen dos traits para tener un
m√©todo <code>fly</code> y se implementan en el tipo <code>Human</code>, adem√°s se implementa
directamente un m√©todo <code>fly</code> en <code>Human</code></span></p>
<p>Cuando llamamos al m√©todo <code>fly</code> en una instancia de <code>Human</code>, el compilador
por defecto llama al m√©todo que est√° implementado directamente en el tipo, como
se muestra en el Listado 19-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<p><span class="caption">Listing 19-17: Llamando al m√©todo <code>fly</code> en una instancia
de <code>Human</code></span></p>
<p>Ejecutando este c√≥digo imprimir√° <code>*waving arms furiously*</code>, mostrando que Rust
llam√≥ al m√©todo <code>fly</code> implementado directamente en <code>Human</code>.</p>
<p>Para llamar a los m√©todos <code>fly</code> de los traits <code>Pilot</code> o <code>Wizard</code>, necesitamos
usar una sintaxis m√°s expl√≠cita para especificar cu√°l m√©todo <code>fly</code> queremos
llamar. El Listado 19-18 demuestra esta sintaxis.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<p><span class="caption">Listing 19-18: Especificando qu√© m√©todo <code>fly</code> del trait
queremos llamar</span></p>
<p>Especificar el nombre del trait antes del nombre del m√©todo aclara a Rust qu√©
implementaci√≥n del m√©todo <code>fly</code> queremos llamar. Tambi√©n podr√≠amos escribir
<code>Human::fly(&amp;person)</code>; esto es equivalente a <code>person.fly()</code>, pero es un poco
m√°s largo de escribir si no necesitamos desambiguar.</p>
<p>Al ejecutar este c√≥digo imprime lo siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Debido a que el m√©todo <code>fly</code> toma un par√°metro <code>self</code>, si tuvi√©ramos dos
<em>tipos</em> que implementan el mismo <em>trait</em>, Rust podr√≠a determinar cu√°l implementaci√≥n
del trait utilizar en funci√≥n del tipo de <code>self</code>.</p>
<p>Sin embargo, las funciones asociadas que no son m√©todos no tienen un par√°metro
<code>self</code>. Cuando hay m√∫ltiples tipos o traits que definen funciones no m√©todos
con el mismo nombre de funci√≥n, Rust no siempre sabe a qu√© tipo te refieres a
menos que uses <em>sintaxis completamente calificada</em>. Por ejemplo, en el Listado
19-19 creamos un trait para un refugio de animales que quiere nombrar a todos
los perros beb√©s <em>Spot</em>. Creamos un trait <code>Animal</code> con una funci√≥n no m√©todo
asociada <code>baby_name</code>. El trait <code>Animal</code> se implementa para la estructura <code>Dog</code>,
en la que tambi√©n proporcionamos una funci√≥n no m√©todo asociada <code>baby_name</code>
directamente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}</code></pre></pre>
<p><span class="caption">Listing 19-19: Un trait con una funci√≥n asociada y un
tipo con una funci√≥n asociada del mismo nombre que tambi√©n implementa el
trait</span></p>
<p>Implementamos el c√≥digo para nombrar a todos los cachorros Spot en la funci√≥n
asociada <code>baby_name</code> que se define en <code>Dog</code>. El tipo <code>Dog</code> tambi√©n implementa
el trait <code>Animal</code>, que describe las caracter√≠sticas que todos los animales
tienen. Los cachorros de perro se llaman cachorros, y eso se expresa en la
implementaci√≥n del trait <code>Animal</code> en <code>Dog</code> en la funci√≥n <code>baby_name</code> asociada
con el trait <code>Animal</code>.</p>
<p>En <code>main</code>, llamamos a la funci√≥n <code>Dog::baby_name</code>, que llama directamente a la
funci√≥n asociada definida en <code>Dog</code> directamente. Este c√≥digo imprime lo
siguiente:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>El output no es el que quer√≠amos. Queremos llamar a la funci√≥n <code>baby_name</code> que
forma parte del trait <code>Animal</code> que implementamos en <code>Dog</code>, por lo que el c√≥digo
imprime <code>A baby dog is called a puppy</code>. La t√©cnica de especificar el nombre del
trait que usamos en el Listado 19-18 no ayuda aqu√≠; si cambiamos <code>main</code> al
c√≥digo del Listado 19-20, obtendremos un error de compilaci√≥n.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}</code></pre>
<p><span class="caption">Listing 19-20: Al intentar llamar a la funci√≥n
<code>baby_name</code> del trait <code>Animal</code>, Rust no sabe qu√© implementaci√≥n usar</span></p>
<p>Debido a que <code>Animal::baby_name</code> no tiene un par√°metro <code>self</code> y podr√≠a haber
otros tipos que implementen el trait <code>Animal</code>, Rust no puede averiguar qu√©
implementaci√≥n de <code>Animal::baby_name</code> queremos. Obtendremos este error de
compilaci√≥n:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin &quot;traits-example&quot;) due to 1 previous error
</code></pre>
<p>Para desambiguar y decirle a Rust que queremos usar la implementaci√≥n de
<code>Animal</code> para <code>Dog</code> en lugar de la implementaci√≥n de <code>Animal</code> para alg√∫n otro
tipo, necesitamos usar la sintaxis completamente calificada. El Listado 19-21
demuestra c√≥mo usar la sintaxis completamente calificada.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<p><span class="caption">Listing 19-21: Usando la sintaxis completamente
calificada para especificar que queremos llamar a la funci√≥n <code>baby_name</code> del
trait <code>Animal</code> implementado en <code>Dog</code></span></p>
<p>Estamos proporcionando a Rust una anotaci√≥n de tipo dentro de los corchetes
angulares, lo que indica que queremos llamar al m√©todo <code>baby_name</code> del trait
<code>Animal</code> implementado en <code>Dog</code> diciendo que queremos tratar el tipo <code>Dog</code> como
un <code>Animal</code> para esta llamada de funci√≥n. Este c√≥digo ahora imprimir√° lo que
queremos:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>En general, la sintaxis completamente calificada se define de la siguiente</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>Para las funciones asociadas que no son m√©todos, no habr√≠a un <code>receiver</code>:
solo habr√≠a una lista de otros argumentos. Podr√≠as usar la sintaxis
completamente calificada en todas partes donde llames a funciones o m√©todos.
Sin embargo, se te permite omitir cualquier parte de esta sintaxis que Rust
pueda deducir de otra informaci√≥n en el programa. Solo necesitas usar esta
sintaxis m√°s verbosa en casos en los que haya m√∫ltiples implementaciones que
usen el mismo nombre y Rust necesite ayuda para identificar qu√© implementaci√≥n
quieres llamar.</p>
<h3 id="usando-supertraits-para-requerir-la-funcionalidad-de-un-trait-dentro-de-otro-trait"><a class="header" href="#usando-supertraits-para-requerir-la-funcionalidad-de-un-trait-dentro-de-otro-trait">Usando supertraits para requerir la funcionalidad de un trait dentro de otro trait</a></h3>
<p>A veces, es posible que desees escribir una definici√≥n de trait que dependa de
otro trait: para que un tipo implemente el primer trait, quieres exigir que
este tipo tambi√©n implemente el segundo trait. Esto se hace para que la
definici√≥n de tu trait pueda hacer uso de los elementos asociados del segundo
trait. El trait en el que se basa la definici√≥n de tu trait se llama
<em>supertrait</em> de tu trait.</p>
<p>Por ejemplo, supongamos que queremos crear un trait llamado <code>OutlinePrint</code> con
un m√©todo <code>outline_print</code> que imprima un valor dado enmarcado entre asteriscos.
Es decir, dado un struct <code>Point</code> que implementa el trait de la biblioteca
est√°ndar <code>Display</code> para que el resultado sea <code>(x, y)</code>, cuando llamemos a
<code>outline_print</code> en una instancia de <code>Point</code> que tenga <code>1</code> para <code>x</code> y <code>3</code> para
<code>y</code>, deber√≠a imprimir lo siguiente:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>Al implementar el m√©todo <code>outline_print</code>, queremos usar la funcionalidad de
<code>Display</code>. Por lo tanto, necesitamos indicar que el trait <code>OutlinePrint</code> solo
funcionar√° con tipos que tambi√©n implementen <code>Display</code> y proporcionen la
funcionalidad que <code>OutlinePrint</code> necesita. Podemos hacer eso en la definici√≥n
del trait especificando <code>OutlinePrint: Display</code>. Esta t√©cnica es similar a
agregar un l√≠mite de trait al trait. El Listado 19-22 muestra una
implementaci√≥n del trait <code>OutlinePrint</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {output} *&quot;);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 19-22: Implementando el trait <code>OutlinePrint</code>
que requiere la funcionalidad de <code>Display</code></span></p>
<p>Dado que hemos especificado que <code>OutlinePrint</code> requiere el trait <code>Display</code>, el
utilizar la funci√≥n <code>to_string</code> que se implementa autom√°ticamente para cualquier
tipo que implemente <code>Display</code> est√° bien. Si intent√°ramos usar <code>to_string</code> sin
agregar dos puntos y especificar el trait <code>Display</code> despu√©s del nombre del
trait, obtendr√≠amos un error diciendo que no se encontr√≥ ning√∫n m√©todo llamado
<code>to_string</code> para el tipo <code>&amp;Self</code> en el scope actual.</p>
<p>Veamos qu√© sucede cuando intentamos usar <code>OutlinePrint</code> en un tipo que
no implementa <code>Display</code>, como el struct <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {output} *&quot;);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
<p>Obtenemos un error que indica que se requiere implementar <code>Display</code>, pero no
est√° implementado:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin &quot;traits-example&quot;) due to 2 previous errors
</code></pre>
<p>Para solucionar esto, implementamos <code>Display</code> en <code>Point</code> y cumplimos con la
restricci√≥n que requiere <code>OutlinePrint</code>, de la siguiente manera:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {output} *&quot;);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
<p>Entonces, al implementar el trait <code>OutlinePrint</code> en <code>Point</code>, se compilar√°
exitosamente, y podemos llamar a <code>outline_print</code> en una instancia de <code>Point</code>
para mostrarla dentro de un contorno de asteriscos.</p>
<h3 id="usando-el-pattern-newtype-para-implementar-traits-externos-en-tipos-externos"><a class="header" href="#usando-el-pattern-newtype-para-implementar-traits-externos-en-tipos-externos">Usando el pattern Newtype para implementar traits externos en tipos externos</a></h3>
<p>En el cap√≠tulo 10 en la secci√≥n <a href="ch10-02-traits.html#implementando-un-trait-en-un-tipo">‚ÄúImplementando un trait en un
tipo‚Äù</a><!-- ignore -->, mencionamos los orphan
rules que establecen que solo podemos implementar un trait en un tipo si
bien el trait o el tipo son locales a nuestro crate. Es posible evitar esta
restricci√≥n usando el <em>patr√≥n newtype</em>, que implica crear un nuevo tipo en un
struct de tupla. (Cubrimos los structs de tupla en la secci√≥n <a href="ch05-01-defining-structs.html#usando-structs-de-tuplas-sin-campos-nombrados-para-crear-diferentes-tipos">‚ÄúUsando
structs de tupla sin campos nombrados para crear diferentes
tipos‚Äù</a><!-- ignore --> del cap√≠tulo 5.) El struct de tupla
tendr√° un campo y ser√° un envoltorio delgado alrededor del tipo en el que
queremos implementar un trait. Entonces, el tipo de envoltorio es local a
nuestro crate, y podemos implementar el trait en el envoltorio. <em>Newtype</em> es
un t√©rmino que se origina en el lenguaje de programaci√≥n Haskell. No hay
penalizaci√≥n de rendimiento en tiempo de ejecuci√≥n por usar este patr√≥n, y el
tipo de wrapper se omite en tiempo de compilaci√≥n.</p>
<p>Como ejemplo, supongamos que queremos implementar <code>Display</code> en <code>Vec&lt;T&gt;</code>, lo
cual nos impide hacerlo directamente debido a regla de los &quot;orphan rules&quot;, ya
que el trait <code>Display</code> y el tipo <code>Vec&lt;T&gt;</code> est√°n definidos fuera de nuestro
crate. Podemos hacer un struct llamado <code>Wrapper</code> que contenga una instancia de
<code>Vec&lt;T&gt;</code>. Luego podemos implementar <code>Display</code> en <code>Wrapper</code> y usar el valor de
<code>Vec&lt;T&gt;</code>, como se muestra en el Listado 19-23.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {w}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 19-23: Crear un tipo <code>Wrapper</code> alrededor de
<code>Vec&lt;String&gt;</code> para implementar <code>Display</code></span></p>
<p>La implementaci√≥n de <code>Display</code> usa <code>self.0</code> para acceder al <code>Vec&lt;T&gt;</code> interno,
porque <code>Wrapper</code> es un struct de tupla y <code>Vec&lt;T&gt;</code> es el item en el √≠ndice 0 de
la tupla. Luego podemos usar la funcionalidad del trait <code>Display</code> en <code>Wrapper</code>.</p>
<p>La desventaja de usar esta t√©cnica es que <code>Wrapper</code> es un nuevo tipo, por lo
que no tiene los m√©todos del valor que contiene. Tendr√≠amos que implementar
todos los m√©todos de <code>Vec&lt;T&gt;</code> directamente en <code>Wrapper</code> de tal manera que los
m√©todos deleguen a <code>self.0</code>, lo que nos permitir√≠a tratar a <code>Wrapper</code>
exactamente como un <code>Vec&lt;T&gt;</code>. Si quisi√©ramos que el nuevo tipo tenga todos los
m√©todos del tipo interno, implementar el trait <code>Deref</code> (discutido en el
cap√≠tulo 15 en la secci√≥n <a href="ch15-02-deref.html#tratando-los-smart-pointers-como-referencias-regulares-con-el-trait-deref">‚ÄúTratando a los smart pointers como referencias
regulares con el trait <code>Deref</code>‚Äù</a><!-- ignore -->) en
<code>Wrapper</code> para devolver el tipo interno ser√≠a una soluci√≥n. Si no queremos que
el tipo <code>Wrapper</code> tenga todos los m√©todos del tipo interno, por ejemplo, para
restringir el comportamiento del tipo <code>Wrapper</code>, tendr√≠amos que implementar
manualmente solo los m√©todos que queremos.</p>
<p>El pattern newtype tambi√©n es √∫til incluso cuando no se involucran traits.
Ahora cambiemos de enfoque y exploremos algunas formas avanzadas de interactuar
con el sistema de tipos de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-avanzados"><a class="header" href="#tipos-avanzados">Tipos Avanzados</a></h2>
<p>El sistema de tipos de Rust tiene algunas caracter√≠sticas que hemos mencionado
hasta ahora, pero que a√∫n no hemos discutido. Comenzaremos discutiendo los
newtypes en general mientras examinamos por qu√© los newtypes son √∫tiles
como tipos. Luego pasaremos a los type aliases, una caracter√≠stica similar a
los newtypes pero con sem√°ntica ligeramente diferente. Tambi√©n discutiremos
el tipo <code>!</code> y los tipos de tama√±o din√°mico.</p>
<h3 id="usando-el-newtype-pattern-para-seguridad-de-tipos-y-abstracci√≥n"><a class="header" href="#usando-el-newtype-pattern-para-seguridad-de-tipos-y-abstracci√≥n">Usando el Newtype Pattern para Seguridad de Tipos y Abstracci√≥n</a></h3>
<blockquote>
<p>Nota: Esta secci√≥n asume que has le√≠do la secci√≥n anterior <a href="ch19-03-advanced-traits.html#usando-el-pattern-newtype-para-implementar-traits-externos-en-tipos-externos">‚ÄúUsando el
Pattern Newtype para Implementar Traits Externos en Tipos
Externos.‚Äù</a><!-- ignore --></p>
</blockquote>
<p>El newtype pattern tambi√©n es √∫til para tareas m√°s all√° de las que hemos
discutido hasta ahora, incluyendo hacer cumplir est√°ticamente que los valores
nunca se confundan e indicar las unidades de un valor. Viste un ejemplo de
usar newtypes para indicar unidades en el Listado 19-15: recuerda que los
structs <code>Millimeters</code> y <code>Meters</code> envolvieron valores <code>u32</code> en un newtype. Si
escribi√©ramos una funci√≥n con un par√°metro de tipo <code>Millimeters</code>, no podr√≠amos
compilar un programa que accidentalmente intentara llamar a esa funci√≥n con
un valor de tipo <code>Meters</code> o un <code>u32</code> simple.</p>
<p>Tambi√©n podemos usar el pattern newtype para abstraer algunos detalles de
implementaci√≥n de un tipo: el nuevo tipo puede exponer una API p√∫blica que es
diferente de la API del tipo interno privado.</p>
<p>Los newtypes tambi√©n pueden ocultar la implementaci√≥n interna. Por ejemplo,
podr√≠amos proporcionar un tipo <code>People</code> para envolver un <code>HashMap&lt;i32, String&gt;</code>
que almacena el ID de una persona asociado con su nombre. El c√≥digo que usa
<code>People</code> solo interactuar√≠a con la API p√∫blica que proporcionamos, como un
m√©todo para agregar un string de nombre a la colecci√≥n <code>People</code>; ese c√≥digo
no necesitar√≠a saber que asignamos un ID <code>i32</code> a los nombres internamente. El
newtype pattern es una forma ligera de lograr la encapsulaci√≥n para ocultar
los detalles de implementaci√≥n, que discutimos en la secci√≥n <a href="ch17-01-what-is-oo.html#encapsulacion-que-oculta-los-detalles-de-implementacion">‚ÄúEncapsulaci√≥n
que Oculta los Detalles de
Implementaci√≥n‚Äù</a><!-- ignore -->
del Cap√≠tulo 17.</p>
<h3 id="creando-type-synonyms-con-type-aliases"><a class="header" href="#creando-type-synonyms-con-type-aliases">Creando Type Synonyms con Type Aliases</a></h3>
<p>Rust proporciona la capacidad de declarar un <em>type alias</em> para darle a un
tipo existente otro nombre. Para esto usamos la palabra clave <code>type</code>. Por
ejemplo, podemos crear el alias <code>Kilometers</code> a <code>i32</code> de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Ahora, el alias <code>Kilometers</code> es un <em>sin√≥nimo</em> para <code>i32</code>; a diferencia de los
tipos <code>Millimeters</code> y <code>Meters</code> que creamos en el Listado 19-15, <code>Kilometers</code>
no es un tipo nuevo y separado. Los valores que tienen el tipo <code>Kilometers</code>
se tratar√°n de la misma manera que los valores del tipo <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}</span></code></pre></pre>
<p>Debido a que <code>Kilometers</code> e <code>i32</code> son el mismo tipo, podemos agregar valores
de ambos tipos y podemos pasar valores <code>Kilometers</code> a funciones que toman
par√°metros <code>i32</code>. Sin embargo, usando este m√©todo, no obtenemos los beneficios
de verificaci√≥n de tipos que obtenemos del newtype pattern discutido
anteriormente. En otras palabras, si mezclamos valores <code>Kilometers</code> e <code>i32</code>
en alg√∫n lugar, el compilador no nos dar√° un error.</p>
<p>El caso de uso principal para los sin√≥nimos de tipo es reducir la repetici√≥n.
Por ejemplo, podr√≠amos tener un tipo largo como este:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Escribir este tipo extenso en firmas de funci√≥n y como anotaciones de tipo
en todo el c√≥digo puede ser tedioso y propenso a errores. Imagina tener un
proyecto lleno de c√≥digo como el del Listado 19-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-24: Usando un tipo largo en muchos
lugares</span></p>
<p>Un type alias hace que este c√≥digo sea m√°s manejable al reducir la repetici√≥n.
En el Listado 19-25, hemos introducido un alias llamado <code>Thunk</code> para el tipo
extenso y podemos reemplazar todos los usos del tipo con el alias m√°s corto
<code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-25: Introduciendo un type alias <code>Thunk</code> para
reducir la repetici√≥n</span></p>
<p>¬°Este c√≥digo es mucho m√°s f√°cil de leer y escribir! Elegir un nombre
significativo para un alias de tipo tambi√©n puede ayudar a comunicar tu
intenci√≥n (<em>thunk</em> es una palabra para c√≥digo que se evaluar√° en un momento
posterior, por lo que es un nombre apropiado para un cierre que se almacena).</p>
<p>Los type alias tambi√©n se utilizan con frecuencia con el tipo <code>Result&lt;T, E&gt;</code>
para reducir la repetici√≥n. Considera el m√≥dulo <code>std::io</code> en la biblioteca
est√°ndar. Las operaciones de E/S a menudo devuelven un <code>Result&lt;T, E&gt;</code> para
manejar situaciones en las que las operaciones no funcionan. Esta biblioteca
tiene una estructura <code>std::io::Error</code> que representa todos los posibles errores
de E/S. Muchas de las funciones en <code>std::io</code> devolver√°n <code>Result&lt;T, E&gt;</code> donde
<code>E</code> es <code>std::io::Error</code>, como estas funciones en el trait <code>Write</code>:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>√âl <code>Result&lt;..., Error&gt;</code> se repite mucho. Como tal, <code>std::io</code> tiene esta
declaraci√≥n de alias de tipo:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Dado que esta declaraci√≥n est√° en el m√≥dulo <code>std::io</code>, podemos usar el alias
completamente calificado <code>std::io::Result&lt;T&gt;</code>; es decir, un <code>Result&lt;T, E&gt;</code>
con <code>E</code> lleno como <code>std::io::Error</code>. Las firmas de las funciones del trait
<code>Write</code> terminan vi√©ndose as√≠:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>El type alias ayuda de dos maneras: hace que el c√≥digo sea m√°s f√°cil de
escribir <em>y</em> nos da una interfaz consistente en todo <code>std::io</code>. Debido a que
es un alias, es solo otro <code>Result&lt;T, E&gt;</code>, lo que significa que podemos usar
cualquier m√©todo que funcione en <code>Result&lt;T, E&gt;</code> con √©l, as√≠ como la sintaxis
especial como el operador <code>?</code>.</p>
<h3 id="el-tipo-que-nunca-retorna"><a class="header" href="#el-tipo-que-nunca-retorna">El tipo que nunca retorna</a></h3>
<p>Rust tiene un tipo especial llamado <code>!</code>, conocido en la jerga de la teor√≠a de
tipos como <em>tipo vac√≠o</em> porque no tiene valores. Preferimos llamarlo <em>tipo
never</em> porque se encuentra en el lugar del tipo de retorno cuando una funci√≥n
nunca retornar√°. Aqu√≠ hay un ejemplo:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>Este c√≥digo se lee como ‚Äúla funci√≥n <code>bar</code> devuelve never‚Äù. Las funciones que
devuelven never se llaman <em>funciones divergentes</em>. No podemos crear valores
del tipo <code>!</code> por lo que <code>bar</code> nunca puede devolver.</p>
<p>Pero, ¬øqu√© utilidad tiene un tipo del que nunca se pueden crear valores?
Recuerda el c√≥digo del Juego de Adivinar el N√∫mero mostrado en el Listado
2-5; hemos reproducido parte de √©l aqu√≠ en el Listado 19-26.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 19-26: Un <code>match</code> con una opci√≥n que termina en
<code>continue</code></span></p>
<p>En ese momento, omitimos algunos detalles en este c√≥digo. En el Cap√≠tulo 6 en
la secci√≥n <a href="ch06-02-match.html#the-match-control-flow-operator">‚ÄúEl operador de control de flujo
<code>match</code>‚Äù</a><!-- ignore -->
discutimos que las opciones de <code>match</code> deben devolver todos el mismo tipo. Por
lo tanto, por ejemplo, el siguiente c√≥digo no funciona:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}</span></code></pre>
<p>El tipo de <code>guess</code> en este c√≥digo tendr√≠a que ser un entero <em>y</em> un string, y
Rust requiere que <code>guess</code> tenga solo un tipo. Entonces, ¬øqu√© devuelve
<code>continue</code>? ¬øC√≥mo se nos permiti√≥ devolver un <code>u32</code> de una opci√≥n y tener otra
opci√≥n que termina con <code>continue</code> en el Listado 19-26?</p>
<p>Como habr√°s adivinado, <code>continue</code> tiene un valor <code>!</code>. Es decir, cuando Rust
calcula el tipo de <code>guess</code>, mira ambas opciones de <code>match</code>, el primero con un
valor de <code>u32</code> y el segundo con un valor de <code>!</code>. Debido a que <code>!</code> nunca puede
tener un valor, Rust decide que el tipo de <code>guess</code> es <code>u32</code>.</p>
<p>La forma formal de describir este comportamiento es que las expresiones de tipo
<code>!</code> se pueden convertir en cualquier otro tipo. Se nos permite terminar esta
opci√≥n de <code>match</code> con <code>continue</code> porque <code>continue</code> no devuelve un valor; en
cambio, mueve el control de nuevo a la parte superior del bucle, por lo que en
el caso de <code>Err</code>, nunca asignamos un valor a <code>guess</code>.</p>
<p>El tipo never tambi√©n es √∫til con la macro <code>panic!</code>. Recordemos la funci√≥n
<code>unwrap</code> que llamamos en valores <code>Option&lt;T&gt;</code> para producir un valor o
generar un panic con esta definici√≥n:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}</code></pre>
<p>en este c√≥digo, ocurre lo mismo que en el <code>match</code> del Listado 19-26: Rust ve
que <code>val</code> tiene el tipo <code>T</code> y <code>panic!</code> tiene el tipo <code>!</code>, por lo que el
resultado de la expresi√≥n <code>match</code> es <code>T</code>. Este c√≥digo funciona porque <code>panic!</code>
no produce un valor; termina el programa. En el caso de <code>None</code>, no devolveremos
un valor de <code>unwrap</code>, por lo que este c√≥digo es v√°lido.</p>
<p>Una expresi√≥n final que tiene el tipo <code>!</code> es un <code>loop</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;forever &quot;);

    loop {
        print!(&quot;and ever &quot;);
    }
<span class="boring">}</span></code></pre>
<p>Aqu√≠, el bucle nunca termina, por lo que <code>!</code> es el valor de la expresi√≥n. Sin
embargo, esto no ser√≠a cierto si incluy√©ramos un <code>break</code>, porque el bucle
terminar√≠a cuando llegara al <code>break</code>.</p>
<h3 id="tipos-de-tamano-dinamico-y-el-trait-sized"><a class="header" href="#tipos-de-tamano-dinamico-y-el-trait-sized">Tipos de tamano dinamico y el trait <code>Sized</code></a></h3>
<p>Rust necesita conocer ciertos detalles sobre sus tipos, como la cantidad de
espacio para asignar a un valor de un tipo particular. Esto deja una esquina de
su sistema de tipos un poco confusa al principio: el concepto de <em>tipos de
tama√±o din√°mico</em>. A veces se refiere como <em>DST</em> o <em>tipos no dimensionados</em>,
estos tipos nos permiten escribir c√≥digo usando valores cuyo tama√±o solo
podemos conocer en tiempo de ejecuci√≥n.</p>
<p>Profundicemos en los detalles de un tipo de tama√±o din√°mico llamado <code>str</code>, que
hemos estado usando a lo largo del libro. As√≠ es, no <code>&amp;str</code>, sino <code>str</code> por s√≠
solo, es un DST. No podemos saber cu√°nto tiempo es la cadena hasta el tiempo de
ejecuci√≥n, lo que significa que no podemos crear una variable de tipo <code>str</code>, ni
podemos tomar un argumento de tipo <code>str</code>. Considera el siguiente c√≥digo, que
no funciona:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Hello there!&quot;;
    let s2: str = &quot;How's it going?&quot;;
<span class="boring">}</span></code></pre>
<p>Rust necesita conocer cu√°nta memoria asignar para cualquier valor de un tipo
particular, y todos los valores de un tipo deben usar la misma cantidad de
memoria. Si Rust nos permitiera escribir este c√≥digo, estos dos valores <code>str</code>
necesitar√≠an ocupar el mismo espacio. Pero tienen longitudes diferentes: <code>s1</code>
necesita 12 bytes de almacenamiento y <code>s2</code> necesita 15. Es por eso que no es
posible crear una variable que contenga un tipo de tama√±o din√°mico.</p>
<p>Entonces, ¬øqu√© hacemos en este caso? En este caso, como ya sabes, la soluci√≥n
es hacer que los tipos de <code>s1</code> y <code>s2</code> sean <code>&amp;str</code> en lugar de <code>str</code>. Recuerda
de la secci√≥n <a href="ch04-03-slices.html#string-slices">‚ÄúString Slices‚Äù</a><!-- ignore --> del
Cap√≠tulo 4 que la estructura de datos de slice solo almacena la posici√≥n de
inicio y la longitud del slice. Por lo tanto, aunque un <code>&amp;T</code> es un solo
valor que almacena la direcci√≥n de memoria de donde se encuentra el <code>T</code>, un
<code>&amp;str</code> son <em>dos</em> valores: la direcci√≥n del <code>str</code> y su longitud. Como tal,
podemos conocer el tama√±o de un valor <code>&amp;str</code> en tiempo de compilaci√≥n: es dos
veces la longitud de un <code>usize</code>. Es decir, siempre conocemos el tama√±o de un
<code>&amp;str</code>, sin importar cu√°n larga sea la cadena a la que se refiere. En general,
esta es la forma en que se usan los tipos de tama√±o din√°mico en Rust: tienen un
bit adicional de metadatos que almacena el tama√±o de la informaci√≥n din√°mica.
La regla de oro de los tipos de tama√±o din√°mico es que debemos envolverlos en
alg√∫n tipo de puntero.</p>
<p>Podemos combinar <code>str</code> con todo tipo de punteros: por ejemplo, <code>Box&lt;str&gt;</code> o
<code>Rc&lt;str&gt;</code>. De hecho, ya has visto esto antes, pero con un tipo de tama√±o
din√°mico diferente: los traits. Cada trait es un tipo de tama√±o din√°mico al que
podemos referirnos usando el nombre del trait. En el Cap√≠tulo 17 en la
secci√≥n <a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">‚ÄúUsando trait objects que permiten valores de diferentes
tipos‚Äù</a><!--
ignore -->, mencionamos que para usar traits como objetos de trait, debemos
ponerlos detr√°s de un puntero, como <code>&amp;dyn Trait</code> o <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> tambi√©n funcionar√≠a).</p>
<p>Para trabajar con DST, Rust proporciona el trait <code>Sized</code> para determinar si el
tama√±o de un tipo es conocido en tiempo de compilaci√≥n o no. Este trait se
implementa autom√°ticamente para todo lo cuyo tama√±o es conocido en tiempo de
compilaci√≥n. Adem√°s, Rust agrega impl√≠citamente un l√≠mite en <code>Sized</code> a cada
funci√≥n generic. Es decir, una definici√≥n de funci√≥n generic como esta:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>en realidad se trata como si hubi√©ramos escrito esto:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>De forma predeterminada, las funciones generic solo funcionar√°n en tipos que
tienen un tama√±o conocido en tiempo de compilaci√≥n. Sin embargo, puede usar la
siguiente sintaxis especial para relajar esta restricci√≥n:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p>Un trait bound en <code>?Sized</code> significa ‚Äú<code>T</code> puede o no ser <code>Sized</code>‚Äù y esta
notaci√≥n anula el valor predeterminado de que los tipos generic deben tener un
tama√±o conocido en tiempo de compilaci√≥n. La sintaxis <code>?Trait</code> con este
significado solo est√° disponible para <code>Sized</code>, no para ning√∫n otro trait.</p>
<p>Tambi√©n debes tener en cuenta que hemos cambiado el tipo del par√°metro <code>t</code> de
<code>T</code> a <code>&amp;T</code>. Debido a que el tipo puede no ser <code>Sized</code>, necesitamos usarlo
detr√°s de alg√∫n tipo de puntero. En este caso, hemos elegido una referencia.</p>
<p>¬°A continuaci√≥n, hablaremos sobre funciones y closures!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funciones-y-closures-avanzados"><a class="header" href="#funciones-y-closures-avanzados">Funciones y Closures Avanzados</a></h2>
<p>Esta secci√≥n cubre algunas caracter√≠sticas avanzadas relacionadas con
funciones y closures, incluyendo punteros a funciones y retornar closures.</p>
<h3 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h3>
<p>Hemos hablado de c√≥mo pasar closures a funciones; ¬°tambi√©n puedes pasar
funciones regulares a funciones! Esta t√©cnica es √∫til cuando quieres pasar una
funci√≥n que ya has definido en lugar de definir un nuevo closure. Las funciones
se coercen al tipo <code>fn</code> (con una f min√∫scula), no confundir con el trait de
cierre <code>Fn</code>. El tipo <code>fn</code> se llama <em>puntero a funci√≥n</em>. Pasar funciones con
punteros a funci√≥n te permitir√° usar funciones como argumentos para otras
funciones.</p>
<p>La sintaxis para especificar que un par√°metro es un puntero a funci√≥n es
similar a la de los closures, como se muestra en el Listado 19-27, donde hemos
definido una funci√≥n <code>add_one</code> que suma uno a su par√°metro. La funci√≥n
<code>do_twice</code> toma dos par√°metros: un puntero a funci√≥n a cualquier funci√≥n que
tome un par√°metro <code>i32</code> y devuelva un <code>i32</code>, y un valor <code>i32</code>. La funci√≥n
<code>do_twice</code> llama a la funci√≥n <code>f</code> dos veces, pas√°ndole el valor <code>arg</code>, luego
suma los dos resultados de la llamada a la funci√≥n. La funci√≥n <code>main</code> llama a
<code>do_twice</code> con los argumentos <code>add_one</code> y <code>5</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {answer}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 19-27: Usando el tipo <code>fn</code> para aceptar un
puntero a function como un argumento</span></p>
<p>Este c√≥digo imprime <code>The answer is: 12</code>. Especificamos que el par√°metro <code>f</code> en
<code>do_twice</code> es un <code>fn</code> que toma un par√°metro de tipo <code>i32</code> y devuelve un <code>i32</code>.
Luego podemos llamar a <code>f</code> en el cuerpo de <code>do_twice</code>. En <code>main</code>, podemos pasar
el nombre de la funci√≥n <code>add_one</code> como el primer argumento a <code>do_twice</code>.</p>
<p>A diferencia de los closures, <code>fn</code> es un tipo en lugar de un trait, por lo que
especificamos <code>fn</code> como el tipo de par√°metro directamente en lugar de declarar
un par√°metro de tipo gen√©rico con uno de los traits <code>Fn</code> como un trait bound.</p>
<p>Los punteros a funciones implementan los tres closure traits (<code>Fn</code>, <code>FnMut</code> y
<code>FnOnce</code>), lo que significa que siempre puedes pasar un puntero a funci√≥n como
un argumento para una funci√≥n que espera un closure. Es mejor escribir
funciones usando un tipo generic y uno de los closure traits para que tus
funciones puedan aceptar funciones o closures.</p>
<p>Dicho esto, un ejemplo de d√≥nde querr√≠as aceptar solo <code>fn</code> y no closures es
cuando te comunicas con c√≥digo externo que no tiene closures: las funciones de
C pueden aceptar funciones como argumentos, pero C no tiene closures.</p>
<p>Como ejemplo de d√≥nde podr√≠as usar un closure definido en l√≠nea o una funci√≥n
nombrada, veamos un uso del m√©todo <code>map</code> proporcionado por el trait <code>Iterator</code>
en la biblioteca est√°ndar. Para usar la funci√≥n <code>map</code> para convertir un vector
de n√∫meros en un vector de strings, podr√≠amos usar un closure, como este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p>O podr√≠amos nombrar una funci√≥n como argumento para <code>map</code> en lugar del
closure, como este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p>Ten en cuenta que debemos utilizar la sintaxis completamente calificada que
mencionamos anteriormente en la secci√≥n <a href="ch19-03-advanced-traits.html#traits-avanzados">‚ÄúTraits avanzados‚Äù</a></p>
<!-- ignore --> porque hay m√∫ltiples funciones disponibles llamadas `to_string`.
<p>Aqu√≠, estamos usando la funci√≥n <code>to_string</code> definida en el trait <code>ToString</code>,
que la biblioteca est√°ndar ha implementado para cualquier tipo que implemente
<code>Display</code>.</p>
<p>Recuerda la secci√≥n <a href="ch06-01-defining-an-enum.html#valores-enum">‚ÄúValores de Enum‚Äù</a><!-- ignore --> del
Cap√≠tulo 6, que el nombre de cada variante de enum que definimos tambi√©n se
convierte en una funci√≥n inicializadora. Podemos usar estas funciones
inicializadoras como punteros a funci√≥n que implementan los closure traits,
lo que significa que podemos especificar las funciones inicializadoras como
argumentos para los m√©todos que toman closures, como se muestra a continuaci√≥n:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p>Aqu√≠ creamos instancias de <code>Status::Value</code> usando cada valor <code>u32</code> en el rango
en el que se llama a <code>map</code> usando la funci√≥n inicializadora de <code>Status::Value</code>.
A algunas personas les gusta este estilo, y a otras les gusta usar closures.
Compilan al mismo c√≥digo, as√≠ que usa el estilo que sea m√°s claro para ti.</p>
<h3 id="retornando-closures"><a class="header" href="#retornando-closures">Retornando Closures</a></h3>
<p>Los closures se representan mediante traits, lo que significa que no puedes
devolver closures directamente. En la mayor√≠a de los casos en los que podr√≠as
querer devolver un trait, puedes usar en su lugar el tipo concreto que
implementa el trait como el valor de retorno de la funci√≥n. Sin embargo, no
puedes hacer eso con los closures porque no tienen un tipo concreto que se
pueda devolver; no se te permite usar el puntero a funci√≥n <code>fn</code> como un tipo
de retorno, por ejemplo.</p>
<p>El siguiente c√≥digo intenta devolver un closure directamente, pero no
compilar√°:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre>
<p>El error del compilador es el siguiente:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type
  |
1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
  |                         ~~~~
help: box the return type, and wrap all of the returned values in `Box::new`
  |
1 ~ fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
2 ~     Box::new(|x| x + 1)
  |

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` (lib) due to 1 previous error
</code></pre>
<p>¬°El error hace referencia nuevamente al trait <code>Sized</code>! Rust no sabe cu√°nto
espacio necesitar√° para almacenar el closure. Vimos una soluci√≥n a este
problema anteriormente. Podemos usar un trait object:</p>
<pre><code class="language-rust noplayground">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}</code></pre>
<p>Este c√≥digo se compilar√° correctamente. Para obtener m√°s informaci√≥n sobre los
trait objects, consulta la secci√≥n <a href="ch17-02-trait-objects.html#usando-trait-objects-que-permiten-valores-de-diferentes-tipos">‚ÄúUsando trait objects que permiten valores
de diferentes
tipos‚Äù</a></p>
<!-- ignore --> en el Cap√≠tulo 17.
<p>¬°Ahora veamos las macros!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Hemos utilizado macros como <code>println!</code> a lo largo de este libro, pero no hemos
explorado completamente qu√© es una macro y c√≥mo funciona. El t√©rmino <em>macro</em> se
refiere a una familia de caracter√≠sticas en Rust: macros <em>declarativas</em> con
<code>macro_rules!</code> y tres tipos de macros <em>procedurales</em>:</p>
<ul>
<li>Macros Personalizadas <code>#[derive]</code> que especifican c√≥digo agregado con el</li>
<li>atributo <code>derive</code> usado en structs y enums</li>
<li>Macros similares a atributos que definen atributos personalizados utilizables
en cualquier item</li>
<li>Macros similares a funciones que se ven como llamadas a funciones, pero
operan en los tokens especificados como argumento</li>
</ul>
<p>Hablaremos de cada uno de estos a su vez, pero primero, veamos por qu√©
necesitamos macros cuando ya tenemos funciones.</p>
<h3 id="la-diferencia-entre-macros-y-funciones"><a class="header" href="#la-diferencia-entre-macros-y-funciones">La Diferencia Entre Macros y Funciones</a></h3>
<p>Fundamentalmente, las macros son una forma de escribir c√≥digo que escribe otro
c√≥digo, lo que se conoce como <em>metaprogramaci√≥n</em>. En el Ap√©ndice C, discutimos
el atributo <code>derive</code>, que genera una implementaci√≥n de varios traits para ti.
Tambi√©n hemos usado las macros <code>println!</code> y <code>vec!</code> a lo largo del libro. Todas
estas macros <em>se expanden</em> para producir m√°s c√≥digo que el c√≥digo que has
escrito manualmente.</p>
<p>La metaprogramaci√≥n es √∫til para reducir la cantidad de c√≥digo que tienes que
escribir y mantener, que tambi√©n es uno de los roles de las funciones. Sin
embargo, las macros tienen algunos poderes adicionales que las funciones no
tienen.</p>
<p>Una funci√≥n debe declarar el n√∫mero y el tipo de par√°metros que tiene la
funci√≥n. Las macros, por otro lado, pueden tomar un n√∫mero variable de
par√°metros: podemos llamar a <code>println!(&quot;hello&quot;)</code> con un argumento o
<code>println!(&quot;hello {}&quot;, name)</code> con dos argumentos. Adem√°s, las macros se
expanden antes de que el compilador interprete el significado del c√≥digo, por
lo que una macro puede, por ejemplo, implementar un trait en un tipo dado. Una
funci√≥n no puede, porque se llama en tiempo de ejecuci√≥n y un trait debe
implementarse en tiempo de compilaci√≥n.</p>
<p>La desventaja de implementar una macro en lugar de una funci√≥n es que las
definiciones de macros son m√°s complejas que las definiciones de funciones
porque est√°s escribiendo c√≥digo Rust que escribe c√≥digo Rust. Debido a esta
indirecci√≥n, las definiciones de macros generalmente son m√°s dif√≠ciles de leer,
entender y mantener que las definiciones de funciones.</p>
<p>Otra diferencia importante entre las macros y las funciones es que debes
definir macros o traerlas al scope <em>antes</em> de llamarlas en un archivo, a
diferencia de las funciones que puedes definir en cualquier lugar y llamar en
cualquier lugar.</p>
<h3 id="macros-declarativas-con-macro_rules-para-metaprogramacion-general"><a class="header" href="#macros-declarativas-con-macro_rules-para-metaprogramacion-general">Macros Declarativas con <code>macro_rules!</code> para Metaprogramacion General</a></h3>
<p>La forma m√°s utilizada de macros en Rust es la <em>macro declarativa</em>. A veces
tambi√©n se denominan ‚Äúmacros por ejemplo‚Äù, ‚Äú<code>macro_rules!</code> macros‚Äù o simplemente
‚Äúmacros‚Äù. En su n√∫cleo, las macros declarativas te permiten escribir algo
similar a una expresi√≥n <code>match</code> de Rust. Como se discuti√≥ en el Cap√≠tulo 6, las
expresiones <code>match</code> son estructuras de control que toman una expresi√≥n,
comparan el valor resultante de la expresi√≥n con patrones y luego ejecutan el
c√≥digo asociado con el patr√≥n coincidente. Las macros tambi√©n comparan un valor
con patrones que est√°n asociados con un c√≥digo particular: en esta situaci√≥n,
el valor es el c√≥digo fuente literal de Rust que se pasa a la macro; los
patrones se comparan con la estructura de ese c√≥digo fuente; y el c√≥digo
asociado con cada patr√≥n, cuando coincide, reemplaza el c√≥digo pasado a la
macro. Todo esto sucede durante la compilaci√≥n.</p>
<p>Para definir una macro, usas el constructor <code>macro_rules!</code>. Exploremos c√≥mo
usar <code>macro_rules!</code> mirando c√≥mo se define la macro <code>vec!</code>. El Cap√≠tulo 8
cubri√≥ c√≥mo podemos usar la macro <code>vec!</code> para crear un nuevo vector con valores
particulares. Por ejemplo, la siguiente macro crea un nuevo vector que contiene
tres enteros:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>Tambi√©n podemos usar la macro <code>vec!</code> para crear un vector de dos enteros o un
vector de cinco string slices. No podr√≠amos usar una funci√≥n porque no
conocer√≠amos el n√∫mero o el tipo de valores.</p>
<p>El Listado 19-28 muestra una definici√≥n ligeramente simplificada de la macro
<code>vec!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<p><span class="caption">Listing 19-28: Una versi√≥n simplificada de la definici√≥n
de la macro <code>vec!</code></span></p>
<blockquote>
<p>Nota: La definici√≥n real de la macro <code>vec!</code> en la biblioteca est√°ndar incluye
c√≥digo para preasignar la cantidad correcta de memoria por adelantado. Ese
c√≥digo es una optimizaci√≥n que no incluimos aqu√≠ para hacer el ejemplo m√°s
simple.</p>
</blockquote>
<p>La anotaci√≥n <code>#[macro_export]</code> indica que esta macro debe estar disponible
siempre que la biblioteca en la que se define la macro se traiga al scope. Sin
esta anotaci√≥n, la macro no se puede traer al scope.</p>
<p>Luego comenzamos la definici√≥n de la macro con <code>macro_rules!</code> y el nombre de la
macro que estamos definiendo <em>sin</em> el signo de exclamaci√≥n. El nombre, en este
caso <code>vec</code>, va seguido de llaves que denotan el cuerpo de la definici√≥n de la
macro.</p>
<p>La estructura en el cuerpo de <code>vec!</code> es similar a la estructura de una
expresi√≥n <code>match</code>. Aqu√≠ tenemos un brazo con el patr√≥n <code>( $( $x:expr ),* )</code>,
seguido de <code>=&gt;</code> y el bloque de c√≥digo asociado con este patr√≥n. Si el patr√≥n
coincide, se emitir√° el bloque de c√≥digo asociado. Dado que este es el √∫nico
patr√≥n en esta macro, solo hay una forma v√°lida de coincidir; cualquier otro
patr√≥n dar√° como resultado un error. Las macros m√°s complejas tendr√°n m√°s de una
opci√≥n.</p>
<p>La sintaxis v√°lida del pattern en una macro es diferente de la sintaxis de los
patterns cubiertos en el Cap√≠tulo 18 porque los patterns de macro se comparan
con la estructura del c√≥digo Rust en lugar de con valores. Recorramos lo que
significan las piezas del pattern en el Listado 19-28; para obtener la sintaxis
completa del pattern de macro, consulte la <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Referencia de Rust</a>.</p>
<p>Primero, usamos un conjunto de par√©ntesis para englobar todo el patr√≥n. Usamos
el signo de d√≥lar (<code>$</code>) para declarar una variable en el sistema de macros que
contendr√° el c√≥digo Rust que coincida con el patr√≥n. El signo de d√≥lar hace que
quede claro que esta es una variable de macro en lugar de una variable regular
de Rust. A continuaci√≥n, viene un conjunto de par√©ntesis que captura los valores
que coinciden con el patr√≥n dentro de los par√©ntesis para su uso en el c√≥digo de
reemplazo. Dentro de <code>$()</code> est√° <code>$x:expr</code>, que coincide con cualquier expresi√≥n
de Rust y le da el nombre <code>$x</code>.</p>
<p>La coma que sigue a <code>$()</code> √≠ndica que opcionalmente podr√≠a aparecer un car√°cter
de coma separador literal despu√©s del c√≥digo que coincide con el c√≥digo en
<code>$()</code>. √âl <code>*</code> especifica que el patr√≥n coincide cero o m√°s veces con lo que
precede al <code>*</code>.</p>
<p>Cuando llamamos a esta macro con <code>vec![1, 2, 3];</code>, el patr√≥n <code>$x</code> coincide tres
veces con las tres expresiones <code>1</code>, <code>2</code> y <code>3</code>.</p>
<p>Ahora veamos el pattern en el cuerpo del c√≥digo asociado con esta opci√≥n:
<code>temp_vec.push($x);</code>. Dentro de <code>$()*</code> se genera para cada parte que coincide
con <code>$()</code> en el patr√≥n cero o m√°s veces dependiendo de cu√°ntas veces coincida
el patr√≥n. √âl <code>$x</code> se reemplaza con cada expresi√≥n que coincida. Cuando llamamos
a esta macro con <code>vec![1, 2, 3];</code>, el c√≥digo generado que reemplaza esta
llamada a la macro ser√° el siguiente:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>Hemos definido una macro que puede tomar cualquier n√∫mero de argumentos de
cualquier tipo y puede generar c√≥digo para crear un vector que contenga los
elementos especificados.</p>
<p>Para obtener m√°s informaci√≥n sobre c√≥mo escribir macros, consulta la
documentaci√≥n en l√≠nea u otros recursos, como <a href="https://veykril.github.io/tlborm/">‚ÄúThe Little Book of Rust
Macros‚Äù</a> iniciado por Daniel Keep y continuado por Lukas Wirth.</p>
<h3 id="macros-procedurales-para-generar-c√≥digo-a-partir-de-atributos"><a class="header" href="#macros-procedurales-para-generar-c√≥digo-a-partir-de-atributos">Macros Procedurales para Generar C√≥digo a partir de Atributos</a></h3>
<p>Las macros procedurales, que es la segunda forma de macros, act√∫an m√°s como
una funci√≥n (y son un tipo de procedimiento). Las macros procedurales aceptan
c√≥digo como entrada, operan en ese c√≥digo y producen c√≥digo como salida en
lugar de coincidir con patrones y reemplazar el c√≥digo por otro c√≥digo como lo
hacen las macros declarativas. Los tres tipos de macros procedurales son
derivaciones personalizadas, atributos y funciones, y todas funcionan de manera
similar.</p>
<p>Al crear macros procedurales, las definiciones deben residir en su propio
crate con un tipo de crate especial. Esto se debe a razones t√©cnicas complejas
que esperamos eliminar en el futuro. En el Listado 19-29 se muestra c√≥mo se
define una macro procedural, donde <code>some_attribute</code> es un marcador de posici√≥n
para usar un tipo espec√≠fico de macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Listing 19-29: Un ejemplo de definici√≥n de una macro
procedural</span></p>
<p>La funci√≥n que define una macro procedural tome un <code>TokenStream</code> como entrada y
devuelve un <code>TokenStream</code> como salida. El <code>TokenStream</code> tipo es definido por el
<code>proc_macro</code> crate que se incluye con Rust y representa una secuencia de tokens.
Esta es la base de la macro: el c√≥digo fuente en el que la macro est√° operando
constituye la entrada <code>TokenStream</code>, y el c√≥digo que la macro produce es el
<code>TokenStream</code> de salida. La funci√≥n tambi√©n tiene un atributo adjunto que
especifica qu√© tipo de macro procedural estamos creando. Podemos tener varios
tipos de macros procedurales en el mismo crate.</p>
<p>Veamos los diferentes tipos de macros procedurales. Comenzaremos con una
derivaci√≥n personalizada y luego explicaremos las peque√±as diferencias que
hacen que las otras formas sean diferentes.</p>
<h3 id="c√≥mo-escribir-una-macro-derive-personalizada"><a class="header" href="#c√≥mo-escribir-una-macro-derive-personalizada">C√≥mo Escribir una Macro <code>derive</code> Personalizada</a></h3>
<p>Creemos un crate llamado <code>hello_macro</code> que defina un trait llamado
<code>HelloMacro</code> con una funci√≥n asociada llamada <code>hello_macro</code>. En lugar de hacer
que nuestros usuarios implementen el trait <code>HelloMacro</code> para cada uno de sus
tipos, proporcionaremos una macro procedural para que los usuarios puedan
anotar sus tipos con <code>#[derive(HelloMacro)]</code> para obtener una implementaci√≥n
predeterminada de la funci√≥n <code>hello_macro</code>. La implementaci√≥n predeterminada
imprimir√° <code>Hello, Macro! My name is TypeName!</code>, donde <code>TypeName</code> es el nombre
del tipo en el que se ha definido este trait. En otras palabras, escribiremos
un crate que permita a otro programador escribir c√≥digo como el Listado 19-30
usando nuestro crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Listing 19-30: El c√≥digo que un usuario de nuestro crate
podr√° escribir cunado se use nuestra macro procedural</span></p>
<p>Este c√≥digo imprimir√° <code>Hello, Macro! My name is Pancakes!</code> cuando hayamos
terminado. El primer paso es hacer un nuevo crate de biblioteca, as√≠:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>A continuaci√≥n, definiremos el trait <code>HelloMacro</code> y su funci√≥n asociada:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<p>Tenemos un trait y su funci√≥n. En este punto, nuestro usuario de crate podr√≠a
implementar el trait para lograr la funcionalidad deseada, as√≠:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>Sin embargo, tendr√≠an que escribir el bloque de implementaci√≥n para cada tipo
que quisieran usar con <code>hello_macro</code>; queremos evitar que tengan que hacer este
trabajo.</p>
<p>Adem√°s, a√∫n no podemos proporcionar una implementaci√≥n predeterminada de
la funci√≥n <code>hello_macro</code> que imprimir√° el nombre del tipo en el que se
implementa el trait: rust no tiene capacidades de reflexi√≥n, por lo que no
puede buscar el nombre del tipo en tiempo de ejecuci√≥n. Necesitamos una macro
para generar c√≥digo en tiempo de compilaci√≥n.</p>
<p>El siguiente paso es definir la macro procedural. En el momento de escribir
esto, las macros procedurales deben estar en su propio crate. Eventualmente,
esta restricci√≥n podr√≠a ser levantada. La convenci√≥n para estructurar crates y
macro crates es la siguiente: para un crate llamado <code>foo</code>, un crate de macro
procedural de derivaci√≥n personalizada se llama <code>foo_derive</code>. Creemos un nuevo
crate llamado <code>hello_macro_derive</code> dentro de nuestro proyecto <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Nuestros dos crates est√°n estrechamente relacionados, por lo que creamos el
crate de macro procedural dentro del directorio de nuestro crate <code>hello_macro</code>.
Si cambiamos la definici√≥n del trait en <code>hello_macro</code>, tambi√©n tendremos que
cambiar la implementaci√≥n de la macro procedural en <code>hello_macro_derive</code>. Los
dos crates deber√°n publicarse por separado, y los programadores que usen estos
crates deber√°n agregar ambos como dependencias y traerlos a ambos al scope.
En su lugar, podr√≠amos hacer que el crate <code>hello_macro</code> use <code>hello_macro_derive</code>
como una dependencia y vuelva a exportar el c√≥digo de la macro procedural.
Sin embargo, la forma en que hemos estructurado el proyecto hace posible que
los programadores usen <code>hello_macro</code> incluso si no quieren la funcionalidad
<code>derive</code>.</p>
<p>Necesitamos declarar el crate <code>hello_macro_derive</code> como un crate de macro
procedural. Tambi√©n necesitaremos funcionalidad de los crates <code>syn</code> y <code>quote</code>,
como veremos en un momento, por lo que necesitamos agregarlos como dependencias.
Agrega lo siguiente al archivo <em>Cargo.toml</em> para <code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;2.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>Para comenzar a definir la macro procedural, coloca el c√≥digo del Listado 19-31
en tu archivo <em>src/lib.rs</em> para el crate <code>hello_macro_derive</code>. Ten en cuenta que
este c√≥digo no se compilar√° hasta que agreguemos una definici√≥n para la funci√≥n
<code>impl_hello_macro</code>.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}</code></pre>
<p><span class="caption">Listing 19-31: C√≥digo que la mayor√≠a de los crates de
macros procedurales requerir√°n para procesar c√≥digo Rust</span></p>
<p>Observa que hemos dividido el c√≥digo en la funci√≥n <code>hello_macro_derive</code>, que
es responsable de analizar el <code>TokenStream</code>, y la funci√≥n <code>impl_hello_macro</code>,
que es responsable de transformar el √°rbol de sintaxis: esto hace que escribir
una macro procedural sea m√°s conveniente. El c√≥digo en la funci√≥n externa
(<code>hello_macro_derive</code> en este caso) ser√° el mismo para casi todos los crates de
macros procedurales que veas o crees. El c√≥digo que especifiques en el cuerpo
de la funci√≥n interna (<code>impl_hello_macro</code> en este caso) ser√° diferente
dependiendo del prop√≥sito de tu macro procedural.</p>
<p>Hemos introducido tres nuevos crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, y <a href="https://crates.io/crates/quote"><code>quote</code></a>. El
crate <code>proc_macro</code> viene con Rust, por lo que no necesitamos agregarlo a las
dependencias en <em>Cargo.toml</em>. El crate <code>proc_macro</code> es la API del compilador
que nos permite leer y manipular c√≥digo Rust desde nuestro c√≥digo.</p>
<p>El crate <code>syn</code> analiza el c√≥digo Rust desde un string en una estructura de
datos en la que podemos realizar operaciones. El crate <code>quote</code> convierte las
estructuras de datos de <code>syn</code> nuevamente en c√≥digo Rust. Estos crates hacen que
sea mucho m√°s simple analizar cualquier tipo de c√≥digo Rust que deseemos
manipular: escribir un analizador completo para el c√≥digo Rust no es una tarea
sencilla.</p>
<p>La funci√≥n <code>hello_macro_derive</code> se llamar√° cuando un usuario de nuestro crate
especifique <code>#[derive(HelloMacro)]</code> en un tipo. Esto es posible porque hemos
anotado la funci√≥n <code>hello_macro_derive</code> aqu√≠ con <code>proc_macro_derive</code> y
especificado el nombre <code>HelloMacro</code>, que coincide con el nombre de nuestro
trait; esta es la convenci√≥n que siguen la mayor√≠a de las macros procedurales.</p>
<p>La funci√≥n <code>hello_macro_derive</code> convierte primero el <code>input</code> de un
<code>TokenStream</code> a una estructura de datos que podemos interpretar y realizar
operaciones. Aqu√≠ es donde entra en juego <code>syn</code>. La funci√≥n <code>parse</code> en <code>syn</code>
toma un <code>TokenStream</code> y devuelve un struct <code>DeriveInput</code> que representa el
c√≥digo Rust analizado. El Listado 19-32 muestra las partes relevantes del
struct <code>DeriveInput</code> que obtenemos al analizar el string <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Listing 19-32: La instancia <code>DeriveInput</code> que obtenemos
al analizar el c√≥digo que tiene el atributo de la macro en el
Listado 19-30</span></p>
<p>Los campos de este struct muestran que el c√≥digo Rust que hemos analizado es un
struct unitario con el <code>ident</code> (identificador, es decir, el nombre) de
<code>Pancakes</code>. Hay m√°s campos en este struct para describir todo tipo de c√≥digo
Rust; consulta la <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html">documentaci√≥n de <code>syn</code> para <code>DeriveInput</code></a> para
obtener m√°s informaci√≥n.</p>
<p>Pronto definiremos la funci√≥n <code>impl_hello_macro</code>, que es donde construiremos el
c√≥digo Rust que queremos incluir. Pero antes de hacerlo, ten en cuenta que la
salida de nuestra macro derive tambi√©n es un <code>TokenStream</code>. El <code>TokenStream</code>
devuelto se agrega al c√≥digo que escriben los usuarios de nuestro crate, por lo
que cuando compilan su crate, obtendr√°n la funcionalidad adicional que
proporcionamos en el <code>TokenStream</code> modificado.</p>
<p>Es posible que hayas notado que estamos usando <code>unwrap</code> para hacer que la
funci√≥n <code>hello_macro_derive</code> genere un panic si la llamada a la funci√≥n
<code>syn::parse</code> falla. Es necesario que nuestra macro procedural genere un panic
en caso de error porque las funciones <code>proc_macro_derive</code> deben devolver
<code>TokenStream</code> en lugar de <code>Result</code> para cumplir con la API de las macros
procedurales. Hemos simplificado este ejemplo usando <code>unwrap</code>; en c√≥digo de
producci√≥n, debes proporcionar mensajes de error m√°s espec√≠ficos sobre lo que
sali√≥ mal usando <code>panic!</code> o <code>expect</code>.</p>
<p>Ahora que tenemos el c√≥digo para convertir el c√≥digo de Rust anotado de un
<code>TokenStream</code> a una instancia <code>DeriveInput</code>, generemos el c√≥digo que implementa
el trait <code>HelloMacro</code> en el tipo anotado, como se muestra en el Listado 19-33.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<p><span class="caption">Listing 19-33: Implementando el trait <code>HelloMacro</code> usando
el c√≥digo Rust analizado</span></p>
<p>Obtenemos una instancia del struct <code>DeriveInput</code> que contiene el nombre
(identificador) del tipo anotado usando <code>ast.ident</code>. El struct en el Listado
19-32 muestra que cuando ejecutamos la funci√≥n <code>impl_hello_macro</code> en el c√≥digo
del Listado 19-30, el <code>ident</code> que obtenemos tendr√° el campo <code>ident</code> con un
valor de <code>&quot;Pancakes&quot;</code>. Por lo tanto, la variable <code>name</code> en el Listado 19-33
contendr√° una instancia del struct <code>Ident</code> que, cuando se imprima, ser√° la
cadena <code>&quot;Pancakes&quot;</code>, el nombre del struct en el Listado 19-30.</p>
<p>La macro <code>quote!</code> nos permite construir el c√≥digo que queremos devolver. El
compilador espera algo diferente al resultado directo de la ejecuci√≥n de la
macro <code>quote!</code>, por lo que debemos convertirlo a un <code>TokenStream</code>. Hacemos esto
llamando al m√©todo <code>into</code>, que consume esta representaci√≥n intermedia y
devuelve un valor del tipo <code>TokenStream</code> requerido.</p>
<p>La macro <code>quote!</code> tambi√©n proporciona algunas mec√°nicas de plantillas muy
interesantes: podemos ingresar <code>#name</code>, y <code>quote!</code> lo reemplazar√° con el valor
de la variable <code>name</code>. Incluso puedes hacer alguna repetici√≥n similar a la forma
en que funcionan las macros regulares. Consulta <a href="https://docs.rs/quote">la documentaci√≥n del crate
<code>quote</code></a> para obtener una introducci√≥n completa.</p>
<p>Queremos que nuestra macro procedural genere una implementaci√≥n de nuestro
trait <code>HelloMacro</code> para el tipo que el usuario ha anotado, lo cual podemos
lograr utilizando <code>#name</code>. La implementaci√≥n del trait tiene la funci√≥n
<code>hello_macro</code>, cuyo cuerpo contiene la funcionalidad que queremos proporcionar:
imprimir <code>Hello, Macro! My name is</code> y luego el nombre del tipo anotado.</p>
<p>La macro <code>stringify!</code> utilizada aqu√≠ est√° incorporada en Rust. Toma una
expresi√≥n de Rust como <code>1 + 2</code> y en tiempo de compilaci√≥n convierte la
expresi√≥n en un literal de string como <code>&quot;1 + 2&quot;</code>. Esto es diferente a <code>format!</code>
o <code>println!</code>, macros que eval√∫an la expresi√≥n y luego convierten el resultado en
un <code>String</code>. Existe la posibilidad de que la entrada <code>#name</code> sea una expresi√≥n
para imprimir literalmente, por lo que usamos <code>stringify!</code>. El uso de
<code>stringify!</code> tambi√©n ahorra una asignaci√≥n al convertir <code>#name</code> en un literal
de string en tiempo de compilaci√≥n.</p>
<p>En este punto, <code>cargo build</code> deber√≠a completarse correctamente tanto en
<code>hello_macro</code> como en <code>hello_macro_derive</code>. ¬°Conectemos estos crates al c√≥digo
del Listado 19-30 para ver la macro procedural en acci√≥n! Crea un nuevo
proyecto binario en tu directorio <em>projects</em> usando <code>cargo new pancakes</code>.
Necesitamos agregar <code>hello_macro</code> y <code>hello_macro_derive</code> como dependencias en el
<em>Cargo.toml</em> de <code>pancakes</code>. Si est√°s publicando tus versiones de <code>hello_macro</code>
y <code>hello_macro_derive</code> en <a href="https://crates.io/">crates.io</a>, ser√≠an dependencias
regulares; si no, puedes especificarlas como dependencias <code>path</code> de la
siguiente manera:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Coloca el c√≥digo del Listado 19-30 en <em>src/main.rs</em> y ejecuta <code>cargo run</code>:
deber√≠a imprimir <code>Hello, Macro! My name is Pancakes!</code> La implementaci√≥n del
trait <code>HelloMacro</code> de la macro procedural se incluy√≥ sin que el crate <code>pancakes</code>
tuviera que implementarlo; la macro <code>#[derive(HelloMacro)]</code> agreg√≥ la
implementaci√≥n del trait.</p>
<p>A continuaci√≥n, vamos a explorar c√≥mo los otros tipos de macros procedurales
difieren de las macros derive personalizadas.</p>
<h3 id="macros-similares-a-atributos"><a class="header" href="#macros-similares-a-atributos">Macros similares a atributos</a></h3>
<p>Las macros similares a atributos son similares a las macros derivadas
personalizadas, pero en lugar de generar c√≥digo para el atributo <code>derive</code>,
permiten crear nuevos atributos. Tambi√©n son m√°s flexibles: <code>derive</code> solo
funciona para structs y enums; los atributos se pueden aplicar a otros items
tambi√©n, como funciones. Aqu√≠ hay un ejemplo de uso de una macro similar a un
atributo: digamos que tienes un atributo llamado <code>route</code> que anota funciones
cuando se usa un framework de aplicaci√≥n web:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {</code></pre>
<p>El atributo <code>#[route]</code> ser√° definido por el framework como una macro procedural.
La firma de la funci√≥n de definici√≥n de la macro se ver√≠a as√≠:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Aqu√≠, tenemos dos par√°metros de tipo <code>TokenStream</code>. El primero es para el
contenido del atributo: la parte <code>GET, &quot;/&quot;</code>. El segundo es el cuerpo del item
al que se adjunta el atributo: en este caso, <code>fn index() {}</code> y el resto del
cuerpo de la funci√≥n.</p>
<p>Aparte de eso, las macros similares a atributos funcionan de la misma manera
que las macros derivadas personalizadas: creas un crate con el tipo <code>proc-macro</code>
y defines una funci√≥n que genera el c√≥digo que deseas.</p>
<h3 id="macros-similares-a-funciones"><a class="header" href="#macros-similares-a-funciones">Macros similares a funciones</a></h3>
<p>Las macros tipo funci√≥n definen macros que se ven como llamadas a funciones.
De manera similar a las macros <code>macro_rules!</code>, son m√°s flexibles que las
funciones; por ejemplo, pueden tomar un n√∫mero desconocido de argumentos. Sin
embargo, las macros <code>macro_rules!</code> solo se pueden definir usando la sintaxis
similar a la de los patterns que discutimos en la secci√≥n <a href="ch19-06-macros.html#macros-declarativas-con-macro_rules-para-metaprogramacion-general">‚ÄúMacros declarativas
con <code>macro_rules!</code> para metaprogramaci√≥n general‚Äù</a><!-- ignore -->
anteriormente. Las macros tipo funci√≥n toman un par√°metro <code>TokenStream</code> y su
definici√≥n manipula ese <code>TokenStream</code> usando c√≥digo Rust como los otros dos
tipos de macros procedurales. Un ejemplo de una macro tipo funci√≥n es una macro
<code>sql!</code> que podr√≠a ser llamada as√≠:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>Esta macro analizar√≠a la declaraci√≥n SQL dentro de ella y verificar√≠a que sea
sint√°cticamente correcta, lo cual es un procesamiento mucho m√°s complejo de lo
que una macro <code>macro_rules!</code> puede hacer. La macro <code>sql!</code> se definir√≠a as√≠:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Esta definici√≥n es similar a la firma de la macro de derivaci√≥n personalizada:
recibimos los tokens que est√°n dentro de los par√©ntesis y devolvemos el c√≥digo
que queremos generar.</p>
<h2 id="resumen-18"><a class="header" href="#resumen-18">Resumen</a></h2>
<p>¬°Uf! Ahora que tienes algunas caracter√≠sticas de Rust en tu caja de herramientas
que probablemente no usar√°s a menudo, pero sabr√°s que est√°n disponibles en
circunstancias muy particulares. Hemos introducido varios temas complejos para
que cuando los encuentres en sugerencias de mensajes de error o en el c√≥digo de
otras personas, puedas reconocer estos conceptos y sintaxis. Usa este cap√≠tulo
como referencia para guiarte hacia soluciones.</p>
<p>¬°A continuaci√≥n, pondremos en pr√°ctica todo lo que hemos discutido a lo largo
del libro y haremos un proyecto m√°s!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proyecto-final-construyendo-un-servidor-web-multithread"><a class="header" href="#proyecto-final-construyendo-un-servidor-web-multithread">Proyecto final: Construyendo un servidor web multithread</a></h1>
<p>Ha sido un largo viaje, pero hemos llegado al final del libro. En este
cap√≠tulo, construiremos un proyecto m√°s para demostrar algunos de los
conceptos que cubrimos en los cap√≠tulos finales, as√≠ como recapitular algunas
lecciones anteriores.</p>
<p>Para nuestro proyecto final, haremos un servidor web que diga &quot;hola&quot; y se vea
como la Figura 20-1 en un navegador web.</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">Figure 20-1: Nuestro proyecto final compartido</span></p>
<p>Aqu√≠ est√° nuestro plan para construir el web server:</p>
<ol>
<li>Aprender un poco sobre TCP y HTTP.</li>
<li>Escuchar conexiones TCP en un socket.</li>
<li>Analizar un peque√±o n√∫mero de peticiones HTTP.</li>
<li>Crear una respuesta HTTP adecuada.</li>
<li>Mejorar el rendimiento de nuestro servidor con un <em>thread pool</em>.</li>
</ol>
<p>Antes de comenzar, debemos mencionar un detalle: el m√©todo que usaremos no
ser√° la mejor manera de construir un servidor web con Rust. Los miembros de la
comunidad han publicado una serie de <em>crates</em> listos para producci√≥n
disponibles en <a href="https://crates.io/">crates.io</a> que proporcionan servidores web
y <em>thread pools</em> m√°s completos que los que construiremos. Sin embargo, nuestra
intenci√≥n en este cap√≠tulo es ayudarte a aprender, no tomar el camino f√°cil.
Debido a que Rust es un lenguaje de programaci√≥n de sistemas, podemos elegir el
nivel de abstracci√≥n con el que queremos trabajar y podemos ir a un nivel m√°s
bajo de lo que es posible o pr√°ctico en otros lenguajes. Por lo tanto,
escribiremos el servidor HTTP b√°sico y el <em>thread pool</em> manualmente para que
puedas aprender las ideas y t√©cnicas generales detr√°s de los <em>crates</em> que
podr√≠as usar en el futuro.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="construyendo-un-servidor-web-de-un-solo-hilo"><a class="header" href="#construyendo-un-servidor-web-de-un-solo-hilo">Construyendo un servidor web de un solo hilo</a></h2>
<p>Comenzaremos haciendo funcionar un servidor web de un solo hilo. Antes de
comenzar, veamos una breve descripci√≥n general de los protocolos involucrados
en la construcci√≥n de servidores web. Los detalles de estos protocolos est√°n
fuera del alcance de este libro, pero una breve descripci√≥n general le dar√° la
informaci√≥n que necesita.</p>
<p>Los dos protocolos principales involucrados en los servidores web son <em>Hypertext
Transfer Protocol</em> <em>(HTTP)</em> y <em>Transmission Control Protocol</em> <em>(TCP)</em>. Ambos
protocolos son protocolos de <em>solicitud-respuesta</em>, lo que significa que un
<em>cliente</em> inicia solicitudes y un <em>servidor</em> escucha las solicitudes y
proporciona una respuesta al cliente. El contenido de esas solicitudes y
respuestas est√° definido por los protocolos.</p>
<p>TCP es el protocolo de nivel inferior que describe los detalles de c√≥mo la
informaci√≥n pasa de un servidor a otro, pero no especifica qu√© es esa
informaci√≥n. HTTP se basa en TCP definiendo el contenido de las solicitudes y
respuestas. T√©cnicamente, es posible usar HTTP con otros protocolos, pero en la
gran mayor√≠a de los casos, HTTP env√≠a sus datos a trav√©s de TCP. Trabajaremos
con los bytes sin procesar de las solicitudes y respuestas de TCP y HTTP.</p>
<h3 id="escuchando-la-conexi√≥n-tcp"><a class="header" href="#escuchando-la-conexi√≥n-tcp">Escuchando la conexi√≥n TCP</a></h3>
<p>Nuestro servidor web debe escuchar una conexi√≥n TCP, por lo que esa es la
primera parte en la que trabajaremos. La biblioteca est√°ndar ofrece un m√≥dulo
<code>std::net</code> que nos permite hacer esto. Hagamos un nuevo proyecto de la manera
habitual:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Ahora agreguemos el c√≥digo en el Listado 20-1 en <em>src/main.rs</em> para comenzar.
Este c√≥digo escuchar√° en la direcci√≥n local <code>127.0.0.1:7878</code> para flujos TCP
entrantes. Cuando recibe un flujo entrante, imprimir√° <code>¬°Conexi√≥n establecida!</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listing 20-1: Escuchar transmisiones entrantes e imprimir
un mensaje cuando recibimos una transmisi√≥n</span></p>
<p>Usando <code>TcpListener</code>, podemos escuchar conexiones TCP en la direcci√≥n
<code>127.0.0.1:7878</code>. En la direcci√≥n, la secci√≥n antes de los dos puntos es una
direcci√≥n IP que representa su computadora (esto es lo mismo en todas las
computadoras y no representa la computadora de los autores en particular), y
<code>7878</code> es el puerto. Hemos elegido este puerto por dos razones: HTTP no se
acepta normalmente en este puerto, por lo que es poco probable que nuestro
servidor entre en conflicto con cualquier otro servidor web que pueda tener
ejecut√°ndose en su m√°quina, y 7878 es <em>rust</em> escrito en un tel√©fono.</p>
<p>La funci√≥n <code>bind</code> en este escenario funciona como la funci√≥n <code>new</code> en que
devolver√° una nueva instancia de <code>TcpListener</code>. La funci√≥n se llama <code>bind</code>
porque, en redes, conectarse a un puerto para escuchar se conoce como ‚Äúenlazar
a un puerto‚Äù.</p>
<p>La funci√≥n <code>bind</code> devuelve un <code>Result&lt;T, E&gt;</code>, que indica que es posible que el
enlace falle. Por ejemplo, conectarse al puerto 80 requiere privilegios de
administrador (los no administradores solo pueden escuchar en puertos superiores
a 1023), por lo que si intent√°ramos conectarnos al puerto 80 sin ser un
administrador, el enlace no funcionar√≠a. El enlace tampoco funcionar√≠a, por
ejemplo, si ejecut√°ramos dos instancias de nuestro programa y, por lo tanto,
tuvimos dos programas escuchando el mismo puerto. Debido a que estamos
escribiendo un servidor b√°sico solo con fines de aprendizaje, no nos
preocuparemos por manejar este tipo de errores; en su lugar, usamos <code>unwrap</code>
para detener el programa si ocurren errores.</p>
<p>El m√©todo <code>incoming</code> en <code>TcpListener</code> devuelve un iterator que nos da una
secuencia de flujos (m√°s espec√≠ficamente, flujos de tipo <code>TcpStream</code>). Un solo
<em>flujo</em> representa una conexi√≥n abierta entre el cliente y el servidor. Una
<em>conexi√≥n</em> es el nombre del proceso de solicitud y respuesta completo en el que
un cliente se conecta al servidor, el servidor genera una respuesta y el
servidor cierra la conexi√≥n. Como tal, leeremos del <code>TcpStream</code> para ver lo que
el cliente envi√≥ y luego escribiremos nuestra respuesta en el flujo para enviar
datos de vuelta al cliente. En general, este bucle <code>for</code> procesar√° cada
conexi√≥n a su vez y producir√° una serie de flujos para que los manejemos.</p>
<p>Por ahora, nuestro manejo del flujo consiste en llamar a <code>unwrap</code> para terminar
nuestro programa si el flujo tienen alg√∫n error; si no hay errores, el programa
imprime un mensaje. Agregaremos m√°s funcionalidad para el caso de √©xito en el
siguiente listado. La raz√≥n por la que podr√≠amos recibir errores del m√©todo
<code>incoming</code> cuando un cliente se conecta al servidor es que en realidad no
iteramos sobre las conexiones. En cambio, iteramos sobre <em>intentos de
conexi√≥n</em>. La conexi√≥n podr√≠a no tener √©xito por una serie de razones, muchas
de ellas espec√≠ficas del sistema operativo. Por ejemplo, muchos sistemas
operativos tienen un l√≠mite para el n√∫mero de conexiones abiertas simult√°neas
que pueden admitir; los nuevos intentos de conexi√≥n m√°s all√° de ese n√∫mero
producir√°n un error hasta que algunas de las conexiones abiertas se cierren.</p>
<p>¬°Intentemos ejecutar este c√≥digo! Invoca <code>cargo run</code> en la terminal y luego
carga <em>127.0.0.1:7878</em> en un navegador web. El navegador deber√≠a mostrar un
mensaje de error como ‚ÄúConexi√≥n restablecida‚Äù, porque el servidor no est√°
enviando ning√∫n dato actualmente. ¬°Pero cuando miras tu terminal, deber√≠as ver
varios mensajes que se imprimieron cuando el navegador se conect√≥ al servidor!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>A veces, ver√°s m√∫ltiples mensajes impresos para una solicitud del navegador; la
raz√≥n podr√≠a ser que el navegador est√° haciendo una solicitud para la p√°gina
adem√°s de una solicitud para otros recursos, como el icono <em>favicon.ico</em> que
aparece en la pesta√±a del navegador.</p>
<p>Tambi√©n podr√≠a ser que el navegador est√© intentando conectarse al servidor
varias veces porque el servidor no est√° respondiendo con ning√∫n dato. Cuando
<code>stream</code> sale del scope y se descarta al final del bucle, la conexi√≥n se cierra
como parte de la implementaci√≥n de <code>drop</code>. Los navegadores a veces tratan con
conexiones cerradas volviendo a intentar, porque el problema podr√≠a ser
temporal. ¬°El factor importante es que hemos obtenido con √©xito un controlador
para una conexi√≥n TCP!</p>
<p>Recuerda detener el programa presionando <span class="keystroke">ctrl-c</span>
cuando hayas terminado de ejecutar una versi√≥n particular del c√≥digo. Luego
reinicia el programa invocando el comando <code>cargo run</code> despu√©s de haber hecho
cambios de c√≥digo para asegurarte de que est√°s ejecutando el c√≥digo m√°s nuevo.</p>
<h3 id="leyendo-la-solicitud"><a class="header" href="#leyendo-la-solicitud">Leyendo la solicitud</a></h3>
<p>¬°Vamos a implementar la funcionalidad para leer la solicitud del navegador!. Para
separar las preocupaciones de obtener primero una conexi√≥n y luego tomar alguna
acci√≥n con la conexi√≥n, iniciaremos una nueva funci√≥n para procesar conexiones.
En esta nueva funci√≥n <code>handle_connection</code>, leeremos datos del flujo TCP e
imprimiremos para que podamos ver los datos que se env√≠an desde el navegador.
Cambia el c√≥digo para que se vea como el Listado 20-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!(&quot;Request: {http_request:#?}&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 20-2: Leyendo desde el <code>TcpStream</code> e imprimiendo
los datos</span></p>
<p>Importamos <code>std::io::prelude</code> y <code>std::io::BufReader</code> para obtener acceso a los
traits y tipos que nos permiten leer del flujo. En el bucle <code>for</code> en la funci√≥n
<code>main</code>, en lugar de imprimir un mensaje que diga que hicimos una conexi√≥n,
ahora llamamos a la nueva funci√≥n <code>handle_connection</code> y le pasamos el <code>stream</code>.</p>
<p>En la funci√≥n <code>handle_connection</code>, creamos una nueva instancia de <code>BufReader</code>
que envuelve una referencia mutable al <code>stream</code>. <code>BufReader</code> agrega
almacenamiento en b√∫fer al administrar las llamadas a los m√©todos del trait
<code>std::io::Read</code> por nosotros.</p>
<p>Creamos una variable llamada <code>http_request</code> para recopilar las l√≠neas de la
solicitud que el navegador env√≠a a nuestro servidor. Indicamos que queremos
recopilar estas l√≠neas en un vector agregando la anotaci√≥n de tipo <code>Vec&lt;_&gt;</code>.</p>
<p><code>BufReader</code> implementa el trait <code>std::io::BufRead</code>, que proporciona el m√©todo
<code>lines</code>. El m√©todo <code>lines</code> devuelve un iterator de <code>Result&lt;String, std::io::Error&gt;</code> al dividir el flujo de datos cada vez que ve un byte de nueva
l√≠nea. Para obtener cada <code>String</code>, mapeamos y <code>unwrap</code> cada <code>Result</code>. El
<code>Result</code> podr√≠a ser un error si los datos no son v√°lidos UTF-8 o si hubo un
problema al leer del flujo. Nuevamente, un programa de producci√≥n deber√≠a
manejar estos errores de manera m√°s elegante, pero estamos eligiendo detener el
programa en el caso de error por simplicidad.</p>
<p>El navegador se√±ala el final de una solicitud HTTP enviando dos caracteres de
nueva l√≠nea seguidos, por lo que para obtener una solicitud del flujo, tomamos
l√≠neas hasta que obtenemos una l√≠nea que es el string vac√≠o. Una vez que hemos
recopilado las l√≠neas en el vector, las imprimimos usando el formato de
depuraci√≥n bonito para que podamos echar un vistazo a las instrucciones que el
navegador web est√° enviando a nuestro servidor.</p>
<p>¬°Probemos este c√≥digo! Inicia el programa y luego carga realiza una solicitud
en un navegador web nuevamente. Ten en cuenta que a√∫n obtendremos una p√°gina de
error en el navegador, pero la salida del programa en la terminal se ver√°
similar a esto:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    &quot;GET / HTTP/1.1&quot;,
    &quot;Host: 127.0.0.1:7878&quot;,
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0&quot;,
    &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Language: en-US,en;q=0.5&quot;,
    &quot;Accept-Encoding: gzip, deflate, br&quot;,
    &quot;DNT: 1&quot;,
    &quot;Connection: keep-alive&quot;,
    &quot;Upgrade-Insecure-Requests: 1&quot;,
    &quot;Sec-Fetch-Dest: document&quot;,
    &quot;Sec-Fetch-Mode: navigate&quot;,
    &quot;Sec-Fetch-Site: none&quot;,
    &quot;Sec-Fetch-User: ?1&quot;,
    &quot;Cache-Control: max-age=0&quot;,
]
</code></pre>
<p>Dependiendo de tu navegador, podr√≠as obtener una salida ligeramente diferente.
Ahora que estamos imprimiendo los datos de la solicitud, podemos ver por qu√©
obtenemos m√∫ltiples conexiones desde una solicitud del navegador al mirar la
ruta despu√©s de <code>GET</code> en la primera l√≠nea de la solicitud. Si las conexiones
repetidas est√°n solicitando <em>/</em>, sabemos que el navegador est√° tratando de
obtener <em>/</em> repetidamente porque no est√° obteniendo una respuesta de nuestro
programa.</p>
<p>Descompongamos estos datos de solicitud para comprender lo que el navegador
est√° pidiendo a nuestro programa.</p>
<h3 id="una-mirada-m√°s-cercana-a-una-solicitud-http"><a class="header" href="#una-mirada-m√°s-cercana-a-una-solicitud-http">Una mirada m√°s cercana a una solicitud HTTP</a></h3>
<p>HTTP es un protocolo de texto, y una solicitud toma este formato:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>La primera l√≠nea es la <em>l√≠nea de solicitud</em> que contiene informaci√≥n sobre lo
que el cliente est√° solicitando. La primera parte de la l√≠nea de solicitud
indica el <em>m√©todo</em> que se est√° utilizando, como <code>GET</code> o <code>POST</code>, que describe
c√≥mo el cliente est√° haciendo esta solicitud. Nuestro cliente us√≥ una solicitud
<code>GET</code>, lo que significa que est√° solicitando informaci√≥n.</p>
<p>La siguiente parte de la l√≠nea de solicitud es <em>/</em>, que indica el
<em>Uniform Resource Identifier</em> <em>(URI)</em> que el cliente est√° solicitando: un URI
es casi, pero no exactamente, lo mismo que un <em>Uniform Resource Locator</em>
<em>(URL)</em>. La diferencia entre URIs y URLs no es importante para nuestros
prop√≥sitos en este cap√≠tulo, pero la especificaci√≥n HTTP usa el t√©rmino URI,
por lo que podemos simplemente sustituir mentalmente URL por URI aqu√≠.</p>
<p>La √∫ltima parte es la versi√≥n de HTTP que utiliza el cliente, y luego la l√≠nea
de solicitud termina en una secuencia <em>CRLF</em>. (CRLF significa <em>carriage return</em>
y <em>line feed</em>, que son t√©rminos de los d√≠as de la m√°quina de escribir!) La
secuencia CRLF tambi√©n se puede escribir como <code>\r\n</code>, donde <code>\r</code> es un retorno
de carro y <code>\n</code> es un avance de l√≠nea. La secuencia CRLF separa la l√≠nea de
solicitud del resto de los datos de la solicitud. Tenga en cuenta que cuando se
imprime el CRLF, vemos que comienza una nueva l√≠nea en lugar de <code>\r\n</code>.</p>
<p>Al examinar los datos de la l√≠nea de solicitud que hemos recibido al ejecutar
nuestro programa hasta ahora, vemos que <code>GET</code> es el m√©todo, <em>/</em> es el URI de
solicitud y <code>HTTP/1.1</code> es la versi√≥n.</p>
<p>Despu√©s de la l√≠nea de solicitud, las l√≠neas restantes a partir de <code>Host:</code> en
adelante son encabezados. Las solicitudes <code>GET</code> no tienen cuerpo.</p>
<p>Intenta hacer una solicitud desde un navegador diferente o solicitar una
direcci√≥n diferente, como <em>127.0.0.1:7878/test</em>, para ver c√≥mo cambian los
datos de la solicitud.</p>
<p>Ahora que sabemos lo que el navegador est√° solicitando, ¬°enviemos algunos
datos de vuelta!</p>
<h3 id="escribiendo-una-respuesta"><a class="header" href="#escribiendo-una-respuesta">Escribiendo una respuesta</a></h3>
<p>Vamos a implementar el env√≠o de datos en respuesta a una solicitud del
cliente. Las respuestas tienen el siguiente formato:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>La primera l√≠nea es una <em>l√≠nea de estado</em> que contiene la versi√≥n HTTP 
utilizada en la respuesta, un c√≥digo de estado num√©rico que resume el resultado
de la solicitud y una frase de motivo que proporciona una descripci√≥n textual
del c√≥digo de estado. Despu√©s de la secuencia CRLF hay encabezados, otra
secuencia CRLF y el cuerpo de la respuesta.</p>
<p>Aqu√≠ hay un ejemplo de respuesta que usa la versi√≥n HTTP 1.1, tiene un c√≥digo
de estado 200, una frase de motivo OK, no tiene encabezados y no tiene cuerpo:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>El c√≥digo de estado 200 es la respuesta de √©xito est√°ndar. El texto es una
respuesta HTTP exitosa. ¬°Escribamos esto en el flujo como nuestra respuesta a
una solicitud exitosa! Desde la funci√≥n <code>handle_connection</code>, elimine el
<code>println!</code> que estaba imprimiendo los datos de la solicitud y reempl√°celo con
el c√≥digo en el Listado 20-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-3: Escribiendo una peque√±a respuesta HTTP
exitosa en el flujo de datos</span></p>
<p>El primer cambio introduce la variable <code>response</code>, que contiene los datos
del mensaje de √©xito. Luego, llamamos a <code>as_bytes</code> en nuestra <code>response</code> para
convertir los datos de string en bytes. El m√©todo <code>write_all</code> en <code>stream</code> toma
un <code>&amp;[u8]</code> y env√≠a esos bytes directamente por la conexi√≥n. Debido a que la
operaci√≥n <code>write_all</code> podr√≠a fallar, usamos <code>unwrap</code> en cualquier resultado de
error como antes. Nuevamente, en una aplicaci√≥n real agregar√≠as manejo de
errores aqu√≠.</p>
<p>Con estos cambios, ejecutemos nuestro c√≥digo y hagamos una solicitud. Como ya
no estamos imprimiendo ning√∫n dato en la terminal, no veremos ninguna salida
aparte de la salida generada por Cargo. Cuando cargues <em>127.0.0.1:7878</em> en un
navegador web, deber√≠as ver una p√°gina en blanco en lugar de un error. ¬°Acabas
de codificar a mano la recepci√≥n de una solicitud HTTP y el env√≠o de una
respuesta!</p>
<h3 id="devolviendo-html-real"><a class="header" href="#devolviendo-html-real">Devolviendo HTML real</a></h3>
<p>Vamos a implementar la funcionalidad para devolver algo m√°s que una p√°gina en
blanco. Crea el nuevo archivo <em>hello.html</em> en la ra√≠z de tu directorio del
proyecto, no en el directorio <em>src</em>. Puedes introducir cualquier HTML que
quieras; el Listado 20-4 muestra una posibilidad.</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-4: Un ejemplo de archivo HTML para devolver en 
una respuesta</span></p>
<p>Esto es un documento HTML5 m√≠nimo con un encabezado y un poco de texto. Para
devolver esto desde el servidor cuando se recibe una solicitud, modificaremos
<code>handle_connection</code> como se muestra en el Listado 20-5 para leer el archivo
HTML, agregarlo a la respuesta como un cuerpo y enviarlo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = &quot;HTTP/1.1 200 OK&quot;;
    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-5: Enviando el contenido de <em>hello.html</em> como 
el cuerpo de la respuesta</span></p>
<p>Hemos agregado <code>fs</code> a la declaraci√≥n <code>use</code> para traer el m√≥dulo del sistema de
archivos de la biblioteca est√°ndar al scope. El c√≥digo para leer el contenido
de un archivo a una cadena deber√≠a ser familiar; lo usamos en el Cap√≠tulo 12
cuando le√≠mos el contenido de un archivo para nuestro proyecto de I/O en el
Listado 12-4.</p>
<p>A continuaci√≥n, utilizamos <code>format!</code> para agregar el contenido del archivo como
el cuerpo de la respuesta de √©xito. Para asegurar una respuesta HTTP v√°lida,
agregamos el encabezado <code>Content-Length</code> que se establece en el tama√±o del
cuerpo de nuestra respuesta, en este caso el tama√±o de <code>hello.html</code>.</p>
<p>Ejecuta este c√≥digo con <code>cargo run</code> y carga <em>127.0.0.1:7878</em> en tu navegador;
¬°Deber√≠as ver tu HTML renderizado!</p>
<p>Actualmente, estamos ignorando los datos de la solicitud en <code>http_request</code> y
enviando de vuelta el contenido del archivo HTML incondicionalmente. Eso
significa que si intentas solicitar <em>127.0.0.1:7878/something-else</em> en tu
navegador, a√∫n obtendr√°s esta misma respuesta HTML. En este momento, nuestro
servidor es muy limitado y no hace lo que hacen la mayor√≠a de los servidores
web. Queremos personalizar nuestras respuestas dependiendo de la solicitud y
solo enviar el archivo HTML para una solicitud bien formada a <em>/</em>.</p>
<h3 id="validando-la-solicitud-y-respondiendo-selectivamente"><a class="header" href="#validando-la-solicitud-y-respondiendo-selectivamente">Validando la solicitud y respondiendo selectivamente</a></h3>
<p>En este momento, nuestro servidor web devolver√° el HTML del archivo sin 
importar lo que el cliente haya solicitado. Agreguemos funcionalidad para
verificar que el navegador est√© solicitando <em>/</em> antes de devolver el archivo
HTML y devolver un error si el navegador solicita cualquier otra cosa. Para
esto necesitamos modificar <code>handle_connection</code>, como se muestra en el Listado
20-6. Este nuevo c√≥digo verifica el contenido de la solicitud recibida contra
lo que sabemos que se parece una solicitud para <em>/</em> y agrega bloques <code>if</code> y
<code>else</code> para tratar las solicitudes de manera diferente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == &quot;GET / HTTP/1.1&quot; {
        let status_line = &quot;HTTP/1.1 200 OK&quot;;
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
<p><span class="caption">Listing 20-6: Tratar las solicitudes a <em>/</em> de manera 
diferente a las dem√°s solicitudes</span></p>
<p>Solo vamos a analizar la primera l√≠nea de la solicitud HTTP, por lo que en 
lugar de leer toda la solicitud en un vector, estamos llamando a <code>next</code> para
obtener el primer elemento del iterator. El primer <code>unwrap</code> se encarga de la
<code>Option</code> y detiene el programa si el iterator no tiene elementos. El segundo
<code>unwrap</code> maneja el <code>Result</code> y tiene el mismo efecto que el <code>unwrap</code> que estaba
en el <code>map</code> agregado en el Listado 20-2.</p>
<p>A continuaci√≥n, verificamos si la <code>request_line</code> es igual a la l√≠nea de
solicitud de una solicitud GET a la ruta */**. Si es as√≠, el bloque <code>if</code>
devuelve el contenido de nuestro archivo HTML.</p>
<p>Si la <code>request_line</code> no es igual a la l√≠nea de solicitud GET al camino <em>/</em>,
significa que hemos recibido alguna otra solicitud. Agregaremos c√≥digo al
bloque <code>else</code> en un momento para responder a todas las dem√°s solicitudes.</p>
<p>Ejecuta este c√≥digo ahora y solicita <em>127.0.0.1:7878</em>; deber√≠as ver el HTML
en <em>hello.html</em>. Si haces cualquier otra solicitud, como 
<em>127.0.0.1:7878/something-else</em>, obtendr√°s un error de conexi√≥n como los que
viste al ejecutar el c√≥digo en el Listado 20-1 y el Listado 20-2.</p>
<p>Ahora agreguemos el c√≥digo del Listado 20-7 al bloque <code>else</code> para devolver
una respuesta con el c√≥digo de estado 404, que indica que el contenido de la
solicitud no se encontr√≥. Tambi√©n devolveremos un poco de HTML para una p√°gina
que se renderizar√° en el navegador indicando la respuesta al usuario final.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == &quot;GET / HTTP/1.1&quot; {
</span><span class="boring">        let status_line = &quot;HTTP/1.1 200 OK&quot;;
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 20-7: Respondiendo con el c√≥digo de estado 404 y
una p√°gina de error si se solicita algo distinto a <em>/</em></span></p>
<p>Aqu√≠, nuestra respuesta tiene una l√≠nea de estado con el c√≥digo de estado 404
y la frase de motivo <code>NOT FOUND</code>. El cuerpo de la respuesta ser√° el HTML en el
archivo <em>404.html</em>. Necesitar√°s crear un archivo <em>404.html</em> junto a
<em>hello.html</em> para la p√°gina de error; nuevamente, si√©ntete libre de usar
cualquier HTML que desees o usa el HTML de ejemplo en el Listado 20-8.</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Contenido de ejemplo para la p√°gina que
se enviar√° como respuesta en cualquier caso de error 404</span></p>
<p>Con estos cambios, ejecuta tu servidor nuevamente. Al solicitar <em>127.0.0.1:7878</em>
deber√≠as obtener el contenido de <em>hello.html</em>, y cualquier otra solicitud,
como <em>127.0.0.1:7878/foo</em>, deber√≠a devolver el HTML de <em>404.html</em>.</p>
<h3 id="un-toque-de-refactorizaci√≥n"><a class="header" href="#un-toque-de-refactorizaci√≥n">Un toque de refactorizaci√≥n</a></h3>
<p>En este momento, los bloques <code>if</code> y <code>else</code> tienen mucha repetici√≥n: ambos
est√°n leyendo archivos y escribiendo el contenido de los archivos en el
stream. Las √∫nicas diferencias son la l√≠nea de estado y el nombre del archivo.
Hagamos que el c√≥digo sea m√°s conciso extrayendo esas diferencias en l√≠neas
<code>if</code> y <code>else</code> separadas que asignar√°n los valores de la l√≠nea de estado y el
nombre del archivo a variables; luego podemos usar esas variables
incondicionalmente en el c√≥digo para leer el archivo y escribir la respuesta.
El Listado 20-9 muestra el c√≥digo resultante despu√©s de reemplazar los grandes
bloques <code>if</code> y <code>else</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == &quot;GET / HTTP/1.1&quot; {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-9: Refactorizando los bloques <code>if</code> y <code>else</code>
para que contengan solo el c√≥digo que difiere entre los dos casos</span></p>
<p>Ahora los bloques <code>if</code> y <code>else</code> solo devuelven los valores apropiados para la
l√≠nea de estado y el nombre de archivo en una tupla; luego usamos la
destructuraci√≥n para asignar estos dos valores a <code>status_line</code> y <code>filename</code>
usando un patr√≥n en la declaraci√≥n <code>let</code>, como se discuti√≥ en el Cap√≠tulo 18.</p>
<p>El c√≥digo previamente duplicado ahora est√° fuera de los bloques <code>if</code> y <code>else</code>
y usa las variables <code>status_line</code> y <code>filename</code>. Esto hace que sea m√°s f√°cil
ver la diferencia entre los dos casos, y significa que solo tenemos un lugar
para actualizar el c√≥digo si queremos cambiar la forma en que funciona la
lectura de archivos y la escritura de respuestas. El comportamiento del c√≥digo
en el Listado 20-9 ser√° el mismo que el del Listado 20-7.</p>
<p>¬°Incre√≠ble! Ahora tenemos un servidor web simple en aproximadamente 40 l√≠neas
de c√≥digo Rust que responde a una solicitud con una p√°gina de contenido y
responde a todas las dem√°s solicitudes con una respuesta 404.</p>
<p>Actualmente, nuestro servidor se ejecuta en un solo hilo, lo que significa que
solo puede atender una solicitud a la vez. Analicemos c√≥mo esto puede ser un
problema al simular algunas solicitudes lentas. Luego lo arreglaremos para que
nuestro servidor pueda manejar m√∫ltiples solicitudes a la vez.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="convirtiendo-nuestro-servidor-de-un-solo-hilo-en-un-servidor-multihilo"><a class="header" href="#convirtiendo-nuestro-servidor-de-un-solo-hilo-en-un-servidor-multihilo">Convirtiendo nuestro servidor de un solo hilo en un servidor multihilo</a></h2>
<p>Actualmente, el servidor procesar√° cada solicitud de forma secuencial, lo que
significa que no procesar√° una segunda conexi√≥n hasta que se termine de
procesar la primera. Si el servidor recibe m√°s y m√°s solicitudes, esta
ejecuci√≥n en serie ser√° menos y menos √≥ptima. Si el servidor recibe una
solicitud que tarda mucho tiempo en procesarse, las solicitudes posteriores
tendr√°n que esperar hasta que la solicitud larga haya terminado, incluso si las
nuevas solicitudes se pueden procesar r√°pidamente. Tendremos que solucionar
esto, pero primero, veremos el problema en acci√≥n.</p>
<h3 id="simulando-una-solicitud-lenta-en-la-implementaci√≥n-actual-del-servidor"><a class="header" href="#simulando-una-solicitud-lenta-en-la-implementaci√≥n-actual-del-servidor">Simulando una solicitud lenta en la implementaci√≥n actual del servidor</a></h3>
<p>Para simular una solicitud lenta, podemos hacer que el servidor duerma durante
un tiempo antes de responder. Veremos c√≥mo una solicitud de procesamiento
lento puede afectar a otras solicitudes realizadas a nuestra implementaci√≥n
actual del servidor. El listado 20-10 implementa el manejo de una solicitud a
<em>/sleep</em> con una respuesta lenta simulada que har√° que el servidor duerma
durante 5 segundos antes de responder.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
<p><span class="caption">Listing 20-10: Simulando una solicitud lenta durmiendo
durante 5 segundos</span></p>
<p>Hemos cambiado de <code>if</code> a <code>match</code> ahora que tenemos tres casos. Necesitamos
hacer coincidir expl√≠citamente con un slice de <code>request_line</code> para hacer
coincidir con los valores literales de string; <code>match</code> no hace referencia
autom√°tica y desreferenciaci√≥n como el m√©todo de igualdad.</p>
<p>La primera opci√≥n es la misma que el bloque <code>if</code> del Listado 20-9. La segunda
opci√≥n coincide con una solicitud a <em>/sleep</em>. Cuando se recibe esa solicitud, el
servidor dormir√° durante 5 segundos antes de representar la p√°gina HTML
correcta. La tercera opci√≥n es la misma que el bloque <code>else</code> del Listado 20-9.</p>
<p>Puedes ver c√≥mo nuestro servidor es primitivo: ¬°las bibliotecas reales
manejar√≠an el reconocimiento de m√∫ltiples solicitudes de una manera mucho menos
verbosa!</p>
<p>Iniciamos el servidor con <code>cargo run</code>. Luego abrimos dos ventanas del navegador:
una para <em>http://127.0.0.1:7878/</em> y la otra para <em>http://127.0.0.1:7878/sleep</em>.
Si ingresas la URI <em>/</em> varias veces, como antes, ver√°s que responde r√°pidamente.
Pero si ingresas <em>/sleep</em> y luego cargas <em>/</em>, ver√°s que <em>/</em> espera hasta que
<code>sleep</code> haya dormido durante sus 5 segundos completos antes de cargarse.</p>
<p>Existen varias t√©cnicas que podr√≠amos usar para evitar que las solicitudes se
acumulen detr√°s de una solicitud lenta; la que implementaremos es un <em>pool de
hilos</em>.</p>
<h3 id="mejorando-el-rendimiento-con-un-pool-de-hilos"><a class="header" href="#mejorando-el-rendimiento-con-un-pool-de-hilos">Mejorando el rendimiento con un pool de hilos</a></h3>
<p>Un <em>pool de hilos</em> es un grupo de hilos generados que est√°n esperando y listos
para manejar una tarea. Cuando el programa recibe una nueva tarea, asigna uno
de los hilos del grupo a la tarea, y ese hilo procesar√° la tarea. Los hilos
restantes en el grupo est√°n disponibles para manejar cualquier otra tarea que
llegue mientras el primer hilo est√° procesando. Cuando el primer hilo termina
de procesar su tarea, se devuelve al grupo de hilos inactivos, listo para
manejar una nueva tarea. Un pool de hilos le permite procesar conexiones de
forma concurrente, aumentando el rendimiento de su servidor.</p>
<p>Limitaremos el n√∫mero de hilos en el grupo a un n√∫mero peque√±o para protegernos
de los ataques de denegaci√≥n de servicio (DoS); si nuestro programa creara un
nuevo hilo para cada solicitud que llegara, alguien que hiciera 10 millones de
solicitudes a nuestro servidor podr√≠a crear el caos al agotar todos los
recursos de nuestro servidor y detener el procesamiento de las solicitudes.</p>
<p>En lugar de crear un nuevo hilo para cada solicitud, crearemos un grupo de
hilos que actuar√°n como un pool de hilos. Cuando llega una solicitud, el
servidor enviar√° la solicitud al pool de hilos. El pool de hilos mantendr√° una
cola de solicitudes entrantes. Cada uno de los hilos en el pool sacar√° una
solicitud de esta cola, manejar√° la solicitud y luego pedir√° a la cola otra
solicitud. Con este dise√±o, podemos procesar hasta <code>N</code> solicitudes
simult√°neamente, donde <code>N</code> es el n√∫mero de hilos. Si cada hilo responde a una
solicitud de larga duraci√≥n, las solicitudes posteriores a√∫n pueden acumularse
en la cola, pero hemos aumentado el n√∫mero de solicitudes de larga duraci√≥n que
podemos manejar antes de llegar a ese punto.</p>
<p>Esta t√©cnica es solo una de las muchas formas de mejorar el rendimiento de un
servidor web. Otras opciones que puede explorar son el modelo <em>fork / join</em>,
el modelo de <em>I / O asincr√≥nico de un solo hilo</em> o el <em>modelo de I / O
asincr√≥nico de m√∫ltiples hilos</em>. Si est√° interesado en este tema, puedes leer
m√°s sobre otras soluciones e intentar implementarlas; con un lenguaje de bajo
nivel como Rust, todas estas opciones son posibles.</p>
<p>Antes de comenzar a implementar un pool de hilos, hablemos sobre c√≥mo deber√≠a
verse el uso del pool. Cuando intentas dise√±ar c√≥digo, escribir la interfaz del
cliente primero puede ayudar a guiar tu dise√±o. Escribe la API del c√≥digo para
que est√© estructurado de la manera en que deseas llamarlo; luego implementa la
funcionalidad dentro de esa estructura en lugar de implementar la funcionalidad
y luego dise√±ar la API p√∫blica.</p>
<p>Similar a c√≥mo usamos el desarrollo impulsado por pruebas en el proyecto en el
Cap√≠tulo 12, usaremos el desarrollo impulsado por el compilador aqu√≠.
Escribiremos el c√≥digo que llama a las funciones que queremos, y luego
analizaremos los errores del compilador para determinar qu√© debemos cambiar a
continuaci√≥n para que el c√≥digo funcione. Antes de hacer eso, sin embargo,
exploraremos la t√©cnica que no vamos a usar como punto de partida.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="creando-un-hilo-para-cada-solicitud"><a class="header" href="#creando-un-hilo-para-cada-solicitud">Creando un hilo para cada solicitud</a></h4>
<p>Primero, exploremos c√≥mo podr√≠a lucir nuestro c√≥digo si cre√°ramos un nuevo hilo
para cada conexi√≥n. Como se mencion√≥ anteriormente, este no es nuestro plan
final debido a los problemas con la posibilidad de generar un n√∫mero ilimitado
de hilos, pero es un punto de partida para obtener un servidor web
multihilo. Luego agregaremos el pool de hilos como una mejora, y contrastar las
dos soluciones ser√° m√°s f√°cil. El Listado 20-11 muestra los cambios que debe
realizar en <code>main</code> para crear un nuevo hilo para manejar cada flujo dentro del
bucle <code>for</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 20-11: Creando un hilo para cada stream</span></p>
<p>Como aprendiste en el Cap√≠tulo 16, <code>thread::spawn</code> crear√° un nuevo hilo y luego
ejecutar√° el c√≥digo en el cierre en el nuevo hilo. Si ejecutas este c√≥digo y
cargas <em>/sleep</em> en tu navegador, luego <em>/</em> en otras dos pesta√±as del navegador,
ver√°s que las solicitudes a <em>/</em> no tienen que esperar a que <em>/sleep</em> termine.
Sin embargo, como mencionamos, esto eventualmente abrumar√° el sistema porque
estar√≠as creando nuevos hilos sin ning√∫n l√≠mite.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="creando-un-n√∫mero-finito-de-hilos"><a class="header" href="#creando-un-n√∫mero-finito-de-hilos">Creando un n√∫mero finito de hilos</a></h4>
<p>Queremos que nuestro pool de hilos funcione de manera similar y familiar, de
modo que cambiar de hilos a un pool de hilos no requiera grandes cambios en el
c√≥digo que usa nuestra API. El Listado 20-12 muestra la interfaz hipot√©tica
para un struct <code>ThreadPool</code> que queremos usar en lugar de <code>thread::spawn</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-12: Nuestra interfaz ideal de
<code>ThreadPool</code></span></p>
<p>Utilizamos <code>ThreadPool::new</code> para crear un nuevo pool de hilos con un n√∫mero
configurable de hilos, en este caso cuatro. Luego, en el bucle <code>for</code>,
<code>pool.execute</code> tiene una interfaz similar a <code>thread::spawn</code> en que toma un
cierre que el pool debe ejecutar para cada flujo. Necesitamos implementar
<code>pool.execute</code> para que tome el cierre y se lo d√© a un hilo en el pool para que
lo ejecute. Este c√≥digo a√∫n no se compilar√°, pero lo intentaremos para que el
compilador pueda guiarnos en c√≥mo solucionarlo.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="construyendo-threadpool-usando-el-desarrollo-impulsado-por-el-compilador"><a class="header" href="#construyendo-threadpool-usando-el-desarrollo-impulsado-por-el-compilador">Construyendo <code>ThreadPool</code> usando el desarrollo impulsado por el compilador</a></h4>
<p>Realiza los cambios en el Listado 20-12 a <em>src/main.rs</em>, y luego usemos los
errores del compilador de <code>cargo check</code> para impulsar nuestro desarrollo. Aqu√≠
est√° el primer error que obtenemos:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin &quot;hello&quot;) due to 1 previous error
</code></pre>
<p>¬°Eso es genial! Este error nos dice que necesitamos un tipo o m√≥dulo
<code>ThreadPool</code>, as√≠ que lo construiremos ahora. Nuestra implementaci√≥n de
<code>ThreadPool</code> ser√° independiente del tipo de trabajo que nuestro servidor web
est√° haciendo. Entonces, cambiemos el crate de <code>hello</code> de un crate binario a un
crate de biblioteca para contener nuestra implementaci√≥n de <code>ThreadPool</code>.
Despu√©s de cambiar a un crate de biblioteca, tambi√©n podr√≠amos usar la
biblioteca de pool de hilos separada para cualquier trabajo que queramos hacer
usando un pool de hilos y no solo para servir solicitudes web.</p>
<p>Crea un <em>src/lib.rs</em> que contenga lo siguiente, que es la definici√≥n m√°s simple
de un struct <code>ThreadPool</code> que podemos tener por ahora:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
<p>Luego edita el archivo <em>main.rs</em> para traer <code>ThreadPool</code> al scope del crate
desde el crate de la biblioteca agregando el siguiente c√≥digo en la parte
superior de <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p>Este c√≥digo a√∫n no funcionar√°, pero verifiqu√©moslo nuevamente para obtener el
siguiente error que debemos abordar:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin &quot;hello&quot;) due to 1 previous error
</code></pre>
<p>Este error indica que a continuaci√≥n debemos crear una funci√≥n asociada
llamada <code>new</code> para <code>ThreadPool</code>. Tambi√©n sabemos que <code>new</code> debe tener un
par√°metro que pueda aceptar <code>4</code> como argumento y debe devolver una instancia de
<code>ThreadPool</code>. Implementemos la funci√≥n <code>new</code> m√°s simple que tendr√° esas
caracter√≠sticas:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
<p>Elegimos <code>usize</code> como el tipo del par√°metro <code>size</code>, porque sabemos que un n√∫mero
negativo de hilos no tiene sentido. Tambi√©n sabemos que usaremos este <code>4</code> como
el n√∫mero de elementos en una colecci√≥n de hilos, que es para lo que se usa el
tipo <code>usize</code>, como se discuti√≥ en la secci√≥n <a href="ch03-02-data-types.html#tipos-de-enteros">‚ÄúTipos de enteros‚Äù</a>
del Cap√≠tulo 3.</p>
<p>Let‚Äôs check the code again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin &quot;hello&quot;) due to 1 previous error
</code></pre>
<p>Ahora ocurre un error porque no tenemos un m√©todo <code>execute</code> en <code>ThreadPool</code>.
Recordemos de la secci√≥n <a href="ch20-02-multithreaded.html#creating-a-similar-interface-for-a-finite-number-of-threads">‚ÄúCreando un n√∫mero finito de
hilos‚Äù</a><!--
ignore --> que decidimos que nuestro pool de hilos deber√≠a tener una interfaz
similar a <code>thread::spawn</code>. Adem√°s, implementaremos la funci√≥n <code>execute</code> para
que tome el cierre que se le da y se lo d√© a un hilo inactivo en el pool para
que lo ejecute.</p>
<p>Definiremos el m√©todo <code>execute</code> en <code>ThreadPool</code> para tomar un closure como
par√°metro. Recordemos de la secci√≥n <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">‚ÄúMover valores capturados fuera del
closure y los traits <code>Fn</code>‚Äù</a><!-- ignore --> en el Cap√≠tulo 13 que
podemos tomar cierres como par√°metros con tres traits diferentes: <code>Fn</code>,
<code>FnMut</code> y <code>FnOnce</code>. Necesitamos decidir qu√© tipo de cierre usar aqu√≠. Sabemos
que terminaremos haciendo algo similar a la implementaci√≥n de la biblioteca
est√°ndar <code>thread::spawn</code>, por lo que podemos ver qu√© l√≠mites tiene la firma de
<code>thread::spawn</code> en su par√°metro. La documentaci√≥n nos muestra lo siguiente:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>El par√°metro de tipo <code>F</code> es el que nos preocupa aqu√≠; el par√°metro de tipo <code>T</code>
est√° relacionado con el valor de retorno, y no nos preocupa eso. Podemos ver
que <code>spawn</code> usa <code>FnOnce</code> como l√≠mite de trait en <code>F</code>. Esto es probablemente lo
que queremos tambi√©n, porque eventualmente pasaremos el argumento que obtenemos
en <code>execute</code> a <code>spawn</code>. Podemos estar m√°s seguros de que <code>FnOnce</code> es el trait
que queremos usar porque el hilo para ejecutar una solicitud solo ejecutar√° el
closure de esa solicitud una vez, lo que coincide con el <code>Once</code> en <code>FnOnce</code>.</p>
<p>El trait <code>FnOnce</code> tambi√©n tiene un trait bound <code>Send</code> y un lifetime bound
<code>'static</code>, que son √∫tiles en nuestra situaci√≥n: necesitamos <code>Send</code> para
transferir el closure de un hilo a otro y <code>'static</code> porque no sabemos cu√°nto
tiempo tomar√° el hilo para ejecutarse. Creemos un m√©todo <code>execute</code> en
<code>ThreadPool</code> que tomar√° un par√°metro gen√©rico de tipo <code>F</code> con estos bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
<p>A√∫n usamos <code>()</code> despu√©s de <code>FnOnce</code> porque este <code>FnOnce</code> representa un closure
que no toma par√°metros y devuelve el tipo de unidad <code>()</code>. Al igual que las
definiciones de funciones, el tipo de retorno se puede omitir de la firma, pero
incluso si no tenemos par√°metros, todav√≠a necesitamos los par√©ntesis.</p>
<p>Una vez m√°s, esta es la implementaci√≥n m√°s simple del m√©todo <code>execute</code>: no hace
nada, pero estamos tratando de que nuestro c√≥digo compile. Verifiquemos
nuevamente:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>¬°Compila! Pero ten en cuenta que si intentas <code>cargo run</code> y haces una solicitud
en el navegador, ver√°s los errores en el navegador que vimos al comienzo del
cap√≠tulo. ¬°Nuestra biblioteca a√∫n no est√° llamando al closure pasado a
<code>execute</code>!</p>
<blockquote>
<p>Nota: Una frase que podr√≠as escuchar sobre lenguajes con compiladores
estrictos, como Haskell y Rust, es ‚Äúsi el c√≥digo se compila, funciona‚Äù. Pero
esta frase no es universalmente cierta. Nuestro proyecto se compila, ¬°pero no
hace absolutamente nada! Si estuvi√©ramos construyendo un proyecto real y
completo, este ser√≠a un buen momento para comenzar a escribir pruebas
unitarias para verificar que el c√≥digo se compile <em>y</em> tenga el comportamiento
que queremos.</p>
</blockquote>
<h4 id="validando-el-n√∫mero-de-hilos-en-new"><a class="header" href="#validando-el-n√∫mero-de-hilos-en-new">Validando el n√∫mero de hilos en <code>new</code></a></h4>
<p>No estamos haciendo nada con los par√°metros a <code>new</code> y <code>execute</code>. Implementemos
los cuerpos de estas funciones con el comportamiento que queremos. Para
comenzar, pensemos en <code>new</code>. Anteriormente, elegimos un tipo sin signo para el
par√°metro <code>size</code>, porque un pool con un n√∫mero negativo de hilos no tiene
sentido. Sin embargo, un pool con cero hilos tampoco tiene sentido, pero cero
es un <code>usize</code> perfectamente v√°lido. Agregaremos c√≥digo para verificar que
<code>size</code> es mayor que cero antes de devolver una instancia de <code>ThreadPool</code> y
hacer que el programa se bloquee si recibe un cero usando el macro <code>assert!</code>,
como se muestra en el Listado 20-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listing 20-13: Implementando <code>ThreadPool::new</code> para
generar un panic si <code>size</code> es cero</span></p>
<p>Hemos agregado documentaci√≥n para nuestro <code>ThreadPool</code> con comentarios de
documentaci√≥n. Ten en cuenta que seguimos las buenas pr√°cticas de documentaci√≥n
agregando una secci√≥n que llama a las situaciones en las que nuestra funci√≥n
puede entrar en panic, como se discuti√≥ en el Cap√≠tulo 14. ¬°Intenta ejecutar
<code>cargo doc --open</code> y hacer clic en la estructura <code>ThreadPool</code> para ver c√≥mo se
ven los documentos generados para <code>new</code>!</p>
<p>En lugar de agregar la macro <code>assert!</code> como lo hicimos aqu√≠, podr√≠amos cambiar
<code>new</code> a <code>build</code> y devolver un <code>Result</code> como lo hicimos con <code>Config::build</code> en
el proyecto I/O en el Listado 12-9. Pero hemos decidido en este caso que
intentar crear un pool de hilos sin ning√∫n hilo deber√≠a ser un error
irrecuperable. Si te sientes ambicioso, intenta escribir una funci√≥n llamada
<code>build</code> con la siguiente firma para comparar con la funci√≥n <code>new</code>:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="creando-espacio-para-almacenar-los-hilos"><a class="header" href="#creando-espacio-para-almacenar-los-hilos">Creando espacio para almacenar los hilos</a></h4>
<p>Ahora que tenemos una forma de saber que tenemos un n√∫mero v√°lido de hilos para
almacenar en el pool, podemos crear esos hilos y almacenarlos en el struct
<code>ThreadPool</code> antes de devolver el struct. Pero, ¬øc√≥mo ‚Äúalmacenamos‚Äù un hilo?
Echemos otro vistazo a la firma de <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>La funci√≥n <code>spawn</code> devuelve un <code>JoinHandle&lt;T&gt;</code>, donde <code>T</code> es el tipo que el
closure devuelve. Intentemos usar <code>JoinHandle</code> tambi√©n y veamos qu√© sucede. En
nuestro caso, los closures que estamos pasando al pool de hilos manejar√°n la
conexi√≥n y no devolver√°n nada, por lo que <code>T</code> ser√° el tipo de unidad <code>()</code>.</p>
<p>El c√≥digo en el Listado 20-14 se compilar√°, pero a√∫n no crear√° ning√∫n hilo.
Hemos cambiado la definici√≥n de <code>ThreadPool</code> para contener un vector de
instancias de <code>thread::JoinHandle&lt;()&gt;</code>, inicializado el vector con una
capacidad de <code>size</code>, configurado un bucle <code>for</code> que ejecutar√° alg√∫n c√≥digo para
crear los hilos y devuelto una instancia de <code>ThreadPool</code> que los contiene.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listing 20-14: Creando un vector para que <code>ThreadPool</code>
contenga los hilos</span></p>
<p>Hemos llevado <code>std::thread</code> al scope en la biblioteca, porque estamos usando
<code>thread::JoinHandle</code> como el tipo de los elementos en el vector en
<code>ThreadPool</code>.</p>
<p>Una vez que se recibe un tama√±o v√°lido, nuestro <code>ThreadPool</code> crea un nuevo
vector que puede contener <code>size</code> elementos. La funci√≥n <code>with_capacity</code>
realiza la misma tarea que <code>Vec::new</code>, pero con una diferencia importante: se
asigna espacio en el vector. Debido a que sabemos que necesitamos almacenar
<code>size</code> elementos en el vector, hacer esta asignaci√≥n por adelantado es
ligeramente m√°s eficiente que usar <code>Vec::new</code>, que se redimensiona a s√≠ mismo a
medida que se insertan elementos.</p>
<p>Cuando ejecutes <code>cargo check</code> nuevamente, deber√≠a tener √©xito:</p>
<h4 id="un-struct-worker-responsable-de-enviar-c√≥digo-desde-el-threadpool-a-un-hilo"><a class="header" href="#un-struct-worker-responsable-de-enviar-c√≥digo-desde-el-threadpool-a-un-hilo">Un struct <code>Worker</code> responsable de enviar c√≥digo desde el <code>ThreadPool</code> a un hilo</a></h4>
<p>Dejamos un comentario en el bucle <code>for</code> en el Listado 20-14 con respecto a la
creaci√≥n de hilos. Aqu√≠, veremos c√≥mo creamos hilos. La biblioteca est√°ndar
proporciona <code>thread::spawn</code> como una forma de crear hilos, y <code>thread::spawn</code>
espera obtener alg√∫n c√≥digo que el hilo debe ejecutar tan pronto como se cree
el hilo. Sin embargo, en nuestro caso, queremos crear los hilos y hacer que
<em>esperen</em> el c√≥digo que enviaremos m√°s tarde. La implementaci√≥n de la biblioteca
est√°ndar de hilos no incluye ninguna forma de hacer eso; tenemos que
implementarlo manualmente.</p>
<p>Implementaremos este comportamiento introduciendo una nueva estructura de datos
entre <code>ThreadPool</code> y los hilos que administrar√°n este nuevo comportamiento.
Llamaremos a esta estructura de datos <em>&quot;Worker&quot;</em>, que es un t√©rmino com√∫n en las
implementaciones de pooling. El Worker recoge el c√≥digo que debe ejecutarse y
ejecuta el c√≥digo en el hilo del Worker. Piensa en las personas que trabajan
en la cocina de un restaurante: los trabajadores esperan hasta que lleguen los
pedidos de los clientes, y luego son responsables de tomar esos pedidos y
cumplirlos.</p>
<p>En lugar de almacenar un vector de instancias <code>JoinHandle&lt;()&gt;</code> en el pool de
hilos, almacenaremos instancias del struct <code>Worker</code>. Cada <code>Worker</code> contendr√°
una instancia <code>JoinHandle&lt;()&gt;</code>. Luego, implementaremos un m√©todo en <code>Worker</code>
que tomar√° un closure de c√≥digo para ejecutar y lo enviar√° al hilo en ejecuci√≥n
para su ejecuci√≥n. Tambi√©n daremos a cada trabajador un <code>id</code> para que podamos
distinguir entre los diferentes trabajadores en el pool al registrar o depurar.</p>
<p>Aqu√≠ est√° el nuevo proceso que ocurrir√° cuando creemos un <code>ThreadPool</code>.
Implementaremos el c√≥digo que env√≠a el closure al hilo despu√©s de que tengamos
<code>Worker</code> configurado de esta manera:</p>
<ol>
<li>Definimos un struct <code>Worker</code> que contiene un <code>id</code> y un <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Cambiamos <code>ThreadPool</code> para contener un vector de instancias <code>Worker</code>.</li>
<li>Definimos una funci√≥n <code>Worker::new</code> que toma un n√∫mero <code>id</code> y devuelve una
instancia <code>Worker</code> que contiene un <code>id</code> y un hilo creado con un closure
vac√≠o.</li>
<li>En <code>ThreadPool::new</code>, usamos el contador del bucle <code>for</code> para generar un
<code>id</code>, creamos un nuevo <code>Worker</code> con ese <code>id</code> y almacenamos el trabajador en
el vector.</li>
</ol>
<p>Si est√°s listo para un desaf√≠o, intenta implementar estos cambios por ti mismo
antes de ver el c√≥digo en el Listado 20-15.</p>
<p>¬øListo? Aqu√≠ est√° el Listado 20-15 con una forma de hacer las modificaciones</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-15: Modificando <code>ThreadPool</code> para contener
instancias de <code>Worker</code> en lugar de contener hilos directamente</span></p>
<p>Hemos cambiado el nombre del campo en <code>ThreadPool</code> de <code>threads</code> a <code>workers</code>
porque ahora contiene instancias de <code>Worker</code> en lugar de instancias de
<code>JoinHandle&lt;()&gt;</code>. Usamos el contador en el bucle <code>for</code> como argumento para
<code>Worker::new</code>, y almacenamos cada nuevo <code>Worker</code> en el vector llamado
<code>workers</code>.</p>
<p>El c√≥digo externo (como nuestro servidor en <em>src/main.rs</em>) no necesita conocer
los detalles de implementaci√≥n con respecto al uso de un struct <code>Worker</code> dentro
de <code>ThreadPool</code>, por lo que hacemos que el struct <code>Worker</code> y su funci√≥n <code>new</code>
sean privadas. La funci√≥n <code>Worker::new</code> utiliza el <code>id</code> que le damos y almacena
una instancia <code>JoinHandle&lt;()&gt;</code> que se crea al generar un nuevo hilo usando un
closure vac√≠o.</p>
<blockquote>
<p>Nota: Si el sistema operativo no puede crear un hilo porque no hay suficientes
recursos del sistema, <code>thread::spawn</code> entrar√° en panic. Eso har√° que todo
nuestro servidor entre en panic, incluso si la creaci√≥n de algunos hilos
tiene √©xito. Por simplicidad, este comportamiento est√° bien, pero en una
implementaci√≥n de grupo de hilos de producci√≥n, es probable que desee usar
<a href="https://doc.rust-lang.org/std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> y su m√©todo
<a href="https://doc.rust-lang.org/std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore --> que devuelve <code>Result</code> en su lugar.</p>
</blockquote>
<p>Este c√≥digo se compilar√° y almacenar√° el n√∫mero de instancias <code>Worker</code> que
especificamos como argumento para <code>ThreadPool::new</code>. Pero todav√≠a no estamos
procesando el closure que obtenemos en <code>execute</code>. Veamos c√≥mo hacer eso a
continuaci√≥n.</p>
<h4 id="enviando-solicitudes-a-hilos-a-trav√©s-de-canales"><a class="header" href="#enviando-solicitudes-a-hilos-a-trav√©s-de-canales">Enviando solicitudes a hilos a trav√©s de canales</a></h4>
<p>El siguiente problema que abordaremos es que los closures que se pasan a
<code>tread::spawn</code> no hacen absolutamente nada. Actualmente, obtenemos el closure
que queremos ejecutar en el m√©todo <code>execute</code>. Pero necesitamos darle a
<code>thread::spawn</code> un closure para ejecutar cuando creamos cada <code>Worker</code> durante
la creaci√≥n del <code>ThreadPool</code>.</p>
<p>Queremos que los structs <code>Worker</code> que acabamos de crear obtengan el c√≥digo a
ejecutar desde una cola mantenida en <code>ThreadPool</code> y env√≠en ese c√≥digo a su
hilo para su ejecuci√≥n.</p>
<p>Los canales que aprendimos en el Cap√≠tulo 16, una forma simple de comunicarse
entre dos hilos, ser√≠an perfectos para este caso de uso. Usaremos un canal para
funcionar como la cola de trabajos, y <code>execute</code> enviar√° un trabajo desde el
<code>ThreadPool</code> a las instancias <code>Worker</code>, que enviar√°n el trabajo a su hilo. Aqu√≠
est√° el plan:</p>
<ol>
<li>El <code>ThreadPool</code> crear√° un canal y mantendr√° el emisor.</li>
<li>Cada <code>Worker</code> mantendr√° el receptor.</li>
<li>Crearemos un nuevo struct <code>Job</code> que contendr√° los closures que queremos
enviar a trav√©s del canal.</li>
<li>El m√©todo <code>execute</code> enviar√° el trabajo que desea ejecutar a trav√©s del
emisor.</li>
<li>En su hilo, el <code>Worker</code> recorrer√° su receptor y ejecutar√° los closures de
cualquier trabajo que reciba.</li>
</ol>
<p>Empecemos por crear un canal en <code>ThreadPool::new</code> y mantener el emisor en la
instancia <code>ThreadPool</code>, como se muestra en el Listado 20-16. El struct <code>Job</code>
no contiene nada por ahora, pero ser√° el tipo de elemento que enviaremos por el
canal.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-16: Modificando <code>ThreadPool</code> para almacenar el
emisor de un canal que transmite instancias <code>Job</code></span></p>
<p>En <code>ThreadPool::new</code>, creamos nuestro nuevo canal y hacemos que el pool
mantenga el emisor. Esto se compilar√° correctamente.</p>
<p>Intentemos pasar un receptor del canal a cada trabajador mientras el pool de
hilos crea el canal. Sabemos que queremos usar el receptor en el hilo que los
trabajadores generan, por lo que haremos referencia al par√°metro <code>receiver</code> en
el closure. El c√≥digo en el Listado 20-17 a√∫n no se compilar√°.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-17: Pasando el receptor a los
trabajadores</span></p>
<p>Hemos hecho algunos cambios peque√±os y sencillos: pasamos el receptor al
constructor <code>Worker::new</code>, y luego lo usamos dentro del closure.</p>
<p>Cuando intentamos compilar este c√≥digo, obtenemos este error:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>El c√≥digo est√° intentando pasar <code>receiver</code> a m√∫ltiples instancias de <code>Worker</code>.
Esto no funcionar√°, como recordar√° del Cap√≠tulo 16: la implementaci√≥n de canal
que Rust proporciona es de m√∫ltiples <em>productores</em>, un solo <em>consumidor</em>. Esto
significa que no podemos simplemente clonar el extremo consumidor del canal
para solucionar este c√≥digo. Tampoco queremos enviar un mensaje varias veces a
m√∫ltiples consumidores; queremos una lista de mensajes con m√∫ltiples
trabajadores de modo que cada mensaje se procese una vez.</p>
<p>Adem√°s, quitar un trabajo de la cola del canal implica modificar el <code>receiver</code>,
por lo que los hilos necesitan una forma segura de compartir y modificar el
<code>receiver</code>; de lo contrario, podr√≠amos obtener condiciones de carrera (como se
explic√≥ en el Cap√≠tulo 16).</p>
<p>Recuerda los smart pointers thread-safe discutidos en el Cap√≠tulo 16: para
compartir la propiedad entre varios hilos y permitir que los hilos muten el
valor, necesitamos usar <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. El tipo <code>Arc</code> permitir√° que varios
trabajadores sean propietarios del receptor, y <code>Mutex</code> garantizar√° que solo un
trabajador obtenga un trabajo del receptor a la vez. El Listado 20-18 muestra
los cambios que debemos hacer.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
<p><span class="caption">Listing 20-18: Compartiendo el receptor entre los
trabajadores usando <code>Arc</code> y <code>Mutex</code></span></p>
<p>En <code>ThreadPool::new</code>, ponemos el receptor en un <code>Arc</code> y un <code>Mutex</code>. Para cada
nuevo trabajador, clonamos el <code>Arc</code> para aumentar el recuento de referencias
para que los trabajadores puedan compartir la propiedad del receptor.</p>
<p>Con estos cambios, ¬°el c√≥digo se compila! ¬°Estamos llegando!</p>
<h4 id="implementando-el-m√©todo-execute"><a class="header" href="#implementando-el-m√©todo-execute">Implementando el m√©todo <code>execute</code></a></h4>
<p>En este punto, finalmente implementaremos el m√©todo <code>execute</code> en <code>ThreadPool</code>.
Tambi√©n cambiaremos <code>Job</code> de un struct a un alias de tipo para un objeto de
trait que contiene el tipo de cierre que recibe <code>execute</code>. Como se discuti√≥ en
la secci√≥n <a href="ch19-04-advanced-types.html#creando-type-synonyms-con-type-aliases">‚ÄúCreaci√≥n de sin√≥nimos de tipo con alias de
tipo‚Äù</a><!-- ignore -->
del Cap√≠tulo 19, los alias de tipo nos permiten hacer tipos largos m√°s cortos
para facilitar su uso. Mira el Listado 20-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-19: Creando un alias de tipo <code>Job</code> para un
<code>Box</code> que contenga cada closure y luego enviamos el trabajo por el canal</span></p>
<p>Despu√©s de crear una nueva instancia de <code>Job</code> usando el closure que obtenemos
en <code>execute</code>, enviamos ese trabajo por el extremo de env√≠o del canal. Estamos
llamando a <code>unwrap</code> en <code>send</code> para el caso de que el env√≠o falle. Esto podr√≠a
suceder si, por ejemplo, detenemos todos nuestros hilos de ejecuci√≥n, lo que
significa que el extremo receptor ha dejado de recibir nuevos mensajes. En este
momento, no podemos detener que nuestros hilos se ejecuten: nuestros hilos
contin√∫an ejecut√°ndose mientras exista el pool. La raz√≥n por la que usamos
<code>unwrap</code> es que sabemos que el caso de falla no suceder√°, pero el compilador no
sabe eso.</p>
<p>¬°Pero a√∫n no hemos terminado! En el trabajador, nuestro cierre que se pasa a
<code>thread::spawn</code> todav√≠a solo <em>hace referencia</em> al extremo receptor del canal.
En su lugar, necesitamos que el cierre se repita para siempre, preguntando al
extremo receptor del canal por un trabajo y ejecutando el trabajo cuando lo
obtiene. Hagamos el cambio que se muestra en el Listado 20-20 a <code>Worker::new</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {id} got a job; executing.&quot;);

            job();
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-20: Recibiendo y ejecutando los trabajos en el
hilo del trabajador</span></p>
<p>Aqu√≠, primero llamamos a <code>lock</code> en el <code>receiver</code> para adquirir el mutex, y
luego llamamos a <code>unwrap</code> para que el hilo actual se bloquee en caso de que
ocurra alg√∫n error. Adquirir un bloqueo puede fallar si el mutex est√° en un
estado <em>envenenado</em>, lo que puede suceder si alg√∫n otro hilo se bloque√≥ mientras
sosten√≠a el bloqueo en lugar de liberar el bloqueo. En esta situaci√≥n, llamar a
<code>unwrap</code> para que este hilo se bloquee es la acci√≥n correcta a tomar. Si√©ntase
libre de cambiar este <code>unwrap</code> a un <code>expect</code> con un mensaje de error que sea
significativo para ti.</p>
<p>Si obtenemos el bloqueo en el mutex, llamamos a <code>recv</code> en el receptor para
recibir un <code>Job</code>. Un <code>unwrap</code> final mueve m√°s all√° de cualquier error aqu√≠
tambi√©n, que podr√≠a ocurrir si el hilo que tiene el extremo de env√≠o se ha
apagado, similar a c√≥mo el m√©todo <code>send</code> devuelve <code>Err</code> si el receptor se
apaga.</p>
<p>La llamada a <code>recv</code> bloquea, por lo que si a√∫n no hay un trabajo, el hilo
actual esperar√° hasta que haya un trabajo disponible. El <code>Mutex&lt;T&gt;</code> garantiza
que solo un hilo <code>Worker</code> a la vez est√° tratando de solicitar un trabajo.</p>
<p>¬°Nuestro pool de hilos ahora est√° en un estado funcional! Ejecuta <code>cargo run</code>
y haz algunas solicitudes:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>¬°√âxito! Ahora tenemos un pool de hilos que ejecuta conexiones de forma
asincr√≥nica. Nunca hay m√°s de cuatro hilos creados, por lo que nuestro sistema
no se sobrecargar√° si el servidor recibe muchas solicitudes. Si hacemos una
solicitud a <em>/sleep</em>, el servidor podr√° atender otras solicitudes haciendo que
otro hilo las ejecute.</p>
<blockquote>
<p>Nota: Si abres <em>/sleep</em> en m√∫ltiples ventanas del navegador simult√°neamente,
podr√≠an cargarse una a la vez en intervalos de 5 segundos. Algunos navegadores
web ejecutan m√∫ltiples instancias de la misma solicitud secuencialmente por
razones de almacenamiento en cach√©. Esta limitaci√≥n no es causada por nuestro
servidor web.</p>
</blockquote>
<p>Despu√©s de aprender sobre el bucle <code>while let</code> en el Cap√≠tulo 18, es posible que
te preguntes por qu√© no escribimos el c√≥digo del hilo del trabajador como se
muestra en el Listado 20-21.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {id} got a job; executing.&quot;);

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-21: Una implementaci√≥n alternativa de
<code>Worker::new</code> usando <code>while let</code></span></p>
<p>Este c√≥digo se compila y se ejecuta, pero no produce el comportamiento de
sub procesamiento deseado: una solicitud lenta a√∫n har√° que otras solicitudes
esperen ser procesadas. La raz√≥n es algo sutil: el struct <code>Mutex</code> no tiene
un m√©todo p√∫blico <code>unlock</code> porque el ownership del bloqueo se basa en la
duraci√≥n del <code>MutexGuard&lt;T&gt;</code> dentro del <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> que el
m√©todo <code>lock</code> devuelve. En tiempo de compilaci√≥n, el borrow checker puede hacer
cumplir la regla de que un recurso protegido por un <code>Mutex</code> no se puede acceder
a menos que tengamos el bloqueo. Sin embargo, esta implementaci√≥n tambi√©n puede
resultar en que el bloqueo se mantenga m√°s tiempo de lo previsto si no somos
conscientes de la duraci√≥n del <code>MutexGuard&lt;T&gt;</code>.</p>
<p>El c√≥digo en el Listado 20-21 que usa <code>let job = receiver.lock().unwrap().recv().unwrap();</code> funciona porque con <code>let</code>, los
valores temporales utilizados en la expresi√≥n del lado derecho del signo igual
se descartan inmediatamente cuando finaliza la declaraci√≥n <code>let</code>. Sin embargo,
<code>while let</code> (y <code>if let</code> y <code>match</code>) no descarta los valores temporales hasta el
final del bloque asociado. En el Listado 20-21, el bloqueo permanece retenido
durante la duraci√≥n de la llamada a <code>job()</code>, lo que significa que otros
trabajadores no pueden recibir trabajos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apagado-y-limpieza-eficientes"><a class="header" href="#apagado-y-limpieza-eficientes">Apagado y limpieza eficientes</a></h2>
<p>El c√≥digo del Listing 20-20 est√° respondiendo requests de forma as√≠ncrona 
mediante el uso de un pool de threads, como pretend√≠amos, Recibimos 
algunas advertencias sobre los campos <code>workers</code>, <code>id</code> y <code>thread</code> que no
estamos usando de forma directa que nos recuerda que no estamos limpiando
nada. Cuando usamos el m√©todo menos elegante <span class="keystroke">ctrl-c</span>
para detener el thread principal, todos los dem√°s threads se detienen inmediatamente
tambi√©n, incluso si est√°n en medio de servir una request.</p>
<p>A continuaci√≥n, implementaremos el trait <code>Drop</code> para llamar a <code>join</code> en cada uno
de los threads del pool para que puedan terminar las requests en las que est√°n
trabajando antes de cerrar. Luego implementaremos una forma de decirle a los 
threads que deben dejar de aceptar nuevas requests y cerrarse. Para ver este
c√≥digo en acci√≥n, modificaremos nuestro servidor para que acepte solo dos
requests antes de cerrar el pool de threads correctamente.</p>
<h3 id="implementando-el-trait-drop-en-threadpool"><a class="header" href="#implementando-el-trait-drop-en-threadpool">Implementando el Trait <code>Drop</code> en <code>ThreadPool</code></a></h3>
<p>Comencemos implementando <code>Drop</code> en nuestro pool de threads. Cuando el pool se
destruye, nuestros threads deber√≠an unirse para asegurarse de que terminan su
trabajo. El Listing 20-22 muestra un primer intento de implementaci√≥n de <code>Drop</code>;
este c√≥digo a√∫n no funcionar√°.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-22: Uniendo cada thread cuando el thread pool
se sale del scope</span></p>
<p>Primero, iteramos a trav√©s de cada uno de los <code>workers</code> del pool de threads.
Usamos <code>&amp;mut</code> para esto porque <code>self</code> es una referencia mutable, y tambi√©n
necesitamos poder mutar <code>worker</code>. Para cada worker, imprimimos un mensaje
diciendo que este worker en particular se est√° cerrando, y luego llamamos a
<code>join</code> en el thread de ese worker. Si la llamada a <code>join</code> falla, usamos
<code>unwrap</code> para que Rust entre en p√°nico y haga una salida poco elegante.</p>
<p>Aqu√≠ est√° el error que obtenemos cuando compilamos este c√≥digo:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
   |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:1657:17

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>El error nos dice que no podemos llamar a <code>join</code> porque solo tenemos un
mutable borrow de cada <code>worker</code> y <code>join</code> toma el ownership de su argumento. 
Para solucionar este problema, necesitamos mover el thread fuera de la
instancia de <code>Worker</code> que posee <code>thread</code> para que <code>join</code> pueda consumir el
thread. Hicimos esto en el Listing 17-15: si <code>Worker</code> tiene un
<code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> en su lugar, podemos llamar al m√©todo
<code>take</code> en el <code>Option</code> para mover el valor fuera de la variante <code>Some</code> y
dejar una variante <code>None</code> en su lugar. En otras palabras, un <code>Worker</code> que
se est√° ejecutando tendr√° una variante <code>Some</code> en <code>thread</code>, y cuando
queramos limpiar un <code>Worker</code>, reemplazaremos <code>Some</code> con <code>None</code> para que el
<code>Worker</code> no tenga un thread para ejecutar.</p>
<p>Entonces sabemos que queremos actualizar la definici√≥n de <code>Worker</code> de esta
manera:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ahora usemos el compilador para encontrar los otros lugares que necesitan
cambiar. Al verificar este c√≥digo, obtenemos dos errores:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`
   |
note: the method `join` exists on the type `JoinHandle&lt;()&gt;`
  --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/std/src/thread/mod.rs:1657:5
help: consider using `Option::expect` to unwrap the `JoinHandle&lt;()&gt;` value, panicking if the value is an `Option::None`
   |
52 |             worker.thread.expect(&quot;REASON&quot;).join().unwrap();
   |                          +++++++++++++++++

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected `Option&lt;JoinHandle&lt;()&gt;&gt;`, found `JoinHandle&lt;_&gt;`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` (lib) due to 2 previous errors
</code></pre>
<p>Abordemos el segundo error, que apunta al c√≥digo al final de <code>Worker::new</code>;
necesitamos envolver el valor <code>thread</code> en <code>Some</code> cuando creamos un nuevo
<code>Worker</code>. Haga los siguientes cambios para corregir este error:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>El primer error est√° en nuestra implementaci√≥n de <code>Drop</code>. Mencionamos
anteriormente que pretend√≠amos llamar a <code>take</code> en el valor <code>Option</code> para mover
<code>thread</code> fuera de <code>worker</code>. Los siguientes cambios lo har√°n:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Como discutimos en el Cap√≠tulo 17, el m√©todo <code>take</code> en <code>Option</code> toma la variante
<code>Some</code> y deja <code>None</code> en su lugar. Estamos usando <code>if let</code> para deconstruir el
<code>Some</code> y obtener el thread; luego llamamos a <code>join</code> en el thread. Si el thread
de un worker ya es <code>None</code>, sabemos que ese worker ya ha tenido su thread
limpiado, por lo que en ese caso no sucede nada.</p>
<h3 id="se√±alando-a-los-threads-que-dejen-de-escuchar-por-jobs"><a class="header" href="#se√±alando-a-los-threads-que-dejen-de-escuchar-por-jobs">Se√±alando a los threads que dejen de escuchar por jobs</a></h3>
<p>Con todos los cambios que hemos hecho, nuestro c√≥digo se compila sin advertencias.
Sin embargo, las malas noticias son que este c√≥digo a√∫n no funciona de la manera
que queremos. La clave es la l√≥gica en los closures ejecutados por los threads
de las instancias de <code>Worker</code>: en este momento, llamamos a <code>join</code>, pero eso no
detendr√° los threads porque se ejecutan en un <code>loop</code> para siempre buscando jobs.
Si intentamos dejar caer nuestro <code>ThreadPool</code> con nuestra implementaci√≥n actual
de <code>drop</code>, el thread principal se bloquear√° para siempre esperando a que el
primer thread termine.</p>
<p>Para solucionar este problema, necesitamos un cambio en la implementaci√≥n de
<code>drop</code> de <code>ThreadPool</code> y luego un cambio en el loop de <code>Worker</code>.</p>
<p>En primer lugar, cambiemos la implementaci√≥n de <code>drop</code> de <code>ThreadPool</code> para
soltar expl√≠citamente el <code>sender</code> antes de esperar a que los threads terminen.
El Listing 20-23 muestra los cambios en <code>ThreadPool</code> para soltar expl√≠citamente
<code>sender</code>. Usamos la misma t√©cnica <code>Option</code> y <code>take</code> que hicimos con el thread
para poder mover <code>sender</code> fuera de <code>ThreadPool</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-23: Dejar caer expl√≠citamente <code>sender</code> antes de 
unirse a los threads del worker</span></p>
<p>Soltar <code>sender</code> cierra el canal, lo que indica que no se enviar√°n m√°s mensajes.
Cuando eso sucede, todas las llamadas a <code>recv</code> que los workers hacen en el loop
infinito devolver√°n un error. En el Listing 20-24, cambiamos el loop de <code>Worker</code>
para salir del loop con gracia en ese caso, lo que significa que los hreads
terminar√°n cuando la implementaci√≥n de <code>drop</code> de <code>ThreadPool</code> llame a <code>join</code>
en ellos.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p><span class="caption">Listing 20-24: Saliendo expl√≠citamente del loop cuando 
<code>recv</code> devuelve un error</span></p>
<p>Para ver este c√≥digo en acci√≥n, modifiquemos <code>main</code> para aceptar solo dos
requests antes de cerrar el servidor con gracia, como se muestra en el
Listing 20-25.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-25: Apagando el servidor despu√©s de servir dos 
requests saliendo del loop</span></p>
<p>No querr√≠amos que un servidor web del mundo real se apague despu√©s de servir
solo dos requests. Este c√≥digo solo demuestra que el apagado y la limpieza
con gracia funcionan.</p>
<p>El m√©todo <code>take</code> es definido en el trait <code>Iterator</code> y limita la iteraci√≥n
de los primeros dos items como m√°ximo. El <code>ThreadPool</code> saldr√° del scope 
al final de <code>main</code> y la implementaci√≥n <code>drop</code> correr√°.</p>
<p>Iniciamos el servidor con <code>cargo run</code> y hacemos tres requests. La tercera
request deber√≠a fallar, y en su terminal deber√≠a ver una salida similar a esta:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Es posible que vea un orden diferente de workers y mensajes impresos. Podemos
ver c√≥mo funciona este c√≥digo a partir de los mensajes: los workers 0 y 3
obtuvieron las dos primeras requests. El servidor dej√≥ de aceptar conexiones
despu√©s de la segunda conexi√≥n, y la implementaci√≥n <code>Drop</code> en <code>ThreadPool</code>
comienza a ejecutarse antes de que el worker 3 comience su trabajo. Al soltar
<code>sender</code> desconecta a todos los workers y les dice que se apaguen. Los workers
imprimen un mensaje cuando se desconectan, y luego el pool de threads llama a
<code>join</code> para esperar a que cada thread worker termine.</p>
<p>Fij√©monos en un aspecto interesante de esta ejecuci√≥n en particular: el
<code>ThreadPool</code> solt√≥ el <code>sender</code>, y antes de que cualquier worker recibiera un
error, intentamos unirnos al worker 0. El worker 0 a√∫n no hab√≠a recibido un
error de <code>recv</code>, por lo que el thread principal se bloque√≥ esperando a que el
worker 0 terminara. Mientras tanto, el worker 3 recibi√≥ un job y luego todos
los threads recibieron un error. Cuando el worker 0 termin√≥, el thread principal
esper√≥ a que el resto de los workers terminaran. En ese momento, todos hab√≠an
salido de sus loops y se detuvieron.</p>
<p>¬°Enhorabuena! Hemos completado nuestro proyecto; tenemos un servidor web b√°sico
que usa un pool de threads para responder de forma as√≠ncrona. Podemos realizar
un apagado con gracia del servidor, que limpia todos los threads del pool.</p>
<p>Aqu√≠ est√° el c√≥digo completo como referencia:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>¬°Podr√≠amos hacer m√°s! Si quieres seguir mejorando este proyecto, aqu√≠ hay algunas
ideas:</p>
<ul>
<li>A√±adir m√°s documentaci√≥n a <code>ThreadPool</code> y sus m√©todos p√∫blicos.</li>
<li>A√±adir tests de la funcionalidad de la librer√≠a.</li>
<li>Cambiar las llamadas a <code>unwrap</code> por un manejo de errores m√°s robusto.</li>
<li>Usar <code>ThreadPool</code> para realizar alguna tarea que no sea servir requests web.</li>
<li>Encontrar una librer√≠a de pool de threads en <a href="https://crates.io/">crates.io</a> e
implementar un servidor web similar usando la librer√≠a en su lugar. Luego
compara su API y robustez con el pool de threads que implementamos.</li>
</ul>
<h2 id="resumen-19"><a class="header" href="#resumen-19">Resumen</a></h2>
<p>¬°Bien hecho! ¬°Has llegado al final del libro! Queremos agradecerte por unirte
a nosotros en este tour de Rust. Ahora est√°s listo para implementar tus propios
proyectos en Rust y ayudar con los proyectos de otras personas. Ten en cuenta
que hay una comunidad acogedora de otros Rustaceans que estar√≠an encantados de
ayudarte con cualquier desaf√≠o que encuentres en tu viaje con Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ap√©ndice"><a class="header" href="#ap√©ndice">Ap√©ndice</a></h1>
<p>Las siguientes secciones contienen material de referencia que le puede ser √∫til 
en su viaje a Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ap√©ndice-a-palabras-clave"><a class="header" href="#ap√©ndice-a-palabras-clave">Ap√©ndice A: Palabras clave</a></h2>
<p>La siguiente lista contiene palabras clave que est√°n reservadas para el uso
actual o futuro del lenguaje Rust. Por lo tanto, no se pueden usar como
identificadores (excepto como identificadores brutos como discutiremos en la
secci√≥n ‚Äú<a href="appendix-01-keywords.html#identificadores-brutos">Identificadores brutos</a><!-- ignore -->‚Äù). Los
identificadores son nombres de funciones, variables, par√°metros, campos de
estructuras, m√≥dulos, cajas, constantes, macros, valores est√°ticos, atributos,
tipos, rasgos o lifetimes.</p>
<h3 id="palabras-clave-actuales-en-uso"><a class="header" href="#palabras-clave-actuales-en-uso">Palabras clave actuales en uso</a></h3>
<p>La siguiente lista contiene las palabras clave actuales en uso, con su
funcionalidad descrita.</p>
<ul>
<li><code>as</code> - realiza una conversi√≥n primitiva, elimina la ambig√ºedad del <em>trait</em>
espec√≠fico que contiene
un elemento, o cambiar el nombre de los elementos en las declaraciones <code>use</code> y 
<code>extern crate</code></li>
<li><code>async</code> -  retornar un <code>Future</code> en lugar de bloquear el hilo actual</li>
<li><code>await</code> - suspender la ejecuci√≥n hasta que el resultado de un <code>Future</code> est√© 
listo</li>
<li><code>break</code> - salir de un bucle inmediatamente</li>
<li><code>const</code> - define elementos constantes o punteros crudos constantes</li>
<li><code>continue</code> - continuar con la siguiente iteraci√≥n del bucle</li>
<li><code>crate</code> - en un camino de m√≥dulo, se refiere a la ra√≠z del m√≥dulo</li>
<li><code>dyn</code> - despacho din√°mico a un objeto de rasgo</li>
<li><code>else</code> - alternativa para las construcciones de flujo de control <code>if</code> y 
<code>if let</code></li>
<li><code>enum</code> - define una enumeraci√≥n</li>
<li><code>extern</code> - enlaza una funci√≥n o variable externa</li>
<li><code>false</code> - literal booleano falso</li>
<li><code>fn</code> - define una funci√≥n o el tipo de puntero de funci√≥n</li>
<li><code>for</code> - bucle sobre elementos de un iterador, implementa un rasgo, o 
especifica una vida m√°s alta</li>
<li><code>if</code> - ramificaci√≥n basada en el resultado de una expresi√≥n condicional</li>
<li><code>impl</code> - implementa funcionalidad propia o de rasgo</li>
<li><code>in</code> - parte de la sintaxis del bucle <code>for</code></li>
<li><code>let</code> - vincula una variable</li>
<li><code>loop</code> - bucle sin condici√≥n</li>
<li><code>match</code> - combina un valor con patrones</li>
<li><code>mod</code> - define un m√≥dulo</li>
<li><code>move</code> - hace que una funci√≥n clausura tome posesi√≥n de todos sus capturas</li>
<li><code>mut</code> - denota mutabilidad en referencias, punteros crudos o vinculaciones de 
patrones</li>
<li><code>pub</code> - denota visibilidad p√∫blica en campos de estructuras, bloques <code>impl</code> o 
m√≥dulos</li>
<li><code>ref</code> - vincula por referencia</li>
<li><code>return</code> - retorna de una funci√≥n</li>
<li><code>Self</code> - un alias de tipo para el tipo que estamos definiendo o implementando</li>
<li><code>self</code> - sujeto de m√©todo o m√≥dulo actual</li>
<li><code>static</code> - variable global o duraci√≥n de vida que dura toda la ejecuci√≥n del 
programa</li>
<li><code>struct</code> - define una estructura</li>
<li><code>super</code> - m√≥dulo padre del m√≥dulo actual</li>
<li><code>trait</code> - define un rasgo</li>
<li><code>true</code> - literal booleano verdadero</li>
<li><code>type</code> - define un alias de tipo o tipo asociado</li>
<li><code>union</code> - define una <a href="https://doc.rust-lang.org/reference/items/unions.html">uni√≥n</a><!-- ignore -->; solo es una palabra clave 
cuando se usa en una declaraci√≥n de uni√≥n</li>
<li><code>unsafe</code> - denota c√≥digo, funciones, rasgos o implementaciones inseguras</li>
<li><code>use</code> - importa s√≠mbolos en el √°mbito</li>
<li><code>where</code> - denota cl√°usulas que restringen un tipo</li>
<li><code>while</code> - bucle condicionalmente basado en el resultado de una expresi√≥n</li>
</ul>
<h3 id="palabras-clave-reservadas-para-uso-futuro"><a class="header" href="#palabras-clave-reservadas-para-uso-futuro">Palabras clave reservadas para uso futuro</a></h3>
<p>Las siguientes palabras clave no tienen a√∫n ninguna funcionalidad, pero est√°n
reservadas por Rust para un uso potencial en el futuro.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="identificadores-brutos"><a class="header" href="#identificadores-brutos">Identificadores brutos</a></h3>
<p><em>Identificadores brutos</em> son la sintaxis que le permite usar palabras clave
donde normalmente no se permitir√≠an. Usted usa un identificador bruto
prefijando una palabra clave con <code>r#</code>.</p>
<p>Por ejemplo, <code>match</code> es una palabra clave. Si intenta compilar la siguiente
funci√≥n que usa <code>match</code> como su nombre:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>obtendr√° este error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>El error muestra que no se puede usar la palabra clave <code>match</code> como
identificador de funci√≥n. Para usar <code>match</code> como nombre de funci√≥n, necesita
usar la sintaxis de identificador bruto, como esta:</p>
<p><span class="filename">Nombre de archivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}</code></pre></pre>
<p>Este c√≥digo compilar√° sin errores. Note el prefijo <code>r#</code> en el nombre de la
funci√≥n en su definici√≥n, as√≠ como donde se llama la funci√≥n en <code>main</code>.</p>
<p>Los identificadores brutos permiten usar cualquier palabra como identificador,
incluso si esa palabra es una palabra clave. Esto nos da m√°s libertad para
elegir nombres de identificadores, as√≠ como nos permite integrarnos con
programas escritos en un lenguaje donde estas palabras no son palabras clave.
Adem√°s, los identificadores brutos nos permiten usar bibliotecas escritas en
una edici√≥n de Rust diferente a la de su crate. Por ejemplo, <code>try</code> no es una
palabra clave en la edici√≥n 2015, pero lo es en la edici√≥n 2018. Si depende de
una biblioteca que est√° escrita usando la edici√≥n 2015 y tiene una funci√≥n
<code>try</code>, necesitar√° usar la sintaxis de identificador bruto para llamar a esa
funci√≥n desde su c√≥digo de la edici√≥n 2018. Vea <a href="appendix-05-editions.html">Ap√©ndice E</a><!--
ignore --> para obtener m√°s informaci√≥n sobre las ediciones.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-b-operators-and-symbols"><a class="header" href="#appendix-b-operators-and-symbols">Appendix B: Operators and Symbols</a></h2>
<h2 id="ap√©ndice-b-operadores-y-s√≠mbolos"><a class="header" href="#ap√©ndice-b-operadores-y-s√≠mbolos">Ap√©ndice B: Operadores y s√≠mbolos</a></h2>
<p>Este ap√©ndice contiene una lista de los operadores y s√≠mbolos que aparecen en
Rust, incluyendo los operadores y otros s√≠mbolos que aparecen por s√≠ mismos o en
el contexto de rutas, gen√©ricos, l√≠mites de trait, macros, atributos, comentarios,
tuplas y corchetes.</p>
<h3 id="operadores"><a class="header" href="#operadores">Operadores</a></h3>
<p>La tabla B-1 contiene los operadores en Rust, un ejemplo de c√≥mo aparecer√≠a el
operador en contexto, una breve explicaci√≥n y si ese operador es
sobrecargable. Si un operador es sobrecargable, se lista el rasgo relevante para
sobrecargar ese operador.</p>
<p><span class="caption">Tabla B-1: Operadores</span></p>
<div class="table-wrapper"><table><thead><tr><th>Operador</th><th>Ejemplo</th><th>Explicaci√≥n</th><th>Sobrecargable?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Expansor de Macros</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Operador bit a bit o complemento l√≥gico</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Comparador de No Igualdad</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Modulo</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Modulo y asignaci√≥n</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Pr√©stamo</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Pr√©stamo del puntero del tipo</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Operador bit a bit AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Operador bit a bit AND y asignaci√≥n</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Operador l√≥gico AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Multiplicaci√≥n</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Multiplicaci√≥n y asignaci√≥n</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Direferencia</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Puntero</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Restricci√≥n de tipo compuesta</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Aritm√©tico adici√≥n</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Adici√≥n y asignaci√≥n</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Separador de argumentos y elementos</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Aritm√©tico de Negaci√≥n</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Aritm√©tico de sustracci√≥n</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Aritm√©tico de sustracci√≥n y asignaci√≥n</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Tipo de retorno en funciones y clausuras</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Acceso a miembro</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Rango exclusivo a la derecha</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Rango inclusivo a la derecha</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Sintaxis de actualizaci√≥n de estructuras</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Patr√≥n ‚Äúy el resto‚Äù</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Obsoleto, use <code>..=</code> en su lugar) En un patr√≥n: Patr√≥n de rango inclusivo</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Divisi√≥n aritm√©tica</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Divisi√≥n aritm√©tica y asignaci√≥n</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Restricciones</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Inicializador de campo de estructura</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Etiqueta de bucle</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Terminador de declaraci√≥n y elemento</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Parte de la sintaxis de arreglos de tama√±o fijo</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Desplazamiento a la izquierda</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Desplazamiento a la izquierda y asignaci√≥n</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Comparador de menor que</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Comparador de menor o igual que</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Asignaci√≥n/equivalencia</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Comparador de igualdad</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Parte de la sintaxis de match</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Comparador de mayor que</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Comparador de mayor o igual que</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Desplazamiento a la derecha</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Desplazamiento a la derecha y asignaci√≥n</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Patr√≥n de enlace</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Operador bit a bit XOR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Operador bit a bit XOR y asignaci√≥n</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Patr√≥n alternativo</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Operador bit a bit OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Operador bit a bit OR y asignaci√≥n</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Operador l√≥gico OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Operador de propagaci√≥n de errores</td><td></td></tr>
</tbody></table>
</div>
<h3 id="simbolos-no-operadores"><a class="header" href="#simbolos-no-operadores">Simbolos no operadores</a></h3>
<p>La siguiente lista contiene todos los s√≠mbolos que no funcionan como
operadores; es decir, no se comportan como una llamada de funci√≥n o m√©todo.</p>
<p>Tabla B-2 muestra los s√≠mbolos que aparecen por s√≠ mismos y son v√°lidos en una
variedad de ubicaciones.</p>
<p><span class="caption">Tabla B-2: Sintaxis √∫nicas</span></p>
<div class="table-wrapper"><table><thead><tr><th>S√≠mbolos</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Lifetime nombrado o etiqueta de bucle</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Literal num√©rico de un tipo especifico</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>Literal de tipo String</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>Literal de tipo String sin procesar</td></tr>
<tr><td><code>b'...'</code></td><td>Literal de tipo byte; construye un array de bytes en lugar de una cadena</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>Literal de tipo String sin procesar, combinaci√≥n de literal de tipo String y literal de tipo byte</td></tr>
<tr><td><code>'...'</code></td><td>Literal de tipo caracter</td></tr>
<tr><td><code>b'...'</code></td><td>Literal de tipo byte ASCII</td></tr>
<tr><td><code>|...| expr</code></td><td>Clausura</td></tr>
<tr><td><code>!</code></td><td>Tipo de dato vac√≠o siempre vac√≠o para funciones divergentes</td></tr>
<tr><td><code>_</code></td><td>‚ÄúIgnored‚Äù patr√≥n de enlace; tambi√©n se usa para hacer que los literales enteros sean legibles</td></tr>
</tbody></table>
</div>
<p>Tabla B-3 muestra los s√≠mbolos que aparecen en el contexto de un camino a trav√©s
del m√≥dulo de la jerarqu√≠a para un elemento.</p>
<p><span class="caption">Tabla B-3: Sintaxis relacionado a Rutas</span></p>
<div class="table-wrapper"><table><thead><tr><th>S√≠mbolos</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Namespace path</td></tr>
<tr><td><code>::path</code></td><td>Path relative to the crate root (i.e., an explicitly absolute path)</td></tr>
<tr><td><code>self::path</code></td><td>Path relative to the current module (i.e., an explicitly relative path)</td></tr>
<tr><td><code>super::path</code></td><td>Path relative to the parent of the current module</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Associated constants, functions, and types</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Associated item for a type that cannot be directly named (e.g., <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Disambiguating a method call by naming the trait that defines it</td></tr>
<tr><td><code>type::method(...)</code></td><td>Disambiguating a method call by naming the type for which it‚Äôs defined</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Disambiguating a method call by naming the trait and type</td></tr>
</tbody></table>
</div>
<p>Tabla B-4 muestra los s√≠mbolos que aparecen en el contexto de usar par√°metros de
tipo gen√©rico.</p>
<p><span class="caption">Tabla B-4: Genericos</span></p>
<div class="table-wrapper"><table><thead><tr><th>S√≠mbolos</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Especifica par√°metros de tipo gen√©rico en un tipo (por ejemplo, <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Especifica par√°metros de tipo gen√©rico, funci√≥n o m√©todo en una expresi√≥n; a menudo se refiere como pez espada (por ejemplo, <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Define una funci√≥n gen√©rica</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Define una estructura gen√©rica</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Define una enumeraci√≥n gen√©rica</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Define una implementaci√≥n gen√©rica</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>L√≠mites de vida de rango superior</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Un tipo gen√©rico donde uno o m√°s tipos asociados tienen asignaciones espec√≠ficas (por ejemplo, <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Tabla B-5 muestra los s√≠mbolos que aparecen en el contexto de restringir
par√°metros de tipo gen√©rico con l√≠mites de tipo.</p>
<p><span class="caption">Tabla B-5: Restricciones de tipo</span></p>
<div class="table-wrapper"><table><thead><tr><th>Simbolos</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Par√°metro de tipo gen√©rico <code>T</code> restringido a tipos que implementan <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Tipo gen√©rico <code>T</code> debe sobrevivir al tiempo de vida <code>'a</code> (es decir, el tipo no puede contener de forma transitiva referencias con tiempos de vida m√°s cortos que <code>'a</code>)</td></tr>
<tr><td><code>T: 'static</code></td><td>Tipo gen√©rico <code>T</code> no contiene referencias prestadas, excepto las de <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>Tiempo de vida gen√©rico <code>'b</code> debe sobrevivir al tiempo de vida <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Permitir que el par√°metro de tipo gen√©rico sea un tipo de tama√±o din√°mico</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Restricci√≥n de tipo compuesta</td></tr>
</tbody></table>
</div>
<p>Tabla B-6 muestra los s√≠mbolos que aparecen en el contexto de llamar o definir
macros y especificar atributos en un elemento.</p>
<p><span class="caption">Tabla B-6: Macros y Atributos</span></p>
<div class="table-wrapper"><table><thead><tr><th>S√≠mbolos</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Atributo externo</td></tr>
<tr><td><code>#![meta]</code></td><td>Atributo interno</td></tr>
<tr><td><code>$ident</code></td><td>Sustituci√≥n de macro</td></tr>
<tr><td><code>$ident:kind</code></td><td>Captura de macro</td></tr>
<tr><td><code>$(...)...</code></td><td>Repetici√≥n de macro</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Invocaci√≥n de macro</td></tr>
</tbody></table>
</div>
<p>Tabla B-7 muestra los s√≠mbolos que crean comentarios.</p>
<p><span class="caption">Tabla B-7: Comentarios</span></p>
<div class="table-wrapper"><table><thead><tr><th>S√≠mbolos</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Comentario de l√≠nea</td></tr>
<tr><td><code>//!</code></td><td>Comentario de l√≠nea de documentaci√≥n interna</td></tr>
<tr><td><code>///</code></td><td>Comentario de l√≠nea de documentaci√≥n externa</td></tr>
<tr><td><code>/*...*/</code></td><td>Comentario de bloque</td></tr>
<tr><td><code>/*!...*/</code></td><td>Comentario de bloque de documentaci√≥n interna</td></tr>
<tr><td><code>/**...*/</code></td><td>Comentario de bloque de documentaci√≥n externa</td></tr>
</tbody></table>
</div>
<p>Tabla B-8 muestra los s√≠mbolos que aparecen en el contexto de usar tuplas.</p>
<p><span class="caption">Tabla B-8: Tuplas</span></p>
<div class="table-wrapper"><table><thead><tr><th>S√≠mbolos</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Tupla vac√≠a (tambi√©n conocida como unidad), tanto literal como tipo</td></tr>
<tr><td><code>(expr)</code></td><td>Expresi√≥n entre par√©ntesis</td></tr>
<tr><td><code>(expr,)</code></td><td>Expresi√≥n de tupla de un solo elemento</td></tr>
<tr><td><code>(type,)</code></td><td>Tipo de tupla de un solo elemento</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Expresi√≥n de tupla</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tipo de tupla</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Expresi√≥n de llamada de funci√≥n; tambi√©n se usa para inicializar <code>struct</code>s de tupla y variantes de <code>enum</code> de tupla</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>√çndice de tupla</td></tr>
</tbody></table>
</div>
<p>Tabla B-9 muestra los contextos en los que se usan las llaves.</p>
<p><span class="caption">Tabla B-9: Llaves</span></p>
<div class="table-wrapper"><table><thead><tr><th>Contexto</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Expresi√≥n de bloque</td></tr>
<tr><td><code>Type {...}</code></td><td>Literal de <code>struct</code></td></tr>
</tbody></table>
</div>
<p>Tabla B-10 muestra los contextos en los que se usan los corchetes.</p>
<p><span class="caption">Tabla B-10: Corchetes</span></p>
<div class="table-wrapper"><table><thead><tr><th>Contexto</th><th>Explicaci√≥n</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Expresi√≥n de arreglo</td></tr>
<tr><td><code>[type; expr]</code></td><td>Arreglo de tipo y tama√±o</td></tr>
<tr><td><code>expr[expr]</code></td><td>√çndice de colecci√≥n. Sobrecargable (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>√çndice de colecci√≥n fingiendo ser recortes de colecci√≥n, usando <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, o <code>RangeFull</code> como el ‚Äú√≠ndice‚Äù</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="ap√©ndice-c-traits-derivables"><a class="header" href="#ap√©ndice-c-traits-derivables">Ap√©ndice C: Traits derivables</a></h2>
<p>En varios lugares del libro, hemos discutido el atributo <code>derive</code>, que puede
aplicar a una definici√≥n de estructura o enumeraci√≥n. El atributo <code>derive</code>
genera c√≥digo que implementar√° un rasgo con su propia implementaci√≥n
predeterminada en el tipo que ha anotado con la sintaxis <code>derive</code>.</p>
<p>En este ap√©ndice, proporcionamos una referencia de todos los traits en la
biblioteca est√°ndar que puede usar con <code>derive</code>. Cada secci√≥n cubre:</p>
<ul>
<li>Qu√© operadores y m√©todos que derivan este trait se habilitar√°n</li>
<li>Qu√© hace la implementaci√≥n del trait proporcionado por <code>derive</code></li>
<li>Qu√© significa implementar el trait sobre el tipo</li>
<li>Las condiciones en las que se le permite o no implementar el trait</li>
<li>Ejemplos de operaciones que requieren el trait</li>
</ul>
<p>Si desea un comportamiento diferente al proporcionado por el atributo <code>derive</code>,
consulte la documentaci√≥n de la <a href="../std/index.html">biblioteca est√°ndar</a><!-- ignore -->
para cada trait para obtener detalles sobre c√≥mo implementarlos manualmente.</p>
<p>Estos traits enumerados aqu√≠ son los √∫nicos definidos por la biblioteca
est√°ndar que se pueden implementar en sus tipos usando <code>derive</code>. Otros traits
definidos en la biblioteca est√°ndar no tienen un comportamiento predeterminado
sensato, por lo que depende de usted implementarlos de la manera que tenga
sentido para lo que est√° tratando de lograr.</p>
<p>Un ejemplo de un trait que no se puede derivar es <code>Display</code>, que maneja el
formateo para los usuarios finales. Siempre debe considerar la forma apropiada
de mostrar un tipo a un usuario final. ¬øQu√© partes del tipo puede ver un
usuario final? ¬øQu√© partes encontrar√≠an relevantes? ¬øQu√© formato de los datos
ser√≠a m√°s relevante para ellos? El compilador Rust no tiene esta idea, por lo
que no puede proporcionar un comportamiento predeterminado apropiado para
usted.</p>
<p>La lista de traits derivables proporcionada en este ap√©ndice no es
exhaustiva: las bibliotecas pueden implementar <code>derive</code> para sus propios
traits, lo que hace que la lista de traits que puede usar <code>derive</code> sea
realmente abierta. Implementar <code>derive</code> implica usar una macro procedural, que
se cubre en la secci√≥n <a href="ch19-06-macros.html#macros">‚ÄúMacros‚Äù</a><!-- ignore --> del Cap√≠tulo 19.</p>
<h3 id="debug-para-el-output-del-programador"><a class="header" href="#debug-para-el-output-del-programador"><code>Debug</code> para el Output del programador</a></h3>
<p>El trait <code>Debug</code> permite el formateo de depuraci√≥n en cadenas de formato, que
indica agregando <code>:?</code> dentro de los marcadores <code>{}</code>.</p>
<p>El trait <code>Debug</code> te permite imprimir instancias de un tipo con fines de
depuraci√≥n, para que t√∫ y otros programadores que usen tu tipo puedan
inspeccionar una instancia en un punto particular de la ejecuci√≥n de un
programa.</p>
<p>El trait <code>Debug</code> es necesario, por ejemplo, en el uso de la macro <code>assert_eq!</code>.
Esta macro imprime los valores de las instancias dadas como argumentos si la
aserci√≥n de igualdad falla, por lo que los programadores pueden ver por qu√©
las dos instancias no eran iguales.</p>
<h3 id="partialeq-y-eq-para-comparaciones-de-igualdad"><a class="header" href="#partialeq-y-eq-para-comparaciones-de-igualdad"><code>PartialEq</code> y <code>Eq</code> para comparaciones de igualdad</a></h3>
<p>El trait <code>PartialEq</code> te permite comparar instancias de un tipo para verificar
la igualdad y habilita el uso de los operadores <code>==</code> y <code>!=</code>.</p>
<p>Derivar <code>PartialEq</code> implementa el m√©todo <code>eq</code>. Cuando se deriva <code>PartialEq</code>
en estructuras, dos instancias son iguales solo si <em>todos</em> los campos son
iguales, y las instancias no son iguales si alguno de los campos no es igual.
Cuando se deriva en enumeraciones, cada variante es igual a s√≠ misma y no
igual a las otras variantes.</p>
<p>El trait <code>PartialEq</code> es necesario, por ejemplo, con el uso de la macro
<code>assert_eq!</code>, que necesita poder comparar dos instancias de un tipo para la
igualdad.</p>
<p>El trait <code>Eq</code> no tiene m√©todos. Su prop√≥sito es se√±alar que para cada valor
del tipo anotado, el valor es igual a s√≠ mismo. El trait <code>Eq</code> solo se puede
aplicar a tipos que tambi√©n implementan <code>PartialEq</code>, aunque no todos los tipos
que implementan <code>PartialEq</code> pueden implementar <code>Eq</code>. Un ejemplo de esto son
los tipos de n√∫meros de punto flotante: la implementaci√≥n de los n√∫meros de
punto flotante establece que dos instancias del valor no es un n√∫mero (<code>NaN</code>)
no son iguales entre s√≠.</p>
<p>Un ejemplo de cuando se necesita <code>Eq</code> es para las claves en un <code>HashMap&lt;K, V&gt;</code>
para que el <code>HashMap&lt;K, V&gt;</code> pueda decir si dos claves son iguales.</p>
<h3 id="partialord-y-ord-para-comparaciones-de-orden"><a class="header" href="#partialord-y-ord-para-comparaciones-de-orden"><code>PartialOrd</code> y <code>Ord</code> para comparaciones de orden</a></h3>
<p>El trait <code>PartialOrd</code> te permite comparar instancias de un tipo para fines de
ordenaci√≥n. Un tipo que implementa <code>PartialOrd</code> se puede usar con los
operadores <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> y <code>&gt;=</code>. Solo puede aplicar el trait <code>PartialOrd</code> a
tipos que tambi√©n implementan <code>PartialEq</code>.</p>
<p>Derivar <code>PartialOrd</code> implementa el m√©todo <code>partial_cmp</code>, que devuelve un
<code>Option&lt;Ordering&gt;</code> que ser√° <code>None</code> cuando los valores dados no produzcan un
orden. Un ejemplo de un valor que no produce un orden, a pesar de que la
mayor√≠a de los valores de ese tipo se pueden comparar, es el valor de punto
flotante no es un n√∫mero (<code>NaN</code>). Llamar a <code>partial_cmp</code> con cualquier n√∫mero
de punto flotante y el valor de punto flotante <code>NaN</code> devolver√° <code>None</code>.</p>
<p>Cuando se deriva en structs, <code>PartialOrd</code> compara dos instancias comparando el
valor en cada campo en el orden en que aparecen los campos en la definici√≥n
del struct. Cuando se deriva en enums, las variantes del enum declaradas
anteriormente en la definici√≥n de la enumeraci√≥n se consideran menores
que las variantes enumeradas m√°s tarde.</p>
<p>El trait <code>PartialOrd</code> es necesario, por ejemplo, para el m√©todo <code>gen_range</code>
del crate <code>rand</code> que genera un valor aleatorio en el rango especificado por
una expresi√≥n de rango.</p>
<p>El trait <code>Ord</code> permite saber que para cualquier dos valores del tipo anotado,
existir√° un orden v√°lido. El trait <code>Ord</code> implementa el m√©todo <code>cmp</code>, que
devuelve un <code>Ordering</code> en lugar de un <code>Option&lt;Ordering&gt;</code> porque siempre ser√°
posible un orden v√°lido. Solo puede aplicar el trait <code>Ord</code> a tipos que tambi√©n
implementan <code>PartialOrd</code> y <code>Eq</code> (y <code>Eq</code> requiere <code>PartialEq</code>). Cuando se
deriva en structs y enums, <code>cmp</code> se comporta de la misma manera que la
implementaci√≥n derivada para <code>partial_cmp</code> con <code>PartialOrd</code>.</p>
<p>Un ejemplo de cuando se necesita <code>Ord</code> es cuando se almacenan valores en un
<code>BTreeSet&lt;T&gt;</code>, una estructura de datos que almacena datos basados en el orden
de clasificaci√≥n de los valores.</p>
<h3 id="clone-y-copy-para-duplicar-valores"><a class="header" href="#clone-y-copy-para-duplicar-valores"><code>Clone</code> y <code>Copy</code> para duplicar valores</a></h3>
<p>El trait <code>Clone</code> te permite crear expl√≠citamente una copia profunda de un
valor, y el proceso de duplicaci√≥n puede implicar la ejecuci√≥n de c√≥digo
arbitrario y la copia de datos de la pila. Consulte la secci√≥n <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">‚ÄúWays
Variables and Data Interact: Clone‚Äù</a><!-- ignore -->
en el Cap√≠tulo 4 para obtener m√°s informaci√≥n sobre <code>Clone</code>.</p>
<p>Derivar <code>Clone</code> implementa el m√©todo <code>clone</code>, que cuando se implementa para
todo el tipo, llama a <code>clone</code> en cada una de las partes del tipo. Esto
significa que todos los campos o valores en el tipo tambi√©n deben implementar
<code>Clone</code> para derivar <code>Clone</code>.</p>
<p>Un ejemplo de cuando se requiere <code>Clone</code> es cuando se llama al m√©todo <code>to_vec</code>
en una rebanada. La rebanada no posee las instancias de tipo que contiene, pero
el vector devuelto de <code>to_vec</code> necesitar√° poseer sus instancias, por lo que
<code>to_vec</code> llama a <code>clone</code> en cada elemento. Por lo tanto, el tipo almacenado en
la rebanada debe implementar <code>Clone</code>.</p>
<p>El trait <code>Copy</code> te permite duplicar un valor copiando solo los bits almacenados
en la pila; no es necesario ning√∫n c√≥digo arbitrario. Consulte la secci√≥n
<a href="ch04-01-what-is-ownership.html#solo-datos-del-stack-copiar">‚ÄúStack-Only Data: Copy‚Äù</a><!-- ignore --> en el Cap√≠tulo 4
para obtener m√°s informaci√≥n sobre <code>Copy</code>.</p>
<p>El trait <code>Copy</code> no define ning√∫n m√©todo para evitar que los programadores
sobrecarguen esos m√©todos y violen la suposici√≥n de que no se est√° ejecutando
c√≥digo arbitrario. De esa manera, todos los programadores pueden asumir que
copiar un valor ser√° muy r√°pido.</p>
<p>Puede derivar <code>Copy</code> en un tipo solo si todas las partes del tipo implementan
<code>Copy</code>. Un tipo que implementa <code>Copy</code> tambi√©n debe implementar <code>Clone</code>, porque
un tipo que implementa <code>Copy</code> tiene una implementaci√≥n trivial de <code>Clone</code> que
realiza la misma tarea que <code>Copy</code>.</p>
<p>El trait <code>Copy</code> es rara vez requerido; los tipos que implementan <code>Copy</code> tienen
optimizaciones disponibles, lo que significa que no tiene que llamar a <code>clone</code>,
lo que hace que el c√≥digo sea m√°s conciso.</p>
<p>Todo lo posible con <code>Copy</code> tambi√©n se puede lograr con <code>Clone</code>, pero el c√≥digo
podr√≠a ser m√°s lento o tener que usar <code>clone</code> en lugares.</p>
<h3 id="hash-para-mapear-un-valor-a-un-valor-de-tama√±o-fijo"><a class="header" href="#hash-para-mapear-un-valor-a-un-valor-de-tama√±o-fijo"><code>Hash</code> para mapear un valor a un valor de tama√±o fijo</a></h3>
<p>El trait <code>Hash</code> te permite tomar una instancia de un tipo de tama√±o arbitrario
y asignar esa instancia a un valor de tama√±o fijo usando una funci√≥n hash.
Derivar <code>Hash</code> implementa el m√©todo <code>hash</code>. La implementaci√≥n derivada del
m√©todo <code>hash</code> combina el resultado de llamar a <code>hash</code> en cada una de las partes
del tipo, lo que significa que todos los campos o valores tambi√©n deben
implementar <code>Hash</code> para derivar <code>Hash</code>.</p>
<p>Un ejemplo de cuando se requiere <code>Hash</code> es en el almacenamiento de claves en
un <code>HashMap&lt;K, V&gt;</code> para almacenar datos de manera eficiente.</p>
<h3 id="default-para-valores-predeterminados"><a class="header" href="#default-para-valores-predeterminados"><code>Default</code> para valores predeterminados</a></h3>
<p>El trait <code>Default</code> te permite crear un valor predeterminado para un tipo.
Derivar <code>Default</code> implementa la funci√≥n <code>default</code>. La implementaci√≥n derivada
de la funci√≥n <code>default</code> llama a la funci√≥n <code>default</code> en cada parte del tipo,
lo que significa que todos los campos o valores en el tipo tambi√©n deben
implementar <code>Default</code> para derivar <code>Default</code>.</p>
<p>La funci√≥n <code>Default::default</code> es com√∫nmente usada en combinaci√≥n con la
sintaxis de actualizaci√≥n de struct discutida en la secci√≥n <a href="ch05-01-defining-structs.html#creando-instancias-de-otras-instancias-con-sintaxis-de-struct-update">‚ÄúCreating
Instances From Other Instances With
Struct Update Syntax‚Äù</a><!-- ignore -->
en el Cap√≠tulo 5. Puede personalizar algunos campos de un struct y luego
establecer y usar un valor predeterminado para el resto de los campos usando
<code>..Default::default()</code>.</p>
<p>El trait <code>Default</code> es necesario, por ejemplo, cuando se usa el m√©todo
<code>unwrap_or_default</code> en instancias de <code>Option&lt;T&gt;</code>. Si el <code>Option&lt;T&gt;</code> es <code>None</code>,
el m√©todo <code>unwrap_or_default</code> devolver√° el resultado de <code>Default::default</code> para
el tipo <code>T</code> almacenado en el <code>Option&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ap√©ndice-d---herramientas-de-desarrollo-√∫tiles"><a class="header" href="#ap√©ndice-d---herramientas-de-desarrollo-√∫tiles">Ap√©ndice D - Herramientas de desarrollo √∫tiles</a></h2>
<p>En este ap√©ndice, hablaremos sobre algunas herramientas de desarrollo √∫tiles
que proporciona el proyecto Rust. Veremos el formato autom√°tico, formas r√°pidas
de aplicar correcciones de advertencia, un linter e integraci√≥n con IDE.</p>
<h3 id="formato-autom√°tico-con-rustfmt"><a class="header" href="#formato-autom√°tico-con-rustfmt">Formato autom√°tico con <code>rustfmt</code></a></h3>
<p>La herramienta <code>rustfmt</code> reformatea su c√≥digo de acuerdo con el estilo de c√≥digo
de la comunidad. Muchos proyectos colaborativos usan <code>rustfmt</code> para evitar
discusiones sobre qu√© estilo usar al escribir Rust: todos formatean su c√≥digo
usando la herramienta.</p>
<p>Para instalar <code>rustfmt</code>, ingrese lo siguiente:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Este comando le da <code>rustfmt</code> y <code>cargo-fmt</code>, similar a c√≥mo Rust le da <code>rustc</code> y
<code>cargo</code>. Para formatear cualquier proyecto de carga √∫til, ingrese lo siguiente:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Ejecutando este comando reformatea todo el c√≥digo Rust en la carga √∫til actual.
Esto solo deber√≠a cambiar el estilo de c√≥digo, no la sem√°ntica del c√≥digo. Para
m√°s informaci√≥n sobre <code>rustfmt</code>, vea <a href="https://github.com/rust-lang/rustfmt">su documentaci√≥n</a>.</p>
<h3 id="corregir-su-c√≥digo-con-rustfix"><a class="header" href="#corregir-su-c√≥digo-con-rustfix">Corregir su c√≥digo con <code>rustfix</code></a></h3>
<p>La herramienta <code>rustfix</code> se incluye con las instalaciones de Rust y puede
corregir autom√°ticamente las advertencias del compilador que tienen una forma
clara de corregir el problema que es probablemente lo que desea. Es probable que
haya visto advertencias del compilador antes. Por ejemplo, considere este c√≥digo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Aqu√≠, estamos llamando a la funci√≥n <code>do_something</code> 100 veces, pero nunca usamos
la variable <code>i</code> en el cuerpo del bucle <code>for</code>. Rust nos advierte sobre eso:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Esta advertencia sugiere que usemos <code>_i</code> como nombre en su lugar: el gui√≥n bajo
indica que pretendemos que esta variable no se use. Podemos aplicar
autom√°ticamente esa sugerencia usando la herramienta <code>rustfix</code> ejecutando el
comando <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Cuando volvemos a mirar <em>src/main.rs</em>, veremos que <code>cargo fix</code> ha cambiado el
c√≥digo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>La variable del bucle <code>for</code> ahora se llama <code>_i</code>, y la advertencia ya no aparece.</p>
<p>Tambi√©n puede usar <code>cargo fix</code> para transformar su c√≥digo entre diferentes
ediciones de Rust. Las ediciones se tratan en el <a href="appendix-05-editions.html">Ap√©ndice E</a>.</p>
<h3 id="m√°s-lints-con-clippy"><a class="header" href="#m√°s-lints-con-clippy">M√°s lints con Clippy</a></h3>
<p>La herramienta <code>clippy</code> es una colecci√≥n de lints para analizar su c√≥digo para
que pueda detectar errores comunes y mejorar su c√≥digo Rust.</p>
<p>Para instalar <code>clippy</code>, ingrese lo siguiente:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Para ejecutar los lints de Clippy en cualquier proyecto de carga √∫til, ingrese
lo siguiente:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Por ejemplo, digamos que escribe un programa que usa una aproximaci√≥n de una
constante matem√°tica, como pi, como lo hace este programa:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}</code></pre></pre>
<p>Ejecutando <code>cargo clippy</code> en este proyecto resulta en este error:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Este error le informa que Rust ya tiene una constante <code>PI</code> m√°s precisa definida
y que su programa ser√≠a m√°s correcto si usara la constante en su lugar. Luego
cambiar√≠a su c√≥digo para usar la constante <code>PI</code>. El siguiente c√≥digo no
produce ning√∫n error ni advertencia de Clippy:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}</code></pre></pre>
<p>Para obtener m√°s informaci√≥n sobre Clippy, consulte <a href="https://github.com/rust-lang/rust-clippy">su documentaci√≥n</a>.</p>
<h3 id="integraci√≥n-de-ide-con-rust-analyzer"><a class="header" href="#integraci√≥n-de-ide-con-rust-analyzer">Integraci√≥n de IDE con <code>rust-analyzer</code></a></h3>
<p>Para ayudar a la integraci√≥n del IDE, la comunidad Rust recomienda usar
<a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a>. Esta herramienta es un conjunto de utilidades
centradas en el compilador que habla el <a href="http://langserver.org/">Protocolo del servidor de lenguaje</a></p>
<!-- ignore -->, que es una especificaci√≥n para que los IDE y los lenguajes de
<p>programaci√≥n se comuniquen entre s√≠. Diferentes clientes pueden usar
<code>rust-analyzer</code>, como <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">el complemento del analizador Rust para Visual Studio
Code</a>.</p>
<p>Visite la <a href="https://rust-analyzer.github.io">p√°gina de inicio del proyecto <code>rust-analyzer</code></a><!-- ignore -->
para obtener instrucciones de instalaci√≥n, luego instale el soporte del servidor
de lenguaje en su IDE en particular. Su IDE ganar√° habilidades como
autocompletado, salto a la definici√≥n y errores en l√≠nea. </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ap√©ndice-e---ediciones"><a class="header" href="#ap√©ndice-e---ediciones">Ap√©ndice E - Ediciones</a></h2>
<p>En el Cap√≠tulo 1, viste que <code>cargo new</code> agrega un poco de metadatos a tu archivo
<em>Cargo.toml</em> sobre una edici√≥n. ¬°Este ap√©ndice habla sobre lo que eso significa!</p>
<p>El lenguaje Rust y el compilador tienen un ciclo de lanzamiento de seis semanas,
lo que significa que los usuarios obtienen un flujo constante de nuevas
caracter√≠sticas. Otros lenguajes de programaci√≥n lanzan cambios m√°s grandes con
menos frecuencia; Rust lanza actualizaciones m√°s peque√±as con m√°s frecuencia.
Despu√©s de un tiempo, todos estos peque√±os cambios se suman. Pero de una
versi√≥n a otra, puede ser dif√≠cil mirar hacia atr√°s y decir: ‚ÄúWow, entre Rust
1.10 y Rust 1.31, Rust ha cambiado mucho!‚Äù</p>
<p>Cada dos o tres a√±os, el equipo de Rust produce una nueva <em>edici√≥n</em> de Rust.
Cada edici√≥n re√∫ne las caracter√≠sticas que han aterrizado en un paquete claro
con documentaci√≥n y herramientas completamente actualizadas. Las nuevas
ediciones se env√≠an como parte del proceso de lanzamiento habitual de seis
semanas.</p>
<p>Las ediciones sirven para diferentes prop√≥sitos para diferentes personas:</p>
<ul>
<li>Para los usuarios activos de Rust, una nueva edici√≥n re√∫ne los cambios
incrementales en un paquete f√°cil de entender.</li>
<li>Para los no usuarios, una nueva edici√≥n se√±ala que se han realizado algunos
avances importantes, lo que podr√≠a hacer que Rust valga la pena volver a
mirar.</li>
<li>Para aquellos que desarrollan Rust, una nueva edici√≥n proporciona un punto de
reuni√≥n para todo el proyecto.</li>
</ul>
<p>En el momento de escribir esto, hay tres ediciones de Rust disponibles: Rust
2015, Rust 2018 y Rust 2021. Este libro est√° escrito utilizando los
modismos de la edici√≥n Rust 2021.</p>
<p>La clave <code>edition</code> en <em>Cargo.toml</em> indica qu√© edici√≥n debe usar el compilador
para su c√≥digo. Si la clave no existe, Rust usa <code>2015</code> como el valor de la
edici√≥n por razones de compatibilidad con versiones anteriores.</p>
<p>Cada proyecto puede optar por una edici√≥n que no sea la edici√≥n predeterminada
2015. Las ediciones pueden contener cambios incompatibles, como incluir una
nueva palabra clave que entra en conflicto con los identificadores en el c√≥digo.
Sin embargo, a menos que opte por esos cambios, su c√≥digo seguir√° compilando
incluso cuando actualice la versi√≥n del compilador Rust que usa.</p>
<p>Todas las versiones del compilador Rust admiten cualquier edici√≥n que exist√≠a
antes del lanzamiento de ese compilador, y pueden vincular cajas de cualquier
edici√≥n compatible entre s√≠. Los cambios de edici√≥n solo afectan la forma en
que el compilador analiza inicialmente el c√≥digo. Por lo tanto, si est√° usando
Rust 2015 y una de sus dependencias usa Rust 2018, su proyecto se compilar√° y
podr√° usar esa dependencia. La situaci√≥n opuesta, donde su proyecto usa Rust
2018 y una dependencia usa Rust 2015, tambi√©n funciona.</p>
<p>Para ser claros: la mayor√≠a de las caracter√≠sticas estar√°n disponibles en todas
las ediciones. Los desarrolladores que usen cualquier edici√≥n de Rust seguir√°n
viendo mejoras a medida que se realicen nuevos lanzamientos estables. Sin
embargo, en algunos casos, principalmente cuando se agregan nuevas palabras
clave, algunas nuevas caracter√≠sticas pueden estar disponibles solo en ediciones
posteriores. Deber√° cambiar de edici√≥n si desea aprovechar dichas
caracter√≠sticas.</p>
<p>Para m√°s detalles, la <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Gu√≠a de edici√≥n</em></a>
es un libro completo sobre ediciones que enumera las diferencias entre ediciones
y explica c√≥mo actualizar autom√°ticamente su c√≥digo a una nueva edici√≥n a trav√©s
de <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ap√©ndice-f-traducciones-del-libro"><a class="header" href="#ap√©ndice-f-traducciones-del-libro">Ap√©ndice F: Traducciones del libro</a></h2>
<p>Para recursos en idiomas distintos al ingl√©s. La mayor√≠a a√∫n est√°n en progreso;
consulte <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">la etiqueta de traducciones</a> para ayudar o informarnos sobre
una nueva traducci√≥n.</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Portugu√©s (Brasil)</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Portugu√©s</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">Chino simplificado</a></li>
<li><a href="https://github.com/rust-tw/book-tw">Chino tradicional (Taiw√°n)</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Ucraniano</a></li>
<li><a href="https://github.com/thecodix/book">Espa√±ol</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a>
, <a href="https://github.com/RustLangES/rust-book-es">esta versi√≥n</a></li>
<li><a href="https://github.com/EmanueleGurini/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Ruso</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">Coreano</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">Japon√©s</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Franc√©s</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polaco</a></li>
<li><a href="https://github.com/agentzero1/book">Cubano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalo</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">Griego</a></li>
<li><a href="https://github.com/sebras/book">Sueco</a></li>
<li><a href="https://github.com/RustFarsi/book">Persa</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Alem√°n</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">Hind√∫</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">Tailand√©s</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Dan√©s</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ap√©ndice-g---c√≥mo-se-hace-rust-y-rust-nightly"><a class="header" href="#ap√©ndice-g---c√≥mo-se-hace-rust-y-rust-nightly">Ap√©ndice G - C√≥mo se hace Rust y ‚ÄúRust Nightly‚Äù</a></h2>
<p>Este ap√©ndice trata sobre c√≥mo se hace Rust y c√≥mo eso te afecta como
desarrollador de Rust.</p>
<h3 id="estabilidad-sin-estancamiento"><a class="header" href="#estabilidad-sin-estancamiento">Estabilidad sin estancamiento</a></h3>
<p>Como lenguaje, Rust se preocupa <em>mucho</em> por la estabilidad de tu c√≥digo.
Queremos que Rust sea una base s√≥lida sobre la que puedas construir, y si las
cosas cambian constantemente, eso ser√≠a imposible. Al mismo tiempo, si no
podemos experimentar con nuevas caracter√≠sticas, es posible que no descubramos
fallos importantes hasta despu√©s de su lanzamiento, cuando ya no podamos
cambiar las cosas.</p>
<p>Nuestra soluci√≥n a este problema es lo que llamamos ‚Äúestabilidad sin
estancamiento‚Äù, y nuestro principio rector es el siguiente: nunca debes temer
actualizar a una nueva versi√≥n de Rust estable. Cada actualizaci√≥n debe ser
indolora, pero tambi√©n debe traerte nuevas caracter√≠sticas, menos errores y
tiempos de compilaci√≥n m√°s r√°pidos.</p>
<h3 id="choo-choo-canales-de-lanzamiento-y-montando-los-trenes"><a class="header" href="#choo-choo-canales-de-lanzamiento-y-montando-los-trenes">¬°Choo, Choo! Canales de lanzamiento y montando los trenes</a></h3>
<p>El desarrollo de Rust funciona con un <em>horario de trenes</em>. Es decir, todo el
desarrollo se hace en la rama <code>master</code> del repositorio de Rust. Las versiones
siguen un modelo de tren de lanzamiento de software, que ha sido utilizado por
Cisco IOS y otros proyectos de software. Hay tres <em>canales de lanzamiento</em> para
Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>La mayor√≠a de los desarrolladores de Rust utilizan principalmente el canal
estable, pero aquellos que quieran probar nuevas caracter√≠sticas experimentales
pueden utilizar nightly o beta.</p>
<p>Aqu√≠ hay un ejemplo de c√≥mo funciona el proceso de desarrollo y lanzamiento:
supongamos que el equipo de Rust est√° trabajando en el lanzamiento de Rust 1.5.
Ese lanzamiento ocurri√≥ en diciembre de 2015, pero nos proporcionar√° n√∫meros de
versi√≥n realistas. Se a√±ade una nueva caracter√≠stica a Rust: un nuevo commit
aterriza en la rama <code>master</code>. Cada noche, se produce una nueva versi√≥n nightly
de Rust. Cada d√≠a es un d√≠a de lanzamiento, y estos lanzamientos son creados
por nuestra infraestructura de lanzamiento autom√°ticamente. As√≠ que a medida
que pasa el tiempo, nuestros lanzamientos se ven as√≠, una vez por noche:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Cada seis semanas, es hora de preparar un nuevo lanzamiento! La rama <code>beta</code> del
repositorio de Rust se ramifica de la rama <code>master</code> utilizada por nightly.
Ahora, hay dos lanzamientos:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>La mayor√≠a de los usuarios de Rust no utilizan las versiones beta activamente,
pero prueban contra beta en su sistema CI para ayudar a Rust a descubrir
posibles regresiones. Mientras tanto, hay un lanzamiento nightly cada
noche:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Digamos que se encuentra una regresi√≥n. ¬°Qu√© bueno que tuvimos algo de tiempo
para probar la versi√≥n beta antes de que la regresi√≥n se colara en una versi√≥n
estable! La soluci√≥n se aplica a <code>master</code>, de modo que nightly se arregla, y
luego la soluci√≥n se vuelve a aplicar a la rama <code>beta</code>, y se produce una nueva
versi√≥n de beta:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Seis semanas despu√©s de que se cre√≥ la primera beta, ¬°es hora de un lanzamiento
estable! La rama <code>stable</code> se produce a partir de la rama <code>beta</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>¬°Hurra! ¬°Rust 1.5 est√° listo! Sin embargo, nos hemos olvidado de una cosa:
porque han pasado las seis semanas, tambi√©n necesitamos una nueva beta de la
<em>siguiente</em> versi√≥n de Rust, 1.6. As√≠ que despu√©s de que <code>stable</code> se ramifica de
<code>beta</code>, la siguiente versi√≥n de <code>beta</code> se ramifica de <code>nightly</code> de nuevo:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>Esto se llama el ‚Äúmodelo de tren‚Äù porque cada seis semanas, un lanzamiento
‚Äúsale de la estaci√≥n‚Äù, pero a√∫n tiene que hacer un viaje a trav√©s del canal
beta antes de llegar como un lanzamiento estable.</p>
<p>Rust se lanza cada seis semanas, como un reloj. Si conoces la fecha de un
lanzamiento de Rust, puedes conocer la fecha del siguiente: es seis semanas
despu√©s. Un aspecto agradable de tener lanzamientos programados cada seis
semanas es que el pr√≥ximo tren est√° llegando pronto. Si una caracter√≠stica
llega a perder un lanzamiento en particular, no hay necesidad de preocuparse:
¬°otro est√° sucediendo en un corto tiempo! Esto ayuda a reducir la presi√≥n para
colar posiblemente caracter√≠sticas poco pulidas cerca de la fecha l√≠mite de
lanzamiento.</p>
<p>Gracias a este proceso, siempre puedes comprobar la siguiente compilaci√≥n de
Rust y verificar por ti mismo que es f√°cil de actualizar: si una versi√≥n beta
no funciona como se esperaba, puedes informarlo al equipo y solucionarlo antes
de que ocurra el siguiente lanzamiento estable! La rotura en una versi√≥n beta
es relativamente rara, pero <code>rustc</code> sigue siendo un software, y los errores
existen.</p>
<h3 id="tiempo-de-mantenimiento"><a class="header" href="#tiempo-de-mantenimiento">Tiempo de Mantenimiento</a></h3>
<p>El proyecto Rust admite la versi√≥n estable m√°s reciente. Cuando una nueva 
versi√≥n estable es lanzada, la versi√≥n anterior llega al final de su vida √∫til 
(EOL). Esto significa que cada versi√≥n tiene soporte durante seis semanas.</p>
<p><a id="caracteristicas-inestables"></a></p>
<h2 id="caracter√≠sticas-inestables"><a class="header" href="#caracter√≠sticas-inestables">Caracter√≠sticas inestables</a></h2>
<p>Hay alo m√°s con este modelo de lanzamiento: caracter√≠sticas inestables.
Rust utiliza una t√©cnica llamada ‚Äúindicadores de caracter√≠sticas‚Äù para
determinar qu√© caracter√≠sticas est√°n habilitadas en un lanzamiento dado. Si una
nueva caracter√≠stica est√° en desarrollo activo, aterriza en <code>master</code>, y por lo
tanto, en nightly, pero detr√°s de un <em>indicador de caracter√≠stica</em>. Si, como
usuario, desea probar la caracter√≠stica en progreso, puede hacerlo, pero debe
estar utilizando una versi√≥n nightly de Rust y anotar su c√≥digo fuente con el
indicador apropiado para optar por ello.</p>
<p>Si est√° utilizando una versi√≥n beta o estable de Rust, no puede utilizar
indicadores de caracter√≠sticas. Esta es la clave que nos permite obtener un uso
pr√°ctico con nuevas caracter√≠sticas antes de declararlas estables para siempre.
Aquellos que deseen optar por el borde sangrante pueden hacerlo, y aquellos que
deseen una experiencia s√≥lida pueden quedarse con estable y saber que su c√≥digo
no se romper√°. Estabilidad sin estancamiento.</p>
<p>Este libro s√≥lo contiene informaci√≥n sobre caracter√≠sticas estables, ya que las
caracter√≠sticas en progreso a√∫n est√°n cambiando, y seguramente ser√°n diferentes
entre cuando se escribi√≥ este libro y cuando se habiliten en compilaciones
estables. Puede encontrar documentaci√≥n para caracter√≠sticas s√≥lo nocturnas en
l√≠nea.</p>
<h2 id="rustup-y-el-papel-de-rust-nightly"><a class="header" href="#rustup-y-el-papel-de-rust-nightly">Rustup y el papel de Rust Nightly</a></h2>
<p>Rustup facilita el cambio entre diferentes canales de lanzamiento de Rust, a
nivel global o por proyecto. Por defecto, tendr√° instalado Rust estable. Para
instalar nightly, por ejemplo:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Tambi√©n puede ver todas las <em>herramientas</em> (versiones de Rust y componentes
asociados) que tiene instaladas con <code>rustup</code>. Aqu√≠ hay un ejemplo en uno de los
autores de Windows:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Como puede ver, la herramienta estable es la predeterminada. La mayor√≠a de los
usuarios de Rust utilizan estable la mayor parte del tiempo. Es posible que
desee utilizar estable la mayor parte del tiempo, pero utilizar nightly en un
proyecto espec√≠fico, porque le importa una caracter√≠stica de vanguardia. Para
hacerlo, puede utilizar <code>rustup override</code> en el directorio del proyecto para
establecer la herramienta nightly como la que <code>rustup</code> debe utilizar cuando
est√© en ese directorio:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Ahora, cada vez que llame a <code>rustc</code> o <code>cargo</code> dentro de
<em>~/projects/needs-nightly</em>, <code>rustup</code> se asegurar√° de que est√© utilizando Rust
nocturno, en lugar de su estable predeterminado. ¬°Esto es √∫til cuando tienes
muchos proyectos de Rust!</p>
<h2 id="el-proceso-rfc-y-los-equipos"><a class="header" href="#el-proceso-rfc-y-los-equipos">El proceso RFC y los equipos</a></h2>
<p>Entonces, ¬øc√≥mo se aprende sobre estas nuevas caracter√≠sticas? El modelo de
desarrollo de Rust sigue un proceso de <em>Solicitud de comentarios (RFC)</em>. Si
desea una mejora en Rust, puede escribir una propuesta, llamada RFC.</p>
<p>Cualquiera puede escribir RFC para mejorar Rust, y las propuestas son revisadas
y discutidas por el equipo de Rust, que est√° compuesto por muchos subequipos de
temas. Hay una lista completa de los equipos <a href="https://www.rust-lang.org/governance">en el sitio web de
Rust</a>, que incluye equipos para cada √°rea
del proyecto: dise√±o de lenguaje, implementaci√≥n de compilador, infraestructura,
documentaci√≥n y m√°s. El equipo apropiado lee la propuesta y los comentarios,
escribe algunos comentarios propios y, finalmente, hay consenso para aceptar o
rechazar la caracter√≠stica.</p>
<p>Si la caracter√≠stica es aceptada, se abre un problema en el repositorio de
Rust, y alguien puede implementarla. ¬°La persona que lo implementa muy bien no
tiene por qu√© ser la persona que propuso la caracter√≠stica en primer lugar!
Cuando la implementaci√≥n est√° lista, aterriza en la rama <code>master</code> detr√°s de una
puerta de caracter√≠sticas, como discutimos en la secci√≥n <a href="appendix-07-nightly-rust.html#caracteristicas-inestables">‚ÄúCaracter√≠sticas
inestables‚Äù</a><!-- ignore -->.</p>
<p>Despu√©s de alg√∫n tiempo, una vez que los desarrolladores de Rust que utilizan
las versiones nightly han podido probar la nueva caracter√≠stica, los
miembros del equipo discutir√°n la caracter√≠stica, c√≥mo ha funcionado en
nightly, y decidir√°n si debe o no hacerlo en Rust estable. Si la decisi√≥n es
seguir adelante, la puerta de la caracter√≠stica se elimina, ¬°y la caracter√≠stica
ahora se considera estable! Monta los trenes en una nueva versi√≥n estable de
Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
